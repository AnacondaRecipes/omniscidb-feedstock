diff -Naur ./Analyzer/Analyzer.cpp ../omniscidb-master/Analyzer/Analyzer.cpp
--- ./Analyzer/Analyzer.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Analyzer/Analyzer.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -3022,6 +3022,13 @@
   from_expr_->collect_rte_idx(rte_idx_set);
 }
 
+void ArrayExpr::collect_rte_idx(std::set<int>& rte_idx_set) const {
+  for (unsigned i = 0; i < getElementCount(); i++) {
+    const auto expr = getElement(i);
+    expr->collect_rte_idx(rte_idx_set);
+  }
+}
+
 void CaseExpr::collect_column_var(
     std::set<const ColumnVar*, bool (*)(const ColumnVar*, const ColumnVar*)>& colvar_set,
     bool include_agg) const {
@@ -3060,6 +3067,15 @@
   from_expr_->collect_column_var(colvar_set, include_agg);
 }
 
+void ArrayExpr::collect_column_var(
+    std::set<const ColumnVar*, bool (*)(const ColumnVar*, const ColumnVar*)>& colvar_set,
+    bool include_agg) const {
+  for (unsigned i = 0; i < getElementCount(); i++) {
+    const auto expr = getElement(i);
+    expr->collect_column_var(colvar_set, include_agg);
+  }
+}
+
 void CaseExpr::check_group_by(
     const std::list<std::shared_ptr<Analyzer::Expr>>& groupby) const {
   for (auto p : expr_pair_list) {
diff -Naur ./Analyzer/Analyzer.h ../omniscidb-master/Analyzer/Analyzer.h
--- ./Analyzer/Analyzer.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Analyzer/Analyzer.h	2021-04-21 00:02:57.000000000 +0300
@@ -1398,7 +1398,7 @@
  */
 class OffsetInFragment : public Expr {
  public:
-  OffsetInFragment() : Expr(SQLTypeInfo(kINT, true)){};
+  OffsetInFragment() : Expr(SQLTypeInfo(kBIGINT, true)){};
 
   std::shared_ptr<Analyzer::Expr> deep_copy() const override;
 
@@ -1494,6 +1494,12 @@
     return contained_expressions_[i].get();
   }
 
+  void collect_rte_idx(std::set<int>& rte_idx_set) const override;
+  void collect_column_var(
+      std::set<const ColumnVar*, bool (*)(const ColumnVar*, const ColumnVar*)>&
+          colvar_set,
+      bool include_agg) const override;
+
  private:
   ExpressionPtrVector contained_expressions_;
   bool local_alloc_;
diff -Naur ./Archive/Archive.h ../omniscidb-master/Archive/Archive.h
--- ./Archive/Archive.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Archive/Archive.h	2021-04-21 00:02:57.000000000 +0300
@@ -128,9 +128,9 @@
          c) customize init_for_read() which uses archive_read_open
 
    */
-  virtual int open() { return ARCHIVE_OK; }              // nop
-  virtual int close() { return ARCHIVE_OK; }             // nop
-  virtual ssize_t read(const void** buff) { return 0; }  // nop
+  virtual int open() { return ARCHIVE_OK; }                // nop
+  virtual int close() { return ARCHIVE_OK; }               // nop
+  virtual ptrdiff_t read(const void** buff) { return 0; }  // nop
 
   virtual void init_for_read() {
     // set libarchive callbacks
@@ -138,7 +138,7 @@
   }
 
   // these methods are callback for libarchive
-  static ssize_t read(struct archive* a, void* client_data, const void** buff) {
+  static ptrdiff_t read(struct archive* a, void* client_data, const void** buff) {
     return ((Archive*)client_data)->read(buff);
   }
 
diff -Naur ./CMakeLists.txt ../omniscidb-master/CMakeLists.txt
--- ./CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -26,6 +26,7 @@
   set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Choose the type of build." FORCE)
   set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
 endif()
+string(TOLOWER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_LOWER)
 
 if("${CMAKE_VERSION}" VERSION_GREATER 3.11.999)
   cmake_policy(SET CMP0074 NEW)
@@ -130,6 +131,58 @@
   set(MAPD_PACKAGE_FLAGS "${MAPD_PACKAGE_FLAGS}-cpu")
 endif()
 
+# CUDA architecture flags
+if("${CMAKE_BUILD_TYPE_LOWER}" STREQUAL "debug")
+  option(ENABLE_ONLY_ONE_ARCH "Enable quicker building for only one GPU arch" ON)
+else()
+  option(ENABLE_ONLY_ONE_ARCH "Enable quicker building for only one GPU arch" OFF)
+endif()
+if(ENABLE_CUDA)
+  if(ENABLE_ONLY_ONE_ARCH)
+    execute_process(
+      COMMAND cmake -S ${CMAKE_SOURCE_DIR}/NvidiaComputeCapability -B NvidiaComputeCapability
+      OUTPUT_QUIET
+      ERROR_QUIET
+      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
+    )
+    execute_process(
+      COMMAND cmake --build NvidiaComputeCapability
+      OUTPUT_FILE ${CMAKE_BINARY_DIR}/NvidiaComputeCapability/build.out.txt
+      ERROR_FILE ${CMAKE_BINARY_DIR}/NvidiaComputeCapability/build.err.txt
+      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
+    )
+    set(NVIDIA_COMPUTE_CAPABILITY "")
+    if (EXISTS ${CMAKE_BINARY_DIR}/NvidiaComputeCapability.txt)
+      file(STRINGS ${CMAKE_BINARY_DIR}/NvidiaComputeCapability.txt NVIDIA_COMPUTE_CAPABILITY)
+    endif()
+  endif()
+  if (ENABLE_ONLY_ONE_ARCH AND NOT "${NVIDIA_COMPUTE_CAPABILITY}" STREQUAL "")
+    set (CUDA_COMPILATION_ARCH
+      -gencode=arch=compute_${NVIDIA_COMPUTE_CAPABILITY},code=compute_${NVIDIA_COMPUTE_CAPABILITY}
+      -Wno-deprecated-gpu-targets
+    )
+    add_custom_target(clean_nvidia_compute_capability
+      COMMAND ${CMAKE_BUILD_TOOL} clean
+      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/NvidiaComputeCapability
+    )
+    add_dependencies(clean-all clean_nvidia_compute_capability)
+    message(STATUS "CUDA_COMPILATION_ARCH: ${CUDA_COMPILATION_ARCH}")
+  else()
+    set (CUDA_COMPILATION_ARCH
+      -gencode=arch=compute_35,code=compute_35
+      -gencode=arch=compute_50,code=compute_50
+      -gencode=arch=compute_60,code=compute_60
+      -gencode=arch=compute_70,code=compute_70
+      -gencode=arch=compute_75,code=compute_75
+      -Wno-deprecated-gpu-targets
+    )
+    if(ENABLE_ONLY_ONE_ARCH)
+      message(STATUS "ENABLE_ONLY_ONE_ARCH ignored because NvidiaComputeCapability.txt not found or not readable")
+      message(STATUS "CUDA_COMPILATION_ARCH: ${CUDA_COMPILATION_ARCH}")
+    endif()
+  endif()
+endif()
+
 option(SUPPRESS_NULL_LOGGER_DEPRECATION_WARNINGS "Suppress NullLogger deprecated warnings.")
 if (SUPPRESS_NULL_LOGGER_DEPRECATION_WARNINGS)
   add_definitions("-DSUPPRESS_NULL_LOGGER_DEPRECATION_WARNINGS")
@@ -219,6 +272,16 @@
   endif()
 endif()
 
+option(ENABLE_MLPACK "Use mlpack" OFF)
+if(ENABLE_MLPACK)
+  find_package(OpenMP REQUIRED)
+  find_package(Armadillo REQUIRED)
+  find_package(Boost COMPONENTS serialization REQUIRED)
+  find_package(MLPACK REQUIRED)
+  include_directories(${MLPACK_INCLUDE_DIRS})
+  add_definitions("-DHAVE_MLPACK")
+endif()
+
 if(MSVC)
   include_directories(include_directories("${LIBS_PATH}/include/pdcurses"))
 else()
@@ -243,6 +306,10 @@
   endif()
 endif()
 
+if (ENABLE_MLPACK)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}") 
+endif()
+
 if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-deprecated-declarations")
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-deprecated-declarations")
@@ -377,15 +444,6 @@
 find_package(Boost COMPONENTS log log_setup filesystem program_options regex system thread timer locale iostreams REQUIRED)
 include_directories(${Boost_INCLUDE_DIR})
 
-# CUDA architecture flags
-set (CUDA_COMPILATION_ARCH
-  -gencode=arch=compute_35,code=compute_35
-  -gencode=arch=compute_50,code=compute_50
-  -gencode=arch=compute_60,code=compute_60
-  -gencode=arch=compute_70,code=compute_70
-  -gencode=arch=compute_75,code=compute_75
-)
-
 # Allow explicit include statements to access third party headers directly.
 # Ex: raft/canonical/include/raft.h
 include_directories(ThirdParty/)
@@ -507,15 +565,10 @@
 set(gen_cpp_files
     ${CMAKE_BINARY_DIR}/gen-cpp/OmniSci.cpp
     ${CMAKE_BINARY_DIR}/gen-cpp/OmniSci.h
-    ${CMAKE_BINARY_DIR}/gen-cpp/omnisci_constants.cpp
     ${CMAKE_BINARY_DIR}/gen-cpp/omnisci_types.cpp
-    ${CMAKE_BINARY_DIR}/gen-cpp/common_constants.cpp
     ${CMAKE_BINARY_DIR}/gen-cpp/common_types.cpp
-    ${CMAKE_BINARY_DIR}/gen-cpp/completion_hints_constants.cpp
     ${CMAKE_BINARY_DIR}/gen-cpp/completion_hints_types.cpp
-    ${CMAKE_BINARY_DIR}/gen-cpp/serialized_result_set_constants.cpp
     ${CMAKE_BINARY_DIR}/gen-cpp/serialized_result_set_types.cpp
-    ${CMAKE_BINARY_DIR}/gen-cpp/extension_functions_constants.cpp
     ${CMAKE_BINARY_DIR}/gen-cpp/extension_functions_types.cpp
     ${CMAKE_BINARY_DIR}/gen-cpp/extension_functions_types.h
 )
@@ -649,6 +702,10 @@
   list(APPEND MAPD_LIBRARIES ${Folly_LIBRARIES})
 endif()
 
+if(ENABLE_MLPACK)
+  list(APPEND MAPD_LIBRARIES ${MLPACK_LIBRARIES} ${ARMADILLO_LIBRARIES})
+endif()
+
 if(ENABLE_LICENSING_AWS)
   list(APPEND MAPD_LIBRARIES AWSMarketplace)
 endif()
@@ -775,7 +832,6 @@
 
 # Packaging
 
-string(TOLOWER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_LOWER)
 if(NOT "${CMAKE_BUILD_TYPE_LOWER}" STREQUAL "debug" AND NOT "${CMAKE_BUILD_TYPE_LOWER}" STREQUAL "relwithdebinfo")
   set(CPACK_STRIP_FILES ON)
 else()
@@ -876,7 +932,7 @@
     ${CMAKE_BINARY_DIR}/bin/${OMNISCI_UTILITY_JAR}
     ${CMAKE_BINARY_DIR}/bin/${OMNISCI_JDBC_JAR}
     ${CMAKE_BINARY_DIR}/bin/calcite-1.0-SNAPSHOT-jar-with-dependencies.jar
-    COMMAND MVNPATH=${CMAKE_SOURCE_DIR}/java ${MVN_EXECUTABLE} -l ${CMAKE_BINARY_DIR}/mvn_build.log -e clean install -Dthrift.version="${Thrift_VERSION}" -Dmaven.compiler.showDeprecation=true -Dmaven.compiler.showWarnings=true -Domnisci.release.version="${OMNISCI_JAR_RELEASE_VERSION}" -Djava.net.preferIPv4Stack=true -Dmaven.wagon.http.retryHandler.count=3    
+    COMMAND ${MVN_PATH_COMMAND} ${MVN_EXECUTABLE} -l ${CMAKE_BINARY_DIR}/mvn_build.log -e clean install -Dthrift.version="${Thrift_VERSION}" -Dmaven.compiler.showDeprecation=true -Dmaven.compiler.showWarnings=true -Domnisci.release.version="${OMNISCI_JAR_RELEASE_VERSION}" -Djava.net.preferIPv4Stack=true -Dmaven.wagon.http.retryHandler.count=3
     COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/java/mapd/target/${OMNISCI_UTILITY_JAR} ${CMAKE_BINARY_DIR}/bin
     COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/java/omniscijdbc/target/${OMNISCI_JDBC_JAR} ${CMAKE_BINARY_DIR}/bin
     COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/java/calcite/target/calcite-1.0-SNAPSHOT-jar-with-dependencies.jar ${CMAKE_BINARY_DIR}/bin
diff -Naur ./Calcite/CMakeLists.txt ../omniscidb-master/Calcite/CMakeLists.txt
--- ./Calcite/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Calcite/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -2,22 +2,16 @@
     DEPENDS ${CMAKE_SOURCE_DIR}/java/thrift/calciteserver.thrift ${CMAKE_SOURCE_DIR}/completion_hints.thrift
     OUTPUT
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/CalciteServer.cpp
-        ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/calciteserver_constants.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/calciteserver_types.cpp
-        ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_constants.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_types.cpp
-        ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/extension_functions_constants.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/extension_functions_types.cpp
     COMMAND ${Thrift_EXECUTABLE}
     ARGS -gen cpp -r -I ${CMAKE_SOURCE_DIR} -o ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_SOURCE_DIR}/java/thrift/calciteserver.thrift)
 
 add_library(calciteserver_thrift
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/CalciteServer.cpp
-    ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/calciteserver_constants.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/calciteserver_types.cpp
-    ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_constants.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_types.cpp
-    ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/extension_functions_constants.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/extension_functions_types.cpp
 )
 
diff -Naur ./Catalog/Catalog.cpp ../omniscidb-master/Catalog/Catalog.cpp
--- ./Catalog/Catalog.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Catalog/Catalog.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -2161,7 +2161,7 @@
     if (td.persistenceLevel == Data_Namespace::MemoryLevel::DISK_LEVEL) {
       throw std::runtime_error("Only temporary tables can be backed by foreign storage.");
     }
-    ForeignStorageInterface::prepareTable(getCurrentDB().dbId, td, cds);
+    dataMgr_->getForeignStorageInterface()->prepareTable(getCurrentDB().dbId, td, cds);
   }
 
   for (auto cd : cds) {
@@ -2352,7 +2352,7 @@
     addTableToMap(&td, cds, dds);
     calciteMgr_->updateMetadata(currentDB_.dbName, td.tableName);
     if (!td.storageType.empty() && td.storageType != StorageType::FOREIGN_TABLE) {
-      ForeignStorageInterface::registerTable(this, td, cds);
+      dataMgr_->getForeignStorageInterface()->registerTable(this, td, cds);
     }
   } catch (std::exception& e) {
     sqliteConnector_.query("ROLLBACK TRANSACTION");
diff -Naur ./Catalog/ColumnDescriptor.h ../omniscidb-master/Catalog/ColumnDescriptor.h
--- ./Catalog/ColumnDescriptor.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Catalog/ColumnDescriptor.h	2021-04-21 00:02:57.000000000 +0300
@@ -20,6 +20,7 @@
 #include <cassert>
 #include <string>
 #include "../Shared/sqltypes.h"
+#include "../Shared/toString.h"
 
 /**
  * @type ColumnDescriptor
@@ -56,6 +57,13 @@
   ColumnDescriptor(const bool isGeoPhyCol) : ColumnDescriptor() {
     this->isGeoPhyCol = isGeoPhyCol;
   }
+
+  std::string toString() const {
+    return ::typeName(this) + "(tableId=" + ::toString(tableId) +
+           ", columnId=" + ::toString(columnId) +
+           ", columnName=" + ::toString(columnName) +
+           ", columnType=" + ::toString(columnType) + ")";
+  }
 };
 
 #endif  // COLUMN_DESCRIPTOR
diff -Naur ./Catalog/DdlCommandExecutor.cpp ../omniscidb-master/Catalog/DdlCommandExecutor.cpp
--- ./Catalog/DdlCommandExecutor.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Catalog/DdlCommandExecutor.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -1502,14 +1502,8 @@
     auto [td, td_with_lock] =
         get_table_descriptor_with_lock<lockmgr::ReadLock>(*cat_ptr, table_name, false);
 
-    const auto mgr = dynamic_cast<File_Namespace::FileMgr*>(
-        disk_cache->getGlobalFileMgr()->findFileMgr(cat_ptr->getDatabaseId(),
-                                                    td->tableId));
-
-    // NOTE: This size does not include datawrapper metadata that is on disk.
-    // If a mgr does not exist it means a cache is not enabled/created for the given
-    // table.
-    auto table_cache_size = mgr ? mgr->getTotalFileSize() : 0;
+    auto table_cache_size =
+        disk_cache->getSpaceReservedByTable(cat_ptr->getDatabaseId(), td->tableId);
 
     // logical_values -> table data
     logical_values.emplace_back(RelLogicalValues::RowValues{});
diff -Naur ./Catalog/SysCatalog.cpp ../omniscidb-master/Catalog/SysCatalog.cpp
--- ./Catalog/SysCatalog.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Catalog/SysCatalog.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -48,7 +48,7 @@
 #include "../Shared/measure.h"
 #include "MapDRelease.h"
 #include "RWLocks.h"
-#include "bcrypt.h"
+#include "include/bcrypt.h"
 
 using std::list;
 using std::map;
@@ -114,6 +114,7 @@
 namespace Catalog_Namespace {
 
 thread_local bool SysCatalog::thread_holds_read_lock = false;
+std::unique_ptr<SysCatalog> SysCatalog::instance_;
 
 using sys_read_lock = read_lock<SysCatalog>;
 using sys_write_lock = write_lock<SysCatalog>;
diff -Naur ./Catalog/SysCatalog.h ../omniscidb-master/Catalog/SysCatalog.h
--- ./Catalog/SysCatalog.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Catalog/SysCatalog.h	2021-04-21 00:02:57.000000000 +0300
@@ -290,10 +290,14 @@
                                  const std::vector<std::string> grantees);
   bool isAggregator() const { return aggregator_; }
   static SysCatalog& instance() {
-    static SysCatalog sys_cat{};
-    return sys_cat;
+    if (!instance_) {
+      instance_.reset(new SysCatalog());
+    }
+    return *instance_;
   }
 
+  static void destroy() { instance_.reset(); }
+
   void populateRoleDbObjects(const std::vector<DBObject>& objects);
   std::string name() const { return OMNISCI_DEFAULT_DB; }
   void renameObjectsInDescriptorMap(DBObject& object,
@@ -314,6 +318,8 @@
 
   void removeCatalog(const std::string& dbName);
 
+  virtual ~SysCatalog();
+
  private:
   using GranteeMap = std::map<std::string, Grantee*>;
   using ObjectRoleDescriptorMap = std::multimap<std::string, ObjectRoleDescriptor*>;
@@ -326,7 +332,6 @@
       , thread_holding_sqlite_lock(std::thread::id())
       , thread_holding_write_lock(std::thread::id())
       , dummyCatalog_(std::make_shared<Catalog>()) {}
-  virtual ~SysCatalog();
 
   void initDB();
   void buildRoleMap();
@@ -422,6 +427,8 @@
   using dbid_to_cat_map = tbb::concurrent_hash_map<std::string, std::shared_ptr<Catalog>>;
   dbid_to_cat_map cat_map_;
 
+  static std::unique_ptr<SysCatalog> instance_;
+
  public:
   mutable std::mutex sqliteMutex_;
   mutable mapd_shared_mutex sharedMutex_;
diff -Naur ./CudaMgr/CudaMgr.cpp ../omniscidb-master/CudaMgr/CudaMgr.cpp
--- ./CudaMgr/CudaMgr.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/CudaMgr/CudaMgr.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -16,9 +16,9 @@
 
 #include "CudaMgr/CudaMgr.h"
 #include "QueryEngine/NvidiaKernel.h"
+#include "Shared/boost_stacktrace.hpp"
 
 #include <algorithm>
-#include <boost/stacktrace.hpp>
 #include <cassert>
 #include <iostream>
 #include <stdexcept>
diff -Naur ./DataMgr/AbstractBufferMgr.h ../omniscidb-master/DataMgr/AbstractBufferMgr.h
--- ./DataMgr/AbstractBufferMgr.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/AbstractBufferMgr.h	2021-04-21 00:02:57.000000000 +0300
@@ -41,9 +41,10 @@
     }                                                                             \
   }
 
-DEFINE_ENUM_WITH_STRING_CONVERSIONS(MgrType,
-                                    (FILE_MGR)(CPU_MGR)(GPU_MGR)(GLOBAL_FILE_MGR)(
-                                        PERSISTENT_STORAGE_MGR)(FOREIGN_STORAGE_MGR))
+DEFINE_ENUM_WITH_STRING_CONVERSIONS(
+    MgrType,
+    (CACHING_FILE_MGR)(FILE_MGR)(CPU_MGR)(GPU_MGR)(GLOBAL_FILE_MGR)(
+        PERSISTENT_STORAGE_MGR)(FOREIGN_STORAGE_MGR))
 
 namespace Data_Namespace {
 
diff -Naur ./DataMgr/Allocators/ThrustAllocator.cpp ../omniscidb-master/DataMgr/Allocators/ThrustAllocator.cpp
--- ./DataMgr/Allocators/ThrustAllocator.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/Allocators/ThrustAllocator.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -17,7 +17,6 @@
 #include "DataMgr/Allocators/ThrustAllocator.h"
 
 #define BOOST_STACKTRACE_GNU_SOURCE_NOT_REQUIRED 1
-#include <boost/stacktrace.hpp>
 
 #include <cstdint>
 
@@ -25,6 +24,7 @@
 #include "DataMgr/Allocators/CudaAllocator.h"
 #include "DataMgr/DataMgr.h"
 #include "Logger/Logger.h"
+#include "Shared/boost_stacktrace.hpp"
 
 int8_t* ThrustAllocator::allocate(std::ptrdiff_t num_bytes) {
   VLOG(1) << "Thrust allocation: Device #" << device_id_ << " Allocation #"
diff -Naur ./DataMgr/BufferMgr/BufferMgr.h ../omniscidb-master/DataMgr/BufferMgr/BufferMgr.h
--- ./DataMgr/BufferMgr/BufferMgr.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/BufferMgr/BufferMgr.h	2021-04-21 00:02:57.000000000 +0300
@@ -31,11 +31,10 @@
 #include <map>
 #include <mutex>
 
-#include <boost/stacktrace.hpp>
-
 #include "DataMgr/AbstractBuffer.h"
 #include "DataMgr/AbstractBufferMgr.h"
 #include "DataMgr/BufferMgr/BufferSeg.h"
+#include "Shared/boost_stacktrace.hpp"
 #include "Shared/types.h"
 
 class OutOfMemory : public std::runtime_error {
diff -Naur ./DataMgr/CMakeLists.txt ../omniscidb-master/DataMgr/CMakeLists.txt
--- ./DataMgr/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -8,6 +8,7 @@
     DataMgr.cpp
     Encoder.cpp
     StringNoneEncoder.cpp
+    FileMgr/CachingFileMgr.cpp
     FileMgr/GlobalFileMgr.cpp
     FileMgr/FileMgr.cpp
     FileMgr/FileBuffer.cpp
diff -Naur ./DataMgr/Chunk/Chunk.h ../omniscidb-master/DataMgr/Chunk/Chunk.h
--- ./DataMgr/Chunk/Chunk.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/Chunk/Chunk.h	2021-04-21 00:02:57.000000000 +0300
@@ -30,6 +30,7 @@
 #include "DataMgr/ChunkMetadata.h"
 #include "DataMgr/DataMgr.h"
 #include "Shared/sqltypes.h"
+#include "Shared/toString.h"
 #include "Utils/ChunkIter.h"
 
 using Data_Namespace::AbstractBuffer;
@@ -113,6 +114,12 @@
 
   void decompress(int8_t* compressed, VarlenDatum* result, Datum* datum) const;
 
+  std::string toString() const {
+    return ::typeName(this) + "(buffer=" + ::toString(buffer_) +
+           ", index_buf=" + ::toString(index_buf_) +
+           ", column_desc=" + ::toString(column_desc_) + ")";
+  }
+
  private:
   AbstractBuffer* buffer_;
   AbstractBuffer* index_buf_;
diff -Naur ./DataMgr/ChunkMetadata.h ../omniscidb-master/DataMgr/ChunkMetadata.h
--- ./DataMgr/ChunkMetadata.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ChunkMetadata.h	2021-04-21 00:02:57.000000000 +0300
@@ -34,7 +34,7 @@
   size_t numElements;
   ChunkStats chunkStats;
 
-  std::string dump() {
+  std::string dump() const {
     auto type = sqlType.is_array() ? sqlType.get_elem_type() : sqlType;
     // Unencoded strings have no min/max.
     if (type.is_string() && type.get_compression() == kENCODING_NONE) {
@@ -56,6 +56,8 @@
     }
   }
 
+  std::string toString() const { return dump(); }
+
   ChunkMetadata(const SQLTypeInfo& sql_type,
                 const size_t num_bytes,
                 const size_t num_elements,
diff -Naur ./DataMgr/DataMgr.cpp ../omniscidb-master/DataMgr/DataMgr.cpp
--- ./DataMgr/DataMgr.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/DataMgr.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -23,7 +23,6 @@
 #include "BufferMgr/CpuBufferMgr/CpuBufferMgr.h"
 #include "BufferMgr/GpuCudaBufferMgr/GpuCudaBufferMgr.h"
 #include "CudaMgr/CudaMgr.h"
-#include "DataMgr/ForeignStorage/ForeignStorageCache.h"
 #include "FileMgr/GlobalFileMgr.h"
 #include "PersistentStorageMgr/PersistentStorageMgr.h"
 
@@ -549,6 +548,11 @@
   return global_file_mgr;
 }
 
+std::shared_ptr<ForeignStorageInterface> DataMgr::getForeignStorageInterface() const {
+  return dynamic_cast<PersistentStorageMgr*>(bufferMgrs_[0][0])
+      ->getForeignStorageInterface();
+}
+
 std::ostream& operator<<(std::ostream& os, const DataMgr::SystemMemoryUsage& mem_info) {
   os << "jsonlog ";
   os << "{";
diff -Naur ./DataMgr/DataMgr.h ../omniscidb-master/DataMgr/DataMgr.h
--- ./DataMgr/DataMgr.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/DataMgr.h	2021-04-21 00:02:57.000000000 +0300
@@ -206,6 +206,7 @@
 
   CudaMgr_Namespace::CudaMgr* getCudaMgr() const { return cudaMgr_.get(); }
   File_Namespace::GlobalFileMgr* getGlobalFileMgr() const;
+  std::shared_ptr<ForeignStorageInterface> getForeignStorageInterface() const;
 
   // database_id, table_id, column_id, fragment_id
   std::vector<int> levelSizes_;
diff -Naur ./DataMgr/FileMgr/CachingFileMgr.cpp ../omniscidb-master/DataMgr/FileMgr/CachingFileMgr.cpp
--- ./DataMgr/FileMgr/CachingFileMgr.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/CachingFileMgr.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2021 Omnisci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file        CachingFileMgr.h
+ */
+
+#include "DataMgr/FileMgr/CachingFileMgr.h"
+#include <boost/filesystem.hpp>
+#include "Shared/File.h"
+
+constexpr char EPOCH_FILENAME[] = "epoch_metadata";
+
+namespace File_Namespace {
+namespace bf = boost::filesystem;
+
+CachingFileMgr::CachingFileMgr(const std::string& base_path,
+                               const size_t num_reader_threads) {
+  fileMgrBasePath_ = base_path;
+  maxRollbackEpochs_ = 0;
+  defaultPageSize_ = DEFAULT_PAGE_SIZE;
+  nextFileId_ = 0;
+  init(num_reader_threads, -1);
+}
+
+bool CachingFileMgr::coreInit() {
+  mapd_unique_lock<mapd_shared_mutex> write_lock(files_rw_mutex_);
+  bf::path path(fileMgrBasePath_);
+  if (bf::exists(path)) {
+    if (!bf::is_directory(path)) {
+      LOG(FATAL) << "Specified path '" << fileMgrBasePath_
+                 << "' for disk cache is not a directory.";
+    }
+    migrateToLatestFileMgrVersion();
+    openAndReadEpochFile(EPOCH_FILENAME);
+    return true;
+  }
+  LOG(FATAL) << "Cache path: " << fileMgrBasePath_ << "does not exit.";
+  return false;
+}
+
+void CachingFileMgr::clearForTable(int db_id, int tb_id) {
+  {
+    mapd_unique_lock<mapd_shared_mutex> write_lock(chunkIndexMutex_);
+    for (auto it = chunkIndex_.begin(); it != chunkIndex_.end();) {
+      auto& [key, buffer] = *it;
+      if (in_same_table(key, {db_id, tb_id})) {
+        buffer->freePages();
+        delete buffer;
+        it = chunkIndex_.erase(it);
+      } else {
+        ++it;
+      }
+    }
+    auto dir_name = getFileMgrBasePath() + "/" + get_dir_name_for_table(db_id, tb_id);
+    if (bf::exists(dir_name)) {
+      bf::remove_all(dir_name);
+    }
+  }
+  checkpoint(db_id, tb_id);
+  // TODO(Misiu): Implement background file removal.
+  // Currently the renameForDelete idiom will only work in the mapd/ directory as the
+  // cleanup thread is targetted there.  If we want it to work for arbitrary directories
+  // we will need to add a new dir to the thread, or start a second thread.
+  // File_Namespace::renameForDelete(get_dir_name_for_table(db_id, tb_id));
+}
+
+std::string CachingFileMgr::getOrAddTableDir(int db_id, int tb_id) {
+  mapd_unique_lock<mapd_shared_mutex> write_lock(files_rw_mutex_);
+  std::string table_dir =
+      getFileMgrBasePath() + "/" + get_dir_name_for_table(db_id, tb_id);
+  if (!bf::exists(table_dir)) {
+    bf::create_directory(table_dir);
+  } else {
+    if (!bf::is_directory(table_dir)) {
+      LOG(FATAL) << "Specified path '" << table_dir
+                 << "' for cache table data is not a directory.";
+    }
+  }
+  return table_dir;
+}
+
+void CachingFileMgr::closeRemovePhysical() {
+  mapd_unique_lock<mapd_shared_mutex> write_lock(files_rw_mutex_);
+  closePhysicalUnlocked();
+  auto dir_name = getFileMgrBasePath();
+  if (bf::exists(dir_name)) {
+    bf::remove_all(dir_name);
+  }
+
+  // TODO(Misiu): Implement background file removal.
+  // Currently the renameForDelete idiom will only work in the mapd/ directory as the
+  // cleanup thread is targetted there.  If we want it to work for arbitrary directories
+  // we will need to add a new dir to the thread, or start a second thread.
+  // File_Namespace::renameForDelete(getFileMgrBasePath());
+}
+
+uint64_t CachingFileMgr::getChunkSpaceReservedByTable(int db_id, int tb_id) {
+  mapd_shared_lock<mapd_shared_mutex> read_lock(chunkIndexMutex_);
+  uint64_t space_used = 0;
+  for (const auto& [key, buffer] : chunkIndex_) {
+    if (key[CHUNK_KEY_DB_IDX] == db_id && key[CHUNK_KEY_TABLE_IDX] == tb_id) {
+      space_used += buffer->reservedSize();
+    }
+  }
+  return space_used;
+}
+
+uint64_t CachingFileMgr::getMetadataSpaceReservedByTable(int db_id, int tb_id) {
+  mapd_shared_lock<mapd_shared_mutex> read_lock(chunkIndexMutex_);
+  uint64_t space_used = 0;
+  for (const auto& [key, buffer] : chunkIndex_) {
+    if (key[CHUNK_KEY_DB_IDX] == db_id && key[CHUNK_KEY_TABLE_IDX] == tb_id) {
+      space_used += (buffer->numMetadataPages() * METADATA_PAGE_SIZE);
+    }
+  }
+  return space_used;
+}
+
+uint64_t CachingFileMgr::getWrapperSpaceReservedByTable(int db_id, int tb_id) {
+  mapd_shared_lock<mapd_shared_mutex> read_lock(files_rw_mutex_);
+  uint64_t space_used = 0;
+  std::string table_dir =
+      getFileMgrBasePath() + "/" + get_dir_name_for_table(db_id, tb_id);
+  if (bf::exists(table_dir)) {
+    for (const auto& file : bf::recursive_directory_iterator(table_dir)) {
+      if (bf::is_regular_file(file.path())) {
+        space_used += bf::file_size(file.path());
+      }
+    }
+  }
+  return space_used;
+}
+
+uint64_t CachingFileMgr::getSpaceReservedByTable(int db_id, int tb_id) {
+  auto chunkSpace = getChunkSpaceReservedByTable(db_id, tb_id);
+  auto metaSpace = getMetadataSpaceReservedByTable(db_id, tb_id);
+  auto wrapperSpace = getWrapperSpaceReservedByTable(db_id, tb_id);
+  return chunkSpace + metaSpace + wrapperSpace;
+}
+
+std::string CachingFileMgr::describeSelf() {
+  return "cache";
+}
+
+// Similar to FileMgr::checkpoint() but only writes/rolloffs a subset of buffers.
+void CachingFileMgr::checkpoint(const int32_t db_id, const int32_t tb_id) {
+  VLOG(2) << "Checkpointing " << describeSelf() << " (" << db_id << ", " << tb_id
+          << " epoch: " << epoch();
+  {
+    mapd_unique_lock<mapd_shared_mutex> chunk_index_write_lock(chunkIndexMutex_);
+    ChunkKey min_table_key{db_id, tb_id};
+    ChunkKey max_table_key{db_id, tb_id, std::numeric_limits<int32_t>::max()};
+
+    for (auto chunkIt = chunkIndex_.lower_bound(min_table_key);
+         chunkIt != chunkIndex_.upper_bound(max_table_key);
+         ++chunkIt) {
+      if (chunkIt->second->isDirty()) {
+        chunkIt->second->writeMetadata(epoch());
+        chunkIt->second->clearDirtyBits();
+      }
+    }
+  }
+
+  syncFilesToDisk();
+  writeAndSyncEpochToDisk();
+  incrementEpoch();
+  rollOffOldData(db_id, tb_id, lastCheckpointedEpoch());
+  freePages();
+}
+
+void CachingFileMgr::rollOffOldData(const int32_t db_id,
+                                    const int32_t tb_id,
+                                    const int32_t epoch_ceiling) {
+  if (maxRollbackEpochs_ >= 0) {
+    auto min_epoch = std::max(epoch_ceiling - maxRollbackEpochs_, epoch_.floor());
+    if (min_epoch > epoch_.floor()) {
+      freePagesBeforeEpoch(db_id, tb_id, min_epoch);
+      epoch_.floor(min_epoch);
+    }
+  }
+}
+
+void CachingFileMgr::freePagesBeforeEpoch(const int32_t db_id,
+                                          const int32_t tb_id,
+                                          const int32_t min_rollback_epoch) {
+  mapd_shared_lock<mapd_shared_mutex> chunk_index_read_lock(chunkIndexMutex_);
+  ChunkKey min_table_key{db_id, tb_id};
+  ChunkKey max_table_key{db_id, tb_id, std::numeric_limits<int32_t>::max()};
+  freePagesBeforeEpochUnlocked(min_rollback_epoch,
+                               chunkIndex_.lower_bound(min_table_key),
+                               chunkIndex_.upper_bound(max_table_key));
+}
+
+}  // namespace File_Namespace
diff -Naur ./DataMgr/FileMgr/CachingFileMgr.h ../omniscidb-master/DataMgr/FileMgr/CachingFileMgr.h
--- ./DataMgr/FileMgr/CachingFileMgr.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/CachingFileMgr.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2021 Omnisci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file	CachingFileMgr.h
+ *
+ * This file details an extension of the FileMgr that can contain pages from multiple
+ * tables (CachingFileMgr).
+ */
+
+#pragma once
+
+#include "FileMgr.h"
+
+namespace File_Namespace {
+
+inline std::string get_dir_name_for_table(int db_id, int tb_id) {
+  std::stringstream file_name;
+  file_name << "table_" << db_id << "_" << tb_id << "/";
+  return file_name.str();
+}
+
+/**
+ * @class   CachingFileMgr
+ * @brief   A FileMgr capable of limiting it's size and storing data from multiple tables
+ * in a shared directory.  For any table that supports DiskCaching, the CachingFileMgr
+ * must contain either metadata for all table chunks, or for none (the cache is either has
+ * no knowledge of that table, or has complete knowledge of that table).  Any data chunk
+ * within a table may or may not be contained within the cache.
+ */
+class CachingFileMgr : public FileMgr {
+ public:
+  CachingFileMgr(const std::string& base_path, const size_t num_reader_threads = 0);
+  ~CachingFileMgr() {}
+  /**
+   * @brief Determines file path, and if exists, runs file migration and opens and reads
+   * epoch file
+   * @return a boolean representing whether the directory path existed
+   */
+  bool coreInit() override;
+
+  // Simple getters.
+  inline MgrType getMgrType() override { return CACHING_FILE_MGR; };
+  inline std::string getStringMgrType() override { return ToString(CACHING_FILE_MGR); }
+  inline size_t getDefaultPageSize() { return defaultPageSize_; }
+
+  // TODO(Misiu): These are unimplemented for now, but will become necessary when we want
+  // to limit the size.
+  inline size_t getMaxSize() override {
+    UNREACHABLE() << "Unimplemented";
+    return 0;
+  }
+  inline size_t getInUseSize() override {
+    UNREACHABLE() << "Unimplemented";
+    return 0;
+  }
+  inline size_t getAllocated() override {
+    UNREACHABLE() << "Unimplemented";
+    return 0;
+  }
+  inline bool isAllocationCapped() override { return false; }
+
+  /**
+   * @brief Removes all data related to the given table (pages and subdirectories).
+   */
+  void clearForTable(int db_id, int tb_id);
+
+  /**
+   * @brief Returns (and optionally creates) a subdirectory for table-specific persistent
+   * data (e.g. serialized foreign data warppers).
+   */
+  std::string getOrAddTableDir(int db_id, int tb_id);
+
+  /**
+   * @brief Query to determine if the contained pages will have their database and table
+   * ids overriden by the filemgr key (FileMgr does this).
+   */
+  inline bool hasFileMgrKey() const override { return false; }
+  /**
+   * @breif Closes files and removes the caching directory.
+   */
+  void closeRemovePhysical() override;
+
+  /**
+   * Set of functions to determine how much space is reserved in a table by type.
+   */
+  uint64_t getChunkSpaceReservedByTable(int db_id, int tb_id);
+  uint64_t getMetadataSpaceReservedByTable(int db_id, int tb_id);
+  uint64_t getWrapperSpaceReservedByTable(int db_id, int tb_id);
+  uint64_t getSpaceReservedByTable(int db_id, int tb_id);
+
+  std::string describeSelf() override;
+
+  void checkpoint(const int32_t db_id, const int32_t tb_id) override;
+
+  // These functions need locks because FileBuffers will call epoch() which can interfere
+  // with an incremment.
+  inline int32_t epoch() const override {
+    mapd_shared_lock<mapd_shared_mutex> read_lock(epoch_mutex_);
+    return FileMgr::epoch();
+  }
+
+  inline int32_t incrementEpoch() override {
+    mapd_unique_lock<mapd_shared_mutex> write_lock(epoch_mutex_);
+    return FileMgr::incrementEpoch();
+  }
+
+ private:
+  void rollOffOldData(const int32_t db_id,
+                      const int32_t tb_id,
+                      const int32_t epoch_ceiling);
+  void freePagesBeforeEpoch(const int32_t db_id,
+                            const int32_t tb_id,
+                            const int32_t min_epoch);
+
+  mutable mapd_shared_mutex epoch_mutex_;
+};
+
+}  // namespace File_Namespace
diff -Naur ./DataMgr/FileMgr/FileBuffer.cpp ../omniscidb-master/DataMgr/FileMgr/FileBuffer.cpp
--- ./DataMgr/FileMgr/FileBuffer.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/FileBuffer.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -622,4 +622,12 @@
   CHECK(bytesLeft == 0);
 }
 
+std::string FileBuffer::dump() const {
+  std::stringstream ss;
+  ss << "chunk_key = " << show_chunk(chunkKey_) << "\n";
+  ss << "has_encoder = " << (hasEncoder() ? "true\n" : "false\n");
+  ss << "size_ = " << size_ << "\n";
+  return ss.str();
+}
+
 }  // namespace File_Namespace
diff -Naur ./DataMgr/FileMgr/FileBuffer.h ../omniscidb-master/DataMgr/FileMgr/FileBuffer.h
--- ./DataMgr/FileMgr/FileBuffer.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/FileBuffer.h	2021-04-21 00:02:57.000000000 +0300
@@ -38,7 +38,9 @@
 
 namespace File_Namespace {
 
-class FileMgr;  // forward declaration
+// forward declarations
+class FileMgr;
+class CachingFileMgr;
 
 /**
  * @class   FileBuffer
@@ -55,6 +57,7 @@
  */
 class FileBuffer : public AbstractBuffer {
   friend class FileMgr;
+  friend class CachingFileMgr;
 
  public:
   /**
@@ -148,6 +151,8 @@
 
   inline size_t numMetadataPages() const { return metadataPages_.pageVersions.size(); };
 
+  std::string dump() const;
+
  private:
   // FileBuffer(const FileBuffer&);      // private copy constructor
   // FileBuffer& operator=(const FileBuffer&); // private overloaded assignment operator
diff -Naur ./DataMgr/FileMgr/FileInfo.cpp ../omniscidb-master/DataMgr/FileMgr/FileInfo.cpp
--- ./DataMgr/FileMgr/FileInfo.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/FileInfo.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -105,10 +105,14 @@
       // We don't want to read headerSize in our header - so start
       // reading 4 bytes past it
 
-      // always derive dbid/tbid from FileMgr
+      // Derive dbid/tbid if from FileMgr
       ChunkKey chunkKey(&ints[1], &ints[1 + numHeaderElems - 2]);
-      chunkKey[0] = fileMgr->get_fileMgrKey().first;
-      chunkKey[1] = fileMgr->get_fileMgrKey().second;
+      if (fileMgr->hasFileMgrKey()) {
+        // A regular FileMgr is locked to one table, but a CachingFileMgr can contain
+        // chunks from different tables
+        chunkKey[0] = fileMgr->get_fileMgrKey().first;
+        chunkKey[1] = fileMgr->get_fileMgrKey().second;
+      }
       // recover page in case a crash failed deletion of this page
       if (!g_read_only) {
         if (ints[1] == DELETE_CONTINGENT || ints[1] == ROLLOFF_CONTINGENT) {
diff -Naur ./DataMgr/FileMgr/FileMgr.cpp ../omniscidb-master/DataMgr/FileMgr/FileMgr.cpp
--- ./DataMgr/FileMgr/FileMgr.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/FileMgr.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -50,18 +50,6 @@
 
 namespace File_Namespace {
 
-bool headerCompare(const HeaderInfo& firstElem, const HeaderInfo& secondElem) {
-  // HeaderInfo.first is a pair of Chunk key with a vector containing
-  // pageId and version
-  if (firstElem.chunkKey != secondElem.chunkKey) {
-    return firstElem.chunkKey < secondElem.chunkKey;
-  }
-  if (firstElem.pageId != secondElem.pageId) {
-    return firstElem.pageId < secondElem.pageId;
-  }
-  return firstElem.versionEpoch < secondElem.versionEpoch;
-}
-
 FileMgr::FileMgr(const int32_t deviceId,
                  GlobalFileMgr* gfm,
                  const std::pair<const int32_t, const int> fileMgrKey,
@@ -70,11 +58,11 @@
                  const int32_t epoch,
                  const size_t defaultPageSize)
     : AbstractBufferMgr(deviceId)
-    , gfm_(gfm)
-    , fileMgrKey_(fileMgrKey)
     , maxRollbackEpochs_(maxRollbackEpochs)
     , defaultPageSize_(defaultPageSize)
-    , nextFileId_(0) {
+    , nextFileId_(0)
+    , gfm_(gfm)
+    , fileMgrKey_(fileMgrKey) {
   init(num_reader_threads, epoch);
 }
 
@@ -85,11 +73,11 @@
                  const size_t defaultPageSize,
                  const bool runCoreInit)
     : AbstractBufferMgr(deviceId)
-    , gfm_(gfm)
-    , fileMgrKey_(fileMgrKey)
     , maxRollbackEpochs_(-1)
     , defaultPageSize_(defaultPageSize)
-    , nextFileId_(0) {
+    , nextFileId_(0)
+    , gfm_(gfm)
+    , fileMgrKey_(fileMgrKey) {
   const std::string fileMgrDirPrefix("table");
   const std::string FileMgrDirDelim("_");
   fileMgrBasePath_ = (gfm_->getBasePath() + fileMgrDirPrefix + FileMgrDirDelim +
@@ -104,12 +92,12 @@
 
 FileMgr::FileMgr(GlobalFileMgr* gfm, const size_t defaultPageSize, std::string basePath)
     : AbstractBufferMgr(0)
-    , gfm_(gfm)
-    , fileMgrKey_(0, 0)
     , maxRollbackEpochs_(-1)
     , fileMgrBasePath_(basePath)
     , defaultPageSize_(defaultPageSize)
-    , nextFileId_(0) {
+    , nextFileId_(0)
+    , gfm_(gfm)
+    , fileMgrKey_(0, 0) {
   init(basePath, -1);
 }
 
@@ -118,6 +106,9 @@
   epoch_.ceiling(epoch);
 }
 
+// Used to initialize CachingFileMgr.
+FileMgr::FileMgr() : AbstractBufferMgr(0) {}
+
 FileMgr::~FileMgr() {
   // free memory used by FileInfo objects
   for (auto chunkIt = chunkIndex_.begin(); chunkIt != chunkIndex_.end(); ++chunkIt) {
@@ -283,7 +274,7 @@
      * and in order of increasing PageId
      * - Version Epoch */
     auto& header_vec = open_files_result.header_infos;
-    std::sort(header_vec.begin(), header_vec.end(), headerCompare);
+    std::sort(header_vec.begin(), header_vec.end());
 
     /* Goal of next section is to find sequences in the
      * sorted headerVec of the same ChunkId, which we
@@ -308,14 +299,9 @@
           new FileBuffer(this, /*pageSize,*/ lastChunkKey, startIt, header_vec.end());
     }
     nextFileId_ = open_files_result.max_file_id + 1;
-    rollOffOldData(epoch(),
-                   true /* shouldCheckpoint - only happens if data is rolled off */);
+    rollOffOldData(epoch(), true /* only checkpoint if data is rolled off */);
     incrementEpoch();
-    mapd_unique_lock<mapd_shared_mutex> freePagesWriteLock(mutex_free_page_);
-    for (auto& free_page : free_pages_) {
-      free_page.first->freePageDeferred(free_page.second);
-    }
-    free_pages_.clear();
+    freePages();
   } else {
     boost::filesystem::path path(fileMgrBasePath_);
     if (!boost::filesystem::create_directory(path)) {
@@ -330,7 +316,6 @@
       epoch_.floor(0);
       epoch_.ceiling(0);
     }
-
     createEpochFile(EPOCH_FILENAME);
     writeAndSyncEpochToDisk();
     writeAndSyncVersionToDisk(FILE_MGR_VERSION_FILENAME, fileMgrVersion_);
@@ -339,8 +324,8 @@
 
   /* define number of reader threads to be used */
   size_t num_hardware_based_threads =
-      std::thread::hardware_concurrency();  // # of threads is based on # of cores on the
-                                            // host
+      std::thread::hardware_concurrency();  // # of threads is based on # of cores on
+                                            // the host
   if (num_reader_threads == 0) {            // # of threads has not been defined by user
     num_reader_threads_ = num_hardware_based_threads;
   } else {
@@ -489,7 +474,7 @@
      * and in order of increasing PageId
      * - Version Epoch */
 
-    std::sort(headerVec.begin(), headerVec.end(), headerCompare);
+    std::sort(headerVec.begin(), headerVec.end());
 
     /* Goal of next section is to find sequences in the
      * sorted headerVec of the same ChunkId, which we
@@ -568,9 +553,8 @@
   isFullyInitted_ = true;
 }
 
-void FileMgr::closeRemovePhysical() {
-  for (auto file_info_entry : files_) {
-    auto file_info = file_info_entry.second;
+void FileMgr::closePhysicalUnlocked() {
+  for (auto& [idx, file_info] : files_) {
     if (file_info->f) {
       close(file_info->f);
       file_info->f = nullptr;
@@ -586,7 +570,11 @@
     close(epochFile_);
     epochFile_ = nullptr;
   }
+}
 
+void FileMgr::closeRemovePhysical() {
+  mapd_unique_lock<mapd_shared_mutex> write_lock(files_rw_mutex_);
+  closePhysicalUnlocked();
   /* rename for later deletion the directory containing table related data */
   File_Namespace::renameForDelete(getFileMgrBasePath());
 }
@@ -641,6 +629,7 @@
   FILE* legacyEpochFile = open(epochFilePath);
   int32_t epoch;
   read(legacyEpochFile, 0, sizeof(int32_t), (int8_t*)&epoch);
+  close(legacyEpochFile);
   return epoch;
 }
 
@@ -667,70 +656,65 @@
   CHECK(epochFile_);
   write(epochFile_, 0, Epoch::byte_size(), epoch_.storage_ptr());
   int32_t status = fflush(epochFile_);
-  if (status != 0) {
-    LOG(FATAL) << "Could not flush epoch file to disk";
-  }
+  CHECK(status == 0) << "Could not flush epoch file to disk";
 #ifdef __APPLE__
   status = fcntl(fileno(epochFile_), 51);
 #else
   status = omnisci::fsync(fileno(epochFile_));
 #endif
-  if (status != 0) {
-    LOG(FATAL) << "Could not sync epoch file to disk";
-  }
+  CHECK(status == 0) << "Could not sync epoch file to disk";
   epochIsCheckpointed_ = true;
 }
 
-void FileMgr::freePagesBeforeEpoch(const int32_t minRollbackEpoch) {
-  for (auto chunkIt = chunkIndex_.begin(); chunkIt != chunkIndex_.end(); ++chunkIt) {
-    chunkIt->second->freePagesBeforeEpoch(minRollbackEpoch);
+void FileMgr::freePagesBeforeEpoch(const int32_t min_epoch) {
+  mapd_shared_lock<mapd_shared_mutex> chunk_index_read_lock(chunkIndexMutex_);
+  freePagesBeforeEpochUnlocked(min_epoch, chunkIndex_.begin(), chunkIndex_.end());
+}
+
+void FileMgr::freePagesBeforeEpochUnlocked(
+    const int32_t min_epoch,
+    const ChunkKeyToChunkMap::iterator lower_bound,
+    const ChunkKeyToChunkMap::iterator upper_bound) {
+  for (auto chunkIt = lower_bound; chunkIt != upper_bound; ++chunkIt) {
+    chunkIt->second->freePagesBeforeEpoch(min_epoch);
   }
 }
 
-void FileMgr::rollOffOldData(const int32_t epochCeiling, const bool shouldCheckpoint) {
+void FileMgr::rollOffOldData(const int32_t epoch_ceiling, const bool should_checkpoint) {
   if (maxRollbackEpochs_ >= 0) {
-    const int32_t minRollbackEpoch =
-        std::max(epochCeiling - maxRollbackEpochs_, epoch_.floor());
-    if (minRollbackEpoch > epoch_.floor()) {
-      freePagesBeforeEpoch(minRollbackEpoch);
-      epoch_.floor(minRollbackEpoch);
-      if (shouldCheckpoint) {
+    auto min_epoch = std::max(epoch_ceiling - maxRollbackEpochs_, epoch_.floor());
+    if (min_epoch > epoch_.floor()) {
+      freePagesBeforeEpoch(min_epoch);
+      epoch_.floor(min_epoch);
+      if (should_checkpoint) {
         checkpoint();
       }
     }
   }
 }
 
+std::string FileMgr::describeSelf() {
+  stringstream ss;
+  ss << "table (" << fileMgrKey_.first << ", " << fileMgrKey_.second << ")";
+  return ss.str();
+}
+
 void FileMgr::checkpoint() {
-  VLOG(2) << "Checkpointing table (" << fileMgrKey_.first << ", " << fileMgrKey_.second
-          << " epoch: " << epoch();
-  mapd_unique_lock<mapd_shared_mutex> chunkIndexWriteLock(chunkIndexMutex_);
-  for (auto chunkIt = chunkIndex_.begin(); chunkIt != chunkIndex_.end(); ++chunkIt) {
-    if (chunkIt->second->isDirty()) {
-      chunkIt->second->writeMetadata(epoch());
-      chunkIt->second->clearDirtyBits();
+  VLOG(2) << "Checkpointing " << describeSelf() << " epoch: " << epoch();
+  {
+    mapd_unique_lock<mapd_shared_mutex> chunk_index_write_lock(chunkIndexMutex_);
+    for (auto chunkIt = chunkIndex_.begin(); chunkIt != chunkIndex_.end(); ++chunkIt) {
+      if (chunkIt->second->isDirty()) {
+        chunkIt->second->writeMetadata(epoch());
+        chunkIt->second->clearDirtyBits();
+      }
     }
   }
-  chunkIndexWriteLock.unlock();
-
   rollOffOldData(epoch(), false /* shouldCheckpoint */);
-
-  mapd_shared_lock<mapd_shared_mutex> read_lock(files_rw_mutex_);
-  for (auto file_info_entry : files_) {
-    int32_t status = file_info_entry.second->syncToDisk();
-    if (status != 0) {
-      LOG(FATAL) << "Could not sync file to disk";
-    }
-  }
-
+  syncFilesToDisk();
   writeAndSyncEpochToDisk();
   incrementEpoch();
-
-  mapd_unique_lock<mapd_shared_mutex> freePagesWriteLock(mutex_free_page_);
-  for (auto& free_page : free_pages_) {
-    free_page.first->freePageDeferred(free_page.second);
-  }
-  free_pages_.clear();
+  freePages();  // write free_page mutex.
 }
 
 FileBuffer* FileMgr::createBuffer(const ChunkKey& key,
@@ -1202,9 +1186,8 @@
 void FileMgr::setEpoch(const int32_t newEpoch) {
   if (newEpoch < epoch_.floor()) {
     std::stringstream error_message;
-    error_message << "Cannot set epoch for table (" << fileMgrKey_.first << ","
-                  << fileMgrKey_.second << ") lower than the minimum rollback epoch ("
-                  << epoch_.floor() << ").";
+    error_message << "Cannot set epoch for " << describeSelf()
+                  << " lower than the minimum rollback epoch (" << epoch_.floor() << ").";
     throw std::runtime_error(error_message.str());
   }
   epoch_.ceiling(newEpoch);
@@ -1220,20 +1203,6 @@
   UNREACHABLE();
 }
 
-uint64_t FileMgr::getTotalFileSize() const {
-  uint64_t total_size = 0;
-  for (const auto& file_info_entry : files_) {
-    total_size += file_info_entry.second->size();
-  }
-  if (epochFile_) {
-    total_size += fileSize(epochFile_);
-  }
-  if (DBMetaFile_) {
-    total_size += fileSize(DBMetaFile_);
-  }
-  return total_size;
-}
-
 /**
  * Resumes an interrupted file compaction process. This method would
  * normally only be called when re-initializing the file manager
@@ -1597,6 +1566,22 @@
   num_pages_per_metadata_file_ = num_pages;
 }
 
+void FileMgr::syncFilesToDisk() {
+  mapd_shared_lock<mapd_shared_mutex> files_read_lock(files_rw_mutex_);
+  for (auto file_info_entry : files_) {
+    int32_t status = file_info_entry.second->syncToDisk();
+    CHECK(status == 0) << "Could not sync file to disk";
+  }
+}
+
+void FileMgr::freePages() {
+  mapd_unique_lock<mapd_shared_mutex> free_pages_write_lock(mutex_free_page_);
+  for (auto& free_page : free_pages_) {
+    free_page.first->freePageDeferred(free_page.second);
+  }
+  free_pages_.clear();
+}
+
 size_t FileMgr::num_pages_per_data_file_{DEFAULT_NUM_PAGES_PER_DATA_FILE};
 size_t FileMgr::num_pages_per_metadata_file_{DEFAULT_NUM_PAGES_PER_METADATA_FILE};
 }  // namespace File_Namespace
diff -Naur ./DataMgr/FileMgr/FileMgr.h ../omniscidb-master/DataMgr/FileMgr/FileMgr.h
--- ./DataMgr/FileMgr/FileMgr.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/FileMgr.h	2021-04-21 00:02:57.000000000 +0300
@@ -38,14 +38,13 @@
 #include "DataMgr/FileMgr/FileBuffer.h"
 #include "DataMgr/FileMgr/FileInfo.h"
 #include "DataMgr/FileMgr/Page.h"
+#include "Fragmenter/FragmentDefaultValues.h"
 #include "Shared/mapd_shared_mutex.h"
 
 using namespace Data_Namespace;
 
 namespace File_Namespace {
 
-#define DEFAULT_PAGE_SIZE 2097152ULL
-
 class GlobalFileMgr;  // forward declaration
 /**
  * @type PageSizeFileMMap
@@ -164,7 +163,7 @@
   FileMgr(GlobalFileMgr* gfm, const size_t defaultPageSize, std::string basePath);
 
   /// Destructor
-  ~FileMgr() override;
+  virtual ~FileMgr() override;
 
   StorageStats getStorageStats();
   /// Creates a chunk with the specified key and page size.
@@ -216,7 +215,6 @@
 
   inline FileInfo* getFileInfoForFileId(const int32_t fileId) { return files_[fileId]; }
 
-  uint64_t getTotalFileSize() const;
   FileMetadata getMetadataForFile(
       const boost::filesystem::directory_iterator& fileIterator);
 
@@ -229,7 +227,7 @@
    * @return a boolean representing whether the directory path existed
    */
 
-  bool coreInit();
+  virtual bool coreInit();
 
   void copyPage(Page& srcPage,
                 FileMgr* destFileMgr,
@@ -265,18 +263,18 @@
    */
 
   void checkpoint() override;
-  void checkpoint(const int32_t db_id, const int32_t tb_id) override {
+  virtual void checkpoint(const int32_t db_id, const int32_t tb_id) override {
     LOG(FATAL) << "Operation not supported, api checkpoint() should be used instead";
   }
   /**
    * @brief Returns current value of epoch - should be
    * one greater than recorded at last checkpoint
    */
-  inline int32_t epoch() { return static_cast<int32_t>(epoch_.ceiling()); }
+  inline virtual int32_t epoch() const { return static_cast<int32_t>(epoch_.ceiling()); }
 
-  inline int32_t epochFloor() { return static_cast<int32_t>(epoch_.floor()); }
+  inline int32_t epochFloor() const { return static_cast<int32_t>(epoch_.floor()); }
 
-  inline int32_t incrementEpoch() {
+  inline virtual int32_t incrementEpoch() {
     int32_t newEpoch = epoch_.increment();
     epochIsCheckpointed_ = false;
     // We test for error here instead of in Epoch::increment so we can log FileMgr
@@ -329,12 +327,13 @@
   int32_t getDBVersion() const;
   bool getDBConvert() const;
   void createTopLevelMetadata();  // create metadata shared by all tables of all DBs
-  std::string getFileMgrBasePath() const { return fileMgrBasePath_; }
-  void closeRemovePhysical();
+  inline std::string getFileMgrBasePath() const { return fileMgrBasePath_; }
+  virtual void closeRemovePhysical();
 
   void removeTableRelatedDS(const int32_t db_id, const int32_t table_id) override;
 
   void free_page(std::pair<FileInfo*, int32_t>&& page);
+  inline virtual bool hasFileMgrKey() const { return true; }
   const std::pair<const int32_t, const int32_t> get_fileMgrKey() const {
     return fileMgrKey_;
   }
@@ -366,12 +365,9 @@
   static void setNumPagesPerMetadataFile(size_t num_pages);
 
  protected:
-  // For testing purposes only
-  FileMgr(const int epoch);
+  // Used to initialize CachingFileMgr.
+  FileMgr();
 
- private:
-  GlobalFileMgr* gfm_;  /// Global FileMgr
-  std::pair<const int32_t, const int32_t> fileMgrKey_;
   int32_t maxRollbackEpochs_;
   std::string fileMgrBasePath_;  /// The OS file system path containing files related to
                                  /// this FileMgr
@@ -430,12 +426,6 @@
   void openAndReadEpochFile(const std::string& epochFileName);
   void writeAndSyncEpochToDisk();
   void setEpoch(const int32_t newEpoch);  // resets current value of epoch at startup
-  void freePagesBeforeEpoch(const int32_t minRollbackEpoch);
-
-  void rollOffOldData(const int32_t epochCeiling, const bool shouldCheckpoint);
-  // int32_t checkEpochFloor(const std::string& epochFloorFilePath) const;
-  // void setEpochFloor(const std::string& epochFloorFilePath, const int32_t epochFloor);
-
   int32_t readVersionFromDisk(const std::string& versionFileName) const;
   void writeAndSyncVersionToDisk(const std::string& versionFileName,
                                  const int32_t version);
@@ -467,6 +457,26 @@
   void deleteEmptyFiles();
   void resumeFileCompaction(const std::string& status_file_name);
   std::vector<PageMapping> readPageMappingsFromStatusFile();
+
+  // For testing purposes only
+  FileMgr(const int epoch);
+
+  // Used to describe the manager in logging and error messages.
+  virtual std::string describeSelf();
+
+  void closePhysicalUnlocked();
+  void syncFilesToDisk();
+  void freePages();
+  void freePagesBeforeEpochUnlocked(const int32_t min_epoch,
+                                    const ChunkKeyToChunkMap::iterator lower_bound,
+                                    const ChunkKeyToChunkMap::iterator upper_bound);
+
+ private:
+  void rollOffOldData(const int32_t epochCeiling, const bool shouldCheckpoint);
+  void freePagesBeforeEpoch(const int32_t min_epoch);
+
+  GlobalFileMgr* gfm_;  /// Global FileMgr
+  std::pair<const int32_t, const int32_t> fileMgrKey_;
 };
 
 }  // namespace File_Namespace
diff -Naur ./DataMgr/FileMgr/GlobalFileMgr.cpp ../omniscidb-master/DataMgr/FileMgr/GlobalFileMgr.cpp
--- ./DataMgr/FileMgr/GlobalFileMgr.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/GlobalFileMgr.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -31,6 +31,7 @@
 #include <utility>
 #include <vector>
 
+#include "DataMgr/ForeignStorage/ArrowForeignStorage.h"
 #include "DataMgr/ForeignStorage/ForeignStorageInterface.h"
 #include "Shared/File.h"
 
@@ -39,6 +40,7 @@
 namespace File_Namespace {
 
 GlobalFileMgr::GlobalFileMgr(const int32_t deviceId,
+                             std::shared_ptr<ForeignStorageInterface> fsi,
                              std::string basePath,
                              const size_t num_reader_threads,
                              const size_t defaultPageSize)
@@ -48,7 +50,8 @@
     , epoch_(-1)
     ,  // set the default epoch for all tables corresponding to the time of
        // last checkpoint
-    defaultPageSize_(defaultPageSize) {
+    defaultPageSize_(defaultPageSize)
+    , fsi_(fsi) {
   omnisci_db_version_ = 2;
   // DS changes also triggered by individual FileMgr per table project (release 2.1.0)
   dbConvert_ = false;
@@ -189,8 +192,7 @@
       return fm;  // mgr was added between the read lock and the write lock
     }
     const auto file_mgr_key = std::make_pair(db_id, tb_id);
-    const auto foreign_buffer_manager =
-        ForeignStorageInterface::lookupBufferManager(db_id, tb_id);
+    const auto foreign_buffer_manager = fsi_->lookupBufferManager(db_id, tb_id);
     if (foreign_buffer_manager) {
       CHECK(allFileMgrs_.insert(std::make_pair(file_mgr_key, foreign_buffer_manager))
                 .second);
@@ -331,5 +333,4 @@
   // Re-initialize file manager
   getFileMgr(db_id, tb_id);
 }
-
 }  // namespace File_Namespace
diff -Naur ./DataMgr/FileMgr/GlobalFileMgr.h ../omniscidb-master/DataMgr/FileMgr/GlobalFileMgr.h
--- ./DataMgr/FileMgr/GlobalFileMgr.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/GlobalFileMgr.h	2021-04-21 00:02:57.000000000 +0300
@@ -36,6 +36,8 @@
 #include "../AbstractBufferMgr.h"
 #include "FileMgr.h"
 
+class ForeignStorageInterface;
+
 using namespace Data_Namespace;
 
 namespace File_Namespace {
@@ -57,6 +59,7 @@
  public:
   /// Constructor
   GlobalFileMgr(const int32_t deviceId,
+                std::shared_ptr<ForeignStorageInterface> fsi,
                 std::string basePath = ".",
                 const size_t num_reader_threads = 0,
                 const size_t defaultPageSize = DEFAULT_PAGE_SIZE);
@@ -215,6 +218,7 @@
   std::map<FileMgrKey, std::shared_ptr<FileMgr>> ownedFileMgrs_;
   std::map<FileMgrKey, AbstractBufferMgr*> allFileMgrs_;
   std::map<FileMgrKey, int32_t> max_rollback_epochs_per_table_;
+  std::shared_ptr<ForeignStorageInterface> fsi_;
 
   mapd_shared_mutex fileMgrs_mutex_;
 };
diff -Naur ./DataMgr/FileMgr/Page.h ../omniscidb-master/DataMgr/FileMgr/Page.h
--- ./DataMgr/FileMgr/Page.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FileMgr/Page.h	2021-04-21 00:02:57.000000000 +0300
@@ -151,6 +151,16 @@
              const int32_t versionEpoch,
              const Page& page)
       : chunkKey(chunkKey), pageId(pageId), versionEpoch(versionEpoch), page(page) {}
+
+  bool operator<(const HeaderInfo& other) {
+    if (chunkKey != other.chunkKey) {
+      return chunkKey < other.chunkKey;
+    }
+    if (pageId != other.pageId) {
+      return pageId < other.pageId;
+    }
+    return versionEpoch < other.versionEpoch;
+  }
 };
 
 }  // namespace File_Namespace
diff -Naur ./DataMgr/FixedLengthEncoder.h ../omniscidb-master/DataMgr/FixedLengthEncoder.h
--- ./DataMgr/FixedLengthEncoder.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/FixedLengthEncoder.h	2021-04-21 00:02:57.000000000 +0300
@@ -121,7 +121,7 @@
     const V* data = reinterpret_cast<const V*>(dst_data);
 
     std::tie(dataMin, dataMax, has_nulls) = tbb::parallel_reduce(
-        tbb::blocked_range(0UL, num_elements),
+        tbb::blocked_range(size_t(0), num_elements),
         std::tuple(static_cast<V>(dataMin), static_cast<V>(dataMax), has_nulls),
         [&](const auto& range, auto init) {
           auto [min, max, nulls] = init;
diff -Naur ./DataMgr/ForeignStorage/ArrowForeignStorage.cpp ../omniscidb-master/DataMgr/ForeignStorage/ArrowForeignStorage.cpp
--- ./DataMgr/ForeignStorage/ArrowForeignStorage.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/ArrowForeignStorage.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -857,9 +857,8 @@
   ArrowForeignStorage::tables.erase(name);
 }
 
-void registerArrowForeignStorage() {
-  ForeignStorageInterface::registerPersistentStorageInterface(
-      std::make_unique<ArrowForeignStorage>());
+void registerArrowForeignStorage(std::shared_ptr<ForeignStorageInterface> fsi) {
+  fsi->registerPersistentStorageInterface(std::make_unique<ArrowForeignStorage>());
 }
 
 class ArrowCsvForeignStorage : public ArrowForeignStorageBase {
@@ -908,7 +907,7 @@
   }
   switch (ktype) {
     case kBOOLEAN:
-      return boolean();
+      return arrow::boolean();
     case kFLOAT:
       return float32();
     case kDOUBLE:
@@ -1022,7 +1021,6 @@
   return "CSV";
 }
 
-void registerArrowCsvForeignStorage() {
-  ForeignStorageInterface::registerPersistentStorageInterface(
-      std::make_unique<ArrowCsvForeignStorage>());
+void registerArrowCsvForeignStorage(std::shared_ptr<ForeignStorageInterface> fsi) {
+  fsi->registerPersistentStorageInterface(std::make_unique<ArrowCsvForeignStorage>());
 }
diff -Naur ./DataMgr/ForeignStorage/ArrowForeignStorage.h ../omniscidb-master/DataMgr/ForeignStorage/ArrowForeignStorage.h
--- ./DataMgr/ForeignStorage/ArrowForeignStorage.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/ArrowForeignStorage.h	2021-04-21 00:02:57.000000000 +0300
@@ -21,9 +21,9 @@
 
 #include "ForeignStorageInterface.h"
 
-void registerArrowCsvForeignStorage();
+void registerArrowCsvForeignStorage(std::shared_ptr<ForeignStorageInterface> fsi);
 
-void registerArrowForeignStorage();
+void registerArrowForeignStorage(std::shared_ptr<ForeignStorageInterface> fsi);
 
 void setArrowTable(std::string name, std::shared_ptr<arrow::Table> table);
 
diff -Naur ./DataMgr/ForeignStorage/CachingForeignStorageMgr.cpp ../omniscidb-master/DataMgr/ForeignStorage/CachingForeignStorageMgr.cpp
--- ./DataMgr/ForeignStorage/CachingForeignStorageMgr.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/CachingForeignStorageMgr.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -15,7 +15,6 @@
  */
 
 #include "CachingForeignStorageMgr.h"
-
 #include "Catalog/ForeignTable.h"
 #include "CsvDataWrapper.h"
 #include "ForeignStorageException.h"
@@ -26,7 +25,6 @@
 
 namespace {
 constexpr int64_t MAX_REFRESH_TIME_IN_SECONDS = 60 * 60;
-const std::string wrapper_file_name = "/wrapper_metadata.json";
 }  // namespace
 
 CachingForeignStorageMgr::CachingForeignStorageMgr(ForeignStorageCache* cache)
@@ -106,16 +104,18 @@
 void CachingForeignStorageMgr::getChunkMetadataVecForKeyPrefix(
     ChunkMetadataVector& chunk_metadata,
     const ChunkKey& keyPrefix) {
+  auto [db_id, tb_id] = get_table_prefix(keyPrefix);
   ForeignStorageMgr::getChunkMetadataVecForKeyPrefix(chunk_metadata, keyPrefix);
   getDataWrapper(keyPrefix)->serializeDataWrapperInternals(
-      disk_cache_->getCacheDirectoryForTablePrefix(keyPrefix) + wrapper_file_name);
+      disk_cache_->getCacheDirectoryForTable(db_id, tb_id) + wrapper_file_name);
 }
 
 void CachingForeignStorageMgr::recoverDataWrapperFromDisk(
     const ChunkKey& table_key,
     const ChunkMetadataVector& chunk_metadata) {
+  auto [db_id, tb_id] = get_table_prefix(table_key);
   getDataWrapper(table_key)->restoreDataWrapperInternals(
-      disk_cache_->getCacheDirectoryForTablePrefix(table_key) + wrapper_file_name,
+      disk_cache_->getCacheDirectoryForTable(db_id, tb_id) + wrapper_file_name,
       chunk_metadata);
 }
 
diff -Naur ./DataMgr/ForeignStorage/CsvDataWrapper.cpp ../omniscidb-master/DataMgr/ForeignStorage/CsvDataWrapper.cpp
--- ./DataMgr/ForeignStorage/CsvDataWrapper.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/CsvDataWrapper.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -514,7 +514,6 @@
       }
     }
     cached_chunks[chunk_key].appendData(data_block, row_count, 0);
-
     if (is_last_block) {
       // cache the chunks now so they are tracked by eviction algorithm
       std::vector<ChunkKey> key_to_cache{chunk_key};
@@ -882,6 +881,7 @@
       columns_to_scan.insert(column->columnId);
     }
   }
+
   // Track where scan started for appends
   int start_row = num_rows_;
   if (!csv_reader_->isScanFinished()) {
diff -Naur ./DataMgr/ForeignStorage/ForeignStorageCache.cpp ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageCache.cpp
--- ./DataMgr/ForeignStorage/ForeignStorageCache.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageCache.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -54,15 +54,15 @@
 ForeignStorageCache::ForeignStorageCache(const DiskCacheConfig& config)
     : num_chunks_added_(0), num_metadata_added_(0) {
   validatePath(config.path);
-  global_file_mgr_ = std::make_unique<File_Namespace::GlobalFileMgr>(
-      0, config.path, config.num_reader_threads);
+  caching_file_mgr_ = std::make_unique<File_Namespace::CachingFileMgr>(
+      config.path, config.num_reader_threads);
 }
 
 void ForeignStorageCache::deleteBufferIfExists(const ChunkKey& chunk_key) {
   write_lock meta_lock(metadata_mutex_);
   write_lock chunk_lock(chunks_mutex_);
   if (cached_metadata_.find(chunk_key) != cached_metadata_.end()) {
-    global_file_mgr_->deleteBuffer(chunk_key);
+    caching_file_mgr_->deleteBuffer(chunk_key);
     cached_chunks_.erase(chunk_key);
     cached_metadata_.erase(chunk_key);
   }
@@ -75,8 +75,9 @@
   CHECK(!buffer->isDirty());
   buffer->setUpdated();
   num_chunks_added_++;
-  global_file_mgr_->putBuffer(chunk_key, buffer);
-  global_file_mgr_->checkpoint();
+  caching_file_mgr_->putBuffer(chunk_key, buffer);
+  caching_file_mgr_->checkpoint(chunk_key[CHUNK_KEY_DB_IDX],
+                                chunk_key[CHUNK_KEY_TABLE_IDX]);
   cached_metadata_.emplace(chunk_key);
   cached_chunks_.emplace(chunk_key);
   CHECK(!buffer->isDirty());
@@ -94,11 +95,11 @@
   for (const auto& chunk_key : chunk_keys) {
     CHECK_EQ(db_id, chunk_key[CHUNK_KEY_DB_IDX]);
     CHECK_EQ(table_id, chunk_key[CHUNK_KEY_TABLE_IDX]);
-    CHECK(global_file_mgr_->isBufferOnDevice(chunk_key));
+    CHECK(caching_file_mgr_->isBufferOnDevice(chunk_key));
     num_chunks_added_++;
     cached_chunks_.emplace(chunk_key);
   }
-  global_file_mgr_->checkpoint(db_id, table_id);
+  caching_file_mgr_->checkpoint(db_id, table_id);
 }
 
 AbstractBuffer* ForeignStorageCache::getCachedChunkIfExists(const ChunkKey& chunk_key) {
@@ -110,7 +111,7 @@
       return nullptr;
     }
   }
-  return global_file_mgr_->getBuffer(chunk_key);
+  return caching_file_mgr_->getBuffer(chunk_key);
 }
 
 bool ForeignStorageCache::isMetadataCached(const ChunkKey& chunk_key) const {
@@ -123,14 +124,13 @@
   write_lock lock(chunks_mutex_);
   CHECK(meta_vec.size() == 0);
   CHECK(is_table_key(table_key));
-  CHECK(dynamic_cast<File_Namespace::FileMgr*>(global_file_mgr_->getFileMgr(table_key)));
 
-  global_file_mgr_->getChunkMetadataVecForKeyPrefix(meta_vec, table_key);
+  caching_file_mgr_->getChunkMetadataVecForKeyPrefix(meta_vec, table_key);
   for (auto& [chunk_key, metadata] : meta_vec) {
     cached_metadata_.emplace(chunk_key);
     // If there is no page count then the chunk was metadata only and should not be
     // cached.
-    if (const auto& buf = global_file_mgr_->getBuffer(chunk_key); buf->pageCount() > 0) {
+    if (const auto& buf = caching_file_mgr_->getBuffer(chunk_key); buf->pageCount() > 0) {
       cached_chunks_.emplace(chunk_key);
     }
 
@@ -143,7 +143,7 @@
                                   chunk_key[CHUNK_KEY_FRAGMENT_IDX],
                                   2};
 
-      if (const auto& buf = global_file_mgr_->getBuffer(index_chunk_key);
+      if (const auto& buf = caching_file_mgr_->getBuffer(index_chunk_key);
           buf->pageCount() > 0) {
         cached_chunks_.emplace(index_chunk_key);
       }
@@ -164,9 +164,14 @@
 
 void ForeignStorageCache::cacheMetadataVec(const ChunkMetadataVector& metadata_vec) {
   auto timer = DEBUG_TIMER(__func__);
+  if (metadata_vec.empty()) {
+    return;
+  }
+  auto first_chunk_key = metadata_vec.begin()->first;
   write_lock meta_lock(metadata_mutex_);
   write_lock chunk_lock(chunks_mutex_);
   for (auto& [chunk_key, metadata] : metadata_vec) {
+    CHECK(in_same_table(chunk_key, first_chunk_key));
     cached_metadata_.emplace(chunk_key);
     AbstractBuffer* buf;
     AbstractBuffer* index_buffer = nullptr;
@@ -181,20 +186,20 @@
                          2};
     }
     bool chunk_in_cache = false;
-    if (!global_file_mgr_->isBufferOnDevice(chunk_key)) {
-      buf = global_file_mgr_->createBuffer(chunk_key);
+    if (!caching_file_mgr_->isBufferOnDevice(chunk_key)) {
+      buf = caching_file_mgr_->createBuffer(chunk_key);
 
       if (!index_chunk_key.empty()) {
-        CHECK(!global_file_mgr_->isBufferOnDevice(index_chunk_key));
-        index_buffer = global_file_mgr_->createBuffer(index_chunk_key);
+        CHECK(!caching_file_mgr_->isBufferOnDevice(index_chunk_key));
+        index_buffer = caching_file_mgr_->createBuffer(index_chunk_key);
         CHECK(index_buffer);
       }
     } else {
-      buf = global_file_mgr_->getBuffer(chunk_key);
+      buf = caching_file_mgr_->getBuffer(chunk_key);
 
       if (!index_chunk_key.empty()) {
-        CHECK(global_file_mgr_->isBufferOnDevice(index_chunk_key));
-        index_buffer = global_file_mgr_->getBuffer(index_chunk_key);
+        CHECK(caching_file_mgr_->isBufferOnDevice(index_chunk_key));
+        index_buffer = caching_file_mgr_->getBuffer(index_chunk_key);
         CHECK(index_buffer);
       }
 
@@ -220,7 +225,8 @@
     }
     num_metadata_added_++;
   }
-  global_file_mgr_->checkpoint();
+  caching_file_mgr_->checkpoint(first_chunk_key[CHUNK_KEY_DB_IDX],
+                                first_chunk_key[CHUNK_KEY_TABLE_IDX]);
 }
 
 void ForeignStorageCache::getCachedMetadataVecForKeyPrefix(
@@ -231,7 +237,7 @@
   iterate_over_matching_prefix(
       [&metadata_vec, this](auto chunk) {
         std::shared_ptr<ChunkMetadata> buf_metadata = std::make_shared<ChunkMetadata>();
-        global_file_mgr_->getBuffer(chunk)->getEncoder()->getMetadata(buf_metadata);
+        caching_file_mgr_->getBuffer(chunk)->getEncoder()->getMetadata(buf_metadata);
         metadata_vec.push_back(std::make_pair(chunk, buf_metadata));
       },
       cached_metadata_,
@@ -274,7 +280,8 @@
       meta_it = cached_metadata_.erase(meta_it);
     }
   }
-  global_file_mgr_->removeTableRelatedDS(chunk_prefix[0], chunk_prefix[1]);
+  caching_file_mgr_->clearForTable(chunk_prefix[CHUNK_KEY_DB_IDX],
+                                   chunk_prefix[CHUNK_KEY_TABLE_IDX]);
 }
 
 void ForeignStorageCache::clear() {
@@ -293,9 +300,12 @@
       meta_it = cached_metadata_.erase(meta_it);
     }
   }
-  for (const auto& table_key : table_keys) {
-    global_file_mgr_->removeTableRelatedDS(table_key[0], table_key[1]);
-  }
+  // FileMgrs do not clean up after themselves nicely, so we need to close all their disk
+  // resources and then re-create the CachingFileMgr to reset it.
+  caching_file_mgr_->closeRemovePhysical();
+  boost::filesystem::create_directory(caching_file_mgr_->getFileMgrBasePath());
+  caching_file_mgr_ = std::make_unique<File_Namespace::CachingFileMgr>(
+      caching_file_mgr_->getFileMgrBasePath(), caching_file_mgr_->getNumReaderThreads());
 }
 
 std::vector<ChunkKey> ForeignStorageCache::getCachedChunksForKeyPrefix(
@@ -313,8 +323,8 @@
   read_lock lock(chunks_mutex_);
   for (const auto& chunk_key : chunk_keys) {
     CHECK(cached_chunks_.find(chunk_key) == cached_chunks_.end());
-    CHECK(global_file_mgr_->isBufferOnDevice(chunk_key));
-    chunk_buffer_map[chunk_key] = global_file_mgr_->getBuffer(chunk_key);
+    CHECK(caching_file_mgr_->isBufferOnDevice(chunk_key));
+    chunk_buffer_map[chunk_key] = caching_file_mgr_->getBuffer(chunk_key);
     CHECK(dynamic_cast<File_Namespace::FileBuffer*>(chunk_buffer_map[chunk_key]));
     CHECK_EQ(chunk_buffer_map[chunk_key]->pageCount(), static_cast<size_t>(0));
 
@@ -331,7 +341,7 @@
     return;
   }
   File_Namespace::FileBuffer* file_buffer =
-      static_cast<File_Namespace::FileBuffer*>(global_file_mgr_->getBuffer(chunk_key));
+      static_cast<File_Namespace::FileBuffer*>(caching_file_mgr_->getBuffer(chunk_key));
   file_buffer->freeChunkPages();
   cached_chunks_.erase(chunk_key);
 }
@@ -339,7 +349,7 @@
 std::set<ChunkKey>::iterator ForeignStorageCache::evictChunkByIterator(
     const std::set<ChunkKey>::iterator& chunk_it) {
   File_Namespace::FileBuffer* file_buffer =
-      static_cast<File_Namespace::FileBuffer*>(global_file_mgr_->getBuffer(*chunk_it));
+      static_cast<File_Namespace::FileBuffer*>(caching_file_mgr_->getBuffer(*chunk_it));
   file_buffer->freeChunkPages();
   return cached_chunks_.erase(chunk_it);
 }
@@ -380,15 +390,6 @@
   }
 }
 
-std::string ForeignStorageCache::getCacheDirectoryForTablePrefix(
-    const ChunkKey& table_prefix) const {
-  CHECK(table_prefix.size() >= 2);
-  auto fileMgr = dynamic_cast<File_Namespace::FileMgr*>(
-      getGlobalFileMgr()->getFileMgr(table_prefix));
-  CHECK(fileMgr);
-  return fileMgr->getFileMgrBasePath();
-}
-
 void ForeignStorageCache::cacheMetadataWithFragIdGreaterOrEqualTo(
     const ChunkMetadataVector& metadata_vec,
     const int frag_id) {
@@ -406,11 +407,11 @@
     const ChunkKey& chunk_key,
     bool is_new_buffer) {
   if (!is_new_buffer) {
-    CHECK(getGlobalFileMgr()->isBufferOnDevice(chunk_key));
-    return getGlobalFileMgr()->getBuffer(chunk_key);
+    CHECK(caching_file_mgr_->isBufferOnDevice(chunk_key));
+    return caching_file_mgr_->getBuffer(chunk_key);
   } else {
-    CHECK(!getGlobalFileMgr()->isBufferOnDevice(chunk_key));
-    return getGlobalFileMgr()->createBuffer(chunk_key);
+    CHECK(!caching_file_mgr_->isBufferOnDevice(chunk_key));
+    return caching_file_mgr_->createBuffer(chunk_key);
   }
 }
 
diff -Naur ./DataMgr/ForeignStorage/ForeignStorageCache.h ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageCache.h
--- ./DataMgr/ForeignStorage/ForeignStorageCache.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageCache.h	2021-04-21 00:02:57.000000000 +0300
@@ -27,7 +27,7 @@
 
 #include "../Shared/mapd_shared_mutex.h"
 #include "DataMgr/AbstractBufferMgr.h"
-#include "DataMgr/FileMgr/GlobalFileMgr.h"
+#include "DataMgr/FileMgr/CachingFileMgr.h"
 #include "ForeignDataWrapper.h"
 
 class CacheTooSmallException : public std::runtime_error {
@@ -54,6 +54,8 @@
 
 namespace foreign_storage {
 
+const std::string wrapper_file_name = "wrapper_metadata.json";
+
 class ForeignStorageCache {
  public:
   ForeignStorageCache(const DiskCacheConfig& config);
@@ -96,15 +98,22 @@
   std::string dumpCachedChunkEntries() const;
   std::string dumpCachedMetadataEntries() const;
 
-  inline File_Namespace::GlobalFileMgr* getGlobalFileMgr() const {
-    return global_file_mgr_.get();
+  inline std::string getCacheDirectory() const {
+    return caching_file_mgr_->getFileMgrBasePath();
+  }
+
+  inline std::string getCacheDirectoryForTable(int db_id, int tb_id) const {
+    return caching_file_mgr_->getOrAddTableDir(db_id, tb_id);
   }
 
-  std::string getCacheDirectoryForTablePrefix(const ChunkKey&) const;
   void cacheMetadataWithFragIdGreaterOrEqualTo(const ChunkMetadataVector& metadata_vec,
                                                const int frag_id);
   void evictThenEraseChunk(const ChunkKey&);
 
+  inline uint64_t getSpaceReservedByTable(int db_id, int tb_id) const {
+    return caching_file_mgr_->getSpaceReservedByTable(db_id, tb_id);
+  }
+
  private:
   // These methods are private and assume locks are already acquired when called.
   std::set<ChunkKey>::iterator eraseChunk(const std::set<ChunkKey>::iterator&);
@@ -114,8 +123,8 @@
   void evictThenEraseChunkUnlocked(const ChunkKey&);
   void validatePath(const std::string&) const;
 
-  // Underlying storage is handled by a GlobalFileMgr unique to the cache.
-  std::unique_ptr<File_Namespace::GlobalFileMgr> global_file_mgr_;
+  // Underlying storage is handled by a CachingFileMgr unique to the cache.
+  std::unique_ptr<File_Namespace::CachingFileMgr> caching_file_mgr_;
 
   // Keeps tracks of which Chunks/ChunkMetadata are cached.
   std::set<ChunkKey> cached_chunks_;
diff -Naur ./DataMgr/ForeignStorage/ForeignStorageInterface.cpp ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageInterface.cpp
--- ./DataMgr/ForeignStorage/ForeignStorageInterface.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageInterface.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -221,16 +221,3 @@
                                      cols,
                                      lookupBufferManager(db_id, table_id));
 }
-
-void ForeignStorageInterface::destroy() {
-  persistent_storage_interfaces_.clear();
-  managers_map_.clear();
-}
-
-std::unordered_map<std::string, std::unique_ptr<PersistentForeignStorageInterface>>
-    ForeignStorageInterface::persistent_storage_interfaces_;
-std::map<std::pair<int, int>, PersistentForeignStorageInterface*>
-    ForeignStorageInterface::table_persistent_storage_interface_map_;
-std::map<std::pair<int, int>, std::unique_ptr<ForeignStorageBufferMgr>>
-    ForeignStorageInterface::managers_map_;
-std::mutex ForeignStorageInterface::persistent_storage_interfaces_mutex_;
diff -Naur ./DataMgr/ForeignStorage/ForeignStorageInterface.h ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageInterface.h
--- ./DataMgr/ForeignStorage/ForeignStorageInterface.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/ForeignStorageInterface.h	2021-04-21 00:02:57.000000000 +0300
@@ -19,6 +19,7 @@
 #include "../AbstractBufferMgr.h"
 #include "Catalog/Catalog.h"
 
+#include <atomic>
 #include <unordered_map>
 
 struct ForeignStorageColumnBuffer {
@@ -217,30 +218,35 @@
 
 class ForeignStorageInterface {
  public:
-  static Data_Namespace::AbstractBufferMgr* lookupBufferManager(const int db_id,
-                                                                const int table_id);
+  ForeignStorageInterface() {}
+  ~ForeignStorageInterface() {}
 
-  static void registerPersistentStorageInterface(
-      std::unique_ptr<PersistentForeignStorageInterface> persistent_foreign_storage);
+  ForeignStorageInterface(const ForeignStorageInterface& other) = delete;
+  ForeignStorageInterface(ForeignStorageInterface&& other) = delete;
+
+  ForeignStorageInterface& operator=(const ForeignStorageInterface& other) = delete;
+  ForeignStorageInterface& operator=(ForeignStorageInterface&& other) = delete;
 
-  static void destroy();
+  Data_Namespace::AbstractBufferMgr* lookupBufferManager(const int db_id,
+                                                         const int table_id);
+
+  void registerPersistentStorageInterface(
+      std::unique_ptr<PersistentForeignStorageInterface> persistent_foreign_storage);
 
   //! prepare table options and modify columns
-  static void prepareTable(const int db_id,
-                           TableDescriptor& td,
-                           std::list<ColumnDescriptor>& cols);
+  void prepareTable(const int db_id,
+                    TableDescriptor& td,
+                    std::list<ColumnDescriptor>& cols);
   //! ids are created
-  static void registerTable(Catalog_Namespace::Catalog* catalog,
-                            const TableDescriptor& td,
-                            const std::list<ColumnDescriptor>& cols);
+  void registerTable(Catalog_Namespace::Catalog* catalog,
+                     const TableDescriptor& td,
+                     const std::list<ColumnDescriptor>& cols);
 
  private:
-  static std::unordered_map<std::string,
-                            std::unique_ptr<PersistentForeignStorageInterface>>
+  std::unordered_map<std::string, std::unique_ptr<PersistentForeignStorageInterface>>
       persistent_storage_interfaces_;
-  static std::map<std::pair<int, int>, PersistentForeignStorageInterface*>
+  std::map<std::pair<int, int>, PersistentForeignStorageInterface*>
       table_persistent_storage_interface_map_;
-  static std::map<std::pair<int, int>, std::unique_ptr<ForeignStorageBufferMgr>>
-      managers_map_;
-  static std::mutex persistent_storage_interfaces_mutex_;
+  std::map<std::pair<int, int>, std::unique_ptr<ForeignStorageBufferMgr>> managers_map_;
+  std::mutex persistent_storage_interfaces_mutex_;
 };
diff -Naur ./DataMgr/ForeignStorage/FsiJsonUtils.cpp ../omniscidb-master/DataMgr/ForeignStorage/FsiJsonUtils.cpp
--- ./DataMgr/ForeignStorage/FsiJsonUtils.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/FsiJsonUtils.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -27,11 +27,11 @@
 
 // Basic types (more can be added as required)
 void set_value(rapidjson::Value& json_val,
-               const long unsigned int& value,
+               const size_t& value,
                rapidjson::Document::AllocatorType& allocator) {
   json_val.SetUint64(value);
 }
-void get_value(const rapidjson::Value& json_val, long unsigned int& value) {
+void get_value(const rapidjson::Value& json_val, size_t& value) {
   CHECK(json_val.IsUint64());
   value = json_val.GetUint64();
 }
diff -Naur ./DataMgr/ForeignStorage/FsiJsonUtils.h ../omniscidb-master/DataMgr/ForeignStorage/FsiJsonUtils.h
--- ./DataMgr/ForeignStorage/FsiJsonUtils.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/ForeignStorage/FsiJsonUtils.h	2021-04-21 00:02:57.000000000 +0300
@@ -39,9 +39,9 @@
 // Basic types (more can be added as required) will be defined in source file
 // int
 void set_value(rapidjson::Value& json_val,
-               const long unsigned int& value,
+               const size_t& value,
                rapidjson::Document::AllocatorType& allocator);
-void get_value(const rapidjson::Value& json_val, long unsigned int& value);
+void get_value(const rapidjson::Value& json_val, size_t& value);
 // unsigned long int / size_t
 void set_value(rapidjson::Value& json_val,
                const int& value,
diff -Naur ./DataMgr/NoneEncoder.h ../omniscidb-master/DataMgr/NoneEncoder.h
--- ./DataMgr/NoneEncoder.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/NoneEncoder.h	2021-04-21 00:02:57.000000000 +0300
@@ -125,7 +125,7 @@
     const T* data = reinterpret_cast<const T*>(dst_data);
 
     std::tie(dataMin, dataMax, has_nulls) = tbb::parallel_reduce(
-        tbb::blocked_range(0UL, num_elements),
+        tbb::blocked_range(size_t(0), num_elements),
         std::tuple(dataMin, dataMax, has_nulls),
         [&](const auto& range, auto init) {
           auto [min, max, nulls] = init;
diff -Naur ./DataMgr/PersistentStorageMgr/PersistentStorageMgr.cpp ../omniscidb-master/DataMgr/PersistentStorageMgr/PersistentStorageMgr.cpp
--- ./DataMgr/PersistentStorageMgr/PersistentStorageMgr.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/PersistentStorageMgr/PersistentStorageMgr.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -16,6 +16,7 @@
 
 #include "PersistentStorageMgr.h"
 #include "Catalog/Catalog.h"
+#include "DataMgr/ForeignStorage/ArrowForeignStorage.h"
 #include "DataMgr/ForeignStorage/CachingForeignStorageMgr.h"
 #include "DataMgr/ForeignStorage/ForeignStorageInterface.h"
 #include "MutableCachePersistentStorageMgr.h"
@@ -34,12 +35,13 @@
 PersistentStorageMgr::PersistentStorageMgr(const std::string& data_dir,
                                            const size_t num_reader_threads,
                                            const DiskCacheConfig& disk_cache_config)
-    : AbstractBufferMgr(0)
-    , global_file_mgr_(
-          std::make_unique<File_Namespace::GlobalFileMgr>(0,
-                                                          data_dir,
-                                                          num_reader_threads))
-    , disk_cache_config_(disk_cache_config) {
+    : AbstractBufferMgr(0), disk_cache_config_(disk_cache_config) {
+  fsi_ = std::make_shared<ForeignStorageInterface>();
+  ::registerArrowForeignStorage(fsi_);
+  ::registerArrowCsvForeignStorage(fsi_);
+
+  global_file_mgr_ = std::make_unique<File_Namespace::GlobalFileMgr>(
+      0, fsi_, data_dir, num_reader_threads);
   disk_cache_ =
       disk_cache_config_.isEnabled()
           ? std::make_unique<foreign_storage::ForeignStorageCache>(disk_cache_config)
@@ -235,8 +237,8 @@
 bool PersistentStorageMgr::isChunkPrefixCacheable(const ChunkKey& chunk_prefix) const {
   CHECK(has_table_prefix(chunk_prefix));
   // If this is an Arrow FSI table then we can't cache it.
-  if (ForeignStorageInterface::lookupBufferManager(chunk_prefix[CHUNK_KEY_DB_IDX],
-                                                   chunk_prefix[CHUNK_KEY_TABLE_IDX])) {
+  if (fsi_->lookupBufferManager(chunk_prefix[CHUNK_KEY_DB_IDX],
+                                chunk_prefix[CHUNK_KEY_TABLE_IDX])) {
     return false;
   }
   return ((disk_cache_config_.isEnabledForMutableTables() &&
diff -Naur ./DataMgr/PersistentStorageMgr/PersistentStorageMgr.h ../omniscidb-master/DataMgr/PersistentStorageMgr/PersistentStorageMgr.h
--- ./DataMgr/PersistentStorageMgr/PersistentStorageMgr.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/DataMgr/PersistentStorageMgr/PersistentStorageMgr.h	2021-04-21 00:02:57.000000000 +0300
@@ -69,6 +69,10 @@
   foreign_storage::ForeignStorageMgr* getForeignStorageMgr() const;
   foreign_storage::ForeignStorageCache* getDiskCache() const;
   inline const DiskCacheConfig getDiskCacheConfig() const { return disk_cache_config_; }
+  inline const std::shared_ptr<ForeignStorageInterface> getForeignStorageInterface()
+      const {
+    return fsi_;
+  }
 
  protected:
   bool isForeignStorage(const ChunkKey& chunk_key) const;
@@ -80,4 +84,5 @@
   std::unique_ptr<foreign_storage::ForeignStorageMgr> foreign_storage_mgr_;
   std::unique_ptr<foreign_storage::ForeignStorageCache> disk_cache_;
   DiskCacheConfig disk_cache_config_;
+  std::shared_ptr<ForeignStorageInterface> fsi_;
 };
diff -Naur ./Embedded/CMakeLists.txt ../omniscidb-master/Embedded/CMakeLists.txt
--- ./Embedded/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Embedded/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -1,2 +1,44 @@
-add_library(DBEngine SHARED DBEngine.cpp DBEngine.h)
-target_link_libraries(DBEngine tinfo ${LLVM_LINKER_FLAGS} QueryRunner DataMgr ${Arrow_LIBRARIES} ${Boost_LIBRARIES} ${CMAKE_DL_LIBS} ${TBB_LIBS})
+add_library(DBEngine SHARED DBETypes.cpp DBEngine.cpp DBEngine.h DBETypes.h)
+
+target_link_libraries(DBEngine mapd_thrift thrift_handler Catalog QueryState Parser QueryEngine DataMgr ${Arrow_LIBRARIES} ${Boost_LIBRARIES} ${CMAKE_DL_LIBS} ${TBB_LIBS} Geospatial)
+install(TARGETS DBEngine DESTINATION "lib" COMPONENT "DBE")
+install(FILES DBEngine.h DBETypes.h DESTINATION "Embedded" COMPONENT "include")
+install(FILES Python/DBEngine.pxd DESTINATION "Embedded" COMPONENT "include")
+
+add_executable(EmbeddedDbTest EmbeddedDbTest.cpp)
+target_link_libraries(EmbeddedDbTest DBEngine)
+
+add_executable(EmbeddedDbFSITest EmbeddedDbFSITest.cpp)
+target_link_libraries(EmbeddedDbFSITest DBEngine)
+
+
+set(SETUP_PY    "${CMAKE_CURRENT_BINARY_DIR}/setup.py")
+# Currently dbe.cpp is generated near dbe.pyx and not in build dir. This could be revised later
+set(OUTPUT      "${CMAKE_CURRENT_SOURCE_DIR}/dbe.cpp")
+
+configure_file("${CMAKE_CURRENT_SOURCE_DIR}/setup.in.py" "${CMAKE_CURRENT_BINARY_DIR}/setup.py.in" @ONLY)
+# cannot be done in one step, splitting in configure_file and file commands
+file(GENERATE OUTPUT "${SETUP_PY}" INPUT "${CMAKE_CURRENT_BINARY_DIR}/setup.py.in")
+
+# Adding Python targets here for sake of better development experience, to give an example
+find_package(PythonInterp)
+if(PYTHON_EXECUTABLE)
+    set(pydeps ${SETUP_PY} ${CMAKE_CURRENT_SOURCE_DIR}/DBEngine.h ${CMAKE_CURRENT_SOURCE_DIR}/Python/dbe.pyx ${CMAKE_CURRENT_SOURCE_DIR}/Python/DBEngine.pxd)
+
+    add_custom_target(dbe4py
+        COMMAND cd ${CMAKE_CURRENT_BINARY_DIR} && ${PYTHON_EXECUTABLE} ${SETUP_PY} build_ext -g -f -I ${CMAKE_CURRENT_SOURCE_DIR}
+        DEPENDS DBEngine ${pydeps} mapd_java_components
+    )
+    add_custom_target(dbe4py-test
+        COMMAND ${PYTHON_EXECUTABLE} -m pytest -v ${CMAKE_CURRENT_SOURCE_DIR}/test/test_exceptions.py
+        DEPENDS dbe4py
+    )
+    add_custom_target(dbe4py-install
+        COMMAND cd ${CMAKE_CURRENT_BINARY_DIR} && ${PYTHON_EXECUTABLE} ${SETUP_PY} build_ext -g -f -I ${CMAKE_CURRENT_SOURCE_DIR} install
+        DEPENDS DBEngine ${pydeps}
+    )
+    add_custom_target(dbe4py-devel 
+        cd ${CMAKE_CURRENT_BINARY_DIR} && pip install -v -e .
+        DEPENDS dbe4py)
+
+endif()
diff -Naur ./Embedded/DBETypes.cpp ../omniscidb-master/Embedded/DBETypes.cpp
--- ./Embedded/DBETypes.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Embedded/DBETypes.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,185 @@
+/*
+ * Copyright 2020 OmniSci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "DBETypes.h"
+
+namespace {
+void checkColumnRange(size_t index, size_t count) {
+  if (index >= count) {
+    throw std::out_of_range("Column index " + std::to_string(index) +
+                            " is out of range: 0.." + std::to_string(count - 1));
+  }
+}
+
+template <typename T>
+void getFieldValue(T& result, TargetValue* field) {
+  ScalarTargetValue* scalar_value = boost::get<ScalarTargetValue>(field);
+  if (!scalar_value) {
+    throw std::runtime_error("Unsupported field type");
+  }
+  T* result_ptr = boost::get<T>(scalar_value);
+  if (!result_ptr) {
+    throw std::runtime_error("Null field");
+  }
+  result = *result_ptr;
+}
+}  // namespace
+
+namespace EmbeddedDatabase {
+
+/** ColumnDetails methods */
+
+ColumnDetails::ColumnDetails()
+    : col_type(ColumnType::UNKNOWN)
+    , encoding(ColumnEncoding::NONE)
+    , nullable(false)
+    , is_array(false)
+    , precision(0)
+    , scale(0)
+    , comp_param(0) {}
+
+ColumnDetails::ColumnDetails(const std::string& _col_name,
+                             ColumnType _col_type,
+                             ColumnEncoding _encoding,
+                             bool _nullable,
+                             bool _is_array,
+                             int _precision,
+                             int _scale,
+                             int _comp_param)
+    : col_name(_col_name)
+    , col_type(_col_type)
+    , encoding(_encoding)
+    , nullable(_nullable)
+    , is_array(_is_array)
+    , precision(_precision)
+    , scale(_scale)
+    , comp_param(_comp_param) {}
+
+/** Row methods */
+
+Row::Row() {}
+
+Row::Row(std::vector<TargetValue>& row) : row_(std::move(row)) {}
+
+int64_t Row::getInt(size_t col_num) {
+  int64_t value;
+  checkColumnRange(col_num, row_.size());
+  getFieldValue(value, &row_[col_num]);
+  return value;
+}
+
+float Row::getFloat(size_t col_num) {
+  float value;
+  checkColumnRange(col_num, row_.size());
+  getFieldValue(value, &row_[col_num]);
+  return value;
+}
+
+double Row::getDouble(size_t col_num) {
+  double value;
+  checkColumnRange(col_num, row_.size());
+  getFieldValue(value, &row_[col_num]);
+  return value;
+}
+
+std::string Row::getStr(size_t col_num) {
+  checkColumnRange(col_num, row_.size());
+  const auto scalar_value = boost::get<ScalarTargetValue>(&row_[col_num]);
+  auto value = boost::get<NullableString>(scalar_value);
+  if (!value || boost::get<void*>(value)) {
+    return "";
+  }
+  if (auto str = boost::get<std::string>(value)) {
+    return *str;
+  }
+  return "";
+}
+
+ColumnType sqlToColumnType(const SQLTypes& type) {
+  switch (type) {
+    case kBOOLEAN:
+      return ColumnType::BOOL;
+    case kTINYINT:
+      return ColumnType::TINYINT;
+    case kSMALLINT:
+      return ColumnType::SMALLINT;
+    case kINT:
+      return ColumnType::INT;
+    case kBIGINT:
+      return ColumnType::BIGINT;
+    case kFLOAT:
+      return ColumnType::FLOAT;
+    case kNUMERIC:
+    case kDECIMAL:
+      return ColumnType::DECIMAL;
+    case kDOUBLE:
+      return ColumnType::DOUBLE;
+    case kTEXT:
+    case kVARCHAR:
+    case kCHAR:
+      return ColumnType::STR;
+    case kTIME:
+      return ColumnType::TIME;
+    case kTIMESTAMP:
+      return ColumnType::TIMESTAMP;
+    case kDATE:
+      return ColumnType::DATE;
+    case kINTERVAL_DAY_TIME:
+      return ColumnType::INTERVAL_DAY_TIME;
+    case kINTERVAL_YEAR_MONTH:
+      return ColumnType::INTERVAL_YEAR_MONTH;
+    case kPOINT:
+      return ColumnType::POINT;
+    case kLINESTRING:
+      return ColumnType::LINESTRING;
+    case kPOLYGON:
+      return ColumnType::POLYGON;
+    case kMULTIPOLYGON:
+      return ColumnType::MULTIPOLYGON;
+    case kGEOMETRY:
+      return ColumnType::GEOMETRY;
+    case kGEOGRAPHY:
+      return ColumnType::GEOGRAPHY;
+    default:
+      return ColumnType::UNKNOWN;
+  }
+  return ColumnType::UNKNOWN;
+}
+
+ColumnEncoding sqlToColumnEncoding(const EncodingType& type) {
+  switch (type) {
+    case kENCODING_NONE:
+      return ColumnEncoding::NONE;
+    case kENCODING_FIXED:
+      return ColumnEncoding::FIXED;
+    case kENCODING_RL:
+      return ColumnEncoding::RL;
+    case kENCODING_DIFF:
+      return ColumnEncoding::DIFF;
+    case kENCODING_DICT:
+      return ColumnEncoding::DICT;
+    case kENCODING_SPARSE:
+      return ColumnEncoding::SPARSE;
+    case kENCODING_GEOINT:
+      return ColumnEncoding::GEOINT;
+    case kENCODING_DATE_IN_DAYS:
+      return ColumnEncoding::DATE_IN_DAYS;
+    default:
+      return ColumnEncoding::NONE;
+  }
+  return ColumnEncoding::NONE;
+}
+}  // namespace EmbeddedDatabase
\ No newline at end of file
diff -Naur ./Embedded/DBETypes.h ../omniscidb-master/Embedded/DBETypes.h
--- ./Embedded/DBETypes.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Embedded/DBETypes.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2020 OmniSci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "QueryEngine/TargetValue.h"
+#include "Shared/sqltypes.h"
+
+namespace EmbeddedDatabase {
+
+enum class ColumnType {
+  SMALLINT = 0,
+  INT = 1,
+  BIGINT = 2,
+  FLOAT = 3,
+  DECIMAL = 4,
+  DOUBLE = 5,
+  STR = 6,
+  TIME = 7,
+  TIMESTAMP = 8,
+  DATE = 9,
+  BOOL = 10,
+  INTERVAL_DAY_TIME = 11,
+  INTERVAL_YEAR_MONTH = 12,
+  POINT = 13,
+  LINESTRING = 14,
+  POLYGON = 15,
+  MULTIPOLYGON = 16,
+  TINYINT = 17,
+  GEOMETRY = 18,
+  GEOGRAPHY = 19,
+  UNKNOWN = 20
+};
+
+enum class ColumnEncoding {
+  NONE = 0,
+  FIXED = 1,
+  RL = 2,
+  DIFF = 3,
+  DICT = 4,
+  SPARSE = 5,
+  GEOINT = 6,
+  DATE_IN_DAYS = 7
+};
+
+class ColumnDetails {
+ public:
+  std::string col_name;
+  ColumnType col_type;
+  ColumnEncoding encoding;
+  bool nullable;
+  bool is_array;
+  int precision;
+  int scale;
+  int comp_param;
+
+  ColumnDetails();
+
+  ColumnDetails(const std::string& col_name,
+                ColumnType col_type,
+                ColumnEncoding encoding,
+                bool nullable,
+                bool is_array,
+                int precision,
+                int scale,
+                int comp_param);
+};
+
+class Row {
+ public:
+  Row();
+  Row(std::vector<TargetValue>& row);
+  int64_t getInt(size_t col_num);
+  float getFloat(size_t col_num);
+  double getDouble(size_t col_num);
+  std::string getStr(size_t col_num);
+
+ private:
+  std::vector<TargetValue> row_;
+};
+
+ColumnType sqlToColumnType(const SQLTypes& type);
+ColumnEncoding sqlToColumnEncoding(const EncodingType& type);
+}  // namespace EmbeddedDatabase
diff -Naur ./Embedded/DBEngine.cpp ../omniscidb-master/Embedded/DBEngine.cpp
--- ./Embedded/DBEngine.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Embedded/DBEngine.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -16,73 +16,80 @@
 
 #include "DBEngine.h"
 #include <boost/filesystem.hpp>
-#include <boost/variant.hpp>
-#include <iostream>
-#include "Catalog/Catalog.h"
-#include "Logger/Logger.h"
-#include "QueryEngine/CompilationOptions.h"
-#include "QueryEngine/ResultSet.h"
-#include "QueryRunner/QueryRunner.h"
-#include "Shared/sqltypes.h"
+#include <stdexcept>
+#include "DataMgr/ForeignStorage/ArrowForeignStorage.h"
+#include "Fragmenter/FragmentDefaultValues.h"
+#include "Parser/ParserWrapper.h"
+#include "Parser/parser.h"
+#include "QueryEngine/ArrowResultSet.h"
+#include "QueryEngine/Execute.h"
+#include "QueryEngine/ExtensionFunctionsWhitelist.h"
+#include "QueryEngine/TableFunctions/TableFunctionsFactory.h"
+#include "ThriftHandler/CommandLineOptions.h"
+#include "ThriftHandler/DBHandler.h"
+
+extern bool g_enable_union;
+extern bool g_serialize_temp_tables;
 
 namespace EmbeddedDatabase {
 
-enum class ColumnType : uint32_t { Unknown, Integer, Double, Float, String, Array };
+class DBEngineImpl;
 
 /**
  * Cursor internal implementation
  */
 class CursorImpl : public Cursor {
  public:
-  CursorImpl(std::shared_ptr<ResultSet> result_set,
-             std::shared_ptr<Data_Namespace::DataMgr> data_mgr)
-      : result_set_(result_set), data_mgr_(data_mgr) {}
+  CursorImpl(std::shared_ptr<ResultSet> result_set, std::vector<std::string> col_names)
+      : result_set_(result_set), col_names_(col_names) {}
+
+  ~CursorImpl() {
+    col_names_.clear();
+    record_batch_.reset();
+    result_set_.reset();
+  }
 
-  size_t getColCount() { return result_set_->colCount(); }
+  size_t getColCount() { return result_set_ ? result_set_->colCount() : 0; }
 
-  size_t getRowCount() { return result_set_->rowCount(); }
+  size_t getRowCount() { return result_set_ ? result_set_->rowCount() : 0; }
 
   Row getNextRow() {
-    auto row = result_set_->getNextRow(true, false);
-    if (row.empty()) {
-      return Row();
+    if (result_set_) {
+      auto row = result_set_->getNextRow(true, false);
+      return row.empty() ? Row() : Row(row);
     }
-    return Row(row);
+    return Row();
   }
 
   ColumnType getColType(uint32_t col_num) {
     if (col_num < getColCount()) {
       SQLTypeInfo type_info = result_set_->getColType(col_num);
-      switch (type_info.get_type()) {
-        case kNUMERIC:
-        case kDECIMAL:
-        case kINT:
-        case kSMALLINT:
-        case kBIGINT:
-        case kTINYINT:
-          return ColumnType::Integer;
-
-        case kDOUBLE:
-          return ColumnType::Double;
-
-        case kFLOAT:
-          return ColumnType::Float;
-
-        case kCHAR:
-        case kVARCHAR:
-        case kTEXT:
-          return ColumnType::String;
+      return sqlToColumnType(type_info.get_type());
+    }
+    return ColumnType::UNKNOWN;
+  }
 
-        default:
-          return ColumnType::Unknown;
+  std::shared_ptr<arrow::RecordBatch> getArrowRecordBatch() {
+    if (record_batch_) {
+      return record_batch_;
+    }
+    auto col_count = getColCount();
+    if (col_count > 0) {
+      auto row_count = getRowCount();
+      if (row_count > 0) {
+        auto converter =
+            std::make_unique<ArrowResultSetConverter>(result_set_, col_names_, -1);
+        record_batch_ = converter->convertToArrow();
+        return record_batch_;
       }
     }
-    return ColumnType::Unknown;
+    return nullptr;
   }
 
  private:
   std::shared_ptr<ResultSet> result_set_;
-  std::weak_ptr<Data_Namespace::DataMgr> data_mgr_;
+  std::vector<std::string> col_names_;
+  std::shared_ptr<arrow::RecordBatch> record_batch_;
 };
 
 /**
@@ -90,87 +97,359 @@
  */
 class DBEngineImpl : public DBEngine {
  public:
-  // TODO: Remove all that hardcoded settings
-  const int CALCITEPORT = 3279;
-  const std::string OMNISCI_DEFAULT_DB = "omnisci";
-  const std::string OMNISCI_ROOT_USER = "admin";
-  const std::string OMNISCI_DATA_PATH = "//mapd_data";
+  DBEngineImpl() : is_temp_db_(false) {}
 
-  void reset() {
-    // TODO: Destroy all cursors in the cursors_
-    if (query_runner_ != nullptr) {
-      query_runner_->reset();
+  ~DBEngineImpl() { reset(); }
+
+  bool init(const std::string& cmd_line) {
+    static bool initialized{false};
+    if (initialized) {
+      throw std::runtime_error("Database engine already initialized");
+    }
+
+    g_serialize_temp_tables = true;
+
+    // Split the command line into parameters
+    std::vector<std::string> parameters;
+    if (!cmd_line.empty()) {
+      parameters = boost::program_options::split_unix(cmd_line);
     }
+
+    // Generate command line to initialize CommandLineOptions for DBHandler
+    const char* log_option = "omnisci_dbe";
+    std::vector<const char*> cstrings;
+    cstrings.push_back(log_option);
+    for (auto& param : parameters) {
+      cstrings.push_back(param.c_str());
+    }
+    int argc = cstrings.size();
+    const char** argv = cstrings.data();
+
+    CommandLineOptions prog_config_opts(log_option);
+    if (prog_config_opts.parse_command_line(argc, argv, false)) {
+      throw std::runtime_error("DBE paramerameters parsing failed");
+    }
+
+    auto base_path = prog_config_opts.base_path;
+
+    // Check path to the database
+    bool is_new_db = base_path.empty() || !catalogExists(base_path);
+    if (is_new_db) {
+      base_path = createCatalog(base_path);
+      if (base_path.empty()) {
+        throw std::runtime_error("Database directory could not be created");
+      }
+    }
+    prog_config_opts.base_path = base_path;
+    prog_config_opts.init_logging();
+
+    prog_config_opts.system_parameters.omnisci_server_port = -1;
+    prog_config_opts.system_parameters.calcite_keepalive = true;
+
+    try {
+      db_handler_ =
+          mapd::make_shared<DBHandler>(prog_config_opts.db_leaves,
+                                       prog_config_opts.string_leaves,
+                                       prog_config_opts.base_path,
+                                       prog_config_opts.allow_multifrag,
+                                       prog_config_opts.jit_debug,
+                                       prog_config_opts.intel_jit_profile,
+                                       prog_config_opts.read_only,
+                                       prog_config_opts.allow_loop_joins,
+                                       prog_config_opts.enable_rendering,
+                                       prog_config_opts.renderer_use_vulkan_driver,
+                                       prog_config_opts.enable_auto_clear_render_mem,
+                                       prog_config_opts.render_oom_retry_threshold,
+                                       prog_config_opts.render_mem_bytes,
+                                       prog_config_opts.max_concurrent_render_sessions,
+                                       prog_config_opts.reserved_gpu_mem,
+                                       prog_config_opts.render_compositor_use_last_gpu,
+                                       prog_config_opts.num_reader_threads,
+                                       prog_config_opts.authMetadata,
+                                       prog_config_opts.system_parameters,
+                                       prog_config_opts.enable_legacy_syntax,
+                                       prog_config_opts.idle_session_duration,
+                                       prog_config_opts.max_session_duration,
+                                       prog_config_opts.enable_runtime_udf,
+                                       prog_config_opts.udf_file_name,
+                                       prog_config_opts.udf_compiler_path,
+                                       prog_config_opts.udf_compiler_options,
+#ifdef ENABLE_GEOS
+                                       prog_config_opts.libgeos_so_filename,
+#endif
+                                       prog_config_opts.disk_cache_config,
+                                       is_new_db);
+    } catch (const std::exception& e) {
+      LOG(FATAL) << "Failed to initialize database handler: " << e.what();
+    }
+    db_handler_->connect(
+        session_id_, OMNISCI_ROOT_USER, OMNISCI_ROOT_PASSWD_DEFAULT, OMNISCI_DEFAULT_DB);
+    base_path_ = base_path;
+    initialized = true;
+    return true;
   }
 
-  void executeDDL(const std::string& query) {
-    if (query_runner_ != nullptr) {
-      query_runner_->runDDLStatement(query);
+  std::shared_ptr<CursorImpl> sql_execute_dbe(const TSessionId& session_id,
+                                              const std::string& query_str,
+                                              const bool column_format,
+                                              const int32_t first_n,
+                                              const int32_t at_most_n) {
+    ExecutionResult result{std::make_shared<ResultSet>(std::vector<TargetInfo>{},
+                                                       ExecutorDeviceType::CPU,
+                                                       QueryMemoryDescriptor(),
+                                                       nullptr,
+                                                       nullptr,
+                                                       0,
+                                                       0),
+                           {}};
+    db_handler_->sql_execute(
+        result, session_id, query_str, column_format, first_n, at_most_n);
+    auto& targets = result.getTargetsMeta();
+    std::vector<std::string> col_names;
+    for (const auto target : targets) {
+      col_names.push_back(target.get_resname());
     }
+    return std::make_shared<CursorImpl>(result.getRows(), col_names);
   }
 
-  Cursor* executeDML(const std::string& query) {
-    if (query_runner_ != nullptr) {
-      auto rs = query_runner_->runSQL(query, ExecutorDeviceType::CPU);
-      cursors_.emplace_back(new CursorImpl(rs, data_mgr_));
-      return cursors_.back();
+  void executeDDL(const std::string& query) {
+    auto res = sql_execute_dbe(session_id_, query, false, -1, -1);
+  }
+
+  void importArrowTable(const std::string& name,
+                        std::shared_ptr<arrow::Table>& table,
+                        uint64_t fragment_size) {
+    setArrowTable(name, table);
+    try {
+      auto session = db_handler_->get_session_copy(session_id_);
+      TableDescriptor td;
+      td.tableName = name;
+      td.userId = session.get_currentUser().userId;
+      td.storageType = "ARROW:" + name;
+      td.persistenceLevel = Data_Namespace::MemoryLevel::CPU_LEVEL;
+      td.isView = false;
+      td.fragmenter = nullptr;
+      td.fragType = Fragmenter_Namespace::FragmenterType::INSERT_ORDER;
+      td.maxFragRows = fragment_size > 0 ? fragment_size : DEFAULT_FRAGMENT_ROWS;
+      td.maxChunkSize = DEFAULT_MAX_CHUNK_SIZE;
+      td.fragPageSize = DEFAULT_PAGE_SIZE;
+      td.maxRows = DEFAULT_MAX_ROWS;
+      td.keyMetainfo = "[]";
+
+      std::list<ColumnDescriptor> cols;
+      std::vector<Parser::SharedDictionaryDef> dictionaries;
+      auto catalog = session.get_catalog_ptr();
+      // nColumns
+      catalog->createTable(td, cols, dictionaries, false);
+      Catalog_Namespace::SysCatalog::instance().createDBObject(
+          session.get_currentUser(), td.tableName, TableDBObjectType, *catalog);
+    } catch (...) {
+      releaseArrowTable(name);
+      throw;
     }
-    return nullptr;
+    releaseArrowTable(name);
+  }
+
+  std::shared_ptr<CursorImpl> executeDML(const std::string& query) {
+    return sql_execute_dbe(session_id_, query, false, -1, -1);
   }
 
-  DBEngineImpl(const std::string& base_path)
-      : base_path_(base_path), query_runner_(nullptr) {
-    if (!boost::filesystem::exists(base_path_)) {
-      std::cerr << "Catalog basepath " + base_path_ + " does not exist.\n";
-      // TODO: Create database if it does not exist
+  std::shared_ptr<CursorImpl> executeRA(const std::string& query) {
+    return sql_execute_dbe(session_id_, query, false, -1, -1);
+  }
+
+  std::vector<std::string> getTables() {
+    std::vector<std::string> table_names;
+    auto catalog = db_handler_->get_session_copy(session_id_).get_catalog_ptr();
+    if (catalog) {
+      const auto tables = catalog->getAllTableMetadata();
+      for (const auto td : tables) {
+        if (td->shard >= 0) {
+          // skip shards, they're not standalone tables
+          continue;
+        }
+        table_names.push_back(td->tableName);
+      }
     } else {
-      SystemParameters system_parameters;
-      std::string data_path = base_path_ + OMNISCI_DATA_PATH;
-      data_mgr_ = std::make_shared<Data_Namespace::DataMgr>(
-          data_path, system_parameters, false, 0);
-      auto calcite = std::make_shared<Calcite>(-1, CALCITEPORT, base_path_, 1024, 5000);
-      g_base_path = base_path_;
-      auto& sys_cat = Catalog_Namespace::SysCatalog::instance();
-      sys_cat.init(base_path_, data_mgr_, {}, calcite, false, false, {});
-      if (!sys_cat.getSqliteConnector()) {
-        std::cerr << "SqliteConnector is null " << std::endl;
-      } else {
-        sys_cat.getMetadataForDB(OMNISCI_DEFAULT_DB, database_);  // TODO: Check
-        auto catalog = sys_cat.getCatalog(base_path_,
-                                          database_,
-                                          data_mgr_,
-                                          std::vector<LeafHostInfo>(),
-                                          calcite,
-                                          false);
-        sys_cat.getMetadataForUser(OMNISCI_ROOT_USER, user_);
-        auto session = std::make_unique<Catalog_Namespace::SessionInfo>(
-            catalog, user_, ExecutorDeviceType::CPU, "");
-        query_runner_ = QueryRunner::QueryRunner::init(session);
+      throw std::runtime_error("System catalog uninitialized");
+    }
+    return table_names;
+  }
+
+  std::vector<ColumnDetails> getTableDetails(const std::string& table_name) {
+    std::vector<ColumnDetails> result;
+    auto catalog = db_handler_->get_session_copy(session_id_).get_catalog_ptr();
+    if (catalog) {
+      auto metadata = catalog->getMetadataForTable(table_name, false);
+      if (metadata) {
+        const auto col_descriptors =
+            catalog->getAllColumnMetadataForTable(metadata->tableId, false, true, false);
+        const auto deleted_cd = catalog->getDeletedColumn(metadata);
+        for (const auto cd : col_descriptors) {
+          if (cd == deleted_cd) {
+            continue;
+          }
+          ColumnDetails col_details;
+          col_details.col_name = cd->columnName;
+          auto ct = cd->columnType;
+          SQLTypes sql_type = ct.get_type();
+          EncodingType sql_enc = ct.get_compression();
+          col_details.col_type = sqlToColumnType(sql_type);
+          col_details.encoding = sqlToColumnEncoding(sql_enc);
+          col_details.nullable = !ct.get_notnull();
+          col_details.is_array = (sql_type == kARRAY);
+          if (IS_GEO(sql_type)) {
+            col_details.precision = static_cast<int>(ct.get_subtype());
+            col_details.scale = ct.get_output_srid();
+          } else {
+            col_details.precision = ct.get_precision();
+            col_details.scale = ct.get_scale();
+          }
+          if (col_details.encoding == ColumnEncoding::DICT) {
+            // have to get the actual size of the encoding from the dictionary
+            // definition
+            const int dict_id = ct.get_comp_param();
+            auto dd = catalog->getMetadataForDict(dict_id, false);
+            if (dd) {
+              col_details.comp_param = dd->dictNBits;
+            } else {
+              throw std::runtime_error("Dictionary definition for column doesn't exist");
+            }
+          } else {
+            col_details.comp_param = ct.get_comp_param();
+            if (ct.is_date_in_days() && col_details.comp_param == 0) {
+              col_details.comp_param = 32;
+            }
+          }
+          result.push_back(col_details);
+        }
       }
     }
+    return result;
+  }
+
+  bool setDatabase(std::string& db_name) {
+    auto& sys_cat = Catalog_Namespace::SysCatalog::instance();
+    auto& user = db_handler_->get_session_copy(session_id_).get_currentUser();
+    sys_cat.switchDatabase(db_name, user.userName);
+    return true;
+  }
+
+  bool login(std::string& db_name, std::string& user_name, const std::string& password) {
+    db_handler_->disconnect(session_id_);
+    db_handler_->connect(session_id_, user_name, password, db_name);
+    return true;
+  }
+
+ protected:
+  void reset() {
+    if (db_handler_) {
+      db_handler_->disconnect(session_id_);
+      db_handler_->shutdown();
+    }
+    Catalog_Namespace::SysCatalog::destroy();
+    db_handler_.reset();
+
+    logger::shutdown();
+    if (is_temp_db_) {
+      boost::filesystem::remove_all(base_path_);
+    }
+    base_path_.clear();
+  }
+
+  bool catalogExists(const std::string& base_path) {
+    if (!boost::filesystem::exists(base_path)) {
+      return false;
+    }
+    for (auto& subdir : system_folders_) {
+      std::string path = base_path + "/" + subdir;
+      if (!boost::filesystem::exists(path)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  void cleanCatalog(const std::string& base_path) {
+    if (boost::filesystem::exists(base_path)) {
+      for (auto& subdir : system_folders_) {
+        std::string path = base_path + "/" + subdir;
+        if (boost::filesystem::exists(path)) {
+          boost::filesystem::remove_all(path);
+        }
+      }
+    }
+  }
+
+  std::string createCatalog(const std::string& base_path) {
+    std::string root_dir = base_path;
+    if (base_path.empty()) {
+      boost::system::error_code error;
+      auto tmp_path = boost::filesystem::temp_directory_path(error);
+      if (boost::system::errc::success != error.value()) {
+        std::cerr << error.message() << std::endl;
+        return "";
+      }
+      tmp_path /= "omnidbe_%%%%-%%%%-%%%%";
+      auto uniq_path = boost::filesystem::unique_path(tmp_path, error);
+      if (boost::system::errc::success != error.value()) {
+        std::cerr << error.message() << std::endl;
+        return "";
+      }
+      root_dir = uniq_path.string();
+      is_temp_db_ = true;
+    }
+    if (!boost::filesystem::exists(root_dir)) {
+      if (!boost::filesystem::create_directory(root_dir)) {
+        std::cerr << "Cannot create database directory: " << root_dir << std::endl;
+        return "";
+      }
+    }
+    size_t absent_count = 0;
+    for (auto& sub_dir : system_folders_) {
+      std::string path = root_dir + "/" + sub_dir;
+      if (!boost::filesystem::exists(path)) {
+        if (!boost::filesystem::create_directory(path)) {
+          std::cerr << "Cannot create database subdirectory: " << path << std::endl;
+          return "";
+        }
+        ++absent_count;
+      }
+    }
+    if ((absent_count > 0) && (absent_count < system_folders_.size())) {
+      std::cerr << "Database directory structure is broken: " << root_dir << std::endl;
+      return "";
+    }
+    return root_dir;
   }
 
  private:
   std::string base_path_;
-  std::shared_ptr<Data_Namespace::DataMgr> data_mgr_;
-  Catalog_Namespace::DBMetadata database_;
-  Catalog_Namespace::UserMetadata user_;
-  QueryRunner::QueryRunner* query_runner_;
-  std::vector<CursorImpl*> cursors_;
+  std::string session_id_;
+  mapd::shared_ptr<DBHandler> db_handler_;
+  bool is_temp_db_;
+  std::string udf_filename_;
+
+  std::vector<std::string> system_folders_ = {"mapd_catalogs",
+                                              "mapd_data",
+                                              "mapd_export"};
 };
 
-/********************************************* DBEngine external methods*/
+namespace {
+std::mutex engine_create_mutex;
+}
 
-/**
- * Creates DBEngine instance
- *
- * @param sPath Path to the existing database
- */
-DBEngine* DBEngine::create(std::string path) {
-  return new DBEngineImpl(path);
+std::shared_ptr<DBEngine> DBEngine::create(const std::string& cmd_line) {
+  const std::lock_guard<std::mutex> lock(engine_create_mutex);
+  auto engine = std::make_shared<DBEngineImpl>();
+  if (!engine->init(cmd_line)) {
+    throw std::runtime_error("DBE initialization failed");
+  }
+  return engine;
 }
 
 /** DBEngine downcasting methods */
+
 inline DBEngineImpl* getImpl(DBEngine* ptr) {
   return (DBEngineImpl*)ptr;
 }
@@ -178,71 +457,64 @@
   return (const DBEngineImpl*)ptr;
 }
 
-void DBEngine::reset() {
-  // TODO: Make sure that dbengine does not released twice
-  DBEngineImpl* engine = getImpl(this);
-  engine->reset();
-}
+/** DBEngine external methods */
 
-void DBEngine::executeDDL(std::string query) {
+void DBEngine::executeDDL(const std::string& query) {
   DBEngineImpl* engine = getImpl(this);
   engine->executeDDL(query);
 }
 
-Cursor* DBEngine::executeDML(std::string query) {
+std::shared_ptr<Cursor> DBEngine::executeDML(const std::string& query) {
   DBEngineImpl* engine = getImpl(this);
   return engine->executeDML(query);
 }
 
-/********************************************* Row methods */
-
-Row::Row() {}
+std::shared_ptr<Cursor> DBEngine::executeRA(const std::string& query) {
+  DBEngineImpl* engine = getImpl(this);
+  return engine->executeRA(query);
+}
 
-Row::Row(std::vector<TargetValue>& row) : row_(std::move(row)) {}
+void DBEngine::importArrowTable(const std::string& name,
+                                std::shared_ptr<arrow::Table>& table,
+                                uint64_t fragment_size) {
+  DBEngineImpl* engine = getImpl(this);
+  engine->importArrowTable(name, table, fragment_size);
+}
 
-int64_t Row::getInt(size_t col_num) {
-  if (col_num < row_.size()) {
-    const auto scalar_value = boost::get<ScalarTargetValue>(&row_[col_num]);
-    const auto value = boost::get<int64_t>(scalar_value);
-    return *value;
-  }
-  return 0;
+std::vector<std::string> DBEngine::getTables() {
+  DBEngineImpl* engine = getImpl(this);
+  return engine->getTables();
 }
 
-double Row::getDouble(size_t col_num) {
-  if (col_num < row_.size()) {
-    const auto scalar_value = boost::get<ScalarTargetValue>(&row_[col_num]);
-    const auto value = boost::get<double>(scalar_value);
-    return *value;
-  }
-  return 0.;
+std::vector<ColumnDetails> DBEngine::getTableDetails(const std::string& table_name) {
+  DBEngineImpl* engine = getImpl(this);
+  return engine->getTableDetails(table_name);
 }
 
-std::string Row::getStr(size_t col_num) {
-  if (col_num < row_.size()) {
-    const auto scalar_value = boost::get<ScalarTargetValue>(&row_[col_num]);
-    auto value = boost::get<NullableString>(scalar_value);
-    bool is_null = !value || boost::get<void*>(value);
-    if (is_null) {
-      return "Empty";
-    } else {
-      auto value_notnull = boost::get<std::string>(value);
-      return *value_notnull;
-    }
-  }
-  return "Out of range";
+bool DBEngine::setDatabase(std::string& db_name) {
+  DBEngineImpl* engine = getImpl(this);
+  return engine->setDatabase(db_name);
 }
 
-/********************************************* Cursor external methods*/
+bool DBEngine::login(std::string& db_name,
+                     std::string& user_name,
+                     const std::string& password) {
+  DBEngineImpl* engine = getImpl(this);
+  return engine->login(db_name, user_name, password);
+}
 
 /** Cursor downcasting methods */
+
 inline CursorImpl* getImpl(Cursor* ptr) {
   return (CursorImpl*)ptr;
 }
+
 inline const CursorImpl* getImpl(const Cursor* ptr) {
   return (const CursorImpl*)ptr;
 }
 
+/** Cursor external methods */
+
 size_t Cursor::getColCount() {
   CursorImpl* cursor = getImpl(this);
   return cursor->getColCount();
@@ -258,8 +530,13 @@
   return cursor->getNextRow();
 }
 
-int Cursor::getColType(uint32_t col_num) {
+ColumnType Cursor::getColType(uint32_t col_num) {
+  CursorImpl* cursor = getImpl(this);
+  return cursor->getColType(col_num);
+}
+
+std::shared_ptr<arrow::RecordBatch> Cursor::getArrowRecordBatch() {
   CursorImpl* cursor = getImpl(this);
-  return (int)cursor->getColType(col_num);
+  return cursor->getArrowRecordBatch();
 }
 }  // namespace EmbeddedDatabase
diff -Naur ./Embedded/DBEngine.h ../omniscidb-master/Embedded/DBEngine.h
--- ./Embedded/DBEngine.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Embedded/DBEngine.h	2021-04-21 00:02:57.000000000 +0300
@@ -16,43 +16,44 @@
 
 #pragma once
 
-#include <iostream>
-#include <memory>
-#include <string>
-#include <type_traits>
-#include <vector>
-#include "QueryEngine/TargetValue.h"
+#include <arrow/table.h>
+#include "DBETypes.h"
 
 namespace EmbeddedDatabase {
 
-class Row {
- public:
-  Row();
-  Row(std::vector<TargetValue>& row);
-  int64_t getInt(size_t col_num);
-  double getDouble(size_t col_num);
-  std::string getStr(size_t col_num);
-
- private:
-  std::vector<TargetValue> row_;
-};
-
 class Cursor {
  public:
+  virtual ~Cursor() {}
   size_t getColCount();
   size_t getRowCount();
   Row getNextRow();
-  int getColType(uint32_t col_num);
+  ColumnType getColType(uint32_t col_num);
+  std::shared_ptr<arrow::RecordBatch> getArrowRecordBatch();
+
+ protected:
+  Cursor() {}
+  Cursor(const Cursor&) = delete;
+  Cursor& operator=(const Cursor&) = delete;
 };
 
 class DBEngine {
  public:
-  void reset();
-  void executeDDL(std::string query);
-  Cursor* executeDML(std::string query);
-  static DBEngine* create(std::string path);
+  virtual ~DBEngine() {}
+  void executeDDL(const std::string& query);
+  std::shared_ptr<Cursor> executeDML(const std::string& query);
+  std::shared_ptr<Cursor> executeRA(const std::string& query);
+  void importArrowTable(const std::string& name,
+                        std::shared_ptr<arrow::Table>& table,
+                        uint64_t fragment_size = 0);
+  static std::shared_ptr<DBEngine> create(const std::string& cmd_line);
+  std::vector<std::string> getTables();
+  std::vector<ColumnDetails> getTableDetails(const std::string& table_name);
+  bool setDatabase(std::string& db_name);
+  bool login(std::string& db_name, std::string& user_name, const std::string& password);
 
  protected:
   DBEngine() {}
+  DBEngine(const DBEngine&) = delete;
+  DBEngine& operator=(const DBEngine&) = delete;
 };
 }  // namespace EmbeddedDatabase
diff -Naur ./Embedded/EmbeddedDbFSITest.cpp ../omniscidb-master/Embedded/EmbeddedDbFSITest.cpp
--- ./Embedded/EmbeddedDbFSITest.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Embedded/EmbeddedDbFSITest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2020 OmniSci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <boost/filesystem.hpp>
+#include <boost/program_options.hpp>
+#include <exception>
+#include <iostream>
+#include "DBEngine.h"
+
+#include <arrow/api.h>
+#include <arrow/csv/reader.h>
+#include <arrow/io/file.h>
+#include "Shared/ArrowUtil.h"
+
+using namespace EmbeddedDatabase;
+
+int main(int argc, char* argv[]) {
+  std::string base_path, csv_path;
+  int calcite_port = 5555;
+  bool columnar_output = true;
+  namespace po = boost::program_options;
+
+  po::options_description desc("Options");
+  desc.add_options()("help,h", "Print help messages ")(
+      "data",
+      po::value<std::string>(&base_path)->required(),
+      "Directory path to OmniSci catalogs")(
+      "csv", po::value<std::string>(&csv_path)->required(), "Directory path to CSV file")(
+      "calcite-port",
+      po::value<int>(&calcite_port)->default_value(calcite_port),
+      "Calcite port")("columnar-output",
+                      po::value<bool>(&columnar_output)->default_value(columnar_output),
+                      "Enable columnar_output");
+
+  po::positional_options_description positionalOptions;
+  positionalOptions.add("data", 1);
+
+  po::variables_map vm;
+
+  try {
+    po::store(po::command_line_parser(argc, argv)
+                  .options(desc)
+                  .positional(positionalOptions)
+                  .run(),
+              vm);
+    if (vm.count("help")) {
+      std::cout << desc;
+      return 0;
+    }
+    po::notify(vm);
+  } catch (boost::program_options::error& e) {
+    std::cerr << "Usage Error: " << e.what() << std::endl;
+    return 1;
+  }
+
+  try {
+    auto opt_str = base_path + " --calcite-port " + std::to_string(calcite_port);
+    if (columnar_output) {
+      opt_str += "--columnar-output";
+    }
+    auto dbe = DBEngine::create(opt_str);
+    if (dbe) {
+      dbe->executeDDL(std::string(R"(
+CREATE TEMPORARY TABLE test (
+trip_id BIGINT,
+vendor_id TEXT ENCODING NONE,
+pickup_datetime TIMESTAMP,
+dropoff_datetime TIMESTAMP,
+store_and_fwd_flag TEXT ENCODING DICT,
+rate_code_id BIGINT,
+pickup_longitude DOUBLE,
+pickup_latitude DOUBLE,
+dropoff_longitude DOUBLE,
+dropoff_latitude DOUBLE,
+passenger_count BIGINT,
+trip_distance DOUBLE,
+fare_amount DOUBLE,
+extra DOUBLE,
+mta_tax DOUBLE,
+tip_amount DOUBLE,
+tolls_amount DOUBLE,
+ehail_fee DOUBLE,
+improvement_surcharge DOUBLE,
+total_amount DOUBLE,
+payment_type TEXT ENCODING DICT,
+trip_type BIGINT,
+pickup TEXT ENCODING DICT,
+dropoff TEXT ENCODING NONE,
+cab_type TEXT ENCODING DICT,
+precipitation DOUBLE,
+snow_depth BIGINT,
+snowfall DOUBLE,
+max_temperature BIGINT,
+min_temperature BIGINT,
+average_wind_speed DOUBLE,
+pickup_nyct2010_gid BIGINT,
+pickup_ctlabel DOUBLE,
+pickup_borocode BIGINT,
+pickup_boroname TEXT ENCODING NONE,
+pickup_ct2010 BIGINT,
+pickup_boroct2010 BIGINT,
+pickup_cdeligibil TEXT ENCODING DICT,
+pickup_ntacode TEXT ENCODING DICT,
+pickup_ntaname TEXT ENCODING DICT,
+pickup_puma BIGINT,
+dropoff_nyct2010_gid BIGINT,
+dropoff_ctlabel DOUBLE,
+dropoff_borocode BIGINT,
+dropoff_boroname TEXT ENCODING NONE,
+dropoff_ct2010 BIGINT,
+dropoff_boroct2010 BIGINT,
+dropoff_cdeligibil TEXT ENCODING NONE,
+dropoff_ntacode TEXT ENCODING NONE,
+dropoff_ntaname TEXT ENCODING NONE,
+dropoff_puma BIGINT) WITH (storage_type='CSV:") + csv_path + std::string("', fragment_size=100);)"));
+      auto schema = dbe->getTableDetails("test");
+      for (auto& item : schema) {
+        std::cout << item.col_name << std::endl;
+      }
+      auto cursor = dbe->executeDML("select count(*) from test");
+      if (cursor) {
+        std::cout << cursor->getRowCount() << " rows selected" << std::endl;
+        std::shared_ptr<arrow::RecordBatch> rbatch = cursor->getArrowRecordBatch();
+      } else {
+        std::cerr << "Cursor is NULL" << std::endl;
+      }
+    }
+  } catch (std::exception& e) {
+    std::cerr << "Exception: " << e.what() << "\n";
+  }
+  return 0;
+}
diff -Naur ./Embedded/EmbeddedDbTest.cpp ../omniscidb-master/Embedded/EmbeddedDbTest.cpp
--- ./Embedded/EmbeddedDbTest.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Embedded/EmbeddedDbTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2020 OmniSci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <boost/filesystem.hpp>
+#include <boost/program_options.hpp>
+#include <exception>
+#include <iostream>
+#include "DBEngine.h"
+
+#include <arrow/api.h>
+#include <arrow/csv/reader.h>
+#include <arrow/io/file.h>
+#include "Shared/ArrowUtil.h"
+
+using namespace EmbeddedDatabase;
+
+int main(int argc, char* argv[]) {
+  std::string base_path;
+  int calcite_port = 5555;
+  bool columnar_output = true;
+  namespace po = boost::program_options;
+
+  po::options_description desc("Options");
+  desc.add_options()("help,h", "Print help messages ")(
+      "data",
+      po::value<std::string>(&base_path)->required(),
+      "Directory path to OmniSci catalogs")(
+      "calcite-port",
+      po::value<int>(&calcite_port)->default_value(calcite_port),
+      "Calcite port")("columnar-output",
+                      po::value<bool>(&columnar_output)->default_value(columnar_output),
+                      "Enable columnar_output");
+
+  po::positional_options_description positionalOptions;
+  positionalOptions.add("data", 1);
+
+  po::variables_map vm;
+
+  try {
+    po::store(po::command_line_parser(argc, argv)
+                  .options(desc)
+                  .positional(positionalOptions)
+                  .run(),
+              vm);
+    if (vm.count("help")) {
+      std::cout << desc;
+      return 0;
+    }
+    po::notify(vm);
+  } catch (boost::program_options::error& e) {
+    std::cerr << "Usage Error: " << e.what() << std::endl;
+    return 1;
+  }
+
+  try {
+    auto opt_str = base_path + " --calcite-port " + std::to_string(calcite_port);
+    if (columnar_output) {
+      opt_str += "--columnar-output";
+    }
+    auto dbe = DBEngine::create(opt_str);
+    if (dbe) {
+      auto memory_pool = arrow::default_memory_pool();
+      auto arrow_parse_options = arrow::csv::ParseOptions::Defaults();
+      auto arrow_read_options = arrow::csv::ReadOptions::Defaults();
+      auto arrow_convert_options = arrow::csv::ConvertOptions::Defaults();
+      std::shared_ptr<arrow::io::ReadableFile> inp;
+      auto file_result = arrow::io::ReadableFile::Open("/localdisk/artemale/test.csv");
+      ARROW_THROW_NOT_OK(file_result.status());
+      inp = file_result.ValueOrDie();
+      auto table_reader_result = arrow::csv::TableReader::Make(memory_pool,
+                                                               inp,
+                                                               arrow_read_options,
+                                                               arrow_parse_options,
+                                                               arrow_convert_options);
+      ARROW_THROW_NOT_OK(table_reader_result.status());
+      auto table_reader = table_reader_result.ValueOrDie();
+      std::shared_ptr<arrow::Table> arrowTable;
+      auto arrow_table_result = table_reader->Read();
+      ARROW_THROW_NOT_OK(arrow_table_result.status());
+      arrowTable = arrow_table_result.ValueOrDie();
+      dbe->importArrowTable("test", arrowTable);
+
+      auto schema = dbe->getTableDetails("test");
+      for (auto& item : schema) {
+        std::cout << item.col_name << std::endl;
+      }
+      auto cursor = dbe->executeDML("select * from test");
+      if (cursor) {
+        std::cout << cursor->getRowCount() << " rows selected" << std::endl;
+        std::shared_ptr<arrow::RecordBatch> rbatch = cursor->getArrowRecordBatch();
+      } else {
+        std::cerr << "Cursor is NULL" << std::endl;
+      }
+    }
+  } catch (std::exception& e) {
+    std::cerr << "Exception: " << e.what() << "\n";
+  }
+  return 0;
+}
diff -Naur ./Embedded/Python/DBEngine.pxd ../omniscidb-master/Embedded/Python/DBEngine.pxd
--- ./Embedded/Python/DBEngine.pxd	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Embedded/Python/DBEngine.pxd	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,95 @@
+from __future__ import absolute_import
+
+from libc.stdint cimport int64_t, uint64_t, uint32_t, uint8_t
+from libcpp.map cimport map
+from libcpp.memory cimport shared_ptr, unique_ptr
+from libcpp.string cimport string
+from libcpp cimport bool, nullptr_t, nullptr
+from libcpp.pair cimport pair
+from libcpp.vector cimport vector
+from cython.operator cimport dereference as deref
+from pyarrow.lib cimport CTable
+
+cdef extern from "arrow/api.h" namespace "arrow" nogil:
+    cdef cppclass CRecordBatch" arrow::RecordBatch":
+        int num_columns()
+        int64_t num_rows()
+
+cdef extern from "DBETypes.h" namespace 'EmbeddedDatabase':
+    cdef cppclass ColumnType:
+        pass
+
+    cdef cppclass ColumnEncoding:
+        pass
+
+    cdef cppclass ColumnDetails:
+        string col_name
+        ColumnType col_type
+        ColumnEncoding encoding
+        bool nullable
+        bool is_array
+        int precision
+        int scale
+        int comp_param
+        ColumnDetails()
+        ColumnDetails(string,ColumnType,ColumnEncoding,bool,bool,int,int,int)
+
+    cdef cppclass Row:
+        int64_t getInt(size_t col) except +
+        float getFloat(size_t col) except +
+        double getDouble(size_t col) except +
+        string getStr(size_t col) except +
+
+cdef extern from "DBEngine.h" namespace 'EmbeddedDatabase':
+    cdef cppclass Cursor:
+        size_t getColCount()
+        size_t getRowCount()
+        Row getNextRow()
+        ColumnType getColType(uint32_t nPos)
+        shared_ptr[CRecordBatch] getArrowRecordBatch() nogil except +
+
+    cdef cppclass DBEngine:
+        void executeDDL(string) except +
+        shared_ptr[Cursor] executeDML(string) except +
+        shared_ptr[Cursor] executeRA(string) except +
+        vector[string] getTables() except +
+        vector[ColumnDetails] getTableDetails(string) except +
+        void importArrowTable(string, shared_ptr[CTable]&, uint64_t) except +
+        bool setDatabase(string db_name) except +
+        bool login(string db_name, string user_name, string password) except +
+        @staticmethod
+        shared_ptr[DBEngine] create(string cmd_str) except+
+
+cdef extern from "DBETypes.h" namespace 'EmbeddedDatabase::ColumnType':
+    cdef ColumnType SMALLINT
+    cdef ColumnType INT
+    cdef ColumnType BIGINT
+    cdef ColumnType FLOAT
+    cdef ColumnType DECIMAL
+    cdef ColumnType DOUBLE
+    cdef ColumnType STR
+    cdef ColumnType TIME
+    cdef ColumnType TIMESTAMP
+    cdef ColumnType DATE
+    cdef ColumnType BOOL
+    cdef ColumnType INTERVAL_DAY_TIME
+    cdef ColumnType INTERVAL_YEAR_MONTH
+    cdef ColumnType POINT
+    cdef ColumnType LINESTRING
+    cdef ColumnType POLYGON
+    cdef ColumnType MULTIPOLYGON
+    cdef ColumnType TINYINT
+    cdef ColumnType GEOMETRY
+    cdef ColumnType GEOGRAPHY
+    cdef ColumnType UNKNOWN
+
+
+cdef extern from "DBETypes.h" namespace 'EmbeddedDatabase::ColumnEncoding':
+    cdef ColumnEncoding NONE
+    cdef ColumnEncoding FIXED
+    cdef ColumnEncoding RL
+    cdef ColumnEncoding DIFF
+    cdef ColumnEncoding DICT
+    cdef ColumnEncoding SPARSE
+    cdef ColumnEncoding GEOINT
+    cdef ColumnEncoding DATE_IN_DAYS
diff -Naur ./Embedded/Python/dbe.pyx ../omniscidb-master/Embedded/Python/dbe.pyx
--- ./Embedded/Python/dbe.pyx	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Embedded/Python/dbe.pyx	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,232 @@
+#cython: language_level=3
+
+from cython.operator cimport dereference as deref
+from libcpp.memory cimport unique_ptr
+from libcpp.string cimport string
+from libc.stdint cimport int64_t, uint64_t, uint32_t
+from libcpp.map cimport map
+from libcpp.memory cimport shared_ptr
+from libcpp cimport bool
+from libcpp.pair cimport pair
+from libcpp.vector cimport vector
+from datetime import datetime
+from collections import namedtuple
+
+import os
+import sys
+
+from DBEngine cimport *
+from DBEngine cimport ColumnType as _ColumnType
+from DBEngine cimport ColumnEncoding as _ColumnEncoding
+from DBEngine cimport ColumnDetails as _ColumnDetails
+from DBEngine cimport Row as _Row
+from DBEngine cimport Cursor as _Cursor
+from DBEngine cimport DBEngine
+from pyarrow.lib cimport *
+
+cdef class PyColumnType:
+  cdef _ColumnType c_column_type
+
+  def __cinit__(self, int val):
+    self.c_column_type = <_ColumnType> val
+
+  def __eq__(self, val):
+    if isinstance(val, int):
+        return val == <int> self.c_column_type
+    return False
+
+  def to_str(self):
+    cdef c = {
+        <int>SMALLINT : "SMALLINT",
+        <int>INT : "INT",
+        <int>BIGINT : "BIGINT",
+        <int>FLOAT : "FLOAT",
+        <int>DECIMAL : "DECIMAL",
+        <int>DOUBLE : "DOUBLE",
+        <int>STR : "STR",
+        <int>TIME : "TIME",
+        <int>TIMESTAMP : "TIMESTAMP",
+        <int>DATE : "DATE",
+        <int>BOOL : "BOOL",
+        <int>INTERVAL_DAY_TIME : "INTERVAL_DAY_TIME",
+        <int>INTERVAL_YEAR_MONTH : "INTERVAL_YEAR_MONTH",
+        <int>POINT : "POINT",
+        <int>LINESTRING : "LINESTRING",
+        <int>POLYGON : "POLYGON",
+        <int>MULTIPOLYGON : "MULTIPOLYGON",
+        <int>TINYINT : "TINYINT",
+        <int>GEOMETRY : "GEOMETRY",
+        <int>GEOGRAPHY : "TIME",
+        <int>UNKNOWN : "UNKNOWN"}
+    return c[<int>self.c_column_type]
+
+cdef class PyColumnEncoding:
+  cdef _ColumnEncoding c_column_enc
+
+  def __cinit__(self, int val):
+    self.c_column_enc = <_ColumnEncoding> val
+
+  def __eq__(self, val):
+    if isinstance(val, int):
+        return val == <int> self.c_column_enc
+    return False
+
+  def to_str(self):
+    cdef c = {
+        <int>NONE : "NONE",
+        <int>FIXED : "FIXED",
+        <int>RL : "RL",
+        <int>DIFF : "DIFF",
+        <int>DICT : "DICT",
+        <int>SPARSE : "SPARSE",
+        <int>GEOINT : "GEOINT",
+        <int>DATE_IN_DAYS : "DATE_IN_DAYS"}
+    return c[<int>self.c_column_enc]
+
+
+cdef class PyColumnDetails:
+    cdef _ColumnDetails c_col
+    def __cinit__(self, string col_name, int col_type, int col_enc, bool nullable, bool is_array, int precision, int scale, int comp_param):
+        self.c_col = _ColumnDetails(col_name, <_ColumnType>col_type, <_ColumnEncoding>col_enc, nullable, is_array, precision, scale, comp_param)
+
+
+cdef class PyRow:
+    cdef _Row c_row  #Hold a C++ instance which we're wrapping
+
+    def getField(self, col_num, col_type):
+        if col_type == <int>INT:
+            return self.c_row.getInt(col_num);
+        if col_type == <int>FLOAT:
+            return self.c_row.getFloat(col_num);
+        if col_type == <int>DOUBLE:
+            return self.c_row.getDouble(col_num);
+        if col_type == <int>STR:
+            return self.c_row.getStr(col_num);
+        return "Unknown type"
+
+
+cdef class PyCursor:
+    cdef shared_ptr[_Cursor] c_cursor  #Hold a C++ instance which we're wrapping
+    cdef shared_ptr[CRecordBatch] c_batch
+
+    def colCount(self):
+        return self.c_cursor.get().getColCount()
+
+    def rowCount(self):
+        return self.c_cursor.get().getRowCount()
+
+    def nextRow(self):
+        obj = PyRow()
+        obj.c_row = self.c_cursor.get().getNextRow()
+        return obj
+
+    def getColType(self, uint32_t pos):
+        obj = PyColumnType(<int>self.c_cursor.get().getColType(pos))
+        return obj
+
+    def showRows(self, int max_rows=0):
+        col_count = self.colCount();
+        row_count = self.rowCount();
+        if max_rows > 0 and row_count > max_rows:
+            row_count = max_rows
+        col_types = [];
+        col_types_str = [];
+        for i in range(col_count):
+            ct = self.getColType(i)
+            col_types.append(ct)
+            col_types_str.append(ct.to_str())
+        format_row = "{:>12}" * (len(col_types) + 1)
+        print(*col_types_str)
+        for j in range(row_count):
+            r = self.nextRow()
+            fields = []
+            for f in range(col_count):
+                fields.append(r.getField(f, col_types[f]))
+            print(*fields, flush=True)
+
+    def getArrowRecordBatch(self):
+        with nogil:
+            self.c_batch = self.c_cursor.get().getArrowRecordBatch()
+        if self.c_batch.get() is NULL:
+            print('Record batch is NULL')
+            return None
+        else:
+            prb = pyarrow_wrap_batch(self.c_batch)
+            return prb
+
+ColumnDetailsTp = namedtuple("ColumnDetails", ["name", "type", "nullable",
+                                             "precision", "scale",
+                                             "comp_param", "encoding",
+                                             "is_array"])
+cdef class PyDbEngine:
+    cdef shared_ptr[DBEngine] c_dbe  #Hold a C++ instance which we're wrapping
+    cdef map[string, string] c_parameters
+
+    def __cinit__(self, **kwargs):
+        cmd_str = "".join(' --%s %r' % x for x in kwargs.iteritems())
+        cmd_str = cmd_str.replace("_", "-")
+        self.c_dbe = DBEngine.create(bytes(cmd_str, 'utf-8'))
+        if self.closed:
+            raise RuntimeError('Initialization failed')
+
+    @property
+    def closed(self):
+        return self.c_dbe == NULL
+
+    def close(self):
+        pass
+
+    def check_closed(self):
+        if self.closed:
+            raise RuntimeError('DB engine uninitialized')
+
+    def executeDDL(self, query):
+        self.check_closed()
+        self.c_dbe.get().executeDDL(bytes(query, 'utf-8'))
+
+    def executeDML(self, query):
+        self.check_closed()
+        obj = PyCursor();
+        obj.c_cursor = self.c_dbe.get().executeDML(bytes(query, 'utf-8'));
+        return obj;
+
+    def executeRA(self, query):
+        self.check_closed()
+        obj = PyCursor();
+        obj.c_cursor = self.c_dbe.get().executeRA(bytes(query, 'utf-8'));
+        return obj
+
+    def importArrowTable(self, name, table, **kwargs):
+        self.check_closed()
+        cdef shared_ptr[CTable] t = pyarrow_unwrap_table(table)
+        cdef string n = bytes(name, 'utf-8')
+        cdef uint64_t fragment_size = kwargs.get("fragment_size", 0)
+        if n.empty() or not t.get():
+            raise RuntimeError('Table initialization failed')
+        self.check_closed()
+        self.c_dbe.get().importArrowTable(n, t, fragment_size)
+
+    # TODO: remove this legacy alias.
+    def consumeArrowTable(self, name, table, **kwargs):
+        return self.importArrowTable(name, table, **kwargs)
+
+    def select_df(self, query):
+        obj = self.executeDML(query)
+        if not obj:
+            raise RuntimeError("Cursor uninitialized")
+        prb = obj.getArrowRecordBatch()
+        return prb.to_pandas()
+
+    def get_table_details(self, table_name):
+        self.check_closed()
+        cdef vector[ColumnDetails] table_details = self.c_dbe.get().getTableDetails(bytes(table_name, 'utf-8'))
+        return [
+            ColumnDetailsTp(x.col_name, PyColumnType(<int>x.col_type).to_str(),
+                            x.nullable, x.precision, x.scale, x.comp_param,
+                            PyColumnEncoding(<int>x.encoding).to_str(), x.is_array)
+            for x in table_details
+        ]
+
+    def get_tables(self):
+        self.check_closed()
+        return self.c_dbe.get().getTables()
diff -Naur ./Fragmenter/CMakeLists.txt ../omniscidb-master/Fragmenter/CMakeLists.txt
--- ./Fragmenter/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Fragmenter/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -1,3 +1,3 @@
 add_library(Fragmenter InsertOrderFragmenter.cpp SortedOrderFragmenter.cpp UpdelStorage.cpp TargetValueConvertersFactories.cpp InsertDataLoader.cpp)
 
-target_link_libraries(Fragmenter ${Boost_THREAD_LIBRARY})
+target_link_libraries(Fragmenter ImportExport ${Boost_THREAD_LIBRARY})
diff -Naur ./Fragmenter/FragmentDefaultValues.h ../omniscidb-master/Fragmenter/FragmentDefaultValues.h
--- ./Fragmenter/FragmentDefaultValues.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Fragmenter/FragmentDefaultValues.h	2021-04-21 00:02:57.000000000 +0300
@@ -20,4 +20,3 @@
 #define DEFAULT_PAGE_SIZE 2097152ULL          // in bytes
 #define DEFAULT_MAX_ROWS ((1LL) << 62)        // in rows
 #define DEFAULT_MAX_CHUNK_SIZE 2147483648ULL  // in bytes 2G
-
diff -Naur ./Fragmenter/UpdelStorage.cpp ../omniscidb-master/Fragmenter/UpdelStorage.cpp
--- ./Fragmenter/UpdelStorage.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Fragmenter/UpdelStorage.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -944,12 +944,15 @@
   auto td = updel_roll.catalog->getMetadataForTable(cd->tableId);
   auto key = std::make_pair(td, &fragment);
   std::lock_guard<std::mutex> lck(updel_roll.mutex);
+  mapd_unique_lock<mapd_shared_mutex> write_lock(fragmentInfoMutex_);
   if (0 == updel_roll.chunkMetadata.count(key)) {
     updel_roll.chunkMetadata[key] = fragment.getChunkMetadataMapPhysical();
   }
   if (0 == updel_roll.numTuples.count(key)) {
     updel_roll.numTuples[key] = fragment.shadowNumTuples;
   }
+  // at this point we are just looking at a reference to the real active metadata it is
+  // unsafe to do operations on this we need this to be a copy?
   auto& chunkMetadata = updel_roll.chunkMetadata[key];
 
   auto buffer = chunk->getBuffer();
diff -Naur ./ImportExport/ArrowImporter.h ../omniscidb-master/ImportExport/ArrowImporter.h
--- ./ImportExport/ArrowImporter.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ImportExport/ArrowImporter.h	2021-04-21 00:02:57.000000000 +0300
@@ -201,9 +201,9 @@
       : DataBufferBase(cd, array, bad_rows_tracker), buffer(buffer) {}
 };
 
-constexpr int64_t kMillisecondsInSecond = 1000L;
-constexpr int64_t kMicrosecondsInSecond = 1000L * 1000L;
-constexpr int64_t kNanosecondsinSecond = 1000L * 1000L * 1000L;
+constexpr int64_t kMillisecondsInSecond = 1000LL;
+constexpr int64_t kMicrosecondsInSecond = 1000LL * 1000LL;
+constexpr int64_t kNanosecondsinSecond = 1000LL * 1000LL * 1000LL;
 constexpr int32_t kSecondsInDay = 86400;
 
 static const std::map<std::pair<int32_t, arrow::TimeUnit::type>,
@@ -275,15 +275,17 @@
   using VALUE_TYPE = void*;
   ArrowValue(const DataBufferBase& data, const VALUE_TYPE& v)
       : ArrowValueBase<VALUE_TYPE>(data, v) {}
-  template <typename DATA_TYPE, typename = enable_if_integral<DATA_TYPE>>
-  explicit operator const DATA_TYPE() const {
-    return inline_fixed_encoding_null_val(data.cd->columnType);
-  }
-  template <typename DATA_TYPE, typename = enable_if_floating<DATA_TYPE>>
+
+  template <typename DATA_TYPE>
   explicit operator DATA_TYPE() const {
-    return inline_fp_null_val(data.cd->columnType);
+    if constexpr (std::is_integral<DATA_TYPE>::value) {
+      return inline_fixed_encoding_null_val(data.cd->columnType);
+    } else if constexpr (std::is_floating_point<DATA_TYPE>::value) {
+      return inline_fp_null_val(data.cd->columnType);
+    } else if constexpr (std::is_same<DATA_TYPE, std::string>::value) {
+      return std::string();
+    }
   }
-  explicit operator const std::string() const { return std::string(); }
 };
 
 template <>
@@ -291,18 +293,20 @@
   using VALUE_TYPE = bool;
   ArrowValue(const DataBufferBase& data, const VALUE_TYPE& v)
       : ArrowValueBase<VALUE_TYPE>(data, v) {}
-  template <typename DATA_TYPE, typename = enable_if_integral<DATA_TYPE>>
-  explicit operator const DATA_TYPE() const {
-    if (!(data.cd->columnType.is_number() || data.cd->columnType.is_boolean())) {
-      type_conversion_error("bool", data.cd, data.bad_rows_tracker);
-    }
-    return v;
-  }
-  template <typename DATA_TYPE, typename = enable_if_floating<DATA_TYPE>>
+
+  template <typename DATA_TYPE>
   explicit operator DATA_TYPE() const {
-    return v ? 1 : 0;
+    if constexpr (std::is_integral<DATA_TYPE>::value) {
+      if (!(data.cd->columnType.is_number() || data.cd->columnType.is_boolean())) {
+        type_conversion_error("bool", data.cd, data.bad_rows_tracker);
+      }
+      return v;
+    } else if constexpr (std::is_floating_point<DATA_TYPE>::value) {
+      return v ? 1 : 0;
+    } else if constexpr (std::is_same<DATA_TYPE, std::string>::value) {
+      return v ? "T" : "F";
+    }
   }
-  explicit operator const std::string() const { return v ? "T" : "F"; }
 };
 
 template <>
@@ -310,21 +314,23 @@
   using VALUE_TYPE = float;
   ArrowValue(const DataBufferBase& data, const VALUE_TYPE& v)
       : ArrowValueBase<VALUE_TYPE>(data, v) {}
-  template <typename DATA_TYPE, typename = enable_if_integral<DATA_TYPE>>
-  explicit operator const DATA_TYPE() const {
-    const auto ti = data.cd->columnType;
-    DATA_TYPE v = ti.is_decimal() ? this->v * pow(10, ti.get_scale()) : this->v;
-    if (!(std::numeric_limits<DATA_TYPE>::lowest() < v &&
-          v <= std::numeric_limits<DATA_TYPE>::max())) {
-      data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
-    }
-    return v;
-  }
-  template <typename DATA_TYPE, typename = enable_if_floating<DATA_TYPE>>
+
+  template <typename DATA_TYPE>
   explicit operator DATA_TYPE() const {
-    return v;
+    if constexpr (std::is_integral<DATA_TYPE>::value) {
+      const auto ti = data.cd->columnType;
+      DATA_TYPE v = ti.is_decimal() ? this->v * pow(10, ti.get_scale()) : this->v;
+      if (!(std::numeric_limits<DATA_TYPE>::lowest() < v &&
+            v <= std::numeric_limits<DATA_TYPE>::max())) {
+        data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
+      }
+      return v;
+    } else if constexpr (std::is_floating_point<DATA_TYPE>::value) {
+      return v;
+    } else if constexpr (std::is_same<DATA_TYPE, std::string>::value) {
+      return std::to_string(v);
+    }
   }
-  explicit operator const std::string() const { return std::to_string(v); }
 };
 
 template <>
@@ -332,27 +338,29 @@
   using VALUE_TYPE = double;
   ArrowValue(const DataBufferBase& data, const VALUE_TYPE& v)
       : ArrowValueBase<VALUE_TYPE>(data, v) {}
-  template <typename DATA_TYPE, typename = enable_if_integral<DATA_TYPE>>
-  explicit operator const DATA_TYPE() const {
-    const auto ti = data.cd->columnType;
-    DATA_TYPE v = ti.is_decimal() ? this->v * pow(10, ti.get_scale()) : this->v;
-    if (!(std::numeric_limits<DATA_TYPE>::lowest() < v &&
-          v <= std::numeric_limits<DATA_TYPE>::max())) {
-      data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
-    }
-    return v;
-  }
-  template <typename DATA_TYPE, typename = enable_if_floating<DATA_TYPE>>
+
+  template <typename DATA_TYPE>
   explicit operator DATA_TYPE() const {
-    if (std::is_same<DATA_TYPE, float>::value) {
-      if (!(std::numeric_limits<float>::lowest() < v &&
-            v <= std::numeric_limits<float>::max())) {
-        data_conversion_error<float>(v, data.cd, data.bad_rows_tracker);
+    if constexpr (std::is_integral<DATA_TYPE>::value) {
+      const auto ti = data.cd->columnType;
+      DATA_TYPE v = ti.is_decimal() ? this->v * pow(10, ti.get_scale()) : this->v;
+      if (!(std::numeric_limits<DATA_TYPE>::lowest() < v &&
+            v <= std::numeric_limits<DATA_TYPE>::max())) {
+        data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
       }
+      return v;
+    } else if constexpr (std::is_floating_point<DATA_TYPE>::value) {
+      if (std::is_same<DATA_TYPE, float>::value) {
+        if (!(std::numeric_limits<float>::lowest() < v &&
+              v <= std::numeric_limits<float>::max())) {
+          data_conversion_error<float>(v, data.cd, data.bad_rows_tracker);
+        }
+      }
+      return v;
+    } else if constexpr (std::is_same<DATA_TYPE, std::string>::value) {
+      return std::to_string(v);
     }
-    return v;
   }
-  explicit operator const std::string() const { return std::to_string(v); }
 };
 
 template <>
@@ -360,51 +368,52 @@
   using VALUE_TYPE = int64_t;
   ArrowValue(const DataBufferBase& data, const VALUE_TYPE& v)
       : ArrowValueBase<VALUE_TYPE>(data, v) {}
-  template <typename DATA_TYPE, typename = enable_if_integral<DATA_TYPE>>
-  explicit operator const DATA_TYPE() const {
-    int64_t v = this->v;
-    if (std::is_same<int64_t, DATA_TYPE>::value) {
-    } else if (std::numeric_limits<DATA_TYPE>::lowest() < v &&
-               v <= std::numeric_limits<DATA_TYPE>::max()) {
-    } else {
-      data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
-    }
-    if (data.cd->columnType.is_time()) {
-      v = this->resolve_time(v);
-    }
-    return v;
-  }
-  template <typename DATA_TYPE, typename = enable_if_floating<DATA_TYPE>>
+
+  template <typename DATA_TYPE>
   explicit operator DATA_TYPE() const {
-    return v;
-  }
-  explicit operator const std::string() const {
-    const auto& type_id = data.arrow_type.id();
-    if (type_id == arrow::Type::DATE32 || type_id == arrow::Type::DATE64) {
-      auto& date_type = static_cast<const arrow::DateType&>(data.arrow_type);
-      SQLTypeInfo ti(kDATE);
-      Datum datum{.bigintval = date_type.unit() == arrow::DateUnit::MILLI
-                                   ? v / kMicrosecondsInSecond
-                                   : v};
-      return DatumToString(datum, ti);
-    } else if (type_id == arrow::Type::TIME32 || type_id == arrow::Type::TIME64 ||
-               type_id == arrow::Type::TIMESTAMP) {
-      auto& time_type = static_cast<const arrow::TimeType&>(data.arrow_type);
-      const auto result =
-          _precision_scale_lookup.find(std::make_pair(0, time_type.unit()));
-      int64_t divisor{1};
-      if (result != _precision_scale_lookup.end()) {
-        divisor = result->second.second;
+    if constexpr (std::is_integral<DATA_TYPE>::value) {
+      int64_t v = this->v;
+      if (std::is_same<int64_t, DATA_TYPE>::value) {
+      } else if (std::numeric_limits<DATA_TYPE>::lowest() < v &&
+                 v <= std::numeric_limits<DATA_TYPE>::max()) {
+      } else {
+        data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
+      }
+      if (data.cd->columnType.is_time()) {
+        v = this->resolve_time(v);
       }
-      SQLTypeInfo ti(kTIMESTAMP);
-      Datum datum{.bigintval = v / divisor};
-      auto time_str = DatumToString(datum, ti);
-      if (divisor != 1 && v % divisor) {
-        time_str += "." + std::to_string(v % divisor);
+      return v;
+    } else if constexpr (std::is_floating_point<DATA_TYPE>::value) {
+      return v;
+    } else if constexpr (std::is_same<DATA_TYPE, std::string>::value) {
+      const auto& type_id = data.arrow_type.id();
+      if (type_id == arrow::Type::DATE32 || type_id == arrow::Type::DATE64) {
+        auto& date_type = static_cast<const arrow::DateType&>(data.arrow_type);
+        SQLTypeInfo ti(kDATE);
+        Datum datum;
+        datum.bigintval =
+            date_type.unit() == arrow::DateUnit::MILLI ? v / kMicrosecondsInSecond : v;
+        return DatumToString(datum, ti);
+      } else if (type_id == arrow::Type::TIME32 || type_id == arrow::Type::TIME64 ||
+                 type_id == arrow::Type::TIMESTAMP) {
+        auto& time_type = static_cast<const arrow::TimeType&>(data.arrow_type);
+        const auto result =
+            _precision_scale_lookup.find(std::make_pair(0, time_type.unit()));
+        int64_t divisor{1};
+        if (result != _precision_scale_lookup.end()) {
+          divisor = result->second.second;
+        }
+        SQLTypeInfo ti(kTIMESTAMP);
+        Datum datum;
+        datum.bigintval = v / divisor;
+        auto time_str = DatumToString(datum, ti);
+        if (divisor != 1 && v % divisor) {
+          time_str += "." + std::to_string(v % divisor);
+        }
+        return time_str;
       }
-      return time_str;
+      return std::to_string(v);
     }
-    return std::to_string(v);
   }
 };
 
@@ -413,38 +422,39 @@
   using VALUE_TYPE = std::string;
   ArrowValue(const DataBufferBase& data, const VALUE_TYPE& v)
       : ArrowValueBase<VALUE_TYPE>(data, v) {}
-  explicit operator const bool() const {
-    if (v.size() == 0) {
-      return inline_int_null_value<int8_t>();
-    }
-    try {
-      SQLTypeInfo ti(kBOOLEAN);
-      auto datum = StringToDatum(v, ti);
-      return datum.boolval;
-    } catch (...) {
-      data_conversion_error(v, data.cd, data.bad_rows_tracker);
-      return false;
-    }
-  }
-  template <typename DATA_TYPE, typename = enable_if_integral_not_bool<DATA_TYPE>>
-  explicit operator const DATA_TYPE() const {
-    if (v.size() == 0) {
-      return inline_fixed_encoding_null_val(data.cd->columnType);
-    }
-    try {
-      auto ti = data.cd->columnType;
-      auto datum = StringToDatum(v, ti);
-      return datum.bigintval;
-    } catch (...) {
-      data_conversion_error(v, data.cd, data.bad_rows_tracker);
-      return 0;
-    }
-  }
-  template <typename DATA_TYPE, typename = enable_if_floating<DATA_TYPE>>
+
+  template <typename DATA_TYPE>
   explicit operator DATA_TYPE() const {
-    return atof(v.data());
+    if constexpr (std::is_same<DATA_TYPE, bool>::value) {
+      if (v.size() == 0) {
+        return inline_int_null_value<int8_t>();
+      }
+      try {
+        SQLTypeInfo ti(kBOOLEAN);
+        auto datum = StringToDatum(v, ti);
+        return datum.boolval;
+      } catch (...) {
+        data_conversion_error(v, data.cd, data.bad_rows_tracker);
+        return false;
+      }
+    } else if constexpr (std::is_integral<DATA_TYPE>::value) {
+      if (v.size() == 0) {
+        return inline_fixed_encoding_null_val(data.cd->columnType);
+      }
+      try {
+        auto ti = data.cd->columnType;
+        auto datum = StringToDatum(v, ti);
+        return datum.bigintval;
+      } catch (...) {
+        data_conversion_error(v, data.cd, data.bad_rows_tracker);
+        return 0;
+      }
+    } else if constexpr (std::is_floating_point<DATA_TYPE>::value) {
+      return atof(v.data());
+    } else if constexpr (std::is_same<DATA_TYPE, std::string>::value) {
+      return v;
+    }
   }
-  explicit operator const std::string() const { return v; }
 };
 
 template <>
@@ -457,30 +467,30 @@
                    error_context(data.cd, data.bad_rows_tracker) +
                        "Truncation error on Arrow Decimal128 value");
   }
-  template <typename DATA_TYPE, typename = enable_if_integral<DATA_TYPE>>
-  explicit operator const DATA_TYPE() const {
-    int64_t v = static_cast<int64_t>(this->v);
-    if (data.cd->columnType.is_decimal()) {
-      return convert_decimal_value_to_scale(v, data.old_type, data.new_type);
-    }
-    if (data.arrow_decimal_scale) {
-      v = std::llround(v / pow(10, data.arrow_decimal_scale));
-    }
-    if (std::is_same<int64_t, DATA_TYPE>::value) {
-    } else if (std::numeric_limits<DATA_TYPE>::lowest() < v &&
-               v <= std::numeric_limits<DATA_TYPE>::max()) {
-    } else {
-      data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
-    }
-    return v;
-  }
-  template <typename DATA_TYPE, typename = enable_if_floating<DATA_TYPE>>
+
+  template <typename DATA_TYPE>
   explicit operator DATA_TYPE() const {
-    int64_t v = static_cast<int64_t>(this->v);
-    return data.arrow_decimal_scale ? v / pow(10, data.arrow_decimal_scale) : v;
-  }
-  explicit operator const std::string() const {
-    return v.ToString(data.arrow_decimal_scale);
+    if constexpr (std::is_integral<DATA_TYPE>::value) {
+      int64_t v = static_cast<int64_t>(this->v);
+      if (data.cd->columnType.is_decimal()) {
+        return convert_decimal_value_to_scale(v, data.old_type, data.new_type);
+      }
+      if (data.arrow_decimal_scale) {
+        v = std::llround(v / pow(10, data.arrow_decimal_scale));
+      }
+      if (std::is_same<int64_t, DATA_TYPE>::value) {
+      } else if (std::numeric_limits<DATA_TYPE>::lowest() < v &&
+                 v <= std::numeric_limits<DATA_TYPE>::max()) {
+      } else {
+        data_conversion_error<DATA_TYPE>(v, data.cd, data.bad_rows_tracker);
+      }
+      return v;
+    } else if constexpr (std::is_floating_point<DATA_TYPE>::value) {
+      int64_t v = static_cast<int64_t>(this->v);
+      return data.arrow_decimal_scale ? v / pow(10, data.arrow_decimal_scale) : v;
+    } else if constexpr (std::is_same<DATA_TYPE, std::string>::value) {
+      return v.ToString(data.arrow_decimal_scale);
+    }
   }
 };
 
diff -Naur ./ImportExport/Importer.cpp ../omniscidb-master/ImportExport/Importer.cpp
--- ./ImportExport/Importer.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ImportExport/Importer.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -76,6 +76,11 @@
 
 #include "gen-cpp/OmniSci.h"
 
+#ifdef _WIN32
+#include <fcntl.h>
+#include <io.h>
+#endif
+
 size_t g_max_import_threads =
     32;  // Max number of default import threads to use (num hardware threads will be used
          // if lower, and can also be explicitly overriden in copy statement with threads
@@ -3843,17 +3848,24 @@
 void DataStreamSink::import_compressed(
     std::vector<std::string>& file_paths,
     const Catalog_Namespace::SessionInfo* session_info) {
-#ifdef _MSC_VER
-  throw std::runtime_error("CSV Import not yet supported on Windows.");
-#else
   // a new requirement is to have one single input stream into
   // Importer::importDelimited, so need to move pipe related
   // stuff to the outmost block.
   int fd[2];
-  if (pipe(fd) < 0) {
+#ifdef _WIN32
+  // For some reason when folly is used to create the pipe, reader can
+  // read nothing.
+  auto pipe_res =
+      _pipe(fd, static_cast<unsigned int>(copy_params.buffer_size), _O_BINARY);
+#else
+  auto pipe_res = pipe(fd);
+#endif
+  if (pipe_res < 0) {
     throw std::runtime_error(std::string("failed to create a pipe: ") + strerror(errno));
   }
+#ifndef _WIN32
   signal(SIGPIPE, SIG_IGN);
+#endif
 
   std::exception_ptr teptr;
   // create a thread to read uncompressed byte stream out of pipe and
@@ -3934,7 +3946,7 @@
           throw std::runtime_error("AWS S3 support not available");
 #endif  // HAVE_AWS_S3
         }
-#if 0   // TODO(ppan): implement and enable any other archive class
+#if 0  // TODO(ppan): implement and enable any other archive class
         else
         if ("hdfs" == url_parts[2])
           uarch.reset(new HdfsArchive(file_path));
@@ -4093,7 +4105,6 @@
   if (teptr) {
     std::rethrow_exception(teptr);
   }
-#endif
 }
 
 ImportStatus Importer::import(const Catalog_Namespace::SessionInfo* session_info) {
diff -Naur ./ImportExport/Importer.h ../omniscidb-master/ImportExport/Importer.h
--- ./ImportExport/Importer.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ImportExport/Importer.h	2021-04-21 00:02:57.000000000 +0300
@@ -286,25 +286,25 @@
   int8_t* getAsBytes() const {
     switch (column_desc_->columnType.get_type()) {
       case kBOOLEAN:
-        return reinterpret_cast<int8_t*>(&((*bool_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(bool_buffer_->data());
       case kTINYINT:
-        return reinterpret_cast<int8_t*>(&((*tinyint_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(tinyint_buffer_->data());
       case kSMALLINT:
-        return reinterpret_cast<int8_t*>(&((*smallint_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(smallint_buffer_->data());
       case kINT:
-        return reinterpret_cast<int8_t*>(&((*int_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(int_buffer_->data());
       case kBIGINT:
       case kNUMERIC:
       case kDECIMAL:
-        return reinterpret_cast<int8_t*>(&((*bigint_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(bigint_buffer_->data());
       case kFLOAT:
-        return reinterpret_cast<int8_t*>(&((*float_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(float_buffer_->data());
       case kDOUBLE:
-        return reinterpret_cast<int8_t*>(&((*double_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(double_buffer_->data());
       case kDATE:
       case kTIME:
       case kTIMESTAMP:
-        return reinterpret_cast<int8_t*>(&((*bigint_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(bigint_buffer_->data());
       default:
         abort();
     }
@@ -354,11 +354,11 @@
   int8_t* getStringDictBuffer() const {
     switch (column_desc_->columnType.get_size()) {
       case 1:
-        return reinterpret_cast<int8_t*>(&((*string_dict_i8_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(string_dict_i8_buffer_->data());
       case 2:
-        return reinterpret_cast<int8_t*>(&((*string_dict_i16_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(string_dict_i16_buffer_->data());
       case 4:
-        return reinterpret_cast<int8_t*>(&((*string_dict_i32_buffer_)[0]));
+        return reinterpret_cast<int8_t*>(string_dict_i32_buffer_->data());
       default:
         abort();
     }
diff -Naur ./ImportExport/KafkaImporter.cpp ../omniscidb-master/ImportExport/KafkaImporter.cpp
--- ./ImportExport/KafkaImporter.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ImportExport/KafkaImporter.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -110,12 +110,12 @@
         VLOG(1) << "Timestamp: " << tsname << " " << ts.timestamp << std::endl;
       }
 
-      char buffer[message->len() + 1];
-      sprintf(buffer,
+      std::vector<char> buffer(message->len() + 1);
+      sprintf(buffer.data(),
               "%.*s\n",
               static_cast<int>(message->len()),
               static_cast<const char*>(message->payload()));
-      VLOG(1) << "Full Message received is :'" << buffer << "'";
+      VLOG(1) << "Full Message received is :'" << buffer.data() << "'";
 
       char field[MAX_FIELD_LEN];
       size_t field_i = 0;
@@ -124,8 +124,9 @@
 
       auto row_desc = row_loader.get_row_descriptor();
 
-      const std::pair<std::unique_ptr<boost::regex>, std::unique_ptr<std::string>>*
-          xforms[row_desc.size()];
+      std::vector<
+          const std::pair<std::unique_ptr<boost::regex>, std::unique_ptr<std::string>>*>
+          xforms(row_desc.size());
       for (size_t i = 0; i < row_desc.size(); i++) {
         auto it = transformations.find(row_desc[i].col_name);
         if (it != transformations.end()) {
diff -Naur ./ImportExport/RowToColumnLoader.cpp ../omniscidb-master/ImportExport/RowToColumnLoader.cpp
--- ./ImportExport/RowToColumnLoader.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ImportExport/RowToColumnLoader.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -27,6 +27,9 @@
 #include "ImportExport/DelimitedParserUtils.h"
 #include "Logger/Logger.h"
 
+#include <chrono>
+#include <thread>
+
 using namespace ::apache::thrift;
 
 SQLTypes get_sql_types(const TColumnType& ct) {
@@ -293,7 +296,7 @@
     std::vector<TStringValue> row,
     const import_export::CopyParams& copy_params) {
   // create datum and push data to column structure from row data
-  uint curr_col = 0;
+  uint64_t curr_col = 0;
   for (TStringValue ts : row) {
     try {
       switch (column_type_info_[curr_col].get_type()) {
@@ -399,7 +402,7 @@
   std::cout << "  Waiting  " << copy_params.retry_wait
             << " secs to retry Inserts , will try " << (copy_params.retry_count - tries)
             << " times more " << std::endl;
-  sleep(copy_params.retry_wait);
+  std::this_thread::sleep_for(std::chrono::seconds(copy_params.retry_wait));
 
   closeConnection();
   createConnection(conn_details_);
diff -Naur ./ImportExport/StreamImporter.cpp ../omniscidb-master/ImportExport/StreamImporter.cpp
--- ./ImportExport/StreamImporter.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ImportExport/StreamImporter.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -68,8 +68,9 @@
 
   auto row_desc = row_loader.get_row_descriptor();
 
-  const std::pair<std::unique_ptr<boost::regex>, std::unique_ptr<std::string>>*
-      xforms[row_desc.size()];
+  std::vector<
+      const std::pair<std::unique_ptr<boost::regex>, std::unique_ptr<std::string>>*>
+      xforms(row_desc.size());
   for (size_t i = 0; i < row_desc.size(); i++) {
     auto it = transformations.find(row_desc[i].col_name);
     if (it != transformations.end()) {
diff -Naur ./MapDServer.cpp ../omniscidb-master/MapDServer.cpp
--- ./MapDServer.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/MapDServer.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -92,6 +92,9 @@
 }
 
 void register_signal_handler(int signum, void (*handler)(int)) {
+#ifdef _WIN32
+  signal(signum, handler);
+#else
   struct sigaction act;
   memset(&act, 0, sizeof(act));
   if (handler != SIG_DFL && handler != SIG_IGN) {
@@ -100,6 +103,7 @@
   }
   act.sa_handler = handler;
   sigaction(signum, &act, NULL);
+#endif
 }
 
 // Signal handler to set a global flag telling the server to exit.
@@ -127,18 +131,26 @@
   // because on some systems, some signals will execute their default
   // action immediately when and if the signal handler returns.
   // We would like to do some emergency cleanup before core dump.
-  if (signum == SIGQUIT || signum == SIGABRT || signum == SIGSEGV || signum == SIGFPE) {
+  if (signum == SIGABRT || signum == SIGSEGV || signum == SIGFPE
+#ifndef _WIN32
+      || signum == SIGQUIT
+#endif
+  ) {
     // Wait briefly to give heartbeat() a chance to flush the logs and
     // do any other emergency shutdown tasks.
-    sleep(2);
+    std::this_thread::sleep_for(std::chrono::seconds(2));
 
     // Explicitly trigger whatever default action this signal would
     // have done, such as terminate the process or dump core.
     // Signals are currently blocked so this new signal will be queued
     // until this signal handler returns.
     register_signal_handler(signum, SIG_DFL);
+#ifdef _WIN32
+    raise(signum);
+#else
     kill(getpid(), signum);
-    sleep(5);
+#endif
+    std::this_thread::sleep_for(std::chrono::seconds(5));
 
 #ifndef __APPLE__
     // as a last resort, abort
@@ -151,13 +163,17 @@
 
 void register_signal_handlers() {
   register_signal_handler(SIGINT, omnisci_signal_handler);
+#ifndef _WIN32
   register_signal_handler(SIGQUIT, omnisci_signal_handler);
   register_signal_handler(SIGHUP, omnisci_signal_handler);
+#endif
   register_signal_handler(SIGTERM, omnisci_signal_handler);
   register_signal_handler(SIGSEGV, omnisci_signal_handler);
   register_signal_handler(SIGABRT, omnisci_signal_handler);
+#ifndef _WIN32
   // Thrift secure socket can cause problems with SIGPIPE
   register_signal_handler(SIGPIPE, SIG_IGN);
+#endif
 }
 
 void start_server(TThreadedServer& server, const int port) {
@@ -268,6 +284,7 @@
 }
 
 void heartbeat() {
+#ifndef _WIN32
   // Block all signals for this heartbeat thread, only.
   sigset_t set;
   sigfillset(&set);
@@ -275,6 +292,7 @@
   if (result != 0) {
     throw std::runtime_error("heartbeat() thread startup failed");
   }
+#endif
 
   // Sleep until omnisci_signal_handler or anything clears the g_running flag.
   VLOG(1) << "heartbeat thread starting";
@@ -291,7 +309,11 @@
   }
 
   // if dumping core, try to do some quick stuff
-  if (signum == SIGQUIT || signum == SIGABRT || signum == SIGSEGV || signum == SIGFPE) {
+  if (signum == SIGABRT || signum == SIGSEGV || signum == SIGFPE
+#ifndef _WIN32
+      || signum == SIGQUIT
+#endif
+  ) {
     if (g_mapd_handler) {
       std::call_once(g_shutdown_once_flag,
                      []() { g_mapd_handler->emergency_shutdown(); });
@@ -382,7 +404,8 @@
 #ifdef ENABLE_GEOS
                                        prog_config_opts.libgeos_so_filename,
 #endif
-                                       prog_config_opts.disk_cache_config);
+                                       prog_config_opts.disk_cache_config,
+                                       false);
     } else {  // running ha server
       LOG(FATAL)
           << "No High Availability module available, please contact OmniSci support";
@@ -486,7 +509,6 @@
   g_running = false;
   file_delete_thread.join();
   heartbeat_thread.join();
-  ForeignStorageInterface::destroy();
 
   if (g_enable_fsi) {
     foreign_storage::ForeignTableRefreshScheduler::stop();
diff -Naur ./NvidiaComputeCapability/CMakeLists.txt ../omniscidb-master/NvidiaComputeCapability/CMakeLists.txt
--- ./NvidiaComputeCapability/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/NvidiaComputeCapability/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,25 @@
+cmake_minimum_required(VERSION 3.16)
+project(NvidiaComputeCapability)
+
+include_directories(..)
+
+find_package(CUDA REQUIRED)
+include_directories(${CUDA_INCLUDE_DIRS})
+list(APPEND CUDA_LIBRARIES ${CUDA_CUDA_LIBRARY})
+
+add_executable(get_nvidia_compute_capability get_nvidia_compute_capability.cpp)
+target_link_libraries(get_nvidia_compute_capability ${CUDA_LIBRARIES})
+add_custom_command(
+  COMMENT
+    "Detecting NVIDIA CUDA compute capability for debug build. (NvidiaComputeCapability.txt)"
+  OUTPUT
+    ${CMAKE_BINARY_DIR}/../NvidiaComputeCapability.txt
+  DEPENDS
+    get_nvidia_compute_capability
+  COMMAND
+    get_nvidia_compute_capability > ${CMAKE_BINARY_DIR}/../NvidiaComputeCapability.txt
+  COMMAND
+    eval echo "NVIDIA CUDA compute capability: $(cat ${CMAKE_BINARY_DIR}/../NvidiaComputeCapability.txt)"
+  VERBATIM
+)
+add_custom_target(NvidiaComputeCapability ALL DEPENDS ${CMAKE_BINARY_DIR}/../NvidiaComputeCapability.txt)
diff -Naur ./NvidiaComputeCapability/get_nvidia_compute_capability.cpp ../omniscidb-master/NvidiaComputeCapability/get_nvidia_compute_capability.cpp
--- ./NvidiaComputeCapability/get_nvidia_compute_capability.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/NvidiaComputeCapability/get_nvidia_compute_capability.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,38 @@
+// Copyright (c) 2021 OmniSci, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "Shared/get_nvidia_compute_capability.h"
+
+#include <iostream>
+
+int main(int argc, char** argv) {
+  std::vector<size_t> capabilities;
+
+  try {
+    capabilities = get_nvidia_compute_capability();
+  } catch (const std::exception& e) {
+    std::cerr << "get_nvidia_compute_capability failed: " << e.what();
+    return 1;
+  } catch (...) {
+    std::cerr << "get_nvidia_compute_capability failed";
+    return 2;
+  }
+
+  for (auto capability : capabilities) {
+    std::cout << capability << std::endl;
+    break;  // TODO(sy): need to add an --all flag
+  }
+
+  return 0;
+}
diff -Naur ./OSDependent/Windows/omnisci_fs.cpp ../omniscidb-master/OSDependent/Windows/omnisci_fs.cpp
--- ./OSDependent/Windows/omnisci_fs.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/OSDependent/Windows/omnisci_fs.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -73,7 +73,18 @@
 
 ::FILE* fopen(const char* filename, const char* mode) {
   FILE* f;
-  const auto err = fopen_s(&f, filename, mode);
+  auto err = fopen_s(&f, filename, mode);
+  // Handle 'too many open files' error
+  if (err == EMFILE) {
+    auto max_handles = _getmaxstdio();
+    if (max_handles < 8192) {
+      auto res = _setmaxstdio(8192);
+      if (res < 0) {
+        LOG(FATAL) << "Cannot increase maximum number of open files";
+      }
+      err = fopen_s(&f, filename, mode);
+    }
+  }
   CHECK(!err);
   return f;
 }
diff -Naur ./OSDependent/Windows/omnisci_glob.cpp ../omniscidb-master/OSDependent/Windows/omnisci_glob.cpp
--- ./OSDependent/Windows/omnisci_glob.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/OSDependent/Windows/omnisci_glob.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -16,13 +16,73 @@
 
 #include "OSDependent/omnisci_glob.h"
 
+#include <boost/filesystem.hpp>
+
+#include <windows.h>
+
 #include <string>
 #include <vector>
 
+namespace fs = boost::filesystem;
+
+namespace {
+
+bool has_wildcard(const std::string& name) {
+  if (name.find('*') != std::string::npos) {
+    return true;
+  }
+  if (name.find('?') != std::string::npos) {
+    return true;
+  }
+  return false;
+}
+
+void glob(const fs::path& base, const fs::path& pattern, std::vector<std::string>& out) {
+  if (pattern.empty()) {
+    out.push_back(base.string());
+    return;
+  }
+
+  auto it = pattern.begin();
+  auto next_part = *(it++);
+  fs::path next_pattern;
+  for (; it != pattern.end(); ++it) {
+    next_pattern /= *it;
+  }
+
+  if (has_wildcard(next_part.string())) {
+    WIN32_FIND_DATA file_data;
+    auto search = base / next_part;
+#ifdef _UNICODE
+    auto handle = FindFirstFile(search.wstring().data(), &file_data);
+#else
+    auto handle = FindFirstFile(search.string().data(), &file_data);
+#endif
+    if (handle != INVALID_HANDLE_VALUE) {
+      do {
+        fs::path found_part(file_data.cFileName);
+        if (!found_part.filename_is_dot() && !found_part.filename_is_dot_dot()) {
+          glob(base / found_part, next_pattern, out);
+        }
+      } while (FindNextFile(handle, &file_data) != 0);
+      FindClose(handle);
+    }
+  } else {
+    glob(base / next_part, next_pattern, out);
+  }
+}
+
+}  // namespace
+
 namespace omnisci {
+
 std::vector<std::string> glob(const std::string& pattern) {
   std::vector<std::string> results;
-
+  fs::path pattern_path(pattern);
+  if (!pattern_path.empty()) {
+    ::glob(pattern_path.root_path(), pattern_path.relative_path(), results);
+  }
   return results;
 }
+
 }  // namespace omnisci
diff -Naur ./Parser/CMakeLists.txt ../omniscidb-master/Parser/CMakeLists.txt
--- ./Parser/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Parser/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -1,5 +1,7 @@
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/Modules/")
 
+if(NOT MSVC)
+
 find_package(Bisonpp REQUIRED)
 find_package(Flexpp REQUIRED)
 
@@ -31,6 +33,8 @@
     COMMENT "Generating Scanner.cpp"
 )
 
+endif()
+
 # C++17 removes the 'register' keyword and it is no longer allowed to
 # suppress the warning, so patch the generated scanner and parser files
 # to remove the register keyword, and also patch embedded filename strings
@@ -38,6 +42,15 @@
 set(ParserPatched ${CMAKE_CURRENT_BINARY_DIR}/Parser.cpp)
 set(ScannerPatched ${CMAKE_CURRENT_BINARY_DIR}/Scanner.cpp)
 
+if(MSVC)
+
+file(CREATE_LINK ${CMAKE_CURRENT_SOURCE_DIR}/parser_wnd_pregen.h ${CMAKE_CURRENT_BINARY_DIR}/parser.h SYMBOLIC COPY_ON_ERROR)
+file(CREATE_LINK ${CMAKE_CURRENT_SOURCE_DIR}/Parser_wnd_pregen.cpp ${CMAKE_CURRENT_BINARY_DIR}/Parser.cpp SYMBOLIC COPY_ON_ERROR)
+file(CREATE_LINK ${CMAKE_CURRENT_SOURCE_DIR}/Scanner_wnd_pregen.cpp ${CMAKE_CURRENT_BINARY_DIR}/Scanner.cpp SYMBOLIC COPY_ON_ERROR)
+file(CREATE_LINK ${CMAKE_CURRENT_SOURCE_DIR}/FlexLexer_wnd.h ${CMAKE_CURRENT_BINARY_DIR}/FlexLexer.h SYMBOLIC COPY_ON_ERROR)
+
+else()
+
 add_custom_command(
     OUTPUT ${ParserPatched}
     COMMAND sed
@@ -66,6 +79,8 @@
 
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-write-strings -Wno-unused-function -Wno-unused-label -Wno-sign-compare")
 
+endif()
+
 set(parser_source_files
     ParserNode.cpp
     ParserNode.h
@@ -80,10 +95,12 @@
     include_directories(Distributed/ee)
 endif()
 
+if(NOT MSVC)
 add_dependencies(PatchParser ParserFiles)
 add_dependencies(PatchScanner ScannerFiles)
 
 add_dependencies(Parser PatchParser PatchScanner)
+endif()
 
 if("${MAPD_EDITION_LOWER}" STREQUAL "ee")
     target_link_libraries(Parser ParserGenerated QueryState ImportExport Shared Analyzer QueryEngine Catalog TableArchiver DataMgr LockMgr Distributed)
diff -Naur ./Parser/FlexLexer_wnd.h ../omniscidb-master/Parser/FlexLexer_wnd.h
--- ./Parser/FlexLexer_wnd.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Parser/FlexLexer_wnd.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,211 @@
+// -*-C++-*-
+// FlexLexer.h -- define interfaces for lexical analyzer classes generated
+// by flex
+
+// Copyright (c) 1993 The Regents of the University of California.
+// All rights reserved.
+//
+// This code is derived from software contributed to Berkeley by
+// Kent Williams and Tom Epperly.
+//
+//  Redistribution and use in source and binary forms, with or without
+//  modification, are permitted provided that the following conditions
+//  are met:
+
+//  1. Redistributions of source code must retain the above copyright
+//  notice, this list of conditions and the following disclaimer.
+//  2. Redistributions in binary form must reproduce the above copyright
+//  notice, this list of conditions and the following disclaimer in the
+//  documentation and/or other materials provided with the distribution.
+
+//  Neither the name of the University nor the names of its contributors
+//  may be used to endorse or promote products derived from this software
+//  without specific prior written permission.
+
+//  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+//  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//  PURPOSE.
+
+// This file defines FlexLexer, an abstract class which specifies the
+// external interface provided to flex C++ lexer objects, and yyFlexLexer,
+// which defines a particular lexer class.
+//
+// If you want to create multiple lexer classes, you use the -P flag
+// to rename each yyFlexLexer to some other xxFlexLexer.  You then
+// include <FlexLexer.h> in your other sources once per lexer class:
+//
+//      #undef yyFlexLexer
+//      #define yyFlexLexer xxFlexLexer
+//      #include <FlexLexer.h>
+//
+//      #undef yyFlexLexer
+//      #define yyFlexLexer zzFlexLexer
+//      #include <FlexLexer.h>
+//      ...
+
+#ifndef __FLEX_LEXER_H
+// Never included before - need to define base class.
+#define __FLEX_LEXER_H
+
+#include <iostream>
+
+extern "C++" {
+
+struct yy_buffer_state;
+typedef int yy_state_type;
+
+class FlexLexer {
+ public:
+  virtual ~FlexLexer() {}
+
+  const char* YYText() const { return yytext; }
+  int YYLeng() const { return yyleng; }
+
+  virtual void yy_switch_to_buffer(yy_buffer_state* new_buffer) = 0;
+  virtual yy_buffer_state* yy_create_buffer(std::istream* s, int size) = 0;
+  virtual yy_buffer_state* yy_create_buffer(std::istream& s, int size) = 0;
+  virtual void yy_delete_buffer(yy_buffer_state* b) = 0;
+  virtual void yyrestart(std::istream* s) = 0;
+  virtual void yyrestart(std::istream& s) = 0;
+
+  virtual int yylex() = 0;
+
+  // Call yylex with new input/output sources.
+  int yylex(std::istream& new_in, std::ostream& new_out) {
+    switch_streams(new_in, new_out);
+    return yylex();
+  }
+
+  int yylex(std::istream* new_in, std::ostream* new_out = 0) {
+    switch_streams(new_in, new_out);
+    return yylex();
+  }
+
+  // Switch to new input/output streams.  A nil stream pointer
+  // indicates "keep the current one".
+  virtual void switch_streams(std::istream* new_in, std::ostream* new_out) = 0;
+  virtual void switch_streams(std::istream& new_in, std::ostream& new_out) = 0;
+
+  int lineno() const { return yylineno; }
+
+  int debug() const { return yy_flex_debug; }
+  void set_debug(int flag) { yy_flex_debug = flag; }
+
+ protected:
+  char* yytext;
+  int yyleng;
+  int yylineno;       // only maintained if you use %option yylineno
+  int yy_flex_debug;  // only has effect with -d or "%option debug"
+};
+}
+#endif  // FLEXLEXER_H
+
+#if defined(yyFlexLexer) || !defined(yyFlexLexerOnce)
+// Either this is the first time through (yyFlexLexerOnce not defined),
+// or this is a repeated include to define a different flavor of
+// yyFlexLexer, as discussed in the flex manual.
+#define yyFlexLexerOnce
+
+extern "C++" {
+
+class yyFlexLexer : public FlexLexer {
+ public:
+  // arg_yyin and arg_yyout default to the cin and cout, but we
+  // only make that assignment when initializing in yylex().
+  yyFlexLexer(std::istream& arg_yyin, std::ostream& arg_yyout);
+  yyFlexLexer(std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0);
+
+ private:
+  void ctor_common();
+
+ public:
+  virtual ~yyFlexLexer();
+
+  void yy_switch_to_buffer(yy_buffer_state* new_buffer);
+  yy_buffer_state* yy_create_buffer(std::istream* s, int size);
+  yy_buffer_state* yy_create_buffer(std::istream& s, int size);
+  void yy_delete_buffer(yy_buffer_state* b);
+  void yyrestart(std::istream* s);
+  void yyrestart(std::istream& s);
+
+  void yypush_buffer_state(yy_buffer_state* new_buffer);
+  void yypop_buffer_state();
+
+  virtual int yylex();
+  virtual void switch_streams(std::istream& new_in, std::ostream& new_out);
+  virtual void switch_streams(std::istream* new_in = 0, std::ostream* new_out = 0);
+  virtual int yywrap();
+
+ protected:
+  virtual int LexerInput(char* buf, int max_size);
+  virtual void LexerOutput(const char* buf, int size);
+  virtual void LexerError(const char* msg);
+
+  void yyunput(int c, char* buf_ptr);
+  int yyinput();
+
+  void yy_load_buffer_state();
+  void yy_init_buffer(yy_buffer_state* b, std::istream& s);
+  void yy_flush_buffer(yy_buffer_state* b);
+
+  int yy_start_stack_ptr;
+  int yy_start_stack_depth;
+  int* yy_start_stack;
+
+  void yy_push_state(int new_state);
+  void yy_pop_state();
+  int yy_top_state();
+
+  yy_state_type yy_get_previous_state();
+  yy_state_type yy_try_NUL_trans(yy_state_type current_state);
+  int yy_get_next_buffer();
+
+  std::istream yyin;   // input source for default LexerInput
+  std::ostream yyout;  // output sink for default LexerOutput
+
+  // yy_hold_char holds the character lost when yytext is formed.
+  char yy_hold_char;
+
+  // Number of characters read into yy_ch_buf.
+  int yy_n_chars;
+
+  // Points to current character in buffer.
+  char* yy_c_buf_p;
+
+  int yy_init;   // whether we need to initialize
+  int yy_start;  // start state number
+
+  // Flag which is used to allow yywrap()'s to do buffer switches
+  // instead of setting up a fresh yyin.  A bit of a hack ...
+  int yy_did_buffer_switch_on_eof;
+
+  size_t yy_buffer_stack_top;        /**< index of top of stack. */
+  size_t yy_buffer_stack_max;        /**< capacity of stack. */
+  yy_buffer_state** yy_buffer_stack; /**< Stack as an array. */
+  void yyensure_buffer_stack(void);
+
+  // The following are not always needed, but may be depending
+  // on use of certain flex features (like REJECT or yymore()).
+
+  yy_state_type yy_last_accepting_state;
+  char* yy_last_accepting_cpos;
+
+  yy_state_type* yy_state_buf;
+  yy_state_type* yy_state_ptr;
+
+  char* yy_full_match;
+  int* yy_full_state;
+  int yy_full_lp;
+
+  int yy_lp;
+  int yy_looking_for_trail_begin;
+
+  int yy_more_flag;
+  int yy_more_len;
+  int yy_more_offset;
+  int yy_prev_more_offset;
+};
+}
+
+#endif  // yyFlexLexer || ! yyFlexLexerOnce
diff -Naur ./Parser/ParserNode.cpp ../omniscidb-master/Parser/ParserNode.cpp
--- ./Parser/ParserNode.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Parser/ParserNode.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -81,12 +81,12 @@
 using namespace std::string_literals;
 
 using TableDefFuncPtr = boost::function<void(TableDescriptor&,
-                                             const NameValueAssign*,
+                                             const Parser::NameValueAssign*,
                                              const std::list<ColumnDescriptor>& columns)>;
 
 using DataframeDefFuncPtr =
     boost::function<void(DataframeTableDescriptor&,
-                         const NameValueAssign*,
+                         const Parser::NameValueAssign*,
                          const std::list<ColumnDescriptor>& columns)>;
 
 namespace Parser {
@@ -3019,13 +3019,13 @@
         size_t leaf_count = leafs_connector_->leafCount();
 
         size_t max_number_of_rows_per_package =
-            std::min(num_rows / leaf_count, 64UL * 1024UL);
+            std::min(num_rows / leaf_count, size_t(64 * 1024));
 
         size_t start_row = 0;
         size_t num_rows_to_process = std::min(num_rows, max_number_of_rows_per_package);
 
         // ensure that at least one row is being processed
-        num_rows_to_process = std::max(num_rows_to_process, 1UL);
+        num_rows_to_process = std::max(num_rows_to_process, size_t(1));
 
         std::vector<std::unique_ptr<TargetValueConverter>> value_converters;
 
diff -Naur ./Parser/Parser_wnd_pregen.cpp ../omniscidb-master/Parser/Parser_wnd_pregen.cpp
--- ./Parser/Parser_wnd_pregen.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Parser/Parser_wnd_pregen.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,5472 @@
+#define YY_Parser_h_included
+
+/*  A Bison++ parser, made from Parser/parser.y  */
+
+/* with Bison++ version bison++ version 1.21-45, adapted from GNU Bison by
+ * coetmeur@icdc.fr
+ */
+
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+/* HEADER SECTION */
+#if defined(_MSDOS) || defined(MSDOS) || defined(__MSDOS__)
+#define __MSDOS_AND_ALIKE
+#endif
+#if defined(_WINDOWS) && defined(_MSC_VER)
+#define __HAVE_NO_ALLOCA
+#define __MSDOS_AND_ALIKE
+#endif
+
+#ifndef alloca
+#if defined(__GNUC__)
+#define alloca __builtin_alloca
+
+#elif (!defined(__STDC__) && defined(sparc)) || defined(__sparc__) || \
+    defined(__sparc) || defined(__sgi)
+#include <alloca.h>
+
+#elif defined(__MSDOS_AND_ALIKE)
+#include <malloc.h>
+#ifndef __TURBOC__
+/* MS C runtime lib */
+#define alloca _alloca
+#endif
+
+#elif defined(_AIX)
+#include <malloc.h>
+#pragma alloca
+
+#elif defined(__hpux)
+#ifdef __cplusplus
+extern "C" {
+void* alloca(unsigned int);
+};
+#else  /* not __cplusplus */
+void* alloca();
+#endif /* not __cplusplus */
+
+#endif /* not _AIX  not MSDOS, or __TURBOC__ or _AIX, not sparc.  */
+#endif /* alloca not defined.  */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+#ifdef __cplusplus
+#ifndef YY_USE_CLASS
+#define YY_USE_CLASS
+#endif
+#else
+#ifndef __STDC__
+#define const
+#endif
+#endif
+#include <stdio.h>
+#define YYBISON 1
+
+#define YY_Parser_CLASS SQLParser
+#define YY_Parser_LVAL yylval
+#define YY_Parser_CONSTRUCTOR_INIT  : lexer(yylval)
+#define YY_Parser_MEMBERS                                                                     \
+  virtual ~SQLParser() {}                                                                     \
+  int parse(const std::string& inputStrOrig,                                                  \
+            std::list<std::unique_ptr<Stmt>>& parseTrees,                                     \
+            std::string& lastParsed) {                                                        \
+    auto inputStr = boost::algorithm::trim_right_copy_if(                                     \
+                        inputStrOrig, boost::is_any_of(";") || boost::is_space()) +           \
+                    ";";                                                                      \
+    boost::regex create_view_expr{                                                            \
+        R"(CREATE\s+VIEW\s+(IF\s+NOT\s+EXISTS\s+)?([A-Za-z_][A-Za-z0-9\$_]*)\s+AS\s+(.*);?)", \
+        boost::regex::extended | boost::regex::icase};                                        \
+    std::lock_guard<std::mutex> lock(mutex_);                                                 \
+    boost::smatch what;                                                                       \
+    const auto trimmed_input = boost::algorithm::trim_copy(inputStr);                         \
+    if (boost::regex_match(                                                                   \
+            trimmed_input.cbegin(), trimmed_input.cend(), what, create_view_expr)) {          \
+      const bool if_not_exists = what[1].length() > 0;                                        \
+      const auto view_name = what[2].str();                                                   \
+      const auto select_query = what[3].str();                                                \
+      parseTrees.emplace_back(                                                                \
+          new CreateViewStmt(view_name, select_query, if_not_exists));                        \
+      return 0;                                                                               \
+    }                                                                                         \
+    std::istringstream ss(inputStr);                                                          \
+    lexer.switch_streams(&ss, 0);                                                             \
+    yyparse(parseTrees);                                                                      \
+    lastParsed = lexer.YYText();                                                              \
+    if (!errors_.empty()) {                                                                   \
+      throw std::runtime_error(errors_[0]);                                                   \
+    }                                                                                         \
+    return yynerrs;                                                                           \
+  }                                                                                           \
+                                                                                              \
+ private:                                                                                     \
+  SQLLexer lexer;                                                                             \
+  std::mutex mutex_;                                                                          \
+  std::vector<std::string> errors_;
+#define YY_Parser_LEX_BODY \
+  { return lexer.yylex(); }
+#define YY_Parser_ERROR_BODY                                                            \
+  {} /*{ std::cerr << "Syntax error on line " << lexer.lineno() << ". Last word parsed: \
+        " << lexer.YYText() << std::endl; } */
+
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/trim.hpp>
+#include <boost/regex.hpp>
+#include <cstdlib>
+#include <fstream>
+#include <iostream>
+#include <list>
+#include <mutex>
+#include <sstream>
+#include <stdexcept>
+#include <string>
+#include <utility>
+#include "Parser/FlexLexer.h"
+#include "ParserNode.h"
+#include "ReservedKeywords.h"
+#include "TrackedPtr.h"
+
+#ifdef DELETE
+#undef DELETE
+#endif
+
+#ifdef IN
+#undef IN
+#endif
+
+using namespace Parser;
+#define YY_Parser_PARSE_PARAM std::list<std::unique_ptr<Stmt>>& parseTrees
+
+typedef union {
+  bool boolval;
+  int64_t intval;
+  float floatval;
+  double doubleval;
+  TrackedPtr<std::string>* stringval;
+  SQLOps opval;
+  SQLQualifier qualval;
+  TrackedListPtr<Node>* listval;
+  TrackedListPtr<std::string>* slistval;
+  TrackedPtr<Node>* nodeval;
+} yy_Parser_stype;
+#define YY_Parser_STYPE yy_Parser_stype
+
+class SQLLexer : public yyFlexLexer {
+ public:
+  SQLLexer(YY_Parser_STYPE& lval) : yylval(lval){};
+  YY_Parser_STYPE& yylval;
+  std::vector<std::unique_ptr<TrackedPtr<std::string>>> parsed_str_tokens_{};
+  std::vector<std::unique_ptr<TrackedListPtr<std::string>>> parsed_str_list_tokens_{};
+  std::vector<std::unique_ptr<TrackedPtr<Node>>> parsed_node_tokens_{};
+  std::vector<std::unique_ptr<TrackedListPtr<Node>>> parsed_node_list_tokens_{};
+};
+
+/* %{ and %header{ and %union, during decl */
+#define YY_Parser_BISON 1
+#ifndef YY_Parser_COMPATIBILITY
+#ifndef YY_USE_CLASS
+#define YY_Parser_COMPATIBILITY 1
+#else
+#define YY_Parser_COMPATIBILITY 0
+#endif
+#endif
+
+#if YY_Parser_COMPATIBILITY != 0
+/* backward compatibility */
+#ifdef YYLTYPE
+#ifndef YY_Parser_LTYPE
+#define YY_Parser_LTYPE YYLTYPE
+#endif
+#endif
+#ifdef YYSTYPE
+#ifndef YY_Parser_STYPE
+#define YY_Parser_STYPE YYSTYPE
+#endif
+#endif
+#ifdef YYDEBUG
+#ifndef YY_Parser_DEBUG
+#define YY_Parser_DEBUG YYDEBUG
+#endif
+#endif
+#ifdef YY_Parser_STYPE
+#ifndef yystype
+#define yystype YY_Parser_STYPE
+#endif
+#endif
+/* use goto to be compatible */
+#ifndef YY_Parser_USE_GOTO
+#define YY_Parser_USE_GOTO 1
+#endif
+#endif
+
+/* use no goto to be clean in C++ */
+#ifndef YY_Parser_USE_GOTO
+#define YY_Parser_USE_GOTO 0
+#endif
+
+#ifndef YY_Parser_PURE
+
+/*  YY_Parser_PURE */
+#endif
+
+/* section apres lecture def, avant lecture grammaire S2 */
+
+/* prefix */
+#ifndef YY_Parser_DEBUG
+
+/* YY_Parser_DEBUG */
+#endif
+
+#ifndef YY_Parser_LSP_NEEDED
+
+/* YY_Parser_LSP_NEEDED*/
+#endif
+
+/* DEFAULT LTYPE*/
+#ifdef YY_Parser_LSP_NEEDED
+#ifndef YY_Parser_LTYPE
+typedef struct yyltype {
+  int timestamp;
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+  char* text;
+} yyltype;
+
+#define YY_Parser_LTYPE yyltype
+#endif
+#endif
+/* DEFAULT STYPE*/
+/* We used to use `unsigned long' as YY_Parser_STYPE on MSDOS,
+   but it seems better to be consistent.
+   Most programs should declare their own type anyway.  */
+
+#ifndef YY_Parser_STYPE
+#define YY_Parser_STYPE int
+#endif
+/* DEFAULT MISCELANEOUS */
+#ifndef YY_Parser_PARSE
+#define YY_Parser_PARSE yyparse
+#endif
+#ifndef YY_Parser_LEX
+#define YY_Parser_LEX yylex
+#endif
+#ifndef YY_Parser_LVAL
+#define YY_Parser_LVAL yylval
+#endif
+#ifndef YY_Parser_LLOC
+#define YY_Parser_LLOC yylloc
+#endif
+#ifndef YY_Parser_CHAR
+#define YY_Parser_CHAR yychar
+#endif
+#ifndef YY_Parser_NERRS
+#define YY_Parser_NERRS yynerrs
+#endif
+#ifndef YY_Parser_DEBUG_FLAG
+#define YY_Parser_DEBUG_FLAG yydebug
+#endif
+#ifndef YY_Parser_ERROR
+#define YY_Parser_ERROR yyerror
+#endif
+#ifndef YY_Parser_PARSE_PARAM
+#ifndef __STDC__
+#ifndef __cplusplus
+#ifndef YY_USE_CLASS
+#define YY_Parser_PARSE_PARAM
+#ifndef YY_Parser_PARSE_PARAM_DEF
+#define YY_Parser_PARSE_PARAM_DEF
+#endif
+#endif
+#endif
+#endif
+#ifndef YY_Parser_PARSE_PARAM
+#define YY_Parser_PARSE_PARAM void
+#endif
+#endif
+#if YY_Parser_COMPATIBILITY != 0
+/* backward compatibility */
+#ifdef YY_Parser_LTYPE
+#ifndef YYLTYPE
+#define YYLTYPE YY_Parser_LTYPE
+#else
+/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header */
+#endif
+#endif
+#ifndef YYSTYPE
+#define YYSTYPE YY_Parser_STYPE
+#else
+/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header */
+#endif
+#ifdef YY_Parser_PURE
+#ifndef YYPURE
+#define YYPURE YY_Parser_PURE
+#endif
+#endif
+#ifdef YY_Parser_DEBUG
+#ifndef YYDEBUG
+#define YYDEBUG YY_Parser_DEBUG
+#endif
+#endif
+#ifndef YY_Parser_ERROR_VERBOSE
+#ifdef YYERROR_VERBOSE
+#define YY_Parser_ERROR_VERBOSE YYERROR_VERBOSE
+#endif
+#endif
+#ifndef YY_Parser_LSP_NEEDED
+#ifdef YYLSP_NEEDED
+#define YY_Parser_LSP_NEEDED YYLSP_NEEDED
+#endif
+#endif
+#endif
+#ifndef YY_USE_CLASS
+/* TOKEN C */
+
+#define NAME 258
+#define DASHEDNAME 259
+#define EMAIL 260
+#define STRING 261
+#define FWDSTR 262
+#define SELECTSTRING 263
+#define QUOTED_IDENTIFIER 264
+#define INTNUM 265
+#define FIXEDNUM 266
+#define OR 267
+#define AND 268
+#define NOT 269
+#define EQUAL 270
+#define COMPARISON 271
+#define UMINUS 272
+#define ADD 273
+#define ALL 274
+#define ALTER 275
+#define AMMSC 276
+#define ANY 277
+#define ARCHIVE 278
+#define ARRAY 279
+#define AS 280
+#define ASC 281
+#define AUTHORIZATION 282
+#define BETWEEN 283
+#define BIGINT 284
+#define BOOLEAN 285
+#define BY 286
+#define CASE 287
+#define CAST 288
+#define CHAR_LENGTH 289
+#define CHARACTER 290
+#define CHECK 291
+#define CLOSE 292
+#define CLUSTER 293
+#define COLUMN 294
+#define COMMIT 295
+#define CONTINUE 296
+#define COPY 297
+#define CREATE 298
+#define CURRENT 299
+#define CURSOR 300
+#define DATABASE 301
+#define DATAFRAME 302
+#define DATE 303
+#define DATETIME 304
+#define DATE_TRUNC 305
+#define DECIMAL 306
+#define DECLARE 307
+#define DEFAULT 308
+#define DELETE 309
+#define DESC 310
+#define DICTIONARY 311
+#define DISTINCT 312
+#define DOUBLE 313
+#define DROP 314
+#define DUMP 315
+#define ELSE 316
+#define END 317
+#define EXISTS 318
+#define EXTRACT 319
+#define FETCH 320
+#define FIRST 321
+#define FLOAT 322
+#define FOR 323
+#define FOREIGN 324
+#define FOUND 325
+#define FROM 326
+#define GEOGRAPHY 327
+#define GEOMETRY 328
+#define GRANT 329
+#define GROUP 330
+#define HAVING 331
+#define IF 332
+#define ILIKE 333
+#define IN 334
+#define INSERT 335
+#define INTEGER 336
+#define INTO 337
+#define IS 338
+#define LANGUAGE 339
+#define LAST 340
+#define LENGTH 341
+#define LIKE 342
+#define LIMIT 343
+#define LINESTRING 344
+#define MOD 345
+#define MULTIPOLYGON 346
+#define NOW 347
+#define NULLX 348
+#define NUMERIC 349
+#define OF 350
+#define OFFSET 351
+#define ON 352
+#define OPEN 353
+#define OPTIMIZE 354
+#define OPTIMIZED 355
+#define OPTION 356
+#define ORDER 357
+#define PARAMETER 358
+#define POINT 359
+#define POLYGON 360
+#define PRECISION 361
+#define PRIMARY 362
+#define PRIVILEGES 363
+#define PROCEDURE 364
+#define SERVER 365
+#define SMALLINT 366
+#define SOME 367
+#define TABLE 368
+#define TEMPORARY 369
+#define TEXT 370
+#define THEN 371
+#define TIME 372
+#define TIMESTAMP 373
+#define TINYINT 374
+#define TO 375
+#define TRUNCATE 376
+#define UNION 377
+#define PUBLIC 378
+#define REAL 379
+#define REFERENCES 380
+#define RENAME 381
+#define RESTORE 382
+#define REVOKE 383
+#define ROLE 384
+#define ROLLBACK 385
+#define SCHEMA 386
+#define SELECT 387
+#define SET 388
+#define SHARD 389
+#define SHARED 390
+#define SHOW 391
+#define UNIQUE 392
+#define UPDATE 393
+#define USER 394
+#define VALIDATE 395
+#define VALUES 396
+#define VIEW 397
+#define WHEN 398
+#define WHENEVER 399
+#define WHERE 400
+#define WITH 401
+#define WORK 402
+#define EDIT 403
+#define ACCESS 404
+#define DASHBOARD 405
+#define SQL 406
+#define EDITOR 407
+
+/* #defines tokens */
+#else
+/* CLASS */
+#ifndef YY_Parser_CLASS
+#define YY_Parser_CLASS Parser
+#endif
+#ifndef YY_Parser_INHERIT
+#define YY_Parser_INHERIT
+#endif
+#ifndef YY_Parser_MEMBERS
+#define YY_Parser_MEMBERS
+#endif
+#ifndef YY_Parser_LEX_BODY
+#define YY_Parser_LEX_BODY
+#endif
+#ifndef YY_Parser_ERROR_BODY
+#define YY_Parser_ERROR_BODY
+#endif
+#ifndef YY_Parser_CONSTRUCTOR_PARAM
+#define YY_Parser_CONSTRUCTOR_PARAM
+#endif
+#ifndef YY_Parser_CONSTRUCTOR_CODE
+#define YY_Parser_CONSTRUCTOR_CODE
+#endif
+#ifndef YY_Parser_CONSTRUCTOR_INIT
+#define YY_Parser_CONSTRUCTOR_INIT
+#endif
+/* choose between enum and const */
+#ifndef YY_Parser_USE_CONST_TOKEN
+#define YY_Parser_USE_CONST_TOKEN 0
+/* yes enum is more compatible with flex,  */
+/* so by default we use it */
+#endif
+#if YY_Parser_USE_CONST_TOKEN != 0
+#ifndef YY_Parser_ENUM_TOKEN
+#define YY_Parser_ENUM_TOKEN yy_Parser_enum_token
+#endif
+#endif
+
+class YY_Parser_CLASS YY_Parser_INHERIT {
+ public:
+#if YY_Parser_USE_CONST_TOKEN != 0
+  /* static const int token ... */
+
+  static const int NAME;
+  static const int DASHEDNAME;
+  static const int EMAIL;
+  static const int STRING;
+  static const int FWDSTR;
+  static const int SELECTSTRING;
+  static const int QUOTED_IDENTIFIER;
+  static const int INTNUM;
+  static const int FIXEDNUM;
+  static const int OR;
+  static const int AND;
+  static const int NOT;
+  static const int EQUAL;
+  static const int COMPARISON;
+  static const int UMINUS;
+  static const int ADD;
+  static const int ALL;
+  static const int ALTER;
+  static const int AMMSC;
+  static const int ANY;
+  static const int ARCHIVE;
+  static const int ARRAY;
+  static const int AS;
+  static const int ASC;
+  static const int AUTHORIZATION;
+  static const int BETWEEN;
+  static const int BIGINT;
+  static const int BOOLEAN;
+  static const int BY;
+  static const int CASE;
+  static const int CAST;
+  static const int CHAR_LENGTH;
+  static const int CHARACTER;
+  static const int CHECK;
+  static const int CLOSE;
+  static const int CLUSTER;
+  static const int COLUMN;
+  static const int COMMIT;
+  static const int CONTINUE;
+  static const int COPY;
+  static const int CREATE;
+  static const int CURRENT;
+  static const int CURSOR;
+  static const int DATABASE;
+  static const int DATAFRAME;
+  static const int DATE;
+  static const int DATETIME;
+  static const int DATE_TRUNC;
+  static const int DECIMAL;
+  static const int DECLARE;
+  static const int DEFAULT;
+  static const int DELETE;
+  static const int DESC;
+  static const int DICTIONARY;
+  static const int DISTINCT;
+  static const int DOUBLE;
+  static const int DROP;
+  static const int DUMP;
+  static const int ELSE;
+  static const int END;
+  static const int EXISTS;
+  static const int EXTRACT;
+  static const int FETCH;
+  static const int FIRST;
+  static const int FLOAT;
+  static const int FOR;
+  static const int FOREIGN;
+  static const int FOUND;
+  static const int FROM;
+  static const int GEOGRAPHY;
+  static const int GEOMETRY;
+  static const int GRANT;
+  static const int GROUP;
+  static const int HAVING;
+  static const int IF;
+  static const int ILIKE;
+  static const int IN;
+  static const int INSERT;
+  static const int INTEGER;
+  static const int INTO;
+  static const int IS;
+  static const int LANGUAGE;
+  static const int LAST;
+  static const int LENGTH;
+  static const int LIKE;
+  static const int LIMIT;
+  static const int LINESTRING;
+  static const int MOD;
+  static const int MULTIPOLYGON;
+  static const int NOW;
+  static const int NULLX;
+  static const int NUMERIC;
+  static const int OF;
+  static const int OFFSET;
+  static const int ON;
+  static const int OPEN;
+  static const int OPTIMIZE;
+  static const int OPTIMIZED;
+  static const int OPTION;
+  static const int ORDER;
+  static const int PARAMETER;
+  static const int POINT;
+  static const int POLYGON;
+  static const int PRECISION;
+  static const int PRIMARY;
+  static const int PRIVILEGES;
+  static const int PROCEDURE;
+  static const int SERVER;
+  static const int SMALLINT;
+  static const int SOME;
+  static const int TABLE;
+  static const int TEMPORARY;
+  static const int TEXT;
+  static const int THEN;
+  static const int TIME;
+  static const int TIMESTAMP;
+  static const int TINYINT;
+  static const int TO;
+  static const int TRUNCATE;
+  static const int UNION;
+  static const int PUBLIC;
+  static const int REAL;
+  static const int REFERENCES;
+  static const int RENAME;
+  static const int RESTORE;
+  static const int REVOKE;
+  static const int ROLE;
+  static const int ROLLBACK;
+  static const int SCHEMA;
+  static const int SELECT;
+  static const int SET;
+  static const int SHARD;
+  static const int SHARED;
+  static const int SHOW;
+  static const int UNIQUE;
+  static const int UPDATE;
+  static const int USER;
+  static const int VALIDATE;
+  static const int VALUES;
+  static const int VIEW;
+  static const int WHEN;
+  static const int WHENEVER;
+  static const int WHERE;
+  static const int WITH;
+  static const int WORK;
+  static const int EDIT;
+  static const int ACCESS;
+  static const int DASHBOARD;
+  static const int SQL;
+  static const int EDITOR;
+
+  /* decl const */
+#else
+  enum YY_Parser_ENUM_TOKEN {
+    YY_Parser_NULL_TOKEN = 0
+
+    ,
+    NAME = 258,
+    DASHEDNAME = 259,
+    EMAIL = 260,
+    STRING = 261,
+    FWDSTR = 262,
+    SELECTSTRING = 263,
+    QUOTED_IDENTIFIER = 264,
+    INTNUM = 265,
+    FIXEDNUM = 266,
+    OR = 267,
+    AND = 268,
+    NOT = 269,
+    EQUAL = 270,
+    COMPARISON = 271,
+    UMINUS = 272,
+    ADD = 273,
+    ALL = 274,
+    ALTER = 275,
+    AMMSC = 276,
+    ANY = 277,
+    ARCHIVE = 278,
+    ARRAY = 279,
+    AS = 280,
+    ASC = 281,
+    AUTHORIZATION = 282,
+    BETWEEN = 283,
+    BIGINT = 284,
+    BOOLEAN = 285,
+    BY = 286,
+    CASE = 287,
+    CAST = 288,
+    CHAR_LENGTH = 289,
+    CHARACTER = 290,
+    CHECK = 291,
+    CLOSE = 292,
+    CLUSTER = 293,
+    COLUMN = 294,
+    COMMIT = 295,
+    CONTINUE = 296,
+    COPY = 297,
+    CREATE = 298,
+    CURRENT = 299,
+    CURSOR = 300,
+    DATABASE = 301,
+    DATAFRAME = 302,
+    DATE = 303,
+    DATETIME = 304,
+    DATE_TRUNC = 305,
+    DECIMAL = 306,
+    DECLARE = 307,
+    DEFAULT = 308,
+    DELETE = 309,
+    DESC = 310,
+    DICTIONARY = 311,
+    DISTINCT = 312,
+    DOUBLE = 313,
+    DROP = 314,
+    DUMP = 315,
+    ELSE = 316,
+    END = 317,
+    EXISTS = 318,
+    EXTRACT = 319,
+    FETCH = 320,
+    FIRST = 321,
+    FLOAT = 322,
+    FOR = 323,
+    FOREIGN = 324,
+    FOUND = 325,
+    FROM = 326,
+    GEOGRAPHY = 327,
+    GEOMETRY = 328,
+    GRANT = 329,
+    GROUP = 330,
+    HAVING = 331,
+    IF = 332,
+    ILIKE = 333,
+    IN = 334,
+    INSERT = 335,
+    INTEGER = 336,
+    INTO = 337,
+    IS = 338,
+    LANGUAGE = 339,
+    LAST = 340,
+    LENGTH = 341,
+    LIKE = 342,
+    LIMIT = 343,
+    LINESTRING = 344,
+    MOD = 345,
+    MULTIPOLYGON = 346,
+    NOW = 347,
+    NULLX = 348,
+    NUMERIC = 349,
+    OF = 350,
+    OFFSET = 351,
+    ON = 352,
+    OPEN = 353,
+    OPTIMIZE = 354,
+    OPTIMIZED = 355,
+    OPTION = 356,
+    ORDER = 357,
+    PARAMETER = 358,
+    POINT = 359,
+    POLYGON = 360,
+    PRECISION = 361,
+    PRIMARY = 362,
+    PRIVILEGES = 363,
+    PROCEDURE = 364,
+    SERVER = 365,
+    SMALLINT = 366,
+    SOME = 367,
+    TABLE = 368,
+    TEMPORARY = 369,
+    TEXT = 370,
+    THEN = 371,
+    TIME = 372,
+    TIMESTAMP = 373,
+    TINYINT = 374,
+    TO = 375,
+    TRUNCATE = 376,
+    UNION = 377,
+    PUBLIC = 378,
+    REAL = 379,
+    REFERENCES = 380,
+    RENAME = 381,
+    RESTORE = 382,
+    REVOKE = 383,
+    ROLE = 384,
+    ROLLBACK = 385,
+    SCHEMA = 386,
+    SELECT = 387,
+    SET = 388,
+    SHARD = 389,
+    SHARED = 390,
+    SHOW = 391,
+    UNIQUE = 392,
+    UPDATE = 393,
+    USER = 394,
+    VALIDATE = 395,
+    VALUES = 396,
+    VIEW = 397,
+    WHEN = 398,
+    WHENEVER = 399,
+    WHERE = 400,
+    WITH = 401,
+    WORK = 402,
+    EDIT = 403,
+    ACCESS = 404,
+    DASHBOARD = 405,
+    SQL = 406,
+    EDITOR = 407
+
+    /* enum token */
+  }; /* end of enum declaration */
+#endif
+ public:
+  int YY_Parser_PARSE(YY_Parser_PARSE_PARAM);
+  virtual void YY_Parser_ERROR(const char* msg) YY_Parser_ERROR_BODY;
+#ifdef YY_Parser_PURE
+#ifdef YY_Parser_LSP_NEEDED
+  virtual int YY_Parser_LEX(YY_Parser_STYPE* YY_Parser_LVAL,
+                            YY_Parser_LTYPE* YY_Parser_LLOC) YY_Parser_LEX_BODY;
+#else
+  virtual int YY_Parser_LEX(YY_Parser_STYPE* YY_Parser_LVAL) YY_Parser_LEX_BODY;
+#endif
+#else
+  virtual int YY_Parser_LEX() YY_Parser_LEX_BODY;
+  YY_Parser_STYPE YY_Parser_LVAL;
+#ifdef YY_Parser_LSP_NEEDED
+  YY_Parser_LTYPE YY_Parser_LLOC;
+#endif
+  int YY_Parser_NERRS;
+  int YY_Parser_CHAR;
+#endif
+#if YY_Parser_DEBUG != 0
+  int YY_Parser_DEBUG_FLAG; /*  nonzero means print parse trace     */
+#endif
+ public:
+  YY_Parser_CLASS(YY_Parser_CONSTRUCTOR_PARAM);
+
+ public:
+  YY_Parser_MEMBERS
+};
+/* other declare folow */
+#if YY_Parser_USE_CONST_TOKEN != 0
+
+const int YY_Parser_CLASS::NAME = 258;
+const int YY_Parser_CLASS::DASHEDNAME = 259;
+const int YY_Parser_CLASS::EMAIL = 260;
+const int YY_Parser_CLASS::STRING = 261;
+const int YY_Parser_CLASS::FWDSTR = 262;
+const int YY_Parser_CLASS::SELECTSTRING = 263;
+const int YY_Parser_CLASS::QUOTED_IDENTIFIER = 264;
+const int YY_Parser_CLASS::INTNUM = 265;
+const int YY_Parser_CLASS::FIXEDNUM = 266;
+const int YY_Parser_CLASS::OR = 267;
+const int YY_Parser_CLASS::AND = 268;
+const int YY_Parser_CLASS::NOT = 269;
+const int YY_Parser_CLASS::EQUAL = 270;
+const int YY_Parser_CLASS::COMPARISON = 271;
+const int YY_Parser_CLASS::UMINUS = 272;
+const int YY_Parser_CLASS::ADD = 273;
+const int YY_Parser_CLASS::ALL = 274;
+const int YY_Parser_CLASS::ALTER = 275;
+const int YY_Parser_CLASS::AMMSC = 276;
+const int YY_Parser_CLASS::ANY = 277;
+const int YY_Parser_CLASS::ARCHIVE = 278;
+const int YY_Parser_CLASS::ARRAY = 279;
+const int YY_Parser_CLASS::AS = 280;
+const int YY_Parser_CLASS::ASC = 281;
+const int YY_Parser_CLASS::AUTHORIZATION = 282;
+const int YY_Parser_CLASS::BETWEEN = 283;
+const int YY_Parser_CLASS::BIGINT = 284;
+const int YY_Parser_CLASS::BOOLEAN = 285;
+const int YY_Parser_CLASS::BY = 286;
+const int YY_Parser_CLASS::CASE = 287;
+const int YY_Parser_CLASS::CAST = 288;
+const int YY_Parser_CLASS::CHAR_LENGTH = 289;
+const int YY_Parser_CLASS::CHARACTER = 290;
+const int YY_Parser_CLASS::CHECK = 291;
+const int YY_Parser_CLASS::CLOSE = 292;
+const int YY_Parser_CLASS::CLUSTER = 293;
+const int YY_Parser_CLASS::COLUMN = 294;
+const int YY_Parser_CLASS::COMMIT = 295;
+const int YY_Parser_CLASS::CONTINUE = 296;
+const int YY_Parser_CLASS::COPY = 297;
+const int YY_Parser_CLASS::CREATE = 298;
+const int YY_Parser_CLASS::CURRENT = 299;
+const int YY_Parser_CLASS::CURSOR = 300;
+const int YY_Parser_CLASS::DATABASE = 301;
+const int YY_Parser_CLASS::DATAFRAME = 302;
+const int YY_Parser_CLASS::DATE = 303;
+const int YY_Parser_CLASS::DATETIME = 304;
+const int YY_Parser_CLASS::DATE_TRUNC = 305;
+const int YY_Parser_CLASS::DECIMAL = 306;
+const int YY_Parser_CLASS::DECLARE = 307;
+const int YY_Parser_CLASS::DEFAULT = 308;
+const int YY_Parser_CLASS::DELETE = 309;
+const int YY_Parser_CLASS::DESC = 310;
+const int YY_Parser_CLASS::DICTIONARY = 311;
+const int YY_Parser_CLASS::DISTINCT = 312;
+const int YY_Parser_CLASS::DOUBLE = 313;
+const int YY_Parser_CLASS::DROP = 314;
+const int YY_Parser_CLASS::DUMP = 315;
+const int YY_Parser_CLASS::ELSE = 316;
+const int YY_Parser_CLASS::END = 317;
+const int YY_Parser_CLASS::EXISTS = 318;
+const int YY_Parser_CLASS::EXTRACT = 319;
+const int YY_Parser_CLASS::FETCH = 320;
+const int YY_Parser_CLASS::FIRST = 321;
+const int YY_Parser_CLASS::FLOAT = 322;
+const int YY_Parser_CLASS::FOR = 323;
+const int YY_Parser_CLASS::FOREIGN = 324;
+const int YY_Parser_CLASS::FOUND = 325;
+const int YY_Parser_CLASS::FROM = 326;
+const int YY_Parser_CLASS::GEOGRAPHY = 327;
+const int YY_Parser_CLASS::GEOMETRY = 328;
+const int YY_Parser_CLASS::GRANT = 329;
+const int YY_Parser_CLASS::GROUP = 330;
+const int YY_Parser_CLASS::HAVING = 331;
+const int YY_Parser_CLASS::IF = 332;
+const int YY_Parser_CLASS::ILIKE = 333;
+const int YY_Parser_CLASS::IN = 334;
+const int YY_Parser_CLASS::INSERT = 335;
+const int YY_Parser_CLASS::INTEGER = 336;
+const int YY_Parser_CLASS::INTO = 337;
+const int YY_Parser_CLASS::IS = 338;
+const int YY_Parser_CLASS::LANGUAGE = 339;
+const int YY_Parser_CLASS::LAST = 340;
+const int YY_Parser_CLASS::LENGTH = 341;
+const int YY_Parser_CLASS::LIKE = 342;
+const int YY_Parser_CLASS::LIMIT = 343;
+const int YY_Parser_CLASS::LINESTRING = 344;
+const int YY_Parser_CLASS::MOD = 345;
+const int YY_Parser_CLASS::MULTIPOLYGON = 346;
+const int YY_Parser_CLASS::NOW = 347;
+const int YY_Parser_CLASS::NULLX = 348;
+const int YY_Parser_CLASS::NUMERIC = 349;
+const int YY_Parser_CLASS::OF = 350;
+const int YY_Parser_CLASS::OFFSET = 351;
+const int YY_Parser_CLASS::ON = 352;
+const int YY_Parser_CLASS::OPEN = 353;
+const int YY_Parser_CLASS::OPTIMIZE = 354;
+const int YY_Parser_CLASS::OPTIMIZED = 355;
+const int YY_Parser_CLASS::OPTION = 356;
+const int YY_Parser_CLASS::ORDER = 357;
+const int YY_Parser_CLASS::PARAMETER = 358;
+const int YY_Parser_CLASS::POINT = 359;
+const int YY_Parser_CLASS::POLYGON = 360;
+const int YY_Parser_CLASS::PRECISION = 361;
+const int YY_Parser_CLASS::PRIMARY = 362;
+const int YY_Parser_CLASS::PRIVILEGES = 363;
+const int YY_Parser_CLASS::PROCEDURE = 364;
+const int YY_Parser_CLASS::SERVER = 365;
+const int YY_Parser_CLASS::SMALLINT = 366;
+const int YY_Parser_CLASS::SOME = 367;
+const int YY_Parser_CLASS::TABLE = 368;
+const int YY_Parser_CLASS::TEMPORARY = 369;
+const int YY_Parser_CLASS::TEXT = 370;
+const int YY_Parser_CLASS::THEN = 371;
+const int YY_Parser_CLASS::TIME = 372;
+const int YY_Parser_CLASS::TIMESTAMP = 373;
+const int YY_Parser_CLASS::TINYINT = 374;
+const int YY_Parser_CLASS::TO = 375;
+const int YY_Parser_CLASS::TRUNCATE = 376;
+const int YY_Parser_CLASS::UNION = 377;
+const int YY_Parser_CLASS::PUBLIC = 378;
+const int YY_Parser_CLASS::REAL = 379;
+const int YY_Parser_CLASS::REFERENCES = 380;
+const int YY_Parser_CLASS::RENAME = 381;
+const int YY_Parser_CLASS::RESTORE = 382;
+const int YY_Parser_CLASS::REVOKE = 383;
+const int YY_Parser_CLASS::ROLE = 384;
+const int YY_Parser_CLASS::ROLLBACK = 385;
+const int YY_Parser_CLASS::SCHEMA = 386;
+const int YY_Parser_CLASS::SELECT = 387;
+const int YY_Parser_CLASS::SET = 388;
+const int YY_Parser_CLASS::SHARD = 389;
+const int YY_Parser_CLASS::SHARED = 390;
+const int YY_Parser_CLASS::SHOW = 391;
+const int YY_Parser_CLASS::UNIQUE = 392;
+const int YY_Parser_CLASS::UPDATE = 393;
+const int YY_Parser_CLASS::USER = 394;
+const int YY_Parser_CLASS::VALIDATE = 395;
+const int YY_Parser_CLASS::VALUES = 396;
+const int YY_Parser_CLASS::VIEW = 397;
+const int YY_Parser_CLASS::WHEN = 398;
+const int YY_Parser_CLASS::WHENEVER = 399;
+const int YY_Parser_CLASS::WHERE = 400;
+const int YY_Parser_CLASS::WITH = 401;
+const int YY_Parser_CLASS::WORK = 402;
+const int YY_Parser_CLASS::EDIT = 403;
+const int YY_Parser_CLASS::ACCESS = 404;
+const int YY_Parser_CLASS::DASHBOARD = 405;
+const int YY_Parser_CLASS::SQL = 406;
+const int YY_Parser_CLASS::EDITOR = 407;
+
+/* const YY_Parser_CLASS::token */
+#endif
+/*apres const  */
+YY_Parser_CLASS::YY_Parser_CLASS(YY_Parser_CONSTRUCTOR_PARAM) YY_Parser_CONSTRUCTOR_INIT {
+#if YY_Parser_DEBUG != 0
+  YY_Parser_DEBUG_FLAG = 0;
+#endif
+  YY_Parser_CONSTRUCTOR_CODE;
+};
+#endif
+
+#define YYFINAL 686
+#define YYFLAG -32768
+#define YYNTBASE 167
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 407 ? yytranslate[x] : 288)
+
+static const short yytranslate[] = {
+    0,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   21,  2,   2,   159, 160, 19,  17,  161, 18,  166, 20,  2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   158, 2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   162, 2,   163, 2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   164, 2,   165, 2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+    2,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,
+    22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,
+    39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,
+    56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,
+    73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
+    90,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106,
+    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,
+    124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140,
+    141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157};
+
+#if YY_Parser_DEBUG != 0
+static const short yyprhs[] = {
+    0,    0,    3,    7,    9,    11,   13,   15,   17,   19,   21,   23,   25,   27,
+    29,   31,   33,   35,   37,   39,   41,   43,   45,   47,   49,   51,   53,   55,
+    57,   59,   61,   63,   68,   76,   81,   88,   95,   99,   106,  113,  115,  119,
+    123,  127,  128,  130,  131,  140,  150,  160,  170,  175,  178,  179,  184,  188,
+    195,  204,  205,  207,  209,  213,  220,  228,  233,  235,  239,  243,  249,  257,
+    259,  261,  268,  275,  279,  283,  291,  299,  304,  309,  314,  318,  320,  324,
+    326,  328,  332,  337,  340,  346,  347,  350,  354,  359,  362,  365,  368,  373,
+    376,  382,  387,  393,  401,  412,  418,  429,  434,  436,  440,  445,  446,  451,
+    452,  456,  457,  461,  463,  467,  471,  475,  476,  478,  480,  481,  484,  487,
+    489,  491,  493,  495,  497,  502,  511,  517,  518,  520,  522,  524,  528,  532,
+    538,  539,  541,  544,  547,  548,  551,  555,  556,  561,  563,  567,  572,  574,
+    578,  586,  588,  590,  593,  595,  599,  601,  604,  607,  608,  612,  614,  618,
+    619,  622,  626,  630,  633,  637,  639,  641,  643,  645,  647,  649,  651,  653,
+    655,  659,  663,  670,  676,  682,  687,  693,  698,  699,  702,  707,  711,  716,
+    720,  727,  733,  735,  739,  744,  749,  751,  753,  755,  757,  759,  762,  766,
+    771,  777,  780,  781,  786,  795,  802,  807,  812,  817,  821,  825,  829,  833,
+    837,  844,  847,  850,  852,  854,  856,  860,  867,  869,  871,  873,  874,  876,
+    879,  883,  884,  886,  890,  892,  894,  899,  905,  911,  916,  918,  920,  924,
+    929,  931,  933,  935,  938,  942,  947,  949,  951,  955,  956,  958,  960,  962,
+    963,  965,  967,  969,  971,  973,  975,  979,  981,  983,  985,  989,  991,  993,
+    995,  999,  1001, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018, 1020, 1022, 1024,
+    1026, 1029, 1032, 1035, 1038, 1041, 1044, 1047, 1050, 1053, 1056, 1059, 1063, 1065,
+    1067, 1069, 1071, 1073, 1075, 1077, 1079, 1083, 1087, 1089, 1091, 1093, 1095, 1097,
+    1102, 1104, 1109, 1116, 1118, 1123, 1130, 1132, 1134, 1136, 1138, 1140, 1143, 1145,
+    1147, 1149, 1154, 1156, 1161, 1163, 1165, 1169, 1174, 1176, 1178, 1180, 1182, 1187,
+    1194, 1199, 1206, 1208, 1210};
+
+static const short yyrhs[] = {
+    168, 158, 0,   167, 168, 158, 0,   179, 0,   180, 0,   181, 0,   182, 0,   214, 0,
+    184, 0,   185, 0,   186, 0,   187, 0,   190, 0,   191, 0,   194, 0,   169, 0,   170,
+    0,   171, 0,   172, 0,   173, 0,   174, 0,   198, 0,   199, 0,   200, 0,   201, 0,
+    202, 0,   204, 0,   205, 0,   203, 0,   196, 0,   197, 0,   48,  51,  177, 3,   0,
+    48,  51,  177, 3,   159, 175, 160, 0,   64,  51,  183, 3,   0,   25,  51,  3,   131,
+    125, 3,   0,   48,  144, 272, 159, 175, 160, 0,   64,  144, 272, 0,   25,  144, 272,
+    159, 175, 160, 0,   25,  144, 272, 131, 125, 272, 0,   176, 0,   175, 161, 176, 0,
+    3,   15,  267, 0,   82,  14,  68,  0,   0,   119, 0,   0,   48,  178, 118, 177, 270,
+    30,  8,   213, 0,   48,  178, 118, 177, 270, 159, 206, 160, 213, 0,   48,  3,   118,
+    177, 270, 159, 206, 160, 213, 0,   48,  52,  270, 159, 206, 160, 76,  6,   213, 0,
+    141, 48,  118, 270, 0,   82,  68,  0,   0,   64,  118, 183, 270, 0,   126, 118, 270,
+    0,   25,  118, 270, 131, 125, 270, 0,   25,  118, 270, 131, 44,  286, 125, 286, 0,
+    0,   44,  0,   208, 0,   189, 161, 208, 0,   25,  118, 270, 23,  188, 208, 0,   25,
+    118, 270, 23,  159, 189, 160, 0,   25,  118, 270, 192, 0,   193, 0,   192, 161, 193,
+    0,   64,  188, 286, 0,   47,  270, 76,  6,   213, 0,   47,  159, 7,   160, 125, 6,
+    213, 0,   65,  0,   28,  0,   195, 118, 270, 125, 6,   213, 0,   132, 118, 270, 76,
+    6,   213, 0,   48,  134, 274, 0,   64,  134, 274, 0,   79,  277, 102, 279, 280, 125,
+    275, 0,   133, 277, 102, 279, 280, 76,  275, 0,   79,  273, 125, 275, 0,   133, 273,
+    76,  275, 0,   104, 118, 271, 213, 0,   145, 43,  213, 0,   207, 0,   206, 161, 207,
+    0,   208, 0,   211, 0,   286, 283, 209, 0,   286, 283, 210, 209, 0,   3,   3,   0,
+    3,   3,   159, 10,  160, 0,   0,   14,  98,  0,   14,  98,  142, 0,   14,  98,  112,
+    3,   0,   58,  267, 0,   58,  98,  0,   58,  144, 0,   41,  159, 243, 160, 0,   130,
+    270, 0,   130, 270, 159, 286, 160, 0,   142, 159, 212, 160, 0,   112, 3,   159, 212,
+    160, 0,   74,  3,   159, 212, 160, 130, 270, 0,   74,  3,   159, 212, 160, 130, 270,
+    159, 212, 160, 0,   139, 3,   159, 286, 160, 0,   140, 61,  159, 286, 160, 130, 270,
+    159, 286, 160, 0,   41,  159, 243, 160, 0,   286, 0,   212, 161, 286, 0,   151, 159,
+    175, 160, 0,   0,   64,  147, 183, 270, 0,   0,   159, 212, 160, 0,   0,   107, 36,
+    217, 0,   218, 0,   217, 161, 218, 0,   10,  219, 220, 0,   281, 219, 220, 0,   0,
+    31,  0,   60,  0,   0,   98,  71,  0,   98,  90,  0,   221, 0,   222, 0,   223, 0,
+    231, 0,   227, 0,   59,  76,  270, 228, 0,   85,  87,  270, 215, 146, 159, 251, 160,
+    0,   85,  87,  270, 215, 8,   0,   0,   24,  0,   62,  0,   226, 0,   225, 161, 226,
+    0,   286, 15,  243, 0,   143, 270, 138, 225, 228, 0,   0,   239, 0,   93,  10,  0,
+    93,  24,  0,   0,   101, 10,  0,   101, 10,  3,   0,   0,   232, 216, 229, 230, 0,
+    233, 0,   232, 127, 233, 0,   232, 127, 24,  233, 0,   234, 0,   159, 232, 160, 0,
+    137, 224, 235, 236, 228, 240, 242, 0,   264, 0,   19,  0,   76,  237, 0,   238, 0,
+    237, 161, 238, 0,   270, 0,   270, 287, 0,   150, 243, 0,   0,   80,  36,  241, 0,
+    243, 0,   241, 161, 243, 0,   0,   81,  243, 0,   243, 12,  243, 0,   243, 13,  243,
+    0,   14,  243, 0,   159, 243, 160, 0,   244, 0,   245, 0,   246, 0,   247, 0,   249,
+    0,   250, 0,   252, 0,   255, 0,   262, 0,   262, 253, 262, 0,   262, 253, 256, 0,
+    262, 14,  33,  262, 13,  262, 0,   262, 33,  262, 13,  262, 0,   262, 14,  92,  265,
+    248, 0,   262, 92,  265, 248, 0,   262, 14,  83,  265, 248, 0,   262, 83,  265, 248,
+    0,   0,   3,   265, 0,   281, 88,  14,  98,  0,   281, 88,  98,  0,   262, 14,  84,
+    256, 0,   262, 84,  256, 0,   262, 14,  84,  159, 251, 160, 0,   262, 84,  159, 251,
+    160, 0,   265, 0,   251, 161, 265, 0,   262, 253, 254, 256, 0,   262, 253, 254, 262,
+    0,   15,  0,   16,  0,   27,  0,   24,  0,   117, 0,   68,  256, 0,   159, 234, 160,
+    0,   148, 243, 121, 243, 0,   257, 148, 243, 121, 243, 0,   66,  243, 0,   0,   37,
+    257, 258, 67,  0,   82,  159, 243, 161, 243, 161, 243, 160, 0,   82,  159, 243, 161,
+    243, 160, 0,   39,  159, 262, 160, 0,   91,  159, 262, 160, 0,   281, 162, 262, 163,
+    0,   262, 17,  262, 0,   262, 18,  262, 0,   262, 19,  262, 0,   262, 20,  262, 0,
+    262, 21,  262, 0,   95,  159, 262, 161, 262, 160, 0,   17,  262, 0,   18,  262, 0,
+    265, 0,   281, 0,   266, 0,   159, 262, 160, 0,   38,  159, 243, 30,  283, 160, 0,
+    259, 0,   260, 0,   261, 0,   0,   243, 0,   243, 3,   0,   243, 30,  3,   0,   0,
+    263, 0,   264, 161, 263, 0,   267, 0,   144, 0,   3,   159, 19,  160, 0,   3,   159,
+    62,  243, 160, 0,   3,   159, 24,  243, 160, 0,   3,   159, 243, 160, 0,   6,   0,
+    10,  0,   97,  159, 160, 0,   54,  159, 243, 160, 0,   11,  0,   72,  0,   63,  0,
+    283, 6,   0,   164, 269, 165, 0,   29,  162, 269, 163, 0,   98,  0,   267, 0,   268,
+    161, 267, 0,   0,   268, 0,   3,   0,   9,   0,   0,   270, 0,   3,   0,   5,   0,
+    4,   0,   9,   0,   274, 0,   273, 161, 274, 0,   3,   0,   4,   0,   276, 0,   275,
+    161, 276, 0,   272, 0,   274, 0,   278, 0,   277, 161, 278, 0,   24,  0,   24,  113,
+    0,   48,  0,   137, 0,   85,  0,   126, 0,   143, 0,   59,  0,   25,  0,   64,  0,
+    147, 0,   153, 0,   154, 0,   25,  115, 0,   48,  115, 0,   48,  118, 0,   48,  147,
+    0,   137, 147, 0,   64,  147, 0,   64,  115, 0,   48,  155, 0,   153, 155, 0,   147,
+    155, 0,   59,  155, 0,   147, 156, 157, 0,   51,  0,   118, 0,   155, 0,   147, 0,
+    115, 0,   3,   0,   10,  0,   3,   0,   3,   166, 3,   0,   3,   166, 19,  0,   10,
+    0,   34,  0,   120, 0,   35,  0,   40,  0,   40,  159, 282, 160, 0,   99,  0,   99,
+    159, 282, 160, 0,   99,  159, 282, 161, 282, 160, 0,   56,  0,   56,  159, 282, 160,
+    0,   56,  159, 282, 161, 282, 160, 0,   86,  0,   124, 0,   116, 0,   72,  0,   129,
+    0,   63,  111, 0,   63,  0,   53,  0,   122, 0,   122, 159, 282, 160, 0,   123, 0,
+    123, 159, 282, 160, 0,   284, 0,   285, 0,   283, 162, 163, 0,   283, 162, 282, 163,
+    0,   109, 0,   94,  0,   110, 0,   96,  0,   77,  159, 284, 160, 0,   77,  159, 284,
+    161, 10,  160, 0,   78,  159, 284, 160, 0,   78,  159, 284, 161, 10,  160, 0,   3,
+    0,   9,   0,   3,   0};
+
+#endif
+
+#if YY_Parser_DEBUG != 0
+static const short yyrline[] = {
+    0,    120,  122,  130,  132,  133,  134,  136,  137,  138,  139,  140,  141,  142,
+    143,  144,  145,  146,  147,  148,  149,  150,  151,  152,  153,  154,  155,  156,
+    157,  158,  159,  185,  190,  195,  201,  208,  214,  220,  225,  232,  237,  243,
+    246,  248,  251,  253,  256,  263,  268,  274,  281,  287,  289,  292,  298,  304,
+    311,  318,  319,  321,  323,  330,  335,  341,  345,  347,  350,  353,  358,  368,
+    369,  371,  378,  385,  391,  397,  403,  409,  415,  422,  429,  436,  438,  445,
+    447,  450,  453,  457,  465,  472,  475,  477,  478,  484,  485,  486,  487,  488,
+    489,  492,  495,  501,  508,  514,  522,  529,  533,  535,  542,  545,  549,  556,
+    558,  613,  615,  618,  620,  627,  630,  634,  636,  637,  640,  642,  643,  648,
+    651,  657,  660,  662,  683,  688,  693,  715,  717,  718,  728,  731,  738,  743,
+    759,  761,  764,  766,  767,  769,  771,  778,  784,  791,  793,  795,  799,  801,
+    804,  816,  818,  821,  825,  827,  834,  836,  839,  843,  845,  848,  850,  857,
+    859,  864,  867,  869,  871,  872,  875,  877,  878,  879,  880,  881,  882,  883,
+    886,  889,  896,  899,  903,  906,  908,  910,  914,  916,  928,  930,  933,  936,
+    948,  950,  954,  956,  963,  968,  974,  976,  979,  981,  982,  985,  989,  993,
+    998,  1004, 1006, 1009, 1013, 1018, 1025, 1027, 1032, 1040, 1042, 1043, 1044, 1045,
+    1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1055, 1056, 1057, 1060, 1062, 1063,
+    1064, 1067, 1069, 1070, 1077, 1079, 1092, 1094, 1095, 1096, 1099, 1101, 1102, 1103,
+    1104, 1105, 1106, 1107, 1108, 1109, 1110, 1113, 1115, 1122, 1124, 1129, 1139, 1142,
+    1144, 1146, 1147, 1147, 1147, 1150, 1152, 1159, 1160, 1163, 1165, 1172, 1173, 1176,
+    1178, 1185, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198,
+    1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1213, 1215,
+    1216, 1217, 1218, 1221, 1223, 1227, 1229, 1230, 1234, 1243, 1245, 1246, 1247, 1248,
+    1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1260, 1261, 1262, 1263,
+    1264, 1265, 1266, 1267, 1268, 1270, 1271, 1278, 1288, 1289, 1290, 1291, 1294, 1296,
+    1299, 1301, 1306, 1315, 1330};
+
+static const char* const yytname[] = {"$",
+                                      "error",
+                                      "$illegal.",
+                                      "NAME",
+                                      "DASHEDNAME",
+                                      "EMAIL",
+                                      "STRING",
+                                      "FWDSTR",
+                                      "SELECTSTRING",
+                                      "QUOTED_IDENTIFIER",
+                                      "INTNUM",
+                                      "FIXEDNUM",
+                                      "OR",
+                                      "AND",
+                                      "NOT",
+                                      "EQUAL",
+                                      "COMPARISON",
+                                      "'+'",
+                                      "'-'",
+                                      "'*'",
+                                      "'/'",
+                                      "'%'",
+                                      "UMINUS",
+                                      "ADD",
+                                      "ALL",
+                                      "ALTER",
+                                      "AMMSC",
+                                      "ANY",
+                                      "ARCHIVE",
+                                      "ARRAY",
+                                      "AS",
+                                      "ASC",
+                                      "AUTHORIZATION",
+                                      "BETWEEN",
+                                      "BIGINT",
+                                      "BOOLEAN",
+                                      "BY",
+                                      "CASE",
+                                      "CAST",
+                                      "CHAR_LENGTH",
+                                      "CHARACTER",
+                                      "CHECK",
+                                      "CLOSE",
+                                      "CLUSTER",
+                                      "COLUMN",
+                                      "COMMIT",
+                                      "CONTINUE",
+                                      "COPY",
+                                      "CREATE",
+                                      "CURRENT",
+                                      "CURSOR",
+                                      "DATABASE",
+                                      "DATAFRAME",
+                                      "DATE",
+                                      "DATETIME",
+                                      "DATE_TRUNC",
+                                      "DECIMAL",
+                                      "DECLARE",
+                                      "DEFAULT",
+                                      "DELETE",
+                                      "DESC",
+                                      "DICTIONARY",
+                                      "DISTINCT",
+                                      "DOUBLE",
+                                      "DROP",
+                                      "DUMP",
+                                      "ELSE",
+                                      "END",
+                                      "EXISTS",
+                                      "EXTRACT",
+                                      "FETCH",
+                                      "FIRST",
+                                      "FLOAT",
+                                      "FOR",
+                                      "FOREIGN",
+                                      "FOUND",
+                                      "FROM",
+                                      "GEOGRAPHY",
+                                      "GEOMETRY",
+                                      "GRANT",
+                                      "GROUP",
+                                      "HAVING",
+                                      "IF",
+                                      "ILIKE",
+                                      "IN",
+                                      "INSERT",
+                                      "INTEGER",
+                                      "INTO",
+                                      "IS",
+                                      "LANGUAGE",
+                                      "LAST",
+                                      "LENGTH",
+                                      "LIKE",
+                                      "LIMIT",
+                                      "LINESTRING",
+                                      "MOD",
+                                      "MULTIPOLYGON",
+                                      "NOW",
+                                      "NULLX",
+                                      "NUMERIC",
+                                      "OF",
+                                      "OFFSET",
+                                      "ON",
+                                      "OPEN",
+                                      "OPTIMIZE",
+                                      "OPTIMIZED",
+                                      "OPTION",
+                                      "ORDER",
+                                      "PARAMETER",
+                                      "POINT",
+                                      "POLYGON",
+                                      "PRECISION",
+                                      "PRIMARY",
+                                      "PRIVILEGES",
+                                      "PROCEDURE",
+                                      "SERVER",
+                                      "SMALLINT",
+                                      "SOME",
+                                      "TABLE",
+                                      "TEMPORARY",
+                                      "TEXT",
+                                      "THEN",
+                                      "TIME",
+                                      "TIMESTAMP",
+                                      "TINYINT",
+                                      "TO",
+                                      "TRUNCATE",
+                                      "UNION",
+                                      "PUBLIC",
+                                      "REAL",
+                                      "REFERENCES",
+                                      "RENAME",
+                                      "RESTORE",
+                                      "REVOKE",
+                                      "ROLE",
+                                      "ROLLBACK",
+                                      "SCHEMA",
+                                      "SELECT",
+                                      "SET",
+                                      "SHARD",
+                                      "SHARED",
+                                      "SHOW",
+                                      "UNIQUE",
+                                      "UPDATE",
+                                      "USER",
+                                      "VALIDATE",
+                                      "VALUES",
+                                      "VIEW",
+                                      "WHEN",
+                                      "WHENEVER",
+                                      "WHERE",
+                                      "WITH",
+                                      "WORK",
+                                      "EDIT",
+                                      "ACCESS",
+                                      "DASHBOARD",
+                                      "SQL",
+                                      "EDITOR",
+                                      "';'",
+                                      "'('",
+                                      "')'",
+                                      "','",
+                                      "'['",
+                                      "']'",
+                                      "'{'",
+                                      "'}'",
+                                      "'.'",
+                                      "sql_list",
+                                      "sql",
+                                      "create_database_statement",
+                                      "drop_database_statement",
+                                      "rename_database_statement",
+                                      "create_user_statement",
+                                      "drop_user_statement",
+                                      "alter_user_statement",
+                                      "name_eq_value_list",
+                                      "name_eq_value",
+                                      "opt_if_not_exists",
+                                      "opt_temporary",
+                                      "create_table_as_statement",
+                                      "create_table_statement",
+                                      "create_dataframe_statement",
+                                      "show_table_schema",
+                                      "opt_if_exists",
+                                      "drop_table_statement",
+                                      "truncate_table_statement",
+                                      "rename_table_statement",
+                                      "rename_column_statement",
+                                      "opt_column",
+                                      "column_defs",
+                                      "add_column_statement",
+                                      "drop_column_statement",
+                                      "drop_columns",
+                                      "drop_column",
+                                      "copy_table_statement",
+                                      "dump_or_archive",
+                                      "dump_table_statement",
+                                      "restore_table_statement",
+                                      "create_role_statement",
+                                      "drop_role_statement",
+                                      "grant_privileges_statement",
+                                      "revoke_privileges_statement",
+                                      "grant_role_statement",
+                                      "revoke_role_statement",
+                                      "optimize_table_statement",
+                                      "validate_system_statement",
+                                      "base_table_element_commalist",
+                                      "base_table_element",
+                                      "column_def",
+                                      "opt_compression",
+                                      "column_constraint_def",
+                                      "table_constraint_def",
+                                      "column_commalist",
+                                      "opt_with_option_list",
+                                      "drop_view_statement",
+                                      "opt_column_commalist",
+                                      "opt_order_by_clause",
+                                      "ordering_spec_commalist",
+                                      "ordering_spec",
+                                      "opt_asc_desc",
+                                      "opt_null_order",
+                                      "manipulative_statement",
+                                      "delete_statement",
+                                      "insert_statement",
+                                      "opt_all_distinct",
+                                      "assignment_commalist",
+                                      "assignment",
+                                      "update_statement",
+                                      "opt_where_clause",
+                                      "opt_limit_clause",
+                                      "opt_offset_clause",
+                                      "select_statement",
+                                      "query_exp",
+                                      "query_term",
+                                      "query_spec",
+                                      "selection",
+                                      "from_clause",
+                                      "table_ref_commalist",
+                                      "table_ref",
+                                      "where_clause",
+                                      "opt_group_by_clause",
+                                      "exp_commalist",
+                                      "opt_having_clause",
+                                      "general_exp",
+                                      "predicate",
+                                      "comparison_predicate",
+                                      "between_predicate",
+                                      "like_predicate",
+                                      "opt_escape",
+                                      "test_for_null",
+                                      "in_predicate",
+                                      "atom_commalist",
+                                      "all_or_any_predicate",
+                                      "comparison",
+                                      "any_all_some",
+                                      "existence_test",
+                                      "subquery",
+                                      "when_then_list",
+                                      "opt_else_expr",
+                                      "case_exp",
+                                      "charlength_exp",
+                                      "array_at_exp",
+                                      "scalar_exp",
+                                      "select_entry",
+                                      "select_entry_commalist",
+                                      "atom",
+                                      "function_ref",
+                                      "literal",
+                                      "literal_commalist",
+                                      "opt_literal_commalist",
+                                      "table",
+                                      "opt_table",
+                                      "username",
+                                      "rolenames",
+                                      "rolename",
+                                      "grantees",
+                                      "grantee",
+                                      "privileges",
+                                      "privilege",
+                                      "privileges_target_type",
+                                      "privileges_target",
+                                      "column_ref",
+                                      "non_neg_int",
+                                      "data_type",
+                                      "geo_type",
+                                      "geometry_type",
+                                      "column",
+                                      "range_variable",
+                                      "range_variable"};
+#endif
+
+static const short yyr1[] = {
+    0,   167, 167, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
+    168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 169, 169, 170,
+    171, 172, 173, 174, 174, 175, 175, 176, 177, 177, 178, 178, 179, 180, 180, 181, 182,
+    183, 183, 184, 185, 186, 187, 188, 188, 189, 189, 190, 190, 191, 192, 192, 193, 194,
+    194, 195, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 206, 207, 207,
+    208, 208, 209, 209, 209, 210, 210, 210, 210, 210, 210, 210, 210, 210, 211, 211, 211,
+    211, 211, 211, 211, 212, 212, 213, 213, 214, 215, 215, 216, 216, 217, 217, 218, 218,
+    219, 219, 219, 220, 220, 220, 168, 221, 221, 221, 221, 222, 223, 223, 224, 224, 224,
+    225, 225, 226, 227, 228, 228, 229, 229, 229, 230, 230, 230, 231, 232, 232, 232, 233,
+    233, 234, 235, 235, 236, 237, 237, 238, 238, 239, 240, 240, 241, 241, 242, 242, 243,
+    243, 243, 243, 243, 244, 244, 244, 244, 244, 244, 244, 244, 245, 245, 246, 246, 247,
+    247, 247, 247, 248, 248, 249, 249, 250, 250, 250, 250, 251, 251, 252, 252, 253, 253,
+    254, 254, 254, 255, 256, 257, 257, 258, 258, 259, 259, 259, 260, 260, 261, 262, 262,
+    262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 263, 263, 263,
+    263, 264, 264, 264, 265, 265, 266, 266, 266, 266, 267, 267, 267, 267, 267, 267, 267,
+    267, 267, 267, 267, 268, 268, 269, 269, 270, 270, 271, 271, 272, 272, 272, 272, 273,
+    273, 274, 274, 275, 275, 276, 276, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278,
+    278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
+    279, 279, 279, 279, 279, 280, 280, 281, 281, 281, 282, 283, 283, 283, 283, 283, 283,
+    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
+    283, 283, 283, 283, 284, 284, 284, 284, -1,  -1,  285, 285, 286, 286, 287};
+
+static const short yyr2[] = {
+    0, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1,  1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 4, 7, 4, 6, 6, 3, 6, 6, 1, 3, 3, 3, 0, 1, 0, 8,  9, 9,  9, 4, 2, 0, 4, 3, 6,
+    8, 0, 1, 1, 3, 6, 7, 4, 1, 3, 3, 5, 7, 1, 1, 6, 6, 3, 3,  7, 7,  4, 4, 4, 3, 1, 3, 1,
+    1, 3, 4, 2, 5, 0, 2, 3, 4, 2, 2, 2, 4, 2, 5, 4, 5, 7, 10, 5, 10, 4, 1, 3, 4, 0, 4, 0,
+    3, 0, 3, 1, 3, 3, 3, 0, 1, 1, 0, 2, 2, 1, 1, 1, 1, 1, 4,  8, 5,  0, 1, 1, 1, 3, 3, 5,
+    0, 1, 2, 2, 0, 2, 3, 0, 4, 1, 3, 4, 1, 3, 7, 1, 1, 2, 1,  3, 1,  2, 2, 0, 3, 1, 3, 0,
+    2, 3, 3, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 6, 5, 5,  4, 5,  4, 0, 2, 4, 3, 4, 3,
+    6, 5, 1, 3, 4, 4, 1, 1, 1, 1, 1, 2, 3, 4, 5, 2, 0, 4, 8,  6, 4,  4, 4, 3, 3, 3, 3, 3,
+    6, 2, 2, 1, 1, 1, 3, 6, 1, 1, 1, 0, 1, 2, 3, 0, 1, 3, 1,  1, 4,  5, 5, 4, 1, 1, 3, 4,
+    1, 1, 1, 2, 3, 4, 1, 1, 3, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,  1, 3,  1, 1, 1, 3, 1, 1, 1,
+    3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,  2, 2,  2, 2, 2, 2, 3, 1, 1,
+    1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 4, 1, 4, 6, 1, 4,  6, 1,  1, 1, 1, 1, 2, 1, 1,
+    1, 4, 1, 4, 1, 1, 3, 4, 1, 1, 1, 1, 4, 6, 4, 6, 1, 1, 1};
+
+static const short yydefact[] = {
+    0,   0,   70,  0,   45,  0,   0,   69,  0,   0,   0,   0,   0,   0,   133, 0,   0,
+    0,   0,   0,   0,   15,  16,  17,  18,  19,  20,  3,   4,   5,   6,   8,   9,   10,
+    11,  12,  13,  14,  0,   29,  30,  21,  22,  23,  24,  25,  28,  26,  27,  7,   125,
+    126, 127, 129, 128, 113, 149, 152, 0,   0,   0,   263, 264, 0,   0,   0,   43,  0,
+    44,  0,   0,   0,   0,   52,  52,  0,   0,   52,  273, 274, 281, 289, 283, 288, 290,
+    285, 286, 284, 287, 291, 292, 293, 0,   271, 0,   279, 0,   265, 0,   0,   0,   0,
+    134, 135, 235, 0,   0,   109, 0,   0,   1,   0,   0,   0,   144, 0,   0,   267, 269,
+    268, 270, 0,   0,   0,   43,  0,   0,   0,   73,  0,   43,  140, 0,   0,   0,   74,
+    36,  0,   282, 294, 295, 296, 297, 301, 304, 300, 299, 298, 303, 0,   302, 0,   0,
+    0,   0,   111, 266, 109, 54,  0,   0,   0,   313, 248, 249, 252, 0,   0,   0,   156,
+    0,   317, 319, 0,   0,   0,   320, 335, 0,   325, 254, 0,   253, 0,   0,   328, 0,
+    345, 0,   347, 0,   258, 322, 344, 346, 330, 318, 336, 338, 329, 332, 243, 0,   261,
+    0,   236, 173, 174, 175, 176, 177, 178, 179, 180, 232, 233, 234, 181, 240, 155, 227,
+    229, 242, 228, 0,   340, 341, 0,   0,   0,   80,  153, 2,   0,   0,   0,   150, 0,
+    147, 0,   57,  57,  0,   63,  64,  0,   0,   0,   109, 0,   0,   31,  0,   0,   0,
+    0,   130, 141, 51,  33,  53,  110, 305, 267, 269, 277, 278, 77,  275, 272, 306, 310,
+    307, 309, 308, 0,   280, 0,   0,   79,  0,   78,  0,   0,   0,   171, 0,   225, 228,
+    226, 261, 0,   212, 0,   0,   0,   0,   0,   333, 0,   207, 0,   0,   0,   0,   0,
+    0,   0,   0,   0,   181, 259, 262, 0,   0,   140, 237, 0,   0,   0,   0,   202, 203,
+    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   235, 0,   0,   255, 0,   50,  352,
+    353, 140, 136, 0,   0,   0,   313, 119, 114, 115, 119, 151, 142, 143, 0,   148, 0,
+    58,  0,   0,   0,   0,   0,   0,   0,   0,   0,   39,  0,   67,  0,   42,  0,   0,
+    0,   0,   0,   0,   0,   0,   81,  83,  84,  0,   0,   0,   162, 0,   311, 312, 0,
+    0,   106, 132, 0,   109, 0,   0,   0,   0,   0,   314, 315, 0,   0,   0,   0,   0,
+    0,   0,   0,   316, 0,   0,   0,   0,   0,   0,   0,   0,   250, 0,   0,   0,   172,
+    230, 0,   256, 157, 158, 160, 163, 169, 170, 238, 0,   0,   0,   0,   219, 220, 221,
+    222, 223, 0,   190, 0,   195, 190, 205, 204, 206, 0,   0,   183, 182, 241, 0,   193,
+    0,   342, 0,   0,   139, 0,   0,   109, 120, 121, 122, 0,   122, 145, 34,  0,   59,
+    61,  66,  0,   55,  65,  38,  0,   37,  0,   109, 0,   0,   0,   0,   0,   0,   0,
+    0,   0,   0,   334, 331, 89,  35,  0,   0,   276, 0,   112, 0,   0,   72,  0,   244,
+    0,   0,   247, 257, 0,   211, 0,   213, 0,   216, 321, 251, 326, 0,   208, 350, 0,
+    0,   217, 0,   323, 0,   337, 339, 260, 0,   354, 161, 0,   167, 0,   190, 0,   194,
+    190, 0,   0,   189, 0,   198, 187, 200, 201, 192, 218, 343, 137, 138, 108, 71,  0,
+    117, 116, 118, 146, 62,  0,   0,   41,  40,  68,  0,   32,  0,   0,   0,   0,   0,
+    0,   0,   82,  0,   0,   0,   0,   0,   85,  89,  109, 0,   75,  107, 0,   76,  246,
+    245, 209, 0,   0,   0,   0,   0,   0,   0,   159, 0,   0,   154, 0,   188, 0,   186,
+    185, 191, 197, 0,   123, 124, 60,  56,  109, 105, 0,   0,   0,   0,   99,  109, 87,
+    90,  0,   94,  95,  93,  97,  86,  46,  109, 131, 210, 231, 327, 351, 215, 0,   224,
+    324, 164, 165, 168, 184, 196, 199, 48,  0,   100, 103, 0,   49,  0,   0,   91,  0,
+    0,   47,  0,   0,   0,   0,   0,   92,  96,  0,   214, 166, 101, 0,   88,  98,  0,
+    0,   0,   0,   102, 104, 0,   0};
+
+static const short yydefgoto[] = {
+    19,  20,  21,  22,  23,  24,  25,  26,  366, 367, 126, 71,  27,  28,  29,  30,
+    133, 31,  32,  33,  34,  359, 474, 35,  36,  243, 244, 37,  38,  39,  40,  41,
+    42,  43,  44,  45,  46,  47,  48,  379, 380, 381, 586, 587, 382, 391, 230, 49,
+    278, 114, 348, 349, 469, 561, 50,  51,  52,  104, 341, 342, 53,  256, 238, 355,
+    54,  55,  56,  57,  204, 315, 428, 429, 257, 539, 647, 607, 205, 206, 207, 208,
+    209, 547, 210, 211, 548, 212, 332, 453, 213, 300, 292, 408, 214, 215, 216, 217,
+    218, 219, 220, 221, 222, 312, 313, 430, 157, 265, 92,  266, 267, 268, 94,  95,
+    275, 390, 223, 412, 224, 225, 226, 383, 537};
+
+static const short yypact[] = {
+    1499,   167,    -32768, 13,     204,    -39,    160,    -32768, 277,    -7,
+    18,     41,     103,    277,    28,     127,    317,    188,    139,    268,
+    107,    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
+    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, 172,    -32768,
+    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
+    -32768, -32768, -32768, -32768, -32768, 192,    -32768, -32768, 300,    317,
+    431,    -32768, -32768, 324,    280,    272,    262,    317,    -32768, 336,
+    431,    274,    317,    288,    288,    336,    431,    288,    -32768, -32768,
+    286,    289,    132,    271,    117,    -32768, -32768, 260,    -32768, -84,
+    282,    -32768, -38,    -32768, 97,     -32768, 317,    317,    317,    317,
+    -6,     123,    -32768, -32768, 604,    292,    322,    314,    77,     265,
+    -32768, 317,    441,    58,     374,    347,    66,     -32768, -32768, -32768,
+    -32768, 55,     325,    482,    262,    485,    493,    353,    -32768, 362,
+    262,    378,    433,    528,    317,    -32768, -32768, 317,    -32768, -32768,
+    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, 390,
+    -32768, 445,    336,    270,    752,    392,    -32768, 314,    -32768, 477,
+    445,    270,    171,    -32768, -32768, -32768, 829,    1054,   1054,   -32768,
+    393,    -32768, -32768, 404,    397,    398,    400,    -32768, 402,    405,
+    11,     406,    20,     407,    409,    -32768, 410,    -32768, 417,    -32768,
+    418,    -32768, 419,    -32768, -32768, -32768, -32768, 420,    421,    -32768,
+    -32768, -32768, 829,    1463,   487,    305,    -32768, -32768, -32768, -32768,
+    -32768, -32768, -32768, -32768, -32768, -32768, -32768, 633,    -32768, 422,
+    -32768, -32768, -32768, -57,    21,     -32768, -32768, 317,    319,    425,
+    -32768, -32768, -32768, 456,    342,    139,    -32768, 230,    488,    466,
+    44,     549,    35,     434,    -32768, 469,    594,    478,    314,    317,
+    533,    443,    448,    594,    317,    829,    -32768, -32768, -32768, -32768,
+    -32768, -32768, -32768, -32768, -32768, -32768, -32768, 447,    -32768, -32768,
+    -32768, -32768, -32768, -32768, -32768, 351,    -32768, 319,    45,     -32768,
+    598,    447,    351,    476,    65,     -32768, 1054,   -32768, 444,    -32768,
+    1463,   829,    75,     829,    1054,   599,    829,    599,    -32768, 474,
+    -32768, 312,    829,    1054,   1054,   452,    599,    599,    599,    27,
+    360,    -32768, 458,    451,    317,    378,    -32768, 829,    829,    610,
+    183,    -32768, -32768, 1054,   1054,   1054,   1054,   1054,   1054,   1307,
+    465,    1307,   732,    829,    112,    1054,   -32768, -2,     -32768, -32768,
+    -32768, 136,    -32768, 602,    594,    619,    460,    68,     467,    -32768,
+    68,     -32768, -32768, -32768, 617,    -32768, 626,    -32768, 319,    319,
+    319,    319,    317,    566,    431,    616,    226,    -32768, 628,    -32768,
+    473,    -32768, 594,    486,    634,    643,    652,    575,    497,    255,
+    -32768, -32768, -32768, 1561,   258,    -15,    416,    445,    -32768, -32768,
+    534,    278,    -32768, -32768, 502,    314,    586,    503,    829,    829,
+    29,     -32768, -32768, 93,     505,    94,     829,    829,    603,    330,
+    209,    -32768, 509,    34,     285,    511,    295,    23,     242,    83,
+    -32768, 298,    513,    514,    -32768, -32768, 1463,   -32768, 517,    -32768,
+    672,    597,    666,    -32768, -32768, 1054,   1307,   521,    1307,   376,
+    376,    -32768, -32768, -32768, 455,    678,    1228,   -32768, 678,    -32768,
+    -32768, -32768, 926,    1151,   -32768, 516,    -32768, 585,    -32768, 57,
+    -32768, 522,    319,    -32768, 829,    302,    314,    -32768, -32768, 589,
+    342,    589,    681,    -32768, 323,    -32768, -32768, -32768, 563,    -32768,
+    -32768, -32768, 1463,   -32768, 594,    314,    448,    331,    829,    530,
+    532,    535,    537,    319,    621,    448,    581,    -32768, 40,     -32768,
+    685,    448,    -32768, 445,    -32768, 319,    1307,   -32768, 445,    -32768,
+    36,     38,     -32768, -32768, 829,    416,    156,    -32768, 1561,   -32768,
+    -32768, -32768, -32768, 599,    -32768, -32768, 694,    829,    -32768, 1054,
+    -32768, 599,    -32768, -32768, -32768, 317,    -32768, -32768, 669,    625,
+    506,    678,    1228,   -32768, 678,    1054,   1307,   -32768, 337,    -32768,
+    -32768, -32768, 516,    -32768, -32768, -32768, -32768, 416,    -32768, -32768,
+    50,     -32768, -32768, -32768, -32768, -32768, 319,    319,    -32768, -32768,
+    -32768, 343,    -32768, 46,     319,    319,    319,    319,    346,    701,
+    -32768, 705,    611,    551,    1384,   317,    -32768, 708,    314,    348,
+    447,    -32768, 357,    447,    -32768, -32768, 416,    829,    211,    552,
+    555,    32,     252,    558,    -32768, 829,    829,    -32768, 1054,   -32768,
+    380,    -32768, 516,    -32768, -32768, 1307,   -32768, -32768, -32768, -32768,
+    314,    -32768, 382,    385,    559,    561,    -32768, 314,    564,    170,
+    829,    -32768, -32768, -32768, 570,    -32768, -32768, 314,    -32768, 416,
+    -32768, -32768, -32768, -32768, 829,    -32768, -32768, 569,    416,    416,
+    516,    -32768, -32768, -32768, 592,    -32768, -32768, 601,    -32768, 722,
+    731,    -32768, 48,     319,    -32768, 53,     829,    317,    317,    576,
+    -32768, -32768, 577,    -32768, 416,    580,    582,    -32768, -32768, 319,
+    319,    389,    584,    -32768, -32768, 740,    -32768};
+
+static const short yypgoto[] = {
+    -32768, 726,    -32768, -32768, -32768, -32768, -32768, -32768, -224,   263,
+    259,    -32768, -32768, -32768, -32768, -32768, 281,    -32768, -32768, -32768,
+    -32768, 510,    -32768, -32768, -32768, -32768, 383,    -32768, -32768, -32768,
+    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -152,
+    257,    -347,   166,    -32768, -32768, -489,   -156,   -32768, -32768, -32768,
+    -32768, 284,    408,    291,    -32768, -32768, -32768, -32768, -32768, 293,
+    -32768, -232,   -32768, -32768, -32768, 739,    -89,    -294,   -32768, -32768,
+    -32768, 225,    -32768, -32768, -32768, -32768, -164,   -32768, -32768, -32768,
+    -32768, -332,   -32768, -32768, -306,   -32768, -32768, -32768, -32768, -215,
+    -32768, -32768, -32768, -32768, -32768, -147,   432,    -32768, -301,   -32768,
+    -193,   -32768, 483,    -3,     -32768, -51,    751,    49,     -157,   387,
+    762,    624,    618,    498,    -161,   -274,   -369,   480,    -32768, -210,
+    -32768};
+
+#define YYLAST 1690
+
+static const short yytable[] = {
+    64,  279,  285, 281, 578, 415, 288,  288, 411, 121, 311,  475, 476, 106,  498, 500,
+    61,  -334, 343, 129, 287, 289, 62,   414, 236, 136, -331, 336, 445, 384,  448, 334,
+    421, 422,  423, 317, 318, 72,  309,  317, 318, 317, 318,  581, 317, 318,  317, 318,
+    317, 318,  317, 318, 102, 393, 582,  310, 116, 93,  317,  318, 317, 318,  93,  461,
+    127, 317,  318, 392, 401, 131, 160,  148, 149, 350, 323,  324, 325, 326,  327, 361,
+    96,  583,  235, 431, 402, 622, 623,  151, 357, 240, 103,  386, 369, 155,  156, 158,
+    159, 311,  584, 467, 323, 324, 325,  326, 327, 335, 317,  318, 233, 463,  323, 324,
+    325, 326,  327, 447, 550, 454, 128,  400, 465, 616, 298,  152, 135, 288,  457, 405,
+    468, 409,  241, 260, 413, 288, 261,  541, 97,  544, 417,  403, 617, 406,  288, 288,
+    501, 549,  351, 410, 487, 598, 477,  478, 415, 432, 433,  152, 418, 419,  415, 98,
+    362, 460,  288, 288, 288, 288, 288,  288, 317, 318, 585,  288, 63,  -334, 288, 105,
+    439, 440,  441, 442, 443, 444, -331, 337, 527, 455, 245,  424, 459, 512,  681, 394,
+    643, 644,  521, 14,  594, 242, 595,  153, 592, 269, 337,  358, 113, 549,  621, 65,
+    671, 609,  458, 73,  611, 673, 246,  514, 435, 18,  58,   618, 554, 99,   543, 407,
+    338, 161,  323, 324, 325, 326, 327,  107, 145, 534, 510,  511, 610, 231,  551, 507,
+    352, 549,  515, 516, 529, 613, 370,  140, 415, 599, 141,  385, 343, 425,  353, 66,
+    67,  603,  154, 323, 324, 325, 326,  327, 146, 110, 436,  437, 685, 323,  324, 325,
+    326, 327,  288, 438, 14,  597, 74,   142, 78,  79,  660,  392, 154, 59,   255, 143,
+    540, 568,  111, 288, 288, 1,   75,   591, 2,   462, 18,   112, 557, 80,   81,  115,
+    76,  403,  552, 77,  316, 350, 559,  60,  661, 481, 652,  3,   4,   317,  318, 113,
+    61,  270,  339, 68,  573, 82,  62,   5,   340, 570, 283,  122, 6,   7,    571, 319,
+    83,  284,  69,  78,  79,  84,  317,  318, 125, 346, 590,  8,   70,  589,  596, 593,
+    347, 9,    388, 134, 123, 619, 137,  479, 518, 389, 85,   601, 392, 392,  624, 625,
+    288, 519,  132, 640, 10,  337, 320,  321, 322, 323, 324,  325, 326, 327,  602, 249,
+    288, 271,  483, 484, 272, 254, 124,  633, 130, 328, 11,   325, 326, 327,  612, 138,
+    12,  13,   528, 86,  139, 14,  187,  147, 189, 15,  227,  16,  645, 17,   87,  494,
+    495, 273,  499, 484, 88,  193, 194,  232, 89,  274, 144,  18,  317, 318,  90,  91,
+    636, 639,  117, 118, 119, 150, 504,  505, 120, 648, 649,  329, 330, 522,  523, 288,
+    263, 264,  119, 339, 331, 672, 120,  525, 526, 340, 530,  531, 228, 650,  558, 484,
+    653, 229,  662, 237, 545, 392, 682,  658, 323, 324, 325,  326, 327, 234,  239, 162,
+    665, 664,  163, 565, 566, 247, 164,  165, 248, 373, 166,  572, 484, 167,  168, 397,
+    251, 614,  615, 250, 398, 258, 674,  620, 495, 170, 626,  505, 637, 495,  171, 172,
+    252, 173,  174, 175, 176, 638, 615,  608, 425, 253, 374,  323, 324, 325,  326, 327,
+    255, 177,  178, 259, 179, 323, 324,  325, 326, 327, 399,  180, 651, 615,  654, 505,
+    181, 655,  505, 262, 182, 683, 505,  277, 291, 280, 183,  290, 293, 294,  184, 295,
+    375, 296,  185, 314, 297, 299, 301,  186, 302, 303, 187,  188, 189, 190,  191, 192,
+    304, 305,  306, 307, 308, 345, 634,  333, 344, 193, 194,  376, 377, 354,  378, 356,
+    195, 357,  364, 363, 196, 365, 197,  198, 199, 371, 372,  368, 395, 200,  335, 162,
+    387, 411,  163, 14,  420, 434, 164,  165, 427, 464, 166,  426, 201, 167,  168, 169,
+    446, 466,  284, 472, 470, 473, 241,  482, 486, 170, 485,  202, 492, 489,  171, 172,
+    203, 173,  174, 175, 176, 488, 490,  320, 321, 322, 323,  324, 325, 326,  327, 491,
+    493, 177,  178, 503, 179, 506, 508,  509, 675, 676, 328,  180, 513, 520,  517, 524,
+    181, 532,  533, 536, 182, 538, 535,  318, 542, 546, 183,  553, 564, 555,  184, 560,
+    567, 574,  185, 575, 298, 588, 576,  186, 577, 579, 187,  188, 189, 190,  191, 192,
+    600, 605,  606, 627, 628, 629, 630,  581, 641, 193, 194,  642, 329, 330,  646, 656,
+    195, 657,  667, 659, 196, 331, 197,  198, 199, 663, 666,  668, 669, 200,  670, 162,
+    677, 678,  163, 679, 686, 680, 164,  165, 684, 109, 480,  569, 201, 167,  168, 360,
+    580, 635,  562, 556, 449, 108, 471,  450, 604, 170, 563,  202, 100, 456,  171, 172,
+    203, 173,  174, 175, 176, 404, 502,  101, 80,  81,  276,  282, 396, 416,  0,   0,
+    0,   177,  178, 0,   179, 0,   0,    0,   0,   0,   0,    180, 0,   0,    0,   0,
+    82,  0,    0,   0,   182, 0,   0,    0,   0,   0,   183,  83,  0,   0,    184, 0,
+    84,  0,    185, 0,   0,   0,   0,    186, 0,   0,   187,  188, 189, 190,  191, 192,
+    162, 0,    0,   163, 0,   85,  0,    164, 165, 193, 194,  166, 0,   0,    167, 168,
+    195, 451,  0,   0,   196, 0,   197,  198, 199, 0,   170,  0,   0,   200,  0,   171,
+    172, 0,    173, 174, 175, 176, 0,    0,   0,   0,   0,    0,   201, 0,    86,  0,
+    0,   0,    177, 178, 0,   179, 0,    0,   0,   87,  0,    452, 180, 0,    0,   88,
+    203, 181,  0,   89,  0,   182, 0,    0,   0,   90,  91,   183, 0,   0,    0,   184,
+    0,   0,    0,   185, 0,   0,   0,    0,   186, 0,   0,    187, 188, 189,  190, 191,
+    192, 162,  0,   0,   163, 0,   0,    0,   164, 165, 193,  194, 0,   0,    0,   167,
+    168, 195,  0,   0,   0,   196, 0,    197, 198, 199, 0,    170, 0,   0,    200, 0,
+    171, 172,  0,   173, 174, 175, 176,  0,   0,   0,   0,    0,   0,   201,  0,   0,
+    0,   0,    0,   177, 178, 0,   179,  0,   0,   0,   0,    0,   202, 180,  0,   0,
+    0,   203,  0,   0,   0,   0,   182,  0,   0,   0,   0,    0,   183, 0,    0,   0,
+    184, 0,    0,   0,   185, 0,   0,    0,   0,   186, 0,    0,   187, 188,  189, 190,
+    191, 192,  0,   0,   0,   0,   0,    0,   0,   0,   0,    193, 194, 0,    0,   0,
+    0,   0,    195, 0,   0,   0,   196,  0,   197, 198, 199,  0,   0,   0,    0,   200,
+    0,   162,  0,   0,   163, 0,   0,    14,  164, 165, 0,    0,   0,   0,    201, 167,
+    168, 0,    0,   0,   0,   0,   0,    0,   0,   0,   0,    170, 0,   286,  0,   0,
+    171, 172,  203, 173, 174, 175, 176,  0,   0,   0,   0,    0,   0,   0,    0,   0,
+    0,   0,    0,   177, 178, 0,   179,  0,   0,   0,   0,    0,   0,   180,  0,   0,
+    0,   0,    0,   0,   0,   0,   182,  0,   0,   0,   0,    0,   183, 0,    0,   0,
+    184, 0,    0,   0,   185, 0,   0,    0,   0,   186, 0,    0,   187, 188,  189, 190,
+    191, 192,  162, 0,   0,   163, 0,    0,   0,   164, 165,  193, 194, 0,    0,   0,
+    167, 168,  195, 0,   0,   0,   196,  0,   197, 198, 199,  0,   170, 0,    0,   200,
+    0,   171,  172, 0,   173, 174, 175,  176, 0,   0,   0,    0,   0,   0,    201, 0,
+    0,   0,    0,   0,   177, 178, 0,    179, 0,   0,   0,    0,   0,   286,  180, 0,
+    0,   0,    203, 0,   0,   0,   0,    182, 0,   0,   0,    0,   0,   183,  0,   0,
+    0,   184,  163, 0,   0,   185, 164,  165, 0,   0,   186,  0,   0,   187,  188, 189,
+    190, 191,  192, 0,   0,   0,   0,    0,   0,   170, 0,    0,   193, 194,  171, 172,
+    0,   0,    0,   195, 176, 0,   0,    196, 0,   197, 198,  199, 0,   0,    0,   0,
+    200, 177,  178, 0,   179, 0,   0,    0,   0,   0,   0,    180, 0,   0,    0,   201,
+    0,   0,    0,   0,   182, 0,   0,    0,   0,   0,   183,  0,   0,   0,    452, 0,
+    0,   163,  185, 203, 0,   164, 165,  0,   0,   0,   187,  0,   189, 190,  191, 192,
+    0,   0,    0,   0,   0,   0,   0,    0,   170, 193, 194,  0,   0,   171,  172, 0,
+    195, 0,    0,   176, 196, 0,   197,  198, 199, 0,   0,    0,   0,   200,  0,   0,
+    177, 178,  0,   179, 0,   14,  0,    0,   0,   0,   180,  0,   201, 0,    0,   0,
+    0,   0,    0,   182, 0,   0,   0,    0,   0,   183, 0,    0,   0,   0,    163, 0,
+    203, 185,  164, 165, 0,   0,   0,    0,   0,   187, 0,    189, 190, 191,  192, 0,
+    0,   0,    0,   0,   0,   170, 0,    0,   193, 194, 171,  172, 0,   0,    0,   195,
+    176, 0,    0,   196, 0,   197, 198,  199, 0,   0,   0,    0,   200, 177,  178, 0,
+    179, 0,    0,   0,   0,   0,   0,    180, 0,   0,   0,    201, 0,   0,    0,   0,
+    182, 0,    0,   0,   0,   0,   183,  0,   0,   0,   0,    0,   0,   163,  185, 203,
+    0,   164,  165, 0,   0,   0,   187,  0,   189, 190, 631,  192, 0,   0,    0,   0,
+    0,   0,    0,   0,   170, 193, 194,  0,   0,   171, 172,  0,   195, 0,    0,   176,
+    196, 0,    197, 198, 199, 0,   0,    0,   0,   200, 0,    0,   177, 178,  0,   179,
+    0,   0,    0,   0,   1,   0,   180,  2,   632, 0,   0,    0,   0,   0,    0,   182,
+    0,   0,    0,   0,   0,   183, 0,    0,   0,   0,   3,    4,   203, 185,  0,   0,
+    0,   0,    0,   0,   0,   187, 5,    189, 190, 191, 192,  6,   7,   0,    0,   0,
+    0,   0,    0,   0,   193, 194, 0,    0,   0,   0,   8,    195, 0,   0,    0,   196,
+    9,   197,  198, 199, 0,   0,   0,    0,   200, 0,   0,    171, 172, 0,    0,   0,
+    0,   176,  0,   10,  0,   0,   0,    0,   0,   0,   0,    0,   0,   0,    177, 0,
+    0,   179,  0,   0,   0,   0,   0,    0,   496, 11,  0,    203, 0,   0,    0,   12,
+    13,  497,  0,   0,   14,  0,   0,    183, 15,  0,   16,   0,   17,  0,    0,   185,
+    0,   0,    0,   0,   0,   0,   0,    187, 0,   189, 18,   0,   192, 0,    0,   0,
+    0,   0,    0,   0,   0,   0,   193,  194, 0,   0,   0,    0,   0,   195,  0,   0,
+    0,   196,  0,   197, 198, 199, 0,    0,   0,   0,   200};
+
+static const short yycheck[] = {
+    3,   157, 166, 160, 493, 299, 167, 168, 10,  60,  203, 358, 359, 16,  383, 30,  3,
+    6,   228, 70,  167, 168, 9,   297, 113, 76,  6,   6,   329, 253, 331, 88,  306, 307,
+    308, 12,  13,  76,  202, 12,  13,  12,  13,  3,   12,  13,  12,  13,  12,  13,  12,
+    13,  24,  8,   14,  202, 59,  8,   12,  13,  12,  13,  13,  337, 67,  12,  13,  277,
+    3,   72,  76,  155, 156, 234, 17,  18,  19,  20,  21,  44,  87,  41,  24,  315, 19,
+    574, 575, 125, 44,  23,  62,  255, 248, 96,  97,  98,  99,  290, 58,  31,  17,  18,
+    19,  20,  21,  162, 12,  13,  111, 341, 17,  18,  19,  20,  21,  330, 448, 332, 69,
+    283, 344, 71,  111, 161, 75,  286, 14,  291, 60,  293, 64,  134, 296, 294, 137, 436,
+    118, 438, 302, 286, 90,  66,  303, 304, 159, 446, 235, 294, 372, 518, 360, 361, 446,
+    317, 318, 161, 303, 304, 452, 118, 125, 163, 323, 324, 325, 326, 327, 328, 12,  13,
+    130, 332, 159, 162, 335, 48,  323, 324, 325, 326, 327, 328, 162, 162, 161, 332, 131,
+    160, 335, 160, 679, 146, 160, 161, 160, 137, 160, 131, 160, 102, 506, 152, 162, 159,
+    127, 506, 160, 3,   160, 541, 98,  51,  544, 160, 159, 121, 33,  159, 51,  566, 163,
+    118, 437, 148, 227, 102, 17,  18,  19,  20,  21,  43,  115, 426, 398, 399, 542, 160,
+    453, 395, 10,  542, 406, 407, 161, 546, 249, 115, 542, 523, 118, 254, 462, 160, 24,
+    51,  52,  531, 161, 17,  18,  19,  20,  21,  147, 158, 83,  84,  0,   17,  18,  19,
+    20,  21,  435, 92,  137, 121, 118, 147, 3,   4,   112, 493, 161, 118, 150, 155, 435,
+    482, 118, 452, 453, 25,  134, 505, 28,  161, 159, 107, 464, 24,  25,  3,   144, 452,
+    453, 147, 3,   470, 466, 144, 142, 364, 615, 47,  48,  12,  13,  127, 3,   51,  3,
+    119, 488, 48,  9,   59,  9,   485, 159, 7,   64,  65,  486, 30,  59,  166, 134, 3,
+    4,   64,  12,  13,  82,  3,   503, 79,  144, 501, 514, 508, 10,  85,  3,   74,  76,
+    567, 77,  362, 30,  10,  85,  527, 574, 575, 576, 577, 529, 160, 82,  160, 104, 162,
+    14,  15,  16,  17,  18,  19,  20,  21,  529, 124, 545, 115, 160, 161, 118, 130, 118,
+    584, 118, 33,  126, 19,  20,  21,  545, 113, 132, 133, 160, 126, 115, 137, 94,  147,
+    96,  141, 118, 143, 160, 145, 137, 160, 161, 147, 160, 161, 143, 109, 110, 158, 147,
+    155, 155, 159, 12,  13,  153, 154, 588, 597, 3,   4,   5,   155, 160, 161, 9,   605,
+    606, 83,  84,  160, 161, 608, 3,   4,   5,   3,   92,  663, 9,   160, 161, 9,   160,
+    161, 138, 608, 160, 161, 620, 151, 630, 93,  13,  679, 680, 627, 17,  18,  19,  20,
+    21,  36,  131, 3,   644, 637, 6,   160, 161, 160, 10,  11,  6,   41,  14,  160, 161,
+    17,  18,  19,  3,   160, 161, 14,  24,  68,  666, 160, 161, 29,  160, 161, 160, 161,
+    34,  35,  159, 37,  38,  39,  40,  160, 161, 13,  160, 159, 74,  17,  18,  19,  20,
+    21,  150, 53,  54,  3,   56,  17,  18,  19,  20,  21,  62,  63,  160, 161, 160, 161,
+    68,  160, 161, 157, 72,  160, 161, 159, 148, 76,  78,  162, 159, 159, 82,  159, 112,
+    159, 86,  76,  159, 159, 159, 91,  159, 159, 94,  95,  96,  97,  98,  99,  159, 159,
+    159, 159, 159, 125, 585, 161, 159, 109, 110, 139, 140, 101, 142, 125, 116, 44,  125,
+    161, 120, 3,   122, 123, 124, 68,  159, 125, 6,   129, 162, 3,   161, 10,  6,   137,
+    160, 3,   10,  11,  165, 15,  14,  161, 144, 17,  18,  19,  159, 6,   166, 10,  161,
+    3,   64,  15,  159, 29,  6,   159, 61,  3,   34,  35,  164, 37,  38,  39,  40,  159,
+    3,   14,  15,  16,  17,  18,  19,  20,  21,  3,   159, 53,  54,  125, 56,  159, 76,
+    160, 667, 668, 33,  63,  163, 160, 67,  160, 68,  160, 160, 3,   72,  80,  161, 13,
+    159, 3,   78,  98,  3,   163, 82,  98,  125, 159, 86,  159, 111, 8,   159, 91,  159,
+    76,  94,  95,  96,  97,  98,  99,  10,  36,  81,  6,   3,   98,  159, 3,   160, 109,
+    110, 160, 83,  84,  160, 160, 116, 160, 130, 159, 120, 92,  122, 123, 124, 159, 161,
+    130, 10,  129, 3,   3,   160, 160, 6,   159, 0,   159, 10,  11,  160, 19,  363, 484,
+    144, 17,  18,  241, 495, 587, 470, 462, 24,  18,  350, 27,  535, 29,  471, 159, 13,
+    333, 34,  35,  164, 37,  38,  39,  40,  290, 387, 13,  24,  25,  154, 161, 282, 301,
+    -1,  -1,  -1,  53,  54,  -1,  56,  -1,  -1,  -1,  -1,  -1,  -1,  63,  -1,  -1,  -1,
+    -1,  48,  -1,  -1,  -1,  72,  -1,  -1,  -1,  -1,  -1,  78,  59,  -1,  -1,  82,  -1,
+    64,  -1,  86,  -1,  -1,  -1,  -1,  91,  -1,  -1,  94,  95,  96,  97,  98,  99,  3,
+    -1,  -1,  6,   -1,  85,  -1,  10,  11,  109, 110, 14,  -1,  -1,  17,  18,  116, 117,
+    -1,  -1,  120, -1,  122, 123, 124, -1,  29,  -1,  -1,  129, -1,  34,  35,  -1,  37,
+    38,  39,  40,  -1,  -1,  -1,  -1,  -1,  -1,  144, -1,  126, -1,  -1,  -1,  53,  54,
+    -1,  56,  -1,  -1,  -1,  137, -1,  159, 63,  -1,  -1,  143, 164, 68,  -1,  147, -1,
+    72,  -1,  -1,  -1,  153, 154, 78,  -1,  -1,  -1,  82,  -1,  -1,  -1,  86,  -1,  -1,
+    -1,  -1,  91,  -1,  -1,  94,  95,  96,  97,  98,  99,  3,   -1,  -1,  6,   -1,  -1,
+    -1,  10,  11,  109, 110, -1,  -1,  -1,  17,  18,  116, -1,  -1,  -1,  120, -1,  122,
+    123, 124, -1,  29,  -1,  -1,  129, -1,  34,  35,  -1,  37,  38,  39,  40,  -1,  -1,
+    -1,  -1,  -1,  -1,  144, -1,  -1,  -1,  -1,  -1,  53,  54,  -1,  56,  -1,  -1,  -1,
+    -1,  -1,  159, 63,  -1,  -1,  -1,  164, -1,  -1,  -1,  -1,  72,  -1,  -1,  -1,  -1,
+    -1,  78,  -1,  -1,  -1,  82,  -1,  -1,  -1,  86,  -1,  -1,  -1,  -1,  91,  -1,  -1,
+    94,  95,  96,  97,  98,  99,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  109, 110,
+    -1,  -1,  -1,  -1,  -1,  116, -1,  -1,  -1,  120, -1,  122, 123, 124, -1,  -1,  -1,
+    -1,  129, -1,  3,   -1,  -1,  6,   -1,  -1,  137, 10,  11,  -1,  -1,  -1,  -1,  144,
+    17,  18,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  29,  -1,  159, -1,  -1,
+    34,  35,  164, 37,  38,  39,  40,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
+    -1,  -1,  53,  54,  -1,  56,  -1,  -1,  -1,  -1,  -1,  -1,  63,  -1,  -1,  -1,  -1,
+    -1,  -1,  -1,  -1,  72,  -1,  -1,  -1,  -1,  -1,  78,  -1,  -1,  -1,  82,  -1,  -1,
+    -1,  86,  -1,  -1,  -1,  -1,  91,  -1,  -1,  94,  95,  96,  97,  98,  99,  3,   -1,
+    -1,  6,   -1,  -1,  -1,  10,  11,  109, 110, -1,  -1,  -1,  17,  18,  116, -1,  -1,
+    -1,  120, -1,  122, 123, 124, -1,  29,  -1,  -1,  129, -1,  34,  35,  -1,  37,  38,
+    39,  40,  -1,  -1,  -1,  -1,  -1,  -1,  144, -1,  -1,  -1,  -1,  -1,  53,  54,  -1,
+    56,  -1,  -1,  -1,  -1,  -1,  159, 63,  -1,  -1,  -1,  164, -1,  -1,  -1,  -1,  72,
+    -1,  -1,  -1,  -1,  -1,  78,  -1,  -1,  -1,  82,  6,   -1,  -1,  86,  10,  11,  -1,
+    -1,  91,  -1,  -1,  94,  95,  96,  97,  98,  99,  -1,  -1,  -1,  -1,  -1,  -1,  29,
+    -1,  -1,  109, 110, 34,  35,  -1,  -1,  -1,  116, 40,  -1,  -1,  120, -1,  122, 123,
+    124, -1,  -1,  -1,  -1,  129, 53,  54,  -1,  56,  -1,  -1,  -1,  -1,  -1,  -1,  63,
+    -1,  -1,  -1,  144, -1,  -1,  -1,  -1,  72,  -1,  -1,  -1,  -1,  -1,  78,  -1,  -1,
+    -1,  159, -1,  -1,  6,   86,  164, -1,  10,  11,  -1,  -1,  -1,  94,  -1,  96,  97,
+    98,  99,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  29,  109, 110, -1,  -1,  34,  35,
+    -1,  116, -1,  -1,  40,  120, -1,  122, 123, 124, -1,  -1,  -1,  -1,  129, -1,  -1,
+    53,  54,  -1,  56,  -1,  137, -1,  -1,  -1,  -1,  63,  -1,  144, -1,  -1,  -1,  -1,
+    -1,  -1,  72,  -1,  -1,  -1,  -1,  -1,  78,  -1,  -1,  -1,  -1,  6,   -1,  164, 86,
+    10,  11,  -1,  -1,  -1,  -1,  -1,  94,  -1,  96,  97,  98,  99,  -1,  -1,  -1,  -1,
+    -1,  -1,  29,  -1,  -1,  109, 110, 34,  35,  -1,  -1,  -1,  116, 40,  -1,  -1,  120,
+    -1,  122, 123, 124, -1,  -1,  -1,  -1,  129, 53,  54,  -1,  56,  -1,  -1,  -1,  -1,
+    -1,  -1,  63,  -1,  -1,  -1,  144, -1,  -1,  -1,  -1,  72,  -1,  -1,  -1,  -1,  -1,
+    78,  -1,  -1,  -1,  -1,  -1,  -1,  6,   86,  164, -1,  10,  11,  -1,  -1,  -1,  94,
+    -1,  96,  97,  98,  99,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  29,  109, 110, -1,
+    -1,  34,  35,  -1,  116, -1,  -1,  40,  120, -1,  122, 123, 124, -1,  -1,  -1,  -1,
+    129, -1,  -1,  53,  54,  -1,  56,  -1,  -1,  -1,  -1,  25,  -1,  63,  28,  144, -1,
+    -1,  -1,  -1,  -1,  -1,  72,  -1,  -1,  -1,  -1,  -1,  78,  -1,  -1,  -1,  -1,  47,
+    48,  164, 86,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  94,  59,  96,  97,  98,  99,  64,
+    65,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  109, 110, -1,  -1,  -1,  -1,  79,  116, -1,
+    -1,  -1,  120, 85,  122, 123, 124, -1,  -1,  -1,  -1,  129, -1,  -1,  34,  35,  -1,
+    -1,  -1,  -1,  40,  -1,  104, -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  53,
+    -1,  -1,  56,  -1,  -1,  -1,  -1,  -1,  -1,  63,  126, -1,  164, -1,  -1,  -1,  132,
+    133, 72,  -1,  -1,  137, -1,  -1,  78,  141, -1,  143, -1,  145, -1,  -1,  86,  -1,
+    -1,  -1,  -1,  -1,  -1,  -1,  94,  -1,  96,  159, -1,  99,  -1,  -1,  -1,  -1,  -1,
+    -1,  -1,  -1,  -1,  109, 110, -1,  -1,  -1,  -1,  -1,  116, -1,  -1,  -1,  120, -1,
+    122, 123, 124, -1,  -1,  -1,  -1,  129};
+
+/* fattrs + tables */
+
+/* parser code folow  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+/* Note: dollar marks section change
+   the next  is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#if YY_Parser_USE_GOTO != 0
+/*
+ SUPRESSION OF GOTO : on some C++ compiler (sun c++)
+  the goto is strictly forbidden if any constructor/destructor
+  is used in the whole function (very stupid isn't it ?)
+ so goto are to be replaced with a 'while/switch/case construct'
+ here are the macro to keep some apparent compatibility
+*/
+#define YYGOTO(lb)     \
+  {                    \
+    yy_gotostate = lb; \
+    continue;          \
+  }
+#define YYBEGINGOTO                          \
+  enum yy_labels yy_gotostate = yygotostart; \
+  for (;;)                                   \
+    switch (yy_gotostate) {                  \
+      case yygotostart: {
+#define YYLABEL(lb) \
+  }                 \
+  case lb: {
+#define YYENDGOTO \
+  }               \
+  }
+#define YYBEGINDECLARELABEL enum yy_labels { yygotostart
+#define YYDECLARELABEL(lb) , lb
+#define YYENDDECLARELABEL \
+  }                       \
+  ;
+#else
+/* macro to keep goto */
+#define YYGOTO(lb) goto lb
+#define YYBEGINGOTO
+#define YYLABEL(lb) \
+  lb:
+#define YYENDGOTO
+#define YYBEGINDECLARELABEL
+#define YYDECLARELABEL(lb)
+#define YYENDDECLARELABEL
+#endif
+/* LABEL DECLARATION */
+YYBEGINDECLARELABEL
+YYDECLARELABEL(yynewstate)
+YYDECLARELABEL(yybackup)
+/* YYDECLARELABEL(yyresume) */
+YYDECLARELABEL(yydefault)
+YYDECLARELABEL(yyreduce)
+YYDECLARELABEL(yyerrlab)  /* here on detecting error */
+YYDECLARELABEL(yyerrlab1) /* here on error raised explicitly by an action */
+YYDECLARELABEL(
+    yyerrdefault) /* current state does not do anything special for the error token. */
+YYDECLARELABEL(
+    yyerrpop) /* pop the current state because it cannot handle the error token */
+YYDECLARELABEL(yyerrhandle)
+YYENDDECLARELABEL
+/* ALLOCA SIMULATION */
+/* __HAVE_NO_ALLOCA */
+#ifdef __HAVE_NO_ALLOCA
+int __alloca_free_ptr(char* ptr, char* ref) {
+  if (ptr != ref)
+    free(ptr);
+  return 0;
+}
+
+#define __ALLOCA_alloca(size) malloc(size)
+#define __ALLOCA_free(ptr, ref) __alloca_free_ptr((char*)ptr, (char*)ref)
+
+#ifdef YY_Parser_LSP_NEEDED
+#define __ALLOCA_return(num)                                        \
+  return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + \
+          __ALLOCA_free(yyls, yylsa) + (num))
+#else
+#define __ALLOCA_return(num) \
+  return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + (num))
+#endif
+#else
+#define __ALLOCA_return(num) return (num)
+#define __ALLOCA_alloca(size) alloca(size)
+#define __ALLOCA_free(ptr, ref)
+#endif
+
+/* ENDALLOCA SIMULATION */
+
+#define yyerrok (yyerrstatus = 0)
+#define yyclearin (YY_Parser_CHAR = YYEMPTY)
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYACCEPT __ALLOCA_return(0)
+#define YYABORT __ALLOCA_return(1)
+#define YYERROR YYGOTO(yyerrlab1)
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL YYGOTO(yyerrlab)
+#define YYRECOVERING() (!!yyerrstatus)
+#define YYBACKUP(token, value)                            \
+  do                                                      \
+    if (YY_Parser_CHAR == YYEMPTY && yylen == 1) {        \
+      YY_Parser_CHAR = (token), YY_Parser_LVAL = (value); \
+      yychar1 = YYTRANSLATE(YY_Parser_CHAR);              \
+      YYPOPSTACK;                                         \
+      YYGOTO(yybackup);                                   \
+    } else {                                              \
+      YY_Parser_ERROR("syntax error: cannot back up");    \
+      YYERROR;                                            \
+    }                                                     \
+  while (0)
+
+#define YYTERROR 1
+#define YYERRCODE 256
+
+#ifndef YY_Parser_PURE
+/* UNPURE */
+#define YYLEX YY_Parser_LEX()
+#ifndef YY_USE_CLASS
+/* If nonreentrant, and not class , generate the variables here */
+int YY_Parser_CHAR;             /*  the lookahead symbol        */
+YY_Parser_STYPE YY_Parser_LVAL; /*  the semantic value of the */
+                                /*  lookahead symbol    */
+int YY_Parser_NERRS;            /*  number of parse errors so far */
+#ifdef YY_Parser_LSP_NEEDED
+YY_Parser_LTYPE YY_Parser_LLOC; /*  location data for the lookahead     */
+                                /*  symbol                              */
+#endif
+#endif
+
+#else
+/* PURE */
+#ifdef YY_Parser_LSP_NEEDED
+#define YYLEX YY_Parser_LEX(&YY_Parser_LVAL, &YY_Parser_LLOC)
+#else
+#define YYLEX YY_Parser_LEX(&YY_Parser_LVAL)
+#endif
+#endif
+#ifndef YY_USE_CLASS
+#if YY_Parser_DEBUG != 0
+int YY_Parser_DEBUG_FLAG; /*  nonzero means print parse trace     */
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks       */
+
+#ifndef YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+#if __GNUC__ > 1 /* GNU C and GNU C++ define this.  */
+#define __yy_bcopy(FROM, TO, COUNT) __builtin_memcpy(TO, FROM, COUNT)
+#else /* not GNU C or C++ */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+
+#ifdef __cplusplus
+static void __yy_bcopy(char* from, char* to, int count)
+#else
+#ifdef __STDC__
+static void __yy_bcopy(char* from, char* to, int count)
+#else
+static void __yy_bcopy(from, to, count) char* from;
+char* to;
+int count;
+#endif
+#endif
+{
+  char* f = from;
+  char* t = to;
+  int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+#endif
+
+int
+#ifdef YY_USE_CLASS
+ YY_Parser_CLASS::
+#endif
+     YY_Parser_PARSE(YY_Parser_PARSE_PARAM)
+#ifndef __STDC__
+#ifndef __cplusplus
+#ifndef YY_USE_CLASS
+/* parameter definition without protypes */
+YY_Parser_PARSE_PARAM_DEF
+#endif
+#endif
+#endif
+{
+  int yystate;
+  int yyn;
+  short* yyssp;
+  YY_Parser_STYPE* yyvsp;
+  int yyerrstatus; /*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0; /*  lookahead token as an internal (translated) token number */
+
+  short yyssa[YYINITDEPTH];           /*  the state stack                     */
+  YY_Parser_STYPE yyvsa[YYINITDEPTH]; /*  the semantic value stack            */
+
+  short* yyss = yyssa;           /*  refer to the stacks thru separate pointers */
+  YY_Parser_STYPE* yyvs = yyvsa; /*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YY_Parser_LSP_NEEDED
+  YY_Parser_LTYPE yylsa[YYINITDEPTH]; /*  the location stack                  */
+  YY_Parser_LTYPE* yyls = yylsa;
+  YY_Parser_LTYPE* yylsp;
+
+#define YYPOPSTACK (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+
+#ifdef YY_Parser_PURE
+  int YY_Parser_CHAR;
+  YY_Parser_STYPE YY_Parser_LVAL;
+  int YY_Parser_NERRS;
+#ifdef YY_Parser_LSP_NEEDED
+  YY_Parser_LTYPE YY_Parser_LLOC;
+#endif
+#endif
+
+  YY_Parser_STYPE yyval; /*  the variable used to return         */
+  /*  semantic values from the action     */
+  /*  routines                            */
+
+  int yylen;
+  /* start loop, in which YYGOTO may be used. */
+  YYBEGINGOTO
+
+#if YY_Parser_DEBUG != 0
+  if (YY_Parser_DEBUG_FLAG)
+    fprintf(stderr, "Starting parse\n");
+#endif
+  yystate = 0;
+  yyerrstatus = 0;
+  YY_Parser_NERRS = 0;
+  YY_Parser_CHAR = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YY_Parser_LSP_NEEDED
+  yylsp = yyls;
+#endif
+
+  /* Push a new state, which is found in  yystate  .  */
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.  */
+  YYLABEL(yynewstate)
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1) {
+    /* Give user a chance to reallocate the stack */
+    /* Use copies of these so that the &'s don't force the real ones into memory. */
+    YY_Parser_STYPE* yyvs1 = yyvs;
+    short* yyss1 = yyss;
+#ifdef YY_Parser_LSP_NEEDED
+    YY_Parser_LTYPE* yyls1 = yyls;
+#endif
+
+    /* Get the current used size of the three stacks, in elements.  */
+    int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+    /* Each stack pointer address is followed by the size of
+       the data in use in that stack, in bytes.  */
+#ifdef YY_Parser_LSP_NEEDED
+    /* This used to be a conditional around just the two extra args,
+       but that might be undefined if yyoverflow is a macro.  */
+    yyoverflow("parser stack overflow",
+               &yyss1,
+               size * sizeof(*yyssp),
+               &yyvs1,
+               size * sizeof(*yyvsp),
+               &yyls1,
+               size * sizeof(*yylsp),
+               &yystacksize);
+#else
+    yyoverflow("parser stack overflow",
+               &yyss1,
+               size * sizeof(*yyssp),
+               &yyvs1,
+               size * sizeof(*yyvsp),
+               &yystacksize);
+#endif
+
+    yyss = yyss1;
+    yyvs = yyvs1;
+#ifdef YY_Parser_LSP_NEEDED
+    yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+    /* Extend the stack our own way.  */
+    if (yystacksize >= YYMAXDEPTH) {
+      YY_Parser_ERROR("parser stack overflow");
+      __ALLOCA_return(2);
+    }
+    yystacksize *= 2;
+    if (yystacksize > YYMAXDEPTH)
+      yystacksize = YYMAXDEPTH;
+    yyss = (short*)__ALLOCA_alloca(yystacksize * sizeof(*yyssp));
+    __yy_bcopy((char*)yyss1, (char*)yyss, size * sizeof(*yyssp));
+    __ALLOCA_free(yyss1, yyssa);
+    yyvs = (YY_Parser_STYPE*)__ALLOCA_alloca(yystacksize * sizeof(*yyvsp));
+    __yy_bcopy((char*)yyvs1, (char*)yyvs, size * sizeof(*yyvsp));
+    __ALLOCA_free(yyvs1, yyvsa);
+#ifdef YY_Parser_LSP_NEEDED
+    yyls = (YY_Parser_LTYPE*)__ALLOCA_alloca(yystacksize * sizeof(*yylsp));
+    __yy_bcopy((char*)yyls1, (char*)yyls, size * sizeof(*yylsp));
+    __ALLOCA_free(yyls1, yylsa);
+#endif
+#endif /* no yyoverflow */
+
+    yyssp = yyss + size - 1;
+    yyvsp = yyvs + size - 1;
+#ifdef YY_Parser_LSP_NEEDED
+    yylsp = yyls + size - 1;
+#endif
+
+#if YY_Parser_DEBUG != 0
+    if (YY_Parser_DEBUG_FLAG)
+      fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+    if (yyssp >= yyss + yystacksize - 1)
+      YYABORT;
+  }
+
+#if YY_Parser_DEBUG != 0
+  if (YY_Parser_DEBUG_FLAG)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  YYGOTO(yybackup);
+  YYLABEL(yybackup)
+
+  /* Do appropriate processing given the current state.  */
+  /* Read a lookahead token if we need one and don't already have one.  */
+  /* YYLABEL(yyresume) */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    YYGOTO(yydefault);
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (YY_Parser_CHAR == YYEMPTY) {
+#if YY_Parser_DEBUG != 0
+    if (YY_Parser_DEBUG_FLAG)
+      fprintf(stderr, "Reading a token: ");
+#endif
+    YY_Parser_CHAR = YYLEX;
+  }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (YY_Parser_CHAR <= 0) /* This means end of input. */
+  {
+    yychar1 = 0;
+    YY_Parser_CHAR = YYEOF; /* Don't call YYLEX any more */
+
+#if YY_Parser_DEBUG != 0
+    if (YY_Parser_DEBUG_FLAG)
+      fprintf(stderr, "Now at end of input.\n");
+#endif
+  } else {
+    yychar1 = YYTRANSLATE(YY_Parser_CHAR);
+
+#if YY_Parser_DEBUG != 0
+    if (YY_Parser_DEBUG_FLAG) {
+      fprintf(stderr, "Next token is %d (%s", YY_Parser_CHAR, yytname[yychar1]);
+      /* Give the individual parser a way to print the precise meaning
+         of a token, for further debugging info.  */
+#ifdef YYPRINT
+      YYPRINT(stderr, YY_Parser_CHAR, YY_Parser_LVAL);
+#endif
+      fprintf(stderr, ")\n");
+    }
+#endif
+  }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    YYGOTO(yydefault);
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0) {
+    if (yyn == YYFLAG)
+      YYGOTO(yyerrlab);
+    yyn = -yyn;
+    YYGOTO(yyreduce);
+  } else if (yyn == 0)
+    YYGOTO(yyerrlab);
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+    /* Shift the lookahead token.  */
+
+#if YY_Parser_DEBUG != 0
+  if (YY_Parser_DEBUG_FLAG)
+    fprintf(stderr, "Shifting token %d (%s), ", YY_Parser_CHAR, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (YY_Parser_CHAR != YYEOF)
+    YY_Parser_CHAR = YYEMPTY;
+
+  *++yyvsp = YY_Parser_LVAL;
+#ifdef YY_Parser_LSP_NEEDED
+  *++yylsp = YY_Parser_LLOC;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  YYGOTO(yynewstate);
+
+  /* Do the default action for the current state.  */
+  YYLABEL(yydefault)
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    YYGOTO(yyerrlab);
+
+  /* Do a reduction.  yyn is the number of a rule to reduce with.  */
+  YYLABEL(yyreduce)
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1 - yylen]; /* implement default value of the action */
+
+#if YY_Parser_DEBUG != 0
+  if (YY_Parser_DEBUG_FLAG) {
+    int i;
+
+    fprintf(stderr, "Reducing via rule %d (line %d), ", yyn, yyrline[yyn]);
+
+    /* Print the symbols being reduced, and their result.  */
+    for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+      fprintf(stderr, "%s ", yytname[yyrhs[i]]);
+    fprintf(stderr, " -> %s\n", yytname[yyr1[yyn]]);
+  }
+#endif
+
+  switch (yyn) {
+    case 1:
+
+    {
+      parseTrees.emplace_front(dynamic_cast<Stmt*>((yyvsp[-1].nodeval)->release()));
+      ;
+      break;
+    }
+    case 2:
+
+    {
+      parseTrees.emplace_front(dynamic_cast<Stmt*>((yyvsp[-1].nodeval)->release()));
+      ;
+      break;
+    }
+    case 3:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 4:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 5:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 6:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 7:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 8:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 9:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 10:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 11:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 12:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 13:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 14:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 15:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 16:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 17:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 18:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 19:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 20:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 21:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 22:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 23:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 24:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 25:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 26:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 27:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 28:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 29:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 30:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 31:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CreateDBStmt((yyvsp[0].stringval)->release(), nullptr, yyvsp[-1].boolval));
+      ;
+      break;
+    }
+    case 32:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CreateDBStmt((yyvsp[-3].stringval)->release(),
+                           reinterpret_cast<std::list<NameValueAssign*>*>(
+                               (yyvsp[-1].listval)->release()),
+                           yyvsp[-4].boolval));
+      ;
+      break;
+    }
+    case 33:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new DropDBStmt((yyvsp[0].stringval)->release(), yyvsp[-1].boolval));
+      ;
+      break;
+    }
+    case 34:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new RenameDatabaseStmt((yyvsp[-3].stringval)->release(),
+                                                        (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 35:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CreateUserStmt((yyvsp[-3].stringval)->release(),
+                             reinterpret_cast<std::list<NameValueAssign*>*>(
+                                 (yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 36:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new DropUserStmt((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 37:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new AlterUserStmt((yyvsp[-3].stringval)->release(),
+                            reinterpret_cast<std::list<NameValueAssign*>*>(
+                                (yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 38:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new RenameUserStmt((yyvsp[-3].stringval)->release(),
+                                                    (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 39:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 40:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 41:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new NameValueAssign((yyvsp[-2].stringval)->release(),
+                              dynamic_cast<Literal*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 42:
+
+    {
+      yyval.boolval = true;
+      ;
+      break;
+    }
+    case 43:
+
+    {
+      yyval.boolval = false;
+      ;
+      break;
+    }
+    case 44:
+
+    {
+      yyval.boolval = true;
+      ;
+      break;
+    }
+    case 45:
+
+    {
+      yyval.boolval = false;
+      ;
+      break;
+    }
+    case 46:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CreateTableAsSelectStmt((yyvsp[-3].stringval)->release(),
+                                      (yyvsp[-1].stringval)->release(),
+                                      yyvsp[-6].boolval,
+                                      yyvsp[-4].boolval,
+                                      reinterpret_cast<std::list<NameValueAssign*>*>(
+                                          (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 47:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CreateTableStmt(
+              (yyvsp[-4].stringval)->release(),
+              nullptr,
+              reinterpret_cast<std::list<TableElement*>*>((yyvsp[-2].listval)->release()),
+              yyvsp[-7].boolval,
+              yyvsp[-5].boolval,
+              reinterpret_cast<std::list<NameValueAssign*>*>(
+                  (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 48:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CreateTableStmt(
+              (yyvsp[-4].stringval)->release(),
+              (yyvsp[-7].stringval)->release(),
+              reinterpret_cast<std::list<TableElement*>*>((yyvsp[-2].listval)->release()),
+              false,
+              yyvsp[-5].boolval,
+              reinterpret_cast<std::list<NameValueAssign*>*>(
+                  (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 49:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CreateDataframeStmt(
+              (yyvsp[-6].stringval)->release(),
+              reinterpret_cast<std::list<TableElement*>*>((yyvsp[-4].listval)->release()),
+              (yyvsp[-1].stringval)->release(),
+              reinterpret_cast<std::list<NameValueAssign*>*>(
+                  (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 50:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ShowCreateTableStmt((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 51:
+
+    {
+      yyval.boolval = true;
+      ;
+      break;
+    }
+    case 52:
+
+    {
+      yyval.boolval = false;
+      ;
+      break;
+    }
+    case 53:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new DropTableStmt((yyvsp[0].stringval)->release(), yyvsp[-1].boolval));
+      ;
+      break;
+    }
+    case 54:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new TruncateTableStmt((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 55:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new RenameTableStmt((yyvsp[-3].stringval)->release(),
+                                                     (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 56:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new RenameColumnStmt((yyvsp[-5].stringval)->release(),
+                                                      (yyvsp[-2].stringval)->release(),
+                                                      (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 59:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 60:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 61:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new AddColumnStmt((yyvsp[-3].stringval)->release(),
+                            dynamic_cast<ColumnDef*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 62:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new AddColumnStmt(
+              (yyvsp[-4].stringval)->release(),
+              reinterpret_cast<std::list<ColumnDef*>*>((yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 63:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new DropColumnStmt((yyvsp[-1].stringval)->release(),
+                                                    (yyvsp[0].slistval)->release()));
+      ;
+      break;
+    }
+    case 64:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 65:
+
+    {
+      (yyvsp[-2].listval)->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 66:
+
+    {
+      yyval.stringval = yyvsp[0].stringval;
+      ;
+      break;
+    }
+    case 67:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CopyTableStmt((yyvsp[-3].stringval)->release(),
+                            (yyvsp[-1].stringval)->release(),
+                            reinterpret_cast<std::list<NameValueAssign*>*>(
+                                (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 68:
+
+    {
+      if (!boost::istarts_with(*(yyvsp[-4].stringval)->get(), "SELECT") &&
+          !boost::istarts_with(*(yyvsp[-4].stringval)->get(), "WITH")) {
+        throw std::runtime_error("SELECT or WITH statement expected");
+      }
+      *(yyvsp[-4].stringval)->get() += ";";
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ExportQueryStmt((yyvsp[-4].stringval)->release(),
+                              (yyvsp[-1].stringval)->release(),
+                              reinterpret_cast<std::list<NameValueAssign*>*>(
+                                  (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 71:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new DumpTableStmt((yyvsp[-3].stringval)->release(),
+                            (yyvsp[-1].stringval)->release(),
+                            reinterpret_cast<std::list<NameValueAssign*>*>(
+                                (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 72:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new RestoreTableStmt((yyvsp[-3].stringval)->release(),
+                               (yyvsp[-1].stringval)->release(),
+                               reinterpret_cast<std::list<NameValueAssign*>*>(
+                                   (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 73:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new CreateRoleStmt((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 74:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new DropRoleStmt((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 75:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new GrantPrivilegesStmt((yyvsp[-5].slistval)->release(),
+                                                         (yyvsp[-3].stringval)->release(),
+                                                         (yyvsp[-2].stringval)->release(),
+                                                         (yyvsp[0].slistval)->release()));
+      ;
+      break;
+    }
+    case 76:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new RevokePrivilegesStmt((yyvsp[-5].slistval)->release(),
+                                   (yyvsp[-3].stringval)->release(),
+                                   (yyvsp[-2].stringval)->release(),
+                                   (yyvsp[0].slistval)->release()));
+      ;
+      break;
+    }
+    case 77:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new GrantRoleStmt((yyvsp[-2].slistval)->release(),
+                                                   (yyvsp[0].slistval)->release()));
+      ;
+      break;
+    }
+    case 78:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new RevokeRoleStmt((yyvsp[-2].slistval)->release(),
+                                                    (yyvsp[0].slistval)->release()));
+      ;
+      break;
+    }
+    case 79:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OptimizeTableStmt((yyvsp[-1].stringval)->release(),
+                                reinterpret_cast<std::list<NameValueAssign*>*>(
+                                    (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 80:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ValidateStmt((yyvsp[-1].stringval)->release(),
+                           reinterpret_cast<std::list<NameValueAssign*>*>(
+                               (yyvsp[0].listval)->release())));
+      ;
+      break;
+    }
+    case 81:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 82:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 83:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 84:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 85:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnDef((yyvsp[-2].stringval)->release(),
+                        dynamic_cast<SQLType*>((yyvsp[-1].nodeval)->release()),
+                        dynamic_cast<CompressDef*>((yyvsp[0].nodeval)->release()),
+                        nullptr));
+      ;
+      break;
+    }
+    case 86:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnDef(
+              (yyvsp[-3].stringval)->release(),
+              dynamic_cast<SQLType*>((yyvsp[-2].nodeval)->release()),
+              dynamic_cast<CompressDef*>((yyvsp[0].nodeval)->release()),
+              dynamic_cast<ColumnConstraintDef*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 87:
+
+    {
+      if (!boost::iequals(*(yyvsp[-1].stringval)->get(), "encoding"))
+        throw std::runtime_error("Invalid identifier " + *(yyvsp[-1].stringval)->get() +
+                                 " in column definition.");
+      delete (yyvsp[-1].stringval)->release();
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new CompressDef((yyvsp[0].stringval)->release(), 0));
+      ;
+      break;
+    }
+    case 88:
+
+    {
+      if (!boost::iequals(*(yyvsp[-4].stringval)->get(), "encoding"))
+        throw std::runtime_error("Invalid identifier " + *(yyvsp[-4].stringval)->get() +
+                                 " in column definition.");
+      delete (yyvsp[-4].stringval)->release();
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CompressDef((yyvsp[-3].stringval)->release(), (int)yyvsp[-1].intval));
+      ;
+      break;
+    }
+    case 89:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 90:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new ColumnConstraintDef(true, false, false, nullptr));
+      ;
+      break;
+    }
+    case 91:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new ColumnConstraintDef(true, true, false, nullptr));
+      ;
+      break;
+    }
+    case 92:
+
+    {
+      if (!boost::iequals(*(yyvsp[0].stringval)->get(), "key"))
+        throw std::runtime_error("Syntax error at " + *(yyvsp[0].stringval)->get());
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new ColumnConstraintDef(true, true, true, nullptr));
+      ;
+      break;
+    }
+    case 93:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnConstraintDef(false,
+                                  false,
+                                  false,
+                                  dynamic_cast<Literal*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 94:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnConstraintDef(false, false, false, new NullLiteral()));
+      ;
+      break;
+    }
+    case 95:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnConstraintDef(false, false, false, new UserLiteral()));
+      ;
+      break;
+    }
+    case 96:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnConstraintDef(dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 97:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnConstraintDef((yyvsp[0].stringval)->release(), nullptr));
+      ;
+      break;
+    }
+    case 98:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnConstraintDef((yyvsp[-3].stringval)->release(),
+                                  (yyvsp[-1].stringval)->release()));
+      ;
+      break;
+    }
+    case 99:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new UniqueDef(false, (yyvsp[-1].slistval)->release()));
+      ;
+      break;
+    }
+    case 100:
+
+    {
+      if (!boost::iequals(*(yyvsp[-3].stringval)->get(), "key"))
+        throw std::runtime_error("Syntax error at " + *(yyvsp[-3].stringval)->get());
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new UniqueDef(true, (yyvsp[-1].slistval)->release()));
+      ;
+      break;
+    }
+    case 101:
+
+    {
+      if (!boost::iequals(*(yyvsp[-5].stringval)->get(), "key"))
+        throw std::runtime_error("Syntax error at " + *(yyvsp[-5].stringval)->get());
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ForeignKeyDef(
+              (yyvsp[-3].slistval)->release(), (yyvsp[0].stringval)->release(), nullptr));
+      ;
+      break;
+    }
+    case 102:
+
+    {
+      if (!boost::iequals(*(yyvsp[-8].stringval)->get(), "key"))
+        throw std::runtime_error("Syntax error at " + *(yyvsp[-8].stringval)->get());
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new ForeignKeyDef((yyvsp[-6].slistval)->release(),
+                                                   (yyvsp[-3].stringval)->release(),
+                                                   (yyvsp[-1].slistval)->release()));
+      ;
+      break;
+    }
+    case 103:
+
+    {
+      if (!boost::iequals(*(yyvsp[-3].stringval)->get(), "key"))
+        throw std::runtime_error("Syntax error at " + *(yyvsp[-3].stringval)->get());
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new ShardKeyDef(*(yyvsp[-1].stringval)->get()));
+      delete (yyvsp[-3].stringval)->release();
+      delete (yyvsp[-1].stringval)->release();
+      ;
+      break;
+    }
+    case 104:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new SharedDictionaryDef(*(yyvsp[-6].stringval)->get(),
+                                                         *(yyvsp[-3].stringval)->get(),
+                                                         *(yyvsp[-1].stringval)->get()));
+      delete (yyvsp[-6].stringval)->release();
+      delete (yyvsp[-3].stringval)->release();
+      delete (yyvsp[-1].stringval)->release();
+      ;
+      break;
+    }
+    case 105:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CheckDef(dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 106:
+
+    {
+      yyval.slistval = TrackedListPtr<std::string>::make(
+          lexer.parsed_str_list_tokens_, 1, yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 107:
+
+    {
+      yyval.slistval = yyvsp[-2].slistval;
+      yyval.slistval->push_back(yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 108:
+
+    {
+      yyval.listval = yyvsp[-1].listval;
+      ;
+      break;
+    }
+    case 109:
+
+    {
+      yyval.listval = TrackedListPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 110:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new DropViewStmt((yyvsp[0].stringval)->release(), yyvsp[-1].boolval));
+      ;
+      break;
+    }
+    case 111:
+
+    {
+      yyval.slistval = TrackedListPtr<std::string>::makeEmpty();
+      ;
+      break;
+    }
+    case 112:
+
+    {
+      yyval.slistval = yyvsp[-1].slistval;
+      ;
+      break;
+    }
+    case 113:
+
+    {
+      yyval.listval = TrackedListPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 114:
+
+    {
+      yyval.listval = yyvsp[0].listval;
+      ;
+      break;
+    }
+    case 115:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 116:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 117:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OrderSpec(yyvsp[-2].intval, nullptr, yyvsp[-1].boolval, yyvsp[0].boolval));
+      ;
+      break;
+    }
+    case 118:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OrderSpec(0,
+                        dynamic_cast<ColumnRef*>((yyvsp[-2].nodeval)->release()),
+                        yyvsp[-1].boolval,
+                        yyvsp[0].boolval));
+      ;
+      break;
+    }
+    case 119:
+
+    {
+      yyval.boolval = false; /* default is ASC */
+      ;
+      break;
+    }
+    case 120:
+
+    {
+      yyval.boolval = false;
+      ;
+      break;
+    }
+    case 121:
+
+    {
+      yyval.boolval = true;
+      ;
+      break;
+    }
+    case 122:
+
+    {
+      yyval.boolval = false; /* default is NULL LAST */
+      ;
+      break;
+    }
+    case 123:
+
+    {
+      yyval.boolval = true;
+      ;
+      break;
+    }
+    case 124:
+
+    {
+      yyval.boolval = false;
+      ;
+      break;
+    }
+    case 130:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new DeleteStmt((yyvsp[-1].stringval)->release(),
+                         dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 131:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new InsertValuesStmt(
+              (yyvsp[-5].stringval)->release(),
+              (yyvsp[-4].slistval)->release(),
+              reinterpret_cast<std::list<Expr*>*>((yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 132:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new InsertIntoTableAsSelectStmt((yyvsp[-2].stringval)->release(),
+                                          (yyvsp[0].stringval)->release(),
+                                          (yyvsp[-1].slistval)->release()));
+      ;
+      break;
+    }
+    case 133:
+
+    {
+      yyval.boolval = false;
+      ;
+      break;
+    }
+    case 134:
+
+    {
+      yyval.boolval = false;
+      ;
+      break;
+    }
+    case 135:
+
+    {
+      yyval.boolval = true;
+      ;
+      break;
+    }
+    case 136:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 137:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 138:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new Assignment((yyvsp[-2].stringval)->release(),
+                         dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 139:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new UpdateStmt(
+              (yyvsp[-3].stringval)->release(),
+              reinterpret_cast<std::list<Assignment*>*>((yyvsp[-1].listval)->release()),
+              dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 140:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 141:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 142:
+
+    {
+      yyval.intval = yyvsp[0].intval;
+      if (yyval.intval <= 0)
+        throw std::runtime_error("LIMIT must be positive.");
+      ;
+      break;
+    }
+    case 143:
+
+    {
+      yyval.intval = 0; /* 0 means ALL */
+      ;
+      break;
+    }
+    case 144:
+
+    {
+      yyval.intval = 0; /* 0 means ALL */
+      ;
+      break;
+    }
+    case 145:
+
+    {
+      yyval.intval = yyvsp[0].intval;
+      ;
+      break;
+    }
+    case 146:
+
+    {
+      if (!boost::iequals(*(yyvsp[0].stringval)->get(), "row") &&
+          !boost::iequals(*(yyvsp[0].stringval)->get(), "rows"))
+        throw std::runtime_error("Invalid word in OFFSET clause " +
+                                 *(yyvsp[0].stringval)->get());
+      delete (yyvsp[0].stringval)->release();
+      yyval.intval = yyvsp[-1].intval;
+      ;
+      break;
+    }
+    case 147:
+
+    {
+      yyval.intval = 0;
+      ;
+      break;
+    }
+    case 148:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new SelectStmt(
+              dynamic_cast<QueryExpr*>((yyvsp[-3].nodeval)->release()),
+              reinterpret_cast<std::list<OrderSpec*>*>((yyvsp[-2].listval)->release()),
+              yyvsp[-1].intval,
+              yyvsp[0].intval));
+      ;
+      break;
+    }
+    case 149:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 150:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new UnionQuery(false,
+                         dynamic_cast<QueryExpr*>((yyvsp[-2].nodeval)->release()),
+                         dynamic_cast<QueryExpr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 151:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new UnionQuery(true,
+                         dynamic_cast<QueryExpr*>((yyvsp[-3].nodeval)->release()),
+                         dynamic_cast<QueryExpr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 152:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 153:
+
+    {
+      yyval.nodeval = yyvsp[-1].nodeval;
+      ;
+      break;
+    }
+    case 154:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new QuerySpec(
+              yyvsp[-5].boolval,
+              reinterpret_cast<std::list<SelectEntry*>*>((yyvsp[-4].listval)->release()),
+              reinterpret_cast<std::list<TableRef*>*>((yyvsp[-3].listval)->release()),
+              dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+              reinterpret_cast<std::list<Expr*>*>((yyvsp[-1].listval)->release()),
+              dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 155:
+
+    {
+      yyval.listval = yyvsp[0].listval;
+      ;
+      break;
+    }
+    case 156:
+
+    {
+      yyval.listval = TrackedListPtr<Node>::makeEmpty(); /* nullptr means SELECT * */
+      ;
+      break;
+    }
+    case 157:
+
+    {
+      yyval.listval = yyvsp[0].listval;
+      ;
+      break;
+    }
+    case 158:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 159:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 160:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new TableRef((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 161:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new TableRef((yyvsp[-1].stringval)->release(),
+                                              (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 162:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 163:
+
+    {
+      yyval.listval = TrackedListPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 164:
+
+    {
+      yyval.listval = yyvsp[0].listval;
+      ;
+      break;
+    }
+    case 165:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 166:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 167:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 168:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 169:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kOR,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 170:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kAND,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 171:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(
+              kNOT, dynamic_cast<Expr*>((yyvsp[0].nodeval)->release()), nullptr));
+      ;
+      break;
+    }
+    case 172:
+
+    {
+      yyval.nodeval = yyvsp[-1].nodeval;
+      ;
+      break;
+    }
+    case 173:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 174:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 175:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 176:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 177:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 178:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 179:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 180:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 181:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 182:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(yyvsp[-1].opval,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 183:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(yyvsp[-1].opval,
+                       kONE,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      /* subquery can only return a single result */
+      ;
+      break;
+    }
+    case 184:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new BetweenExpr(true,
+                          dynamic_cast<Expr*>((yyvsp[-5].nodeval)->release()),
+                          dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                          dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 185:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new BetweenExpr(false,
+                          dynamic_cast<Expr*>((yyvsp[-4].nodeval)->release()),
+                          dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                          dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 186:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new LikeExpr(true,
+                       false,
+                       dynamic_cast<Expr*>((yyvsp[-4].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 187:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new LikeExpr(false,
+                       false,
+                       dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 188:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new LikeExpr(true,
+                       true,
+                       dynamic_cast<Expr*>((yyvsp[-4].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 189:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new LikeExpr(false,
+                       true,
+                       dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 190:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 191:
+
+    {
+      std::string escape_tok = *(yyvsp[-1].stringval)->get();
+      std::transform(escape_tok.begin(), escape_tok.end(), escape_tok.begin(), ::tolower);
+      if (escape_tok != "escape") {
+        throw std::runtime_error("Syntax error: wrong escape specifier");
+      }
+      delete (yyvsp[-1].stringval)->release();
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 192:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new IsNullExpr(true, dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release())));
+      ;
+      break;
+    }
+    case 193:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new IsNullExpr(false, dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release())));
+      ;
+      break;
+    }
+    case 194:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new InSubquery(true,
+                         dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                         dynamic_cast<SubqueryExpr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 195:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new InSubquery(false,
+                         dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                         dynamic_cast<SubqueryExpr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 196:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new InValues(
+              true,
+              dynamic_cast<Expr*>((yyvsp[-5].nodeval)->release()),
+              reinterpret_cast<std::list<Expr*>*>((yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 197:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new InValues(
+              false,
+              dynamic_cast<Expr*>((yyvsp[-4].nodeval)->release()),
+              reinterpret_cast<std::list<Expr*>*>((yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 198:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 199:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 200:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(yyvsp[-2].opval,
+                       yyvsp[-1].qualval,
+                       dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 201:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(yyvsp[-2].opval,
+                       yyvsp[-1].qualval,
+                       dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 202:
+
+    {
+      yyval.opval = yyvsp[0].opval;
+      ;
+      break;
+    }
+    case 203:
+
+    {
+      yyval.opval = yyvsp[0].opval;
+      ;
+      break;
+    }
+    case 207:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ExistsExpr(dynamic_cast<QuerySpec*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 208:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new SubqueryExpr(dynamic_cast<QuerySpec*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 209:
+
+    {
+      yyval.listval = TrackedListPtr<Node>::make(
+          lexer.parsed_node_list_tokens_,
+          1,
+          new ExprPair(dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 210:
+
+    {
+      yyval.listval = yyvsp[-4].listval;
+      yyval.listval->push_back(
+          new ExprPair(dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 211:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 212:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 213:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CaseExpr(
+              reinterpret_cast<std::list<ExprPair*>*>((yyvsp[-2].listval)->release()),
+              dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 214:
+
+    {
+      std::list<ExprPair*>* when_then_list = new std::list<ExprPair*>(
+          1,
+          new ExprPair(dynamic_cast<Expr*>((yyvsp[-5].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release())));
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CaseExpr(when_then_list,
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 215:
+
+    {
+      std::list<ExprPair*>* when_then_list = new std::list<ExprPair*>(
+          1,
+          new ExprPair(dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new CaseExpr(when_then_list, nullptr));
+      ;
+      break;
+    }
+    case 216:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CharLengthExpr(dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release()), true));
+      ;
+      break;
+    }
+    case 217:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CharLengthExpr(dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release()), false));
+      ;
+      break;
+    }
+    case 218:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kARRAY_AT,
+                       dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 219:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kPLUS,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 220:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kMINUS,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 221:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kMULTIPLY,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 222:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kDIVIDE,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 223:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kMODULO,
+                       dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[0].nodeval)->release())));
+      ;
+      break;
+    }
+    case 224:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(kMODULO,
+                       dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 225:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 226:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new OperExpr(
+              kUMINUS, dynamic_cast<Expr*>((yyvsp[0].nodeval)->release()), nullptr));
+      ;
+      break;
+    }
+    case 227:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 228:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 229:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 230:
+
+    {
+      yyval.nodeval = yyvsp[-1].nodeval;
+      ;
+      break;
+    }
+    case 231:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CastExpr(dynamic_cast<Expr*>((yyvsp[-3].nodeval)->release()),
+                       dynamic_cast<SQLType*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 232:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 233:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 234:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 235:
+
+    {
+      throw std::runtime_error("Empty select entry");
+      ;
+      break;
+    }
+    case 236:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new SelectEntry(dynamic_cast<Expr*>((yyvsp[0].nodeval)->release()), nullptr));
+      ;
+      break;
+    }
+    case 237:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new SelectEntry(dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release()),
+                          (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 238:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new SelectEntry(dynamic_cast<Expr*>((yyvsp[-2].nodeval)->release()),
+                          (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 239:
+
+    {
+      throw std::runtime_error("Empty select entry list");
+      ;
+      break;
+    }
+    case 240:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 241:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 242:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 243:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new UserLiteral());
+      ;
+      break;
+    }
+    case 244:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new FunctionRef((yyvsp[-3].stringval)->release()));
+      ;
+      break;
+    }
+    case 245:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new FunctionRef((yyvsp[-4].stringval)->release(),
+                          true,
+                          dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 246:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new FunctionRef((yyvsp[-4].stringval)->release(),
+                          dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 247:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new FunctionRef((yyvsp[-3].stringval)->release(),
+                          dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 248:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new StringLiteral((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 249:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new IntLiteral(yyvsp[0].intval));
+      ;
+      break;
+    }
+    case 250:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new TimestampLiteral());
+      ;
+      break;
+    }
+    case 251:
+
+    {
+      delete dynamic_cast<Expr*>((yyvsp[-1].nodeval)->release());
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new TimestampLiteral());
+      ;
+      break;
+    }
+    case 252:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new FixedPtLiteral((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 253:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new FloatLiteral(yyvsp[0].floatval));
+      ;
+      break;
+    }
+    case 254:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new DoubleLiteral(yyvsp[0].doubleval));
+      ;
+      break;
+    }
+    case 255:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new CastExpr(new StringLiteral((yyvsp[0].stringval)->release()),
+                       dynamic_cast<SQLType*>((yyvsp[-1].nodeval)->release())));
+      ;
+      break;
+    }
+    case 256:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ArrayLiteral(
+              reinterpret_cast<std::list<Expr*>*>((yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 257:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ArrayLiteral(
+              reinterpret_cast<std::list<Expr*>*>((yyvsp[-1].listval)->release())));
+      ;
+      break;
+    }
+    case 258:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new NullLiteral());
+      ;
+      break;
+    }
+    case 259:
+
+    {
+      yyval.listval =
+          TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 1, yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 260:
+
+    {
+      yyval.listval = yyvsp[-2].listval;
+      yyval.listval->push_back(yyvsp[0].nodeval);
+      ;
+      break;
+    }
+    case 261:
+
+    {
+      yyval.listval = TrackedListPtr<Node>::make(lexer.parsed_node_list_tokens_, 0);
+      ;
+      break;
+    }
+    case 263:
+
+    {
+      const auto uc_col_name =
+          boost::to_upper_copy<std::string>(*(yyvsp[0].stringval)->get());
+      if (reserved_keywords.find(uc_col_name) != reserved_keywords.end()) {
+        errors_.push_back("Cannot use a reserved keyword as table name: " +
+                          *(yyvsp[0].stringval)->get());
+      }
+      yyval.stringval = yyvsp[0].stringval;
+      ;
+      break;
+    }
+    case 264:
+
+    {
+      yyval.stringval = yyvsp[0].stringval;
+      ;
+      break;
+    }
+    case 265:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::makeEmpty();
+      ;
+      break;
+    }
+    case 271:
+
+    {
+      yyval.slistval = TrackedListPtr<std::string>::make(
+          lexer.parsed_str_list_tokens_, 1, yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 272:
+
+    {
+      yyval.slistval = yyvsp[-2].slistval;
+      yyval.slistval->push_back(yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 275:
+
+    {
+      yyval.slistval = TrackedListPtr<std::string>::make(
+          lexer.parsed_str_list_tokens_, 1, yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 276:
+
+    {
+      yyval.slistval = yyvsp[-2].slistval;
+      yyval.slistval->push_back(yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 279:
+
+    {
+      yyval.slistval = TrackedListPtr<std::string>::make(
+          lexer.parsed_str_list_tokens_, 1, yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 280:
+
+    {
+      yyval.slistval = yyvsp[-2].slistval;
+      yyval.slistval->push_back(yyvsp[0].stringval);
+      ;
+      break;
+    }
+    case 281:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "ALL");
+      ;
+      break;
+    }
+    case 282:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "ALL");
+      ;
+      break;
+    }
+    case 283:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "CREATE");
+      ;
+      break;
+    }
+    case 284:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "SELECT");
+      ;
+      break;
+    }
+    case 285:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "INSERT");
+      ;
+      break;
+    }
+    case 286:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "TRUNCATE");
+      ;
+      break;
+    }
+    case 287:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "UPDATE");
+      ;
+      break;
+    }
+    case 288:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "DELETE");
+      ;
+      break;
+    }
+    case 289:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "ALTER");
+      ;
+      break;
+    }
+    case 290:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "DROP");
+      ;
+      break;
+    }
+    case 291:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "VIEW");
+      ;
+      break;
+    }
+    case 292:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "EDIT");
+      ;
+      break;
+    }
+    case 293:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "ACCESS");
+      ;
+      break;
+    }
+    case 294:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "ALTER SERVER");
+      ;
+      break;
+    }
+    case 295:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "CREATE SERVER");
+      ;
+      break;
+    }
+    case 296:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "CREATE TABLE");
+      ;
+      break;
+    }
+    case 297:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "CREATE VIEW");
+      ;
+      break;
+    }
+    case 298:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "SELECT VIEW");
+      ;
+      break;
+    }
+    case 299:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "DROP VIEW");
+      ;
+      break;
+    }
+    case 300:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "DROP SERVER");
+      ;
+      break;
+    }
+    case 301:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "CREATE DASHBOARD");
+      ;
+      break;
+    }
+    case 302:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "EDIT DASHBOARD");
+      ;
+      break;
+    }
+    case 303:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "VIEW DASHBOARD");
+      ;
+      break;
+    }
+    case 304:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "DELETE DASHBOARD");
+      ;
+      break;
+    }
+    case 305:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "VIEW SQL EDITOR");
+      ;
+      break;
+    }
+    case 306:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "DATABASE");
+      ;
+      break;
+    }
+    case 307:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "TABLE");
+      ;
+      break;
+    }
+    case 308:
+
+    {
+      yyval.stringval =
+          TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "DASHBOARD");
+      ;
+      break;
+    }
+    case 309:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "VIEW");
+      ;
+      break;
+    }
+    case 310:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_, "SERVER");
+      ;
+      break;
+    }
+    case 312:
+
+    {
+      yyval.stringval = TrackedPtr<std::string>::make(lexer.parsed_str_tokens_,
+                                                      std::to_string(yyvsp[0].intval));
+      ;
+      break;
+    }
+    case 313:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_, new ColumnRef((yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 314:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new ColumnRef((yyvsp[-2].stringval)->release(),
+                                               (yyvsp[0].stringval)->release()));
+      ;
+      break;
+    }
+    case 315:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new ColumnRef((yyvsp[-2].stringval)->release(), nullptr));
+      ;
+      break;
+    }
+    case 316:
+
+    {
+      if (yyvsp[0].intval < 0)
+        throw std::runtime_error("No negative number in type definition.");
+      yyval.intval = yyvsp[0].intval;
+      ;
+      break;
+    }
+    case 317:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kBIGINT));
+      ;
+      break;
+    }
+    case 318:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kTEXT));
+      ;
+      break;
+    }
+    case 319:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kBOOLEAN));
+      ;
+      break;
+    }
+    case 320:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kCHAR));
+      ;
+      break;
+    }
+    case 321:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new SQLType(kCHAR, yyvsp[-1].intval));
+      ;
+      break;
+    }
+    case 322:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kNUMERIC));
+      ;
+      break;
+    }
+    case 323:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new SQLType(kNUMERIC, yyvsp[-1].intval));
+      ;
+      break;
+    }
+    case 324:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new SQLType(kNUMERIC, yyvsp[-3].intval, yyvsp[-1].intval, false));
+      ;
+      break;
+    }
+    case 325:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kDECIMAL));
+      ;
+      break;
+    }
+    case 326:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new SQLType(kDECIMAL, yyvsp[-1].intval));
+      ;
+      break;
+    }
+    case 327:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(
+          lexer.parsed_node_tokens_,
+          new SQLType(kDECIMAL, yyvsp[-3].intval, yyvsp[-1].intval, false));
+      ;
+      break;
+    }
+    case 328:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kINT));
+      ;
+      break;
+    }
+    case 329:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kTINYINT));
+      ;
+      break;
+    }
+    case 330:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kSMALLINT));
+      ;
+      break;
+    }
+    case 331:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kFLOAT));
+      ;
+      break;
+    }
+    case 332:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kFLOAT));
+      ;
+      break;
+    }
+    case 333:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kDOUBLE));
+      ;
+      break;
+    }
+    case 334:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kDOUBLE));
+      ;
+      break;
+    }
+    case 335:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kDATE));
+      ;
+      break;
+    }
+    case 336:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kTIME));
+      ;
+      break;
+    }
+    case 337:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new SQLType(kTIME, yyvsp[-1].intval));
+      ;
+      break;
+    }
+    case 338:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_, new SQLType(kTIMESTAMP));
+      ;
+      break;
+    }
+    case 339:
+
+    {
+      yyval.nodeval = TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                             new SQLType(kTIMESTAMP, yyvsp[-1].intval));
+      ;
+      break;
+    }
+    case 340:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new SQLType(static_cast<SQLTypes>(yyvsp[0].intval),
+                                             static_cast<int>(kGEOMETRY),
+                                             0,
+                                             false));
+      ;
+      break;
+    }
+    case 341:
+
+    {
+      yyval.nodeval = yyvsp[0].nodeval;
+      ;
+      break;
+    }
+    case 342:
+
+    {
+      yyval.nodeval = yyvsp[-2].nodeval;
+      if (dynamic_cast<SQLType*>((yyval.nodeval)->get())->get_is_array())
+        throw std::runtime_error("array of array not supported.");
+      dynamic_cast<SQLType*>((yyval.nodeval)->get())->set_is_array(true);
+      ;
+      break;
+    }
+    case 343:
+
+    {
+      yyval.nodeval = yyvsp[-3].nodeval;
+      if (dynamic_cast<SQLType*>((yyval.nodeval)->get())->get_is_array())
+        throw std::runtime_error("array of array not supported.");
+      dynamic_cast<SQLType*>((yyval.nodeval)->get())->set_is_array(true);
+      dynamic_cast<SQLType*>((yyval.nodeval)->get())->set_array_size(yyvsp[-1].intval);
+      ;
+      break;
+    }
+    case 344:
+
+    {
+      yyval.intval = kPOINT;
+      ;
+      break;
+    }
+    case 345:
+
+    {
+      yyval.intval = kLINESTRING;
+      ;
+      break;
+    }
+    case 346:
+
+    {
+      yyval.intval = kPOLYGON;
+      ;
+      break;
+    }
+    case 347:
+
+    {
+      yyval.intval = kMULTIPOLYGON;
+      ;
+      break;
+    }
+    case 348:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new SQLType(static_cast<SQLTypes>(yyvsp[-1].intval),
+                                             static_cast<int>(kGEOGRAPHY),
+                                             4326,
+                                             false));
+      ;
+      break;
+    }
+    case 349:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new SQLType(static_cast<SQLTypes>(yyvsp[-3].intval),
+                                             static_cast<int>(kGEOGRAPHY),
+                                             yyvsp[-1].intval,
+                                             false));
+      ;
+      break;
+    }
+    case 350:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new SQLType(static_cast<SQLTypes>(yyvsp[-1].intval),
+                                             static_cast<int>(kGEOMETRY),
+                                             0,
+                                             false));
+      ;
+      break;
+    }
+    case 351:
+
+    {
+      yyval.nodeval =
+          TrackedPtr<Node>::make(lexer.parsed_node_tokens_,
+                                 new SQLType(static_cast<SQLTypes>(yyvsp[-3].intval),
+                                             static_cast<int>(kGEOMETRY),
+                                             yyvsp[-1].intval,
+                                             false));
+      ;
+      break;
+    }
+    case 352:
+
+    {
+      const auto uc_col_name =
+          boost::to_upper_copy<std::string>(*(yyvsp[0].stringval)->get());
+      if (reserved_keywords.find(uc_col_name) != reserved_keywords.end()) {
+        errors_.push_back("Cannot use a reserved keyword as column name: " +
+                          *(yyvsp[0].stringval)->get());
+      }
+      yyval.stringval = yyvsp[0].stringval;
+      ;
+      break;
+    }
+    case 353:
+
+    {
+      yyval.stringval = yyvsp[0].stringval;
+      ;
+      break;
+    }
+    case 354:
+
+    {
+      yyval.stringval = yyvsp[0].stringval;
+      ;
+      break;
+    }
+  }
+
+  /* the action file gets copied in in place of this dollarsign  */
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YY_Parser_LSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YY_Parser_DEBUG != 0
+  if (YY_Parser_DEBUG_FLAG) {
+    short* ssp1 = yyss - 1;
+    fprintf(stderr, "state stack now");
+    while (ssp1 != yyssp)
+      fprintf(stderr, " %d", *++ssp1);
+    fprintf(stderr, "\n");
+  }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YY_Parser_LSP_NEEDED
+  yylsp++;
+  if (yylen == 0) {
+    yylsp->first_line = YY_Parser_LLOC.first_line;
+    yylsp->first_column = YY_Parser_LLOC.first_column;
+    yylsp->last_line = (yylsp - 1)->last_line;
+    yylsp->last_column = (yylsp - 1)->last_column;
+    yylsp->text = 0;
+  } else {
+    yylsp->last_line = (yylsp + yylen - 1)->last_line;
+    yylsp->last_column = (yylsp + yylen - 1)->last_column;
+  }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  YYGOTO(yynewstate);
+
+  YYLABEL(yyerrlab) /* here on detecting error */
+
+  if (!yyerrstatus)
+  /* If not already recovering from an error, report this error.  */
+  {
+    ++YY_Parser_NERRS;
+
+#ifdef YY_Parser_ERROR_VERBOSE
+    yyn = yypact[yystate];
+
+    if (yyn > YYFLAG && yyn < YYLAST) {
+      int size = 0;
+      char* msg;
+      int x, count;
+
+      count = 0;
+      /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+      for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char*)); x++)
+        if (yycheck[x + yyn] == x)
+          size += strlen(yytname[x]) + 15, count++;
+      msg = (char*)malloc(size + 15);
+      if (msg != 0) {
+        strcpy(msg, "parse error");
+
+        if (count < 5) {
+          count = 0;
+          for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char*)); x++)
+            if (yycheck[x + yyn] == x) {
+              strcat(msg, count == 0 ? ", expecting `" : " or `");
+              strcat(msg, yytname[x]);
+              strcat(msg, "'");
+              count++;
+            }
+        }
+        YY_Parser_ERROR(msg);
+        free(msg);
+      } else
+        YY_Parser_ERROR("parse error; also virtual memory exceeded");
+    } else
+#endif /* YY_Parser_ERROR_VERBOSE */
+      YY_Parser_ERROR("parse error");
+  }
+
+  YYGOTO(yyerrlab1);
+  YYLABEL(yyerrlab1) /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3) {
+    /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+    /* return failure if at end of input */
+    if (YY_Parser_CHAR == YYEOF)
+      YYABORT;
+
+#if YY_Parser_DEBUG != 0
+    if (YY_Parser_DEBUG_FLAG)
+      fprintf(stderr, "Discarding token %d (%s).\n", YY_Parser_CHAR, yytname[yychar1]);
+#endif
+
+    YY_Parser_CHAR = YYEMPTY;
+  }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3; /* Each real token shifted decrements this */
+
+  YYGOTO(yyerrhandle);
+
+  YYLABEL(
+      yyerrdefault) /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) YYGOTO(yydefault);
+#endif
+
+  YYLABEL(yyerrpop) /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss)
+    YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YY_Parser_LSP_NEEDED
+  yylsp--;
+#endif
+
+#if YY_Parser_DEBUG != 0
+  if (YY_Parser_DEBUG_FLAG) {
+    short* ssp1 = yyss - 1;
+    fprintf(stderr, "Error: state stack now");
+    while (ssp1 != yyssp)
+      fprintf(stderr, " %d", *++ssp1);
+    fprintf(stderr, "\n");
+  }
+#endif
+
+  YYLABEL(yyerrhandle)
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    YYGOTO(yyerrdefault);
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    YYGOTO(yyerrdefault);
+
+  yyn = yytable[yyn];
+  if (yyn < 0) {
+    if (yyn == YYFLAG)
+      YYGOTO(yyerrpop);
+    yyn = -yyn;
+    YYGOTO(yyreduce);
+  } else if (yyn == 0)
+    YYGOTO(yyerrpop);
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YY_Parser_DEBUG != 0
+  if (YY_Parser_DEBUG_FLAG)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = YY_Parser_LVAL;
+#ifdef YY_Parser_LSP_NEEDED
+  *++yylsp = YY_Parser_LLOC;
+#endif
+
+  yystate = yyn;
+  YYGOTO(yynewstate);
+  /* end loop, in which YYGOTO may be used. */
+  YYENDGOTO
+}
+
+/* END */
diff -Naur ./Parser/Scanner_wnd_pregen.cpp ../omniscidb-master/Parser/Scanner_wnd_pregen.cpp
--- ./Parser/Scanner_wnd_pregen.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Parser/Scanner_wnd_pregen.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,5774 @@
+
+
+#define YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+/* %not-for-header */
+/* %if-c-only */
+/* %if-not-reentrant */
+/* %endif */
+/* %endif */
+/* %ok-for-header */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* %if-c++-only */
+/* The c++ scanner is a mess. The FlexLexer.h header file relies on the
+ * following macro. This is required in order to pass the c++-multiple-scanners
+ * test in the regression suite. We get reports that it breaks inheritance.
+ * We will address this in a future release of flex, or omit the C++ scanner
+ * altogether.
+ */
+#define yyFlexLexer yyFlexLexer
+/* %endif */
+
+/* %if-c-only */
+/* %endif */
+
+/* %if-c-only */
+/* %endif */
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+/* %if-c-only */
+/* %endif */
+
+/* %if-tables-serialization */
+/* %endif */
+/* end standard C headers. */
+
+/* %if-c-or-c++ */
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types.
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t;
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN (-32767 - 1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN (-2147483647 - 1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX (~(size_t)0)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* %endif */
+
+/* begin standard C++ headers. */
+/* %if-c++-only */
+#include <errno.h>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <iostream>
+/* end standard C++ headers. */
+/* %endif */
+
+/* TODO: this is always defined, so inline it */
+#define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
+#else
+#define yynoreturn
+#endif
+
+/* %not-for-header */
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+/* %ok-for-header */
+
+/* %not-for-header */
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
+ */
+#define YY_SC_TO_UI(c) ((YY_CHAR)(c))
+/* %ok-for-header */
+
+/* %if-reentrant */
+/* %endif */
+
+/* %if-not-reentrant */
+
+/* %endif */
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start)-1) / 2)
+#define YYSTATE YY_START
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin)
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state* YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+/* %if-not-reentrant */
+extern int yyleng;
+/* %endif */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+/* %endif */
+/* %endif */
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+ *       access to the local variable yy_act. Since yyless() is a macro, it would break
+ *       existing scanners that call yyless() from OUTSIDE yylex.
+ *       One obvious solution it to make yy_act a global. I tried that, and saw
+ *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+ *       normally declared as a variable-- so it is not worth it.
+ */
+#define YY_LESS_LINENO(n)              \
+  do {                                 \
+    int yyl;                           \
+    for (yyl = n; yyl < yyleng; ++yyl) \
+      if (yytext[yyl] == '\n')         \
+        --yylineno;                    \
+  } while (0)
+#define YY_LINENO_REWIND_TO(dst)         \
+  do {                                   \
+    const char* p;                       \
+    for (p = yy_cp - 1; p >= (dst); --p) \
+      if (*p == '\n')                    \
+        --yylineno;                      \
+  } while (0)
+
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n)                                   \
+  do {                                              \
+    /* Undo effects of setting up yytext. */        \
+    int yyless_macro_arg = (n);                     \
+    YY_LESS_LINENO(yyless_macro_arg);               \
+    *yy_cp = (yy_hold_char);                        \
+    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = \
+        yy_bp + yyless_macro_arg - YY_MORE_ADJ;     \
+    YY_DO_BEFORE_ACTION; /* set up yytext again */  \
+  } while (0)
+#define unput(c) yyunput(c, (yytext_ptr))
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state {
+  /* %if-c-only */
+  /* %endif */
+
+  /* %if-c++-only */
+  std::streambuf* yy_input_file;
+  /* %endif */
+
+  char* yy_ch_buf;  /* input buffer */
+  char* yy_buf_pos; /* current position in input buffer */
+
+  /* Size of input buffer in bytes, not including room for EOB
+   * characters.
+   */
+  int yy_buf_size;
+
+  /* Number of characters read into yy_ch_buf, not including EOB
+   * characters.
+   */
+  int yy_n_chars;
+
+  /* Whether we "own" the buffer - i.e., we know we created it,
+   * and can realloc() it to grow it, and should free() it to
+   * delete it.
+   */
+  int yy_is_our_buffer;
+
+  /* Whether this is an "interactive" input source; if so, and
+   * if we're using stdio for input, then we want to use getc()
+   * instead of fread(), to make sure we stop fetching input after
+   * each newline.
+   */
+  int yy_is_interactive;
+
+  /* Whether we're considered to be at the beginning of a line.
+   * If so, '^' rules will be active on the next match, otherwise
+   * not.
+   */
+  int yy_at_bol;
+
+  int yy_bs_lineno; /**< The line count. */
+  int yy_bs_column; /**< The column count. */
+
+  /* Whether to try to fill the input buffer when we reach the
+   * end of it.
+   */
+  int yy_fill_buffer;
+
+  int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+  /* When an EOF's been seen but there's still some text to process
+   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+   * shouldn't try reading from the input source any more.  We might
+   * still have a bunch of tokens to match, though, because of
+   * possible backing-up.
+   *
+   * When we actually see the EOF, we change the status to "new"
+   * (via yyrestart()), so that the user can continue scanning by
+   * just pointing yyin at a new input file.
+   */
+#define YY_BUFFER_EOF_PENDING 2
+};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+/* %if-not-reentrant */
+/* %endif */
+/* %ok-for-header */
+
+/* %endif */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER \
+  ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* %if-c-only Standard (non-C++) definition */
+/* %if-not-reentrant */
+/* %not-for-header */
+/* %ok-for-header */
+
+/* %endif */
+/* %endif */
+
+void* yyalloc(yy_size_t);
+void* yyrealloc(void*, yy_size_t);
+void yyfree(void*);
+
+#define yy_new_buffer yy_create_buffer
+#define yy_set_interactive(is_interactive)                            \
+  {                                                                   \
+    if (!YY_CURRENT_BUFFER) {                                         \
+      yyensure_buffer_stack();                                        \
+      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE); \
+    }                                                                 \
+    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;     \
+  }
+#define yy_set_bol(at_bol)                                            \
+  {                                                                   \
+    if (!YY_CURRENT_BUFFER) {                                         \
+      yyensure_buffer_stack();                                        \
+      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE); \
+    }                                                                 \
+    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                     \
+  }
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
+/* Begin user sect3 */
+#define YY_SKIP_YYWRAP
+
+#define FLEX_DEBUG
+typedef flex_uint8_t YY_CHAR;
+
+#define yytext_ptr yytext
+#define YY_INTERACTIVE
+
+#include "Parser/FlexLexer.h"
+
+int yyFlexLexer::yywrap() {
+  return 1;
+}
+
+/* %% [1.5] DFA */
+
+/* %if-c-only Standard (non-C++) definition */
+/* %endif */
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION                                                 \
+  (yytext_ptr) = yy_bp;                                                     \
+  /* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */  \
+  (yytext_ptr) -= (yy_more_len);                                            \
+  yyleng = (int)(yy_cp - (yytext_ptr));                                     \
+  (yy_hold_char) = *yy_cp;                                                  \
+  *yy_cp = '\0';                                                            \
+  /* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */ \
+  (yy_c_buf_p) = yy_cp;
+/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
+#define YY_NUM_RULES 167
+#define YY_END_OF_BUFFER 168
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info {
+  flex_int32_t yy_verify;
+  flex_int32_t yy_nxt;
+};
+static const flex_int16_t yy_acclist[2857] = {
+    0,   168, 166, 167, 164, 166, 167, 164, 167, 166, 167, 166, 167, 166, 167, 166, 167,
+    143, 166, 167, 143, 166, 167, 143, 152, 166, 167, 150, 166, 167, 166, 167, 144, 166,
+    167, 139, 166, 167, 137, 166, 167, 140, 166, 167, 146, 147, 166, 167, 146, 147, 166,
+    167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167,
+    146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146,
+    147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146,
+
+    147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147,
+    166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 166, 167, 164,
+    166, 167, 164, 167, 166, 167, 164, 166, 167, 166, 167, 166, 167, 166, 167, 143, 166,
+    167, 143, 166, 167, 143, 152, 166, 167, 150, 166, 167, 166, 167, 144, 166, 167, 139,
+    166, 167, 137, 166, 167, 140, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146,
+    147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167,
+
+    146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146,
+    147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147,
+    166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166,
+    167, 146, 147, 166, 167, 146, 147, 166, 167, 146, 147, 166, 167, 164, 166, 167, 143,
+    166, 167, 146, 147, 166, 167, 164, 163, 162, 161, 160, 165, 152, 150, 152, 151, 149,
+    141, 138, 142, 146, 147, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+
+    147, 10,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 16,  146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 64,  146, 147, 146, 147,
+    66,  146, 147, 71,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 84,  146, 147, 86,  146, 147, 146, 147, 90,  146, 147, 146,
+
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 123, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 9,
+    10,  146, 147, 157, 164, 164, 157, 163, 162, 157, 161, 160, 157, 165, 152, 150, 152,
+    151, 149, 141, 138, 142, 146, 147, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 10,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 16,  146, 147,
+
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 64,  146, 147,
+    146, 147, 66,  146, 147, 71,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 84,  146, 147, 86,  146, 147, 146, 147, 90,  146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 123, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 66,  146, 147, 164, 146, 147, 162, 160, 165, 165, 165, 155, 151, 153, 149, 146,
+    147, 4,   146, 147, 2,   146, 147, 146, 147, 5,   146, 147, 6,   146, 147, 146, 147,
+    146, 147, 11,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 49,  146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 55,  146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 68,  146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 78,  146, 147, 146, 147, 80,  146, 147, 81,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 109, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 115, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 162, 157, 160, 157, 165, 165, 165, 165, 157, 165,
+    165, 155, 151, 153, 149, 146, 147, 4,   146, 147, 2,   146, 147, 146, 147,
+
+    5,   146, 147, 6,   146, 147, 146, 147, 146, 147, 11,  146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 49,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 55,  146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+
+    147, 68,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 78,
+    146, 147, 146, 147, 80,  146, 147, 81,  146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 109, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 115, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 68,  146,
+    147, 146, 147, 165, 154, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 17,  146, 147, 18,  146, 147, 20,  146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 26,  146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 33,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 40,  146,
+    147, 146, 147, 146, 147, 146, 147, 44,  146, 147, 45,  146, 147, 46,  146,
+
+    147, 48,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 58,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 70,  146, 147, 146, 147, 73,  146, 147, 146, 147, 75,  146, 147, 146,
+    147, 146, 147, 146, 147, 82,  146, 147, 146, 147, 146, 147, 87,  146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 99,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 104, 146, 147, 146, 147,
+
+    146, 147, 146, 147, 146, 147, 146, 147, 112, 146, 147, 146, 147, 114, 146, 147, 146,
+    147, 146, 147, 118, 146, 147, 119, 146, 147, 120, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 128, 146, 147, 146, 147, 146, 147, 146, 147, 132, 146, 147,
+    133, 146, 147, 146, 147, 135, 146, 147, 136, 146, 147, 157, 157, 165, 165, 165, 154,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 17,
+    146, 147, 18,  146, 147, 20,  146, 147, 146, 147, 146, 147, 146, 147, 146,
+
+    147, 146, 147, 146, 147, 26,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 33,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 40,  146, 147, 146, 147,
+    146, 147, 146, 147, 44,  146, 147, 45,  146, 147, 46,  146, 147, 48,  146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 58,  146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 70,  146,
+    147, 146, 147, 73,  146, 147, 146, 147, 75,  146, 147, 146, 147, 146, 147,
+
+    146, 147, 82,  146, 147, 146, 147, 146, 147, 87,  146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 99,  146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 104, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 112, 146, 147, 146, 147, 114, 146, 147, 146, 147, 146, 147, 118, 146,
+    147, 119, 146, 147, 120, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    128, 146, 147, 146, 147, 146, 147, 146, 147, 132, 146, 147, 133, 146, 147,
+
+    146, 147, 135, 146, 147, 136, 146, 147, 69,  70,  146, 147, 146, 147, 148, 148, 165,
+    165, 146, 147, 3,   146, 147, 146, 147, 8,   146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 21,  146, 147, 22,  146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 52,  146, 147, 53,  146, 147, 54,  146, 147, 146,
+
+    147, 57,  146, 147, 146, 147, 146, 147, 61,  146, 147, 62,  146, 147, 146, 147, 65,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 76,  146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 91,  146, 147, 92,  146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 110, 146, 147, 146, 147, 146, 147, 116, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 125, 146, 147, 146, 147, 146,
+
+    147, 146, 147, 146, 147, 146, 147, 134, 146, 147, 156, 148, 156, 157, 156, 148, 165,
+    165, 165, 146, 147, 3,   146, 147, 146, 147, 8,   146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 21,  146, 147, 22,  146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 52,  146, 147, 53,  146, 147, 54,  146, 147,
+
+    146, 147, 57,  146, 147, 146, 147, 146, 147, 61,  146, 147, 62,  146, 147, 146, 147,
+    65,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 76,  146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 91,  146, 147, 92,  146, 147, 146, 147,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 110, 146, 147, 146, 147, 146, 147, 116,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 125, 146, 147, 146, 147,
+
+    146, 147, 146, 147, 146, 147, 146, 147, 134, 146, 147, 146, 147, 159, 148, 165, 1,
+    146, 147, 146, 147, 146, 147, 146, 147, 14,  146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 23,  146, 147, 24,  146, 147, 146, 147, 27,  146, 147, 146, 147, 29,  146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    39,  146, 147, 146, 147, 146, 147, 43,  146, 147, 47,  146, 147, 50,  146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 63,  146, 147, 67,  146, 147, 146, 147,
+
+    146, 147, 74,  146, 147, 146, 147, 146, 147, 146, 147, 85,  146, 147, 146, 147, 88,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 98,  146, 147, 146, 147,
+    101, 146, 147, 146, 147, 103, 146, 147, 146, 147, 106, 146, 147, 107, 146, 147, 108,
+    146, 147, 111, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 126, 146,
+    147, 127, 146, 147, 146, 147, 129, 146, 147, 146, 147, 156, 159, 156, 165, 148, 165,
+    1,   146, 147, 146, 147, 146, 147, 146, 147, 14,  146, 147, 146, 147, 146,
+
+    147, 146, 147, 146, 147, 23,  146, 147, 24,  146, 147, 146, 147, 27,  146, 147, 146,
+    147, 29,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 39,  146, 147, 146, 147, 146, 147, 43,  146, 147, 47,  146, 147, 50,
+    146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 63,  146, 147, 67,  146, 147, 146,
+    147, 146, 147, 74,  146, 147, 146, 147, 146, 147, 146, 147, 85,  146, 147, 146, 147,
+    88,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 98,  146,
+
+    147, 146, 147, 101, 146, 147, 146, 147, 103, 146, 147, 146, 147, 106, 146, 147, 107,
+    146, 147, 108, 146, 147, 111, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 146,
+    147, 126, 146, 147, 127, 146, 147, 146, 147, 129, 146, 147, 146, 147, 107, 146, 147,
+    148, 159, 148, 7,   146, 147, 146, 147, 13,  146, 147, 15,  146, 147, 146, 147, 146,
+    147, 145, 146, 147, 146, 147, 28,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    146, 147, 36,  146, 147, 37,  146, 147, 38,  146, 147, 146, 147, 146, 147,
+
+    51,  146, 147, 56,  146, 147, 146, 147, 146, 147, 68,  146, 147, 146, 147, 146, 147,
+    146, 147, 83,  146, 147, 146, 147, 93,  146, 147, 146, 147, 95,  146, 147, 146, 147,
+    146, 147, 146, 147, 102, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 122, 146,
+    147, 146, 147, 146, 147, 131, 146, 147, 148, 159, 156, 148, 7,   146, 147, 146, 147,
+    13,  146, 147, 15,  146, 147, 146, 147, 146, 147, 145, 146, 147, 146, 147, 28,  146,
+    147, 146, 147, 146, 147, 146, 147, 146, 147, 146, 147, 36,  146, 147, 37,
+
+    146, 147, 38,  146, 147, 146, 147, 146, 147, 51,  146, 147, 56,  146, 147, 146, 147,
+    146, 147, 68,  146, 147, 146, 147, 146, 147, 146, 147, 83,  146, 147, 146, 147, 93,
+    146, 147, 146, 147, 95,  146, 147, 146, 147, 146, 147, 146, 147, 102, 146, 147, 146,
+    147, 146, 147, 146, 147, 146, 147, 122, 146, 147, 146, 147, 146, 147, 131, 146, 147,
+    146, 147, 147, 146, 147, 146, 147, 146, 147, 25,  146, 147, 146, 147, 31,  146, 147,
+    146, 147, 34,  146, 147, 146, 147, 146, 147, 42,  146, 147, 146, 147, 60,
+
+    146, 147, 72,  146, 147, 146, 147, 146, 147, 89,  146, 147, 146, 147, 146, 147, 146,
+    147, 146, 147, 105, 146, 147, 113, 146, 147, 146, 147, 146, 147, 124, 146, 147, 130,
+    146, 147, 146, 147, 146, 147, 146, 147, 25,  146, 147, 146, 147, 31,  146, 147, 146,
+    147, 34,  146, 147, 146, 147, 146, 147, 42,  146, 147, 146, 147, 60,  146, 147, 72,
+    146, 147, 146, 147, 146, 147, 89,  146, 147, 146, 147, 146, 147, 146, 147, 146, 147,
+    105, 146, 147, 113, 146, 147, 146, 147, 146, 147, 124, 146, 147, 130, 146,
+
+    147, 158, 158, 146, 147, 20,  146, 147, 146, 147, 30,  146, 147, 32,  146, 147, 146,
+    147, 146, 147, 59,  146, 147, 146, 147, 146, 147, 94,  146, 147, 146, 147, 97,  146,
+    147, 146, 147, 117, 146, 147, 121, 146, 147, 146, 147, 20,  146, 147, 146, 147, 30,
+    146, 147, 32,  146, 147, 146, 147, 146, 147, 59,  146, 147, 146, 147, 146, 147, 94,
+    146, 147, 146, 147, 97,  146, 147, 146, 147, 117, 146, 147, 121, 146, 147, 146, 147,
+    146, 147, 35,  146, 147, 41,  146, 147, 77,  146, 147, 146, 147, 96,  146,
+
+    147, 100, 146, 147, 146, 147, 146, 147, 35,  146, 147, 41,  146, 147, 77,  146, 147,
+    146, 147, 96,  146, 147, 100, 146, 147, 148, 146, 147, 19,  146, 147, 146, 147, 146,
+    147, 19,  146, 147, 146, 147, 146, 147, 79,  146, 147, 146, 147, 79,  146, 147, 12,
+    146, 147, 12,  146, 147};
+
+static const flex_int16_t yy_accept[1403] = {
+    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+    4,    7,    9,    11,   13,   15,   17,   20,   23,   27,   30,   32,   35,
+    38,   41,   44,   48,   52,   56,   60,   64,   68,   72,   76,   80,   84,
+    88,   92,   96,   100,  104,  108,  112,  116,  120,  124,  128,  132,  134,
+    137,  139,  141,  144,  146,  148,  150,  153,  156,  160,  163,  165,  168,
+    171,  174,  177,  181,  185,  189,  193,  197,  201,  205,  209,  213,  217,
+    221,  225,  229,  233,  237,  241,  245,  249,  253,  257,  261,  265,  268,
+    271,  275,  275,  275,  276,  276,  277,  278,  278,  278,
+
+    278,  279,  280,  280,  281,  282,  283,  284,  284,  285,  285,  286,  287,
+    288,  289,  291,  292,  294,  296,  298,  300,  302,  305,  307,  309,  311,
+    313,  316,  318,  320,  322,  324,  326,  328,  330,  332,  334,  336,  338,
+    340,  342,  344,  346,  348,  350,  352,  354,  356,  358,  360,  362,  364,
+    367,  369,  372,  375,  377,  379,  381,  383,  385,  387,  389,  392,  395,
+    397,  400,  402,  404,  406,  408,  410,  412,  414,  416,  418,  420,  422,
+    424,  426,  428,  430,  433,  435,  437,  439,  441,  443,  445,  447,  449,
+    451,  455,  455,  455,  455,  455,  456,  456,  457,
+
+    458,  459,  459,  459,  460,  460,  461,  462,  462,  462,  462,  463,  463,
+    463,  464,  465,  465,  466,  467,  468,  469,  469,  470,  470,  471,  472,
+    473,  474,  476,  477,  479,  481,  483,  485,  487,  490,  492,  494,  496,
+    498,  501,  503,  505,  507,  509,  511,  513,  515,  517,  519,  521,  523,
+    525,  527,  529,  531,  533,  535,  537,  539,  541,  543,  545,  547,  549,
+    552,  554,  557,  560,  562,  564,  566,  568,  570,  572,  574,  577,  580,
+    582,  585,  587,  589,  591,  593,  595,  597,  599,  601,  603,  605,  607,
+    609,  611,  613,  615,  618,  620,  622,  624,  626,
+
+    628,  630,  632,  634,  636,  639,  640,  640,  640,  640,  640,  642,  642,
+    643,  643,  643,  643,  644,  644,  645,  646,  647,  647,  648,  649,  649,
+    649,  650,  651,  653,  656,  659,  661,  664,  667,  669,  671,  674,  676,
+    678,  680,  682,  684,  686,  688,  690,  692,  694,  696,  698,  700,  702,
+    704,  706,  708,  710,  712,  714,  716,  718,  720,  722,  724,  726,  728,
+    730,  733,  735,  737,  739,  741,  743,  746,  748,  750,  752,  754,  756,
+    758,  760,  762,  765,  767,  769,  771,  773,  775,  777,  780,  782,  785,
+    788,  790,  792,  794,  796,  798,  800,  802,  804,
+
+    806,  808,  810,  812,  814,  816,  818,  820,  822,  824,  826,  828,  830,
+    833,  835,  837,  839,  841,  844,  846,  848,  850,  852,  854,  856,  858,
+    860,  862,  864,  866,  868,  870,  872,  874,  876,  876,  876,  877,  877,
+    877,  877,  877,  877,  878,  878,  879,  880,  880,  880,  881,  882,  883,
+    884,  886,  887,  887,  888,  889,  889,  889,  890,  891,  893,  896,  899,
+    901,  904,  907,  909,  911,  914,  916,  918,  920,  922,  924,  926,  928,
+    930,  932,  934,  936,  938,  940,  942,  944,  946,  948,  950,  952,  954,
+    956,  958,  960,  962,  964,  966,  968,  970,  973,
+
+    975,  977,  979,  981,  983,  986,  988,  990,  992,  994,  996,  998,  1000,
+    1002, 1005, 1007, 1009, 1011, 1013, 1015, 1017, 1020, 1022, 1025, 1028, 1030,
+    1032, 1034, 1036, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054, 1056,
+    1058, 1060, 1062, 1064, 1066, 1068, 1070, 1073, 1075, 1077, 1079, 1081, 1084,
+    1086, 1088, 1090, 1092, 1094, 1096, 1098, 1100, 1102, 1104, 1106, 1108, 1110,
+    1112, 1114, 1116, 1119, 1119, 1119, 1121, 1121, 1121, 1121, 1121, 1121, 1121,
+    1121, 1121, 1121, 1122, 1122, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137,
+    1139, 1142, 1145, 1148, 1150, 1152, 1154, 1156, 1158,
+
+    1160, 1163, 1165, 1167, 1169, 1171, 1173, 1176, 1178, 1180, 1182, 1184, 1187,
+    1189, 1191, 1193, 1196, 1199, 1202, 1205, 1207, 1209, 1211, 1213, 1215, 1217,
+    1219, 1222, 1224, 1226, 1228, 1230, 1232, 1234, 1236, 1238, 1241, 1243, 1246,
+    1248, 1251, 1253, 1255, 1257, 1260, 1262, 1264, 1267, 1269, 1271, 1273, 1275,
+    1277, 1279, 1281, 1283, 1285, 1288, 1290, 1292, 1294, 1296, 1299, 1301, 1303,
+    1305, 1307, 1309, 1312, 1314, 1317, 1319, 1321, 1324, 1327, 1330, 1332, 1334,
+    1336, 1338, 1340, 1343, 1345, 1347, 1349, 1352, 1355, 1357, 1360, 1363, 1363,
+    1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
+
+    1363, 1364, 1364, 1364, 1364, 1364, 1366, 1367, 1368, 1368, 1369, 1371, 1373,
+    1375, 1377, 1379, 1381, 1383, 1385, 1388, 1391, 1394, 1396, 1398, 1400, 1402,
+    1404, 1406, 1409, 1411, 1413, 1415, 1417, 1419, 1422, 1424, 1426, 1428, 1430,
+    1433, 1435, 1437, 1439, 1442, 1445, 1448, 1451, 1453, 1455, 1457, 1459, 1461,
+    1463, 1465, 1468, 1470, 1472, 1474, 1476, 1478, 1480, 1482, 1484, 1487, 1489,
+    1492, 1494, 1497, 1499, 1501, 1503, 1506, 1508, 1510, 1513, 1515, 1517, 1519,
+    1521, 1523, 1525, 1527, 1529, 1531, 1534, 1536, 1538, 1540, 1542, 1545, 1547,
+    1549, 1551, 1553, 1555, 1558, 1560, 1563, 1565, 1567,
+
+    1570, 1573, 1576, 1578, 1580, 1582, 1584, 1586, 1589, 1591, 1593, 1595, 1598,
+    1601, 1603, 1606, 1609, 1613, 1613, 1613, 1615, 1616, 1616, 1616, 1616, 1616,
+    1617, 1618, 1619, 1621, 1624, 1626, 1629, 1631, 1633, 1635, 1637, 1639, 1641,
+    1644, 1647, 1649, 1651, 1653, 1655, 1657, 1659, 1661, 1663, 1665, 1667, 1669,
+    1671, 1673, 1675, 1677, 1679, 1681, 1683, 1685, 1687, 1689, 1691, 1694, 1697,
+    1700, 1702, 1705, 1707, 1709, 1712, 1715, 1717, 1720, 1722, 1724, 1726, 1728,
+    1731, 1733, 1735, 1737, 1739, 1741, 1743, 1746, 1749, 1751, 1753, 1755, 1757,
+    1759, 1761, 1763, 1765, 1767, 1769, 1771, 1773, 1775,
+
+    1777, 1780, 1782, 1784, 1787, 1789, 1791, 1793, 1795, 1798, 1800, 1802, 1804,
+    1806, 1808, 1811, 1812, 1813, 1813, 1814, 1814, 1814, 1815, 1815, 1815, 1815,
+    1816, 1817, 1818, 1819, 1820, 1822, 1825, 1827, 1830, 1832, 1834, 1836, 1838,
+    1840, 1842, 1845, 1848, 1850, 1852, 1854, 1856, 1858, 1860, 1862, 1864, 1866,
+    1868, 1870, 1872, 1874, 1876, 1878, 1880, 1882, 1884, 1886, 1888, 1890, 1892,
+    1895, 1898, 1901, 1903, 1906, 1908, 1910, 1913, 1916, 1918, 1921, 1923, 1925,
+    1927, 1929, 1932, 1934, 1936, 1938, 1940, 1942, 1944, 1947, 1950, 1952, 1954,
+    1956, 1958, 1960, 1962, 1964, 1966, 1968, 1970, 1972,
+
+    1974, 1976, 1978, 1981, 1983, 1985, 1988, 1990, 1992, 1994, 1996, 1999, 2001,
+    2003, 2005, 2007, 2009, 2012, 2012, 2012, 2014, 2014, 2014, 2014, 2015, 2015,
+    2015, 2017, 2020, 2022, 2024, 2026, 2029, 2031, 2033, 2035, 2037, 2040, 2043,
+    2045, 2048, 2050, 2053, 2055, 2057, 2059, 2061, 2063, 2065, 2067, 2069, 2072,
+    2074, 2076, 2079, 2082, 2085, 2087, 2089, 2091, 2093, 2096, 2099, 2101, 2103,
+    2106, 2108, 2110, 2112, 2115, 2117, 2120, 2122, 2124, 2126, 2128, 2130, 2133,
+    2135, 2138, 2140, 2143, 2145, 2148, 2151, 2154, 2157, 2159, 2161, 2163, 2165,
+    2167, 2170, 2173, 2175, 2178, 2180, 2180, 2180, 2181,
+
+    2181, 2181, 2182, 2182, 2182, 2184, 2186, 2189, 2191, 2193, 2195, 2198, 2200,
+    2202, 2204, 2206, 2209, 2212, 2214, 2217, 2219, 2222, 2224, 2226, 2228, 2230,
+    2232, 2234, 2236, 2238, 2241, 2243, 2245, 2248, 2251, 2254, 2256, 2258, 2260,
+    2262, 2265, 2268, 2270, 2272, 2275, 2277, 2279, 2281, 2284, 2286, 2289, 2291,
+    2293, 2295, 2297, 2299, 2302, 2304, 2307, 2309, 2312, 2314, 2317, 2320, 2323,
+    2326, 2328, 2330, 2332, 2334, 2336, 2339, 2342, 2344, 2347, 2349, 2349, 2349,
+    2352, 2353, 2354, 2355, 2358, 2360, 2363, 2366, 2368, 2370, 2373, 2375, 2378,
+    2380, 2382, 2384, 2386, 2388, 2391, 2394, 2397, 2399,
+
+    2401, 2404, 2407, 2409, 2411, 2414, 2416, 2418, 2420, 2423, 2425, 2428, 2430,
+    2433, 2435, 2437, 2439, 2442, 2444, 2446, 2448, 2450, 2453, 2455, 2457, 2460,
+    2461, 2462, 2463, 2464, 2467, 2469, 2472, 2475, 2477, 2479, 2482, 2484, 2487,
+    2489, 2491, 2493, 2495, 2497, 2500, 2503, 2506, 2508, 2510, 2513, 2516, 2518,
+    2520, 2523, 2525, 2527, 2529, 2532, 2534, 2537, 2539, 2542, 2544, 2546, 2548,
+    2551, 2553, 2555, 2557, 2559, 2562, 2564, 2566, 2569, 2569, 2569, 2569, 2569,
+    2571, 2572, 2572, 2574, 2576, 2578, 2581, 2583, 2586, 2588, 2591, 2593, 2595,
+    2598, 2600, 2603, 2606, 2608, 2610, 2613, 2615, 2617,
+
+    2619, 2621, 2624, 2627, 2629, 2631, 2634, 2637, 2639, 2641, 2643, 2646, 2648,
+    2651, 2653, 2656, 2658, 2660, 2663, 2665, 2668, 2671, 2673, 2675, 2678, 2680,
+    2682, 2684, 2686, 2689, 2692, 2694, 2696, 2699, 2702, 2703, 2704, 2704, 2706,
+    2709, 2711, 2714, 2717, 2719, 2721, 2724, 2726, 2728, 2731, 2733, 2736, 2738,
+    2741, 2744, 2746, 2749, 2751, 2754, 2757, 2759, 2761, 2764, 2766, 2768, 2771,
+    2773, 2776, 2778, 2781, 2784, 2784, 2784, 2786, 2788, 2791, 2794, 2797, 2799,
+    2802, 2805, 2807, 2809, 2812, 2815, 2818, 2820, 2823, 2826, 2827, 2829, 2832,
+    2834, 2836, 2839, 2841, 2843, 2846, 2848, 2851, 2854,
+
+    2857, 2857};
+
+static const YY_CHAR yy_ec[256] = {
+    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  4,  4,  5,  1,  1,  1,  1,  1,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  6,  1,  7,  8,  9,  1,  1,  10, 11, 12,
+    12, 13, 12, 14, 15, 12, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 18, 19, 20, 21,
+    1,  22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+    42, 43, 44, 45, 46, 47, 48, 1,  1,  1,  1,  49, 1,  50, 51, 52, 53,
+
+    54, 55, 56, 57, 58, 32, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
+    74, 1,  1,  1,  75, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};
+
+static const YY_CHAR yy_meta[76] = {
+    0, 1, 2, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+
+static const flex_int16_t yy_base[1486] = {
+    0,     0,     0,     53,    54,    104,   0,     149,   150,   176,   177,   620,
+    584,   76,    81,    12505, 82,    162,   187,   575,   76,    179,   188,   244,
+    574,   73,    559,   77,    319,   370,   421,   472,   520,   567,   240,   419,
+    615,   242,   470,   242,   471,   662,   707,   469,   752,   803,   184,   592,
+    532,   144,   606,   229,   397,   547,   582,   629,   790,   750,   707,   868,
+    889,   942,   996,   817,   897,   918,   948,   1071,  1122,  1173,  1224,  1272,
+    1319,  626,   805,   1367,  633,   996,   993,   994,   1414,  1460,  995,   1509,
+    1560,  1608,  1171,  1222,  1653,  924,   208,   159,   550,   1720,  319,   93,
+    12505, 561,   80,    970,   195,
+
+    12505, 538,   1795,  714,   413,   724,   548,   268,   711,   294,   1870,  536,
+    514,   469,   1222,  1945,  1276,  1328,  1334,  1363,  1413,  1507,  1513,  1573,
+    1622,  1435,  1457,  1558,  1720,  1717,  1993,  1718,  1783,  2032,  2076,  1126,
+    1604,  1719,  1799,  1866,  1403,  1805,  1867,  1868,  1797,  1869,  1933,  1953,
+    1978,  2098,  2076,  2110,  2123,  2024,  1651,  2138,  2159,  2198,  2158,  2201,
+    2248,  2242,  2243,  2285,  2299,  2308,  2329,  2185,  2357,  2408,  2330,  2407,
+    2454,  2454,  2482,  2504,  2508,  2523,  2552,  2369,  2555,  2558,  2595,  2595,
+    2599,  2619,  2644,  2654,  2668,  2676,  2697,  2717,  1694,  1412,  976,   1507,
+    2776,  2798,  2416,  2819,
+
+    1318,  1976,  2824,  2830,  2838,  2032,  2075,  2874,  2848,  2897,  2908,  2407,
+    2914,  2932,  2942,  2985,  3006,  3013,  3066,  3073,  3039,  3099,  3126,  3153,
+    3174,  3180,  3201,  3228,  3303,  3378,  174,   249,   1803,  420,   171,   389,
+    629,   424,   422,   177,   245,   736,   1172,  3219,  649,   551,   733,   3058,
+    777,   837,   1127,  373,   479,   1003,  936,   1180,  1275,  612,   1220,  1174,
+    1229,  1285,  2128,  574,   247,   806,   1876,  402,   1125,  931,   2832,  1512,
+    1467,  1551,  1727,  786,   413,   2372,  1657,  2437,  2996,  1923,  3431,  1925,
+    1465,  3226,  2192,  862,   1605,  1962,  1967,  2245,  2015,  2735,  437,   1961,
+    1326,  2036,  2070,  2458,
+
+    2325,  2430,  2133,  1346,  3233,  3215,  2121,  494,   2245,  710,   3477,  3545,
+    214,   463,   398,   3324,  12505, 3620,  3331,  0,     3695,  396,   489,   1990,
+    832,   539,   555,   3770,  3314,  3374,  3375,  3377,  3415,  3433,  3477,  3545,
+    3542,  3544,  3616,  3617,  3621,  3691,  2700,  3631,  3695,  3696,  3768,  3769,
+    3791,  3768,  3817,  3822,  3851,  3870,  3878,  3900,  3908,  3931,  3951,  3971,
+    3996,  3379,  3703,  4004,  4027,  4030,  4037,  3832,  4071,  4073,  4093,  4105,
+    4111,  4129,  4168,  4143,  4182,  4184,  4208,  4222,  4246,  4259,  4260,  4298,
+    4247,  4299,  4311,  4312,  4336,  4349,  4361,  4377,  4389,  4405,  4413,  4427,
+    4439,  4456,  4451,  4476,
+
+    4519,  4517,  4521,  4557,  4556,  4584,  4606,  4608,  4636,  4658,  4660,  4688,
+    4710,  4712,  4741,  4759,  4712,  4771,  4776,  4799,  4813,  4812,  4833,  4835,
+    4864,  4878,  4900,  4906,  4902,  4949,  4951,  4953,  4993,  4992,  2925,  5059,
+    2960,  3520,  3207,  5080,  5086,  3337,  4532,  5108,  3106,  3510,  4077,  5157,
+    5115,  3972,  3132,  4183,  5178,  5232,  5185,  5206,  5255,  5262,  5283,  5290,
+    5312,  2496,  620,   633,   2548,  679,   755,   2481,  2584,  856,   3033,  2038,
+    1817,  2413,  4634,  1407,  885,   2244,  2307,  2554,  1733,  2247,  2677,  2637,
+    3545,  3089,  4600,  3238,  2696,  2834,  907,   2434,  2997,  3164,  1277,  1802,
+    3424,  2835,  938,   3170,
+
+    3411,  1009,  3430,  3239,  3322,  2188,  2050,  3558,  2333,  2585,  2151,  3625,
+    3894,  4092,  1882,  3432,  3809,  3915,  2541,  3943,  1013,  3626,  1176,  1394,
+    3700,  3955,  3469,  3848,  3091,  3962,  4024,  3963,  1506,  4640,  1532,  3701,
+    3870,  3975,  4398,  4175,  1611,  4702,  4415,  4505,  2512,  1670,  3761,  2722,
+    4264,  4540,  1701,  4455,  3552,  4240,  4504,  4543,  4167,  4668,  4832,  4576,
+    3817,  4763,  1711,  2743,  4974,  4325,  3901,  5308,  258,   1234,  5309,  5387,
+    5462,  5537,  5134,  455,   5346,  5612,  5687,  5762,  5837,  600,   726,   5383,
+    5387,  5385,  5458,  5459,  5460,  5464,  5533,  5534,  5535,  5613,  5536,  5610,
+    5611,  5683,  5612,  5684,
+
+    5685,  5758,  5759,  5760,  5836,  5838,  5875,  5870,  5910,  5916,  5939,  5955,
+    5761,  5834,  5975,  5987,  5989,  6022,  6024,  6046,  6071,  6059,  6093,  6096,
+    6118,  6126,  6140,  6150,  6170,  6173,  6183,  6204,  6224,  6222,  6236,  6265,
+    6268,  6281,  6286,  6321,  6327,  6356,  6372,  6390,  6350,  6402,  6415,  6437,
+    6370,  6454,  6475,  6439,  6496,  6497,  6498,  6526,  6548,  6550,  6582,  6550,
+    6598,  6622,  6623,  6652,  6677,  6674,  6707,  6699,  6721,  6746,  6758,  6759,
+    6760,  6793,  6807,  6815,  6850,  6600,  6654,  6854,  6855,  6898,  6898,  6900,
+    6912,  6941,  6949,  6963,  6971,  7025,  7093,  7168,  7243,  7048,  7133,  5371,
+    7073,  5212,  7147,  7055,
+
+    7119,  7318,  7191,  7393,  7468,  5722,  7208,  7543,  7218,  7265,  7618,  7693,
+    4854,  1223,  2918,  3812,  1488,  4578,  473,   683,   5105,  4121,  4793,  2632,
+    2648,  4882,  4922,  701,   2996,  4973,  3236,  4524,  5389,  4723,  2990,  4405,
+    4637,  3700,  811,   5066,  5069,  1273,  873,   1117,  5320,  1225,  3732,  4433,
+    4929,  4658,  4848,  5544,  4084,  1309,  1325,  5391,  5033,  5155,  1558,  5461,
+    1367,  5469,  1405,  5395,  1476,  5157,  1520,  5232,  2831,  5545,  1540,  1587,
+    5874,  1603,  5764,  1846,  5386,  5616,  5695,  4590,  5762,  5895,  5887,  1932,
+    2005,  3378,  5614,  4757,  2078,  5318,  5324,  4972,  5930,  6004,  2093,  5689,
+    2162,  5959,  5615,  2179,
+
+    2209,  3626,  5889,  5468,  2603,  5923,  5811,  2226,  4361,  5988,  6035,  2305,
+    2363,  6168,  2388,  2459,  7314,  2273,  2351,  7317,  7768,  7843,  408,   6560,
+    7918,  7993,  8068,  8143,  7316,  7389,  7390,  7391,  7392,  7464,  7465,  7543,
+    7542,  7466,  7467,  7541,  7544,  7614,  7615,  7617,  7689,  7691,  7692,  7764,
+    7843,  7765,  7766,  7767,  7844,  7842,  7914,  7841,  7915,  7989,  7990,  7991,
+    7992,  8066,  8065,  8067,  8068,  8139,  8140,  8173,  8174,  8198,  8212,  8226,
+    8250,  8263,  8264,  8293,  8311,  8323,  8336,  8360,  8348,  8385,  8388,  8413,
+    8410,  8435,  8443,  8468,  8480,  8502,  8524,  8527,  8549,  8557,  8579,  8571,
+    8601,  8623,  8641,  8653,
+
+    8671,  8696,  8693,  8721,  8733,  8734,  8773,  8791,  8803,  8816,  8828,  8846,
+    8871,  8883,  8895,  6061,  8968,  9043,  7197,  7292,  7271,  7066,  9001,  8990,
+    9118,  7298,  9193,  9064,  9268,  9343,  5393,  2654,  5534,  2725,  2783,  6229,
+    5922,  4694,  6223,  5769,  2885,  2935,  6285,  6075,  6276,  6388,  6306,  6415,
+    3057,  6044,  4705,  3161,  6474,  6298,  4833,  3294,  6102,  6761,  6561,  6421,
+    6771,  3354,  5693,  6567,  3493,  3540,  3594,  5971,  3645,  6108,  6599,  3968,
+    4054,  6375,  4075,  6651,  6801,  6152,  6819,  4090,  6701,  6820,  6805,  6925,
+    6874,  6943,  4136,  4186,  6976,  5829,  4271,  6341,  6241,  6726,  6915,  6957,
+    4281,  6979,  6592,  6849,
+
+    7077,  4294,  4351,  7094,  7251,  4395,  4447,  7091,  7092,  7326,  4455,  7248,
+    7616,  7401,  6213,  7694,  4486,  2414,  3172,  9041,  9418,  9493,  418,   9016,
+    9568,  9643,  9718,  9114,  9115,  9116,  9189,  9117,  9191,  9192,  9264,  9265,
+    9266,  9267,  9339,  9340,  9341,  9342,  9418,  9415,  9493,  9416,  9417,  9492,
+    9490,  9491,  9564,  9566,  9567,  9639,  9640,  9641,  9642,  9714,  9715,  9717,
+    9754,  9755,  9767,  9768,  9792,  9805,  9827,  9835,  9849,  9857,  9879,  9882,
+    9912,  9920,  9934,  9959,  9967,  10000, 9992,  10014, 10022, 10057, 10044, 10069,
+    10081, 10094, 10119, 10122, 10147, 10169, 10171, 10172, 10209, 10222, 10221, 10234,
+    10307, 10382, 7952,  8949,
+
+    10337, 10344, 10457, 10532, 8482,  10607, 4538,  7620,  7545,  7176,  4556,  7316,
+    7367,  7697,  4580,  4642,  4898,  7315,  4912,  7466,  5063,  7776,  7165,  7926,
+    6980,  5083,  6742,  8279,  7542,  5107,  7469,  8174,  5165,  5189,  5262,  7623,
+    7547,  7768,  5271,  5304,  5325,  5428,  7701,  5463,  5470,  7322,  8182,  5513,
+    7618,  5679,  7847,  7845,  7913,  8322,  7767,  5770,  7994,  5876,  8425,  5957,
+    8263,  6006,  6130,  6143,  6186,  8070,  8061,  8201,  7844,  7923,  6233,  6313,
+    8067,  6334,  6419,  6438,  6479,  10682, 10757, 413,   10832, 10307, 10379, 10381,
+    10453, 10454, 10456, 10528, 10529, 10530, 10531, 10603, 10604, 10605, 10606, 10678,
+    10679, 10680, 10757, 10681,
+
+    10754, 10755, 10828, 10756, 10829, 10830, 10842, 10877, 10885, 10899, 10907, 10929,
+    10932, 10962, 10970, 11007, 11010, 11044, 11047, 11069, 11087, 11099, 11112, 11124,
+    11136, 11209, 9023,  9071,  11284, 6508,  7700,  6543,  6560,  8587,  8236,  6632,
+    8609,  6705,  6763,  8631,  7245,  8649,  7992,  6813,  6867,  6908,  8246,  8140,
+    6998,  7016,  7400,  8363,  7043,  8701,  8438,  7476,  7246,  8758,  7325,  8368,
+    7475,  8474,  7546,  8507,  7615,  8504,  8149,  7669,  8600,  7775,  8763,  8831,
+    7881,  0,     10299, 10418, 401,   11359, 11434, 11509, 11209, 11207, 11206, 11280,
+    11282, 11283, 11355, 11356, 11358, 11430, 11431, 11432, 11505, 11506, 11508, 11545,
+    11546, 11558, 11559, 11596,
+
+    11597, 11598, 11599, 11636, 11637, 11649, 11650, 8543,  7916,  8665,  7924,  8306,
+    8000,  8841,  8001,  8555,  8042,  8076,  8666,  8106,  8143,  8603,  8742,  8198,
+    8877,  8896,  8973,  9190,  8243,  8295,  9110,  8390,  8360,  8415,  11044, 391,
+    11723, 11719, 11720, 11721, 11722, 11759, 11772, 11773, 11802, 11824, 11837, 11836,
+    11861, 11885, 11886, 11898, 11910, 8670,  8452,  8753,  8462,  8479,  9050,  9118,
+    8502,  8706,  8776,  8565,  8785,  8616,  8970,  8651,  8697,  11983, 12058, 11979,
+    11981, 11982, 12054, 12055, 12056, 12057, 12094, 9200,  9269,  8717,  8771,  8773,
+    9044,  8822,  8850,  12167, 12163, 12164, 12166, 9119,  8865,  9197,  12204, 12207,
+    9270,  8881,  12232, 8895,
+
+    12505, 325,   12305, 12308, 322,   12311, 12314, 12317, 12320, 12323, 240,   12326,
+    12328, 12331, 12334, 239,   237,   12336, 12339, 12342, 12345, 12348, 12351, 12354,
+    12357, 12360, 12363, 227,   12366, 12368, 12370, 12373, 12375, 215,   12377, 12380,
+    12383, 12386, 12389, 12392, 100,   12395, 12397, 12399, 12401, 12403, 12406, 12409,
+    12411, 12414, 12417, 12420, 12423, 12426, 12429, 12432, 12435, 12438, 12441, 12444,
+    12447, 12450, 79,    12453, 12455, 12457, 12459, 12461, 12464, 12466, 12468, 12471,
+    12474, 12477, 12480, 12482, 12484, 12487, 12490, 12492, 12494, 12496, 12498, 12500,
+    12502};
+
+static const flex_int16_t yy_def[1486] = {
+    0,    1401, 1,    1,    1,    1401, 5,    1,    1,    1,    1,    1401, 1402,
+    1401, 1401, 1401, 1403, 1402, 1404, 1402, 1402, 1402, 1402, 1405, 1402, 1402,
+    1402, 1402, 1401, 28,   29,   29,   29,   29,   29,   29,   32,   32,   29,
+    29,   29,   32,   41,   29,   29,   29,   41,   29,   29,   28,   1406, 1407,
+    1407, 1407, 1407, 1408, 1406, 1409, 1406, 1406, 1406, 1406, 1410, 1406, 1406,
+    1406, 1406, 1401, 67,   68,   68,   68,   68,   68,   68,   71,   71,   68,
+    68,   68,   71,   68,   68,   68,   68,   71,   68,   68,   41,   1401, 1402,
+    44,   1402, 1411, 1401, 1403, 1401, 1412, 1402, 1404, 1413,
+
+    1401, 1402, 1414, 1415, 1402, 1402, 1402, 1402, 1402, 1402, 1416, 1402, 1402,
+    1402, 41,   1417, 41,   32,   32,   32,   41,   41,   41,   41,   41,   29,
+    29,   29,   29,   29,   41,   29,   41,   41,   41,   135,  135,  29,   29,
+    29,   135,  32,   29,   29,   41,   29,   41,   29,   29,   29,   29,   29,
+    29,   135,  135,  135,  41,   41,   32,   32,   32,   32,   41,   41,   29,
+    32,   32,   29,   29,   41,   32,   32,   32,   29,   29,   29,   32,   32,
+    32,   29,   32,   32,   32,   29,   32,   29,   32,   29,   29,   29,   41,
+    135,  1406, 1407, 1407, 1407, 1406, 1418, 1407, 1407,
+
+    1407, 1419, 1419, 1407, 1419, 1420, 1419, 1406, 1421, 1422, 1407, 1422, 1422,
+    1406, 1421, 1423, 1424, 1406, 1406, 1406, 1406, 1406, 1406, 1425, 1406, 1406,
+    1406, 1426, 1427, 1426, 230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,
+
+    230,  230,  230,  230,  135,  1401, 1401, 1401, 1402, 1402, 135,  1428, 1429,
+    1429, 1429, 1430, 1401, 1431, 1415, 1432, 1433, 1402, 1402, 1402, 1402, 1402,
+    1402, 1434, 29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   135,  29,   41,   135,  135,  135,  135,  135,  135,  29,   29,   135,
+    135,  29,   29,   29,   29,   135,  135,  135,  135,  41,   41,   41,   29,
+    29,   135,  41,   135,  135,  135,  29,   41,   41,   41,   41,   41,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    135,  29,   135,  41,   29,   29,   41,   29,   135,
+
+    135,  135,  135,  135,  29,   29,   29,   29,   29,   29,   29,   29,   29,
+    41,   41,   135,  29,   29,   135,  41,   41,   41,   29,   29,   41,   29,
+    29,   41,   29,   135,  135,  41,   41,   41,   1407, 1435, 1420, 1419, 1420,
+    1420, 1420, 1420, 1420, 1436, 1407, 1422, 1422, 1437, 1424, 1438, 1438, 1438,
+    1424, 1439, 1406, 1406, 1406, 1406, 1406, 1406, 1440, 230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,
+
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
+    230,  230,  29,   1401, 1402, 29,   1428, 1441, 1442, 1443, 1444, 1443, 1445,
+    1446, 1447, 1448, 1402, 1402, 29,   41,   29,   29,   29,   29,   41,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,
+
+    29,   29,   29,   29,   29,   41,   41,   41,   41,   41,   41,   41,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   41,   29,   29,   41,   41,   29,   41,   41,   41,   41,   41,   41,
+    41,   41,   41,   29,   29,   41,   29,   29,   29,   41,   41,   41,   29,
+    29,   29,   29,   29,   29,   41,   41,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   41,
+    41,   41,   41,   41,   29,   29,   29,   29,   29,   29,   29,   1407, 1435,
+    1449, 1450, 1451, 1452, 1453, 1454, 1454, 1454, 1453,
+
+    1453, 1455, 1456, 1457, 1458, 1459, 1459, 1460, 1461, 1461, 1462, 1462, 712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,
+
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  29,   1401, 1402, 29,   1463, 1464, 1465, 1466, 1467, 1468,
+    1469, 1470, 29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,
+
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   1471, 1449, 1472, 1451, 1452, 1454, 1454, 1454, 1453, 1473, 1456,
+    1458, 1459, 1460, 1474, 712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,
+
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  1401, 1402, 29,   1464, 1475, 1465, 1466, 1467, 1476,
+    1470, 29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   1472, 1477, 1452, 1454,
+
+    1454, 1453, 1473, 1478, 1459, 1474, 712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  1401, 1402, 1479,
+    1475, 1465, 1476, 29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,
+
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   1477,
+    1454, 1454, 1478, 712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  1480, 1481, 1481, 1480, 1479,
+    1482, 1483, 29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,
+
+    29,   29,   29,   29,   29,   29,   29,   712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  712,  712,  712,  712,  1481, 1480, 1484, 29,   29,
+    29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+    29,   712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,  712,
+    712,  712,  712,  712,  1484, 1485, 29,   29,   29,   29,   29,   29,   29,
+    29,   712,  712,  712,  712,  712,  712,  712,  712,  1485, 29,   29,   29,
+    712,  712,  712,  29,   29,   712,  712,  29,   712,
+
+    0,    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401};
+
+static const flex_int16_t yy_nxt[12581] = {
+    0,    12,   13,   14,   15,   13,   13,   16,   17,   12,   18,   19,   19,   19,
+    20,   21,   22,   23,   24,   25,   26,   27,   12,   28,   29,   30,   31,   32,
+    33,   34,   35,   36,   37,   37,   38,   39,   40,   41,   42,   37,   43,   44,
+    45,   46,   47,   48,   37,   37,   37,   37,   28,   29,   30,   31,   32,   33,
+    34,   35,   36,   37,   38,   39,   40,   41,   42,   37,   43,   44,   45,   46,
+    47,   48,   37,   37,   37,   12,   49,   49,   94,   94,   821,  94,   94,   94,
+    94,   96,   94,   94,   316,  97,   104,  105,  106,  112,  113,  93,   96,   114,
+    93,   93,   313,
+
+    821,  93,   49,   49,   50,   51,   52,   53,   54,   51,   55,   56,   50,   57,
+    58,   58,   58,   59,   60,   61,   62,   63,   64,   65,   66,   50,   67,   68,
+    69,   70,   71,   72,   73,   74,   75,   76,   76,   77,   78,   79,   80,   81,
+    76,   82,   83,   84,   85,   86,   87,   76,   76,   76,   76,   67,   68,   69,
+    70,   71,   72,   73,   74,   75,   76,   77,   78,   79,   80,   81,   76,   82,
+    83,   84,   85,   86,   87,   76,   76,   76,   50,   88,   88,   89,   89,   93,
+    192,  311,  90,   90,   100,  101,  100,  100,  100,  100,  107,  470,  102,  101,
+    228,  463,
+
+    93,   228,  109,  106,  317,  108,  88,   88,   103,  93,   192,  115,  311,  307,
+    110,  328,  91,   91,   309,  184,  315,  185,  470,  115,  186,  228,  463,  572,
+    228,  93,   199,  199,  108,  200,  199,  574,  98,   116,  115,  328,  312,  110,
+    91,   91,   92,   184,  201,  185,  310,  115,  186,  92,   92,   92,   92,   92,
+    92,   92,   92,   92,   92,   92,   92,   92,   92,   93,   149,  115,  115,  228,
+    115,  228,  115,  228,  310,  115,  115,  115,  159,  150,  322,  322,  464,  323,
+    160,  475,  115,  115,  115,  93,   465,  818,  92,   149,  115,  115,  228,  115,
+    228,  115,
+
+    228,  115,  115,  115,  159,  150,  326,  326,  464,  327,  160,  475,  115,  115,
+    115,  93,   465,  818,  92,   92,   94,   94,   111,  94,   94,   92,   92,   115,
+    92,   92,   92,   92,   116,  92,   115,  92,   92,   92,   92,   92,   93,   115,
+    115,  117,  118,  115,  115,  115,  115,  115,  115,  115,  119,  115,  120,  115,
+    115,  115,  121,  122,  115,  123,  115,  115,  115,  115,  115,  115,  115,  115,
+    117,  118,  115,  115,  115,  115,  115,  115,  119,  115,  120,  115,  115,  115,
+    121,  122,  115,  123,  115,  115,  115,  115,  115,  92,   115,  115,  124,  228,
+    199,  199,
+
+    125,  200,  199,  115,  315,  115,  126,  496,  1336, 115,  115,  323,  115,  228,
+    201,  823,  127,  93,   1336, 574,  823,  115,  115,  124,  228,  1180, 228,  125,
+    107,  115,  471,  115,  126,  496,  93,   115,  115,  228,  115,  108,  228,  151,
+    127,  128,  468,  115,  228,  115,  228,  115,  129,  115,  473,  228,  130,  115,
+    471,  131,  474,  469,  132,  228,  823,  133,  228,  115,  108,  115,  151,  315,
+    128,  468,  115,  228,  115,  228,  115,  129,  115,  473,  130,  115,  1023, 131,
+    474,  469,  132,  1023, 228,  133,  93,   115,  156,  115,  134,  170,  157,  115,
+    135,  115,
+
+    158,  115,  136,  228,  323,  171,  115,  161,  137,  497,  93,   138,  228,  162,
+    139,  115,  115,  115,  115,  156,  569,  134,  170,  157,  115,  135,  115,  158,
+    115,  136,  228,  171,  115,  161,  137,  93,   497,  138,  228,  162,  139,  115,
+    115,  115,  115,  140,  115,  569,  194,  194,  115,  196,  194,  141,  327,  142,
+    115,  93,   115,  93,   93,   189,  190,  107,  201,  143,  115,  315,  191,  93,
+    327,  93,   140,  115,  108,  228,  93,   115,  115,  141,  93,   142,  115,  199,
+    199,  115,  200,  199,  189,  190,  485,  143,  115,  144,  191,  93,   93,   145,
+    228,  201,
+
+    146,  108,  228,  147,  115,  93,   148,  194,  194,  195,  196,  194,  195,  115,
+    187,  583,  485,  511,  115,  1401, 144,  93,   188,  197,  145,  228,  146,  198,
+    115,  147,  203,  204,  148,  205,  203,  206,  228,  1401, 115,  115,  115,  187,
+    152,  511,  228,  115,  207,  1401, 153,  188,  154,  503,  262,  228,  115,  155,
+    228,  228,  228,  1401, 115,  1401, 228,  228,  115,  263,  228,  115,  228,  152,
+    472,  228,  228,  228,  153,  484,  154,  503,  228,  262,  228,  155,  1401, 228,
+    228,  228,  115,  115,  228,  163,  1401, 263,  228,  1401, 228,  115,  472,  164,
+    228,  165,
+
+    228,  166,  484,  228,  228,  1401, 1401, 115,  194,  194,  195,  196,  194,  195,
+    115,  320,  163,  320,  320,  320,  320,  115,  228,  164,  197,  165,  324,  166,
+    198,  1401, 228,  93,   93,   115,  115,  321,  570,  325,  109,  106,  228,  583,
+    115,  167,  115,  93,   168,  93,   228,  169,  110,  210,  211,  212,  213,  210,
+    212,  228,  476,  214,  228,  115,  477,  570,  325,  1401, 228,  215,  115,  167,
+    115,  216,  168,  486,  487,  169,  172,  110,  173,  228,  1401, 174,  115,  1401,
+    228,  476,  175,  228,  176,  477,  177,  194,  194,  195,  196,  194,  195,  1401,
+    115,  486,
+
+    487,  492,  1401, 172,  1401, 173,  228,  197,  174,  115,  228,  198,  175,  527,
+    176,  1401, 177,  493,  194,  194,  195,  196,  194,  195,  115,  178,  1401, 264,
+    492,  179,  228,  228,  180,  181,  197,  228,  512,  228,  198,  182,  527,  228,
+    183,  493,  582,  582,  1401, 583,  1401, 115,  228,  228,  178,  93,   264,  1401,
+    179,  228,  228,  180,  181,  228,  228,  512,  208,  182,  1401, 228,  183,  194,
+    194,  195,  196,  194,  195,  115,  228,  228,  1401, 494,  228,  217,  218,  219,
+    549,  197,  228,  1401, 228,  198,  194,  194,  195,  196,  194,  195,  1401, 1401,
+    194,  194,
+
+    195,  196,  194,  195,  220,  494,  197,  228,  1401, 722,  198,  549,  228,  228,
+    197,  221,  225,  226,  198,  194,  194,  195,  196,  194,  195,  94,   94,   1401,
+    94,   306,  1401, 739,  1401, 1401, 307,  197,  722,  1401, 228,  198,  1401, 1401,
+    221,  194,  194,  195,  196,  194,  195,  194,  194,  195,  196,  194,  195,  228,
+    222,  219,  739,  197,  228,  499,  228,  198,  308,  197,  517,  227,  223,  198,
+    1401, 100,  101,  100,  100,  100,  100,  194,  194,  102,  196,  194,  228,  1401,
+    1401, 1401, 1401, 228,  499,  228,  308,  103,  517,  201,  1401, 223,  193,  194,
+    194,  195,
+
+    196,  194,  195,  193,  193,  193,  193,  193,  193,  193,  193,  193,  193,  197,
+    193,  193,  193,  198,  269,  228,  228,  283,  270,  228,  228,  228,  271,  228,
+    1401, 272,  274,  284,  228,  749,  1401, 273,  275,  228,  1401, 228,  228,  228,
+    228,  498,  193,  269,  228,  228,  283,  270,  228,  228,  228,  271,  228,  272,
+    274,  284,  228,  1401, 749,  273,  275,  1401, 228,  228,  228,  228,  228,  498,
+    193,  193,  194,  194,  195,  196,  194,  195,  193,  228,  193,  193,  193,  193,
+    229,  193,  228,  193,  197,  193,  193,  193,  198,  228,  228,  230,  231,  228,
+    228,  228,
+
+    228,  228,  228,  228,  232,  228,  233,  228,  228,  228,  234,  235,  228,  236,
+    228,  228,  228,  228,  228,  228,  228,  228,  230,  231,  228,  228,  228,  228,
+    228,  228,  232,  228,  233,  228,  228,  228,  234,  235,  228,  236,  228,  228,
+    228,  228,  228,  193,  228,  228,  237,  228,  359,  228,  238,  115,  1401, 228,
+    228,  228,  239,  115,  515,  228,  228,  495,  228,  516,  360,  1401, 240,  1401,
+    1401, 1401, 1401, 228,  228,  237,  228,  359,  228,  238,  115,  228,  228,  228,
+    239,  115,  515,  228,  228,  495,  228,  516,  360,  300,  240,  241,  228,  228,
+    228,  228,
+
+    228,  301,  242,  228,  228,  1401, 243,  228,  478,  244,  500,  1401, 245,  505,
+    479,  246,  506,  228,  1401, 228,  300,  501,  241,  228,  228,  228,  228,  228,
+    301,  242,  228,  228,  243,  228,  478,  244,  1401, 500,  245,  505,  479,  246,
+    506,  228,  228,  228,  247,  501,  228,  115,  248,  302,  303,  228,  249,  93,
+    504,  115,  304,  115,  250,  115,  228,  251,  228,  507,  252,  819,  228,  934,
+    228,  228,  1401, 247,  1401, 228,  115,  248,  302,  303,  228,  249,  504,  115,
+    304,  115,  250,  115,  228,  251,  228,  507,  252,  819,  228,  934,  228,  253,
+    228,  228,
+
+    329,  228,  228,  115,  1401, 254,  961,  255,  228,  228,  1401, 115,  228,  115,
+    743,  115,  502,  256,  228,  194,  194,  508,  196,  194,  253,  228,  228,  329,
+    228,  228,  115,  254,  961,  255,  228,  201,  228,  115,  228,  115,  743,  115,
+    502,  256,  228,  257,  1401, 508,  228,  258,  228,  1401, 259,  330,  1401, 260,
+    559,  1401, 261,  115,  1401, 115,  1401, 115,  970,  228,  1401, 331,  1401, 115,
+    228,  1401, 257,  115,  228,  332,  258,  228,  259,  115,  330,  260,  1401, 559,
+    261,  567,  115,  115,  333,  115,  970,  228,  228,  331,  265,  115,  115,  228,
+    115,  115,
+
+    266,  332,  267,  1401, 1401, 115,  976,  268,  115,  334,  1401, 567,  228,  194,
+    194,  333,  196,  194,  228,  228,  1401, 265,  115,  1401, 115,  1401, 266,  115,
+    267,  201,  115,  228,  976,  268,  115,  334,  115,  335,  228,  228,  115,  276,
+    1401, 365,  228,  228,  721,  228,  115,  277,  115,  278,  336,  279,  115,  1401,
+    435,  115,  228,  228,  1401, 115,  115,  1401, 335,  115,  228,  115,  276,  365,
+    228,  341,  721,  228,  115,  277,  115,  278,  336,  279,  1401, 115,  435,  115,
+    1401, 228,  228,  115,  115,  228,  228,  228,  115,  115,  543,  1401, 280,  341,
+    1401, 281,
+
+    522,  1401, 282,  115,  1401, 1401, 228,  115,  194,  194,  115,  196,  194,  228,
+    115,  228,  228,  228,  228,  115,  1401, 543,  280,  937,  201,  281,  522,  228,
+    282,  115,  779,  337,  228,  285,  115,  286,  228,  521,  287,  228,  115,  228,
+    115,  288,  115,  289,  115,  290,  115,  937,  115,  435,  115,  228,  338,  228,
+    782,  779,  337,  228,  285,  115,  286,  228,  521,  287,  228,  115,  115,  288,
+    115,  289,  115,  290,  115,  228,  115,  435,  115,  228,  338,  228,  291,  782,
+    115,  228,  292,  1401, 115,  293,  294,  1401, 523,  974,  115,  524,  295,  228,
+    342,  296,
+
+    115,  1401, 228,  1401, 115,  228,  228,  1401, 115,  291,  115,  115,  115,  292,
+    339,  115,  293,  294,  523,  974,  115,  524,  295,  228,  342,  296,  983,  115,
+    115,  228,  115,  115,  228,  228,  115,  228,  115,  115,  115,  550,  339,  228,
+    228,  297,  115,  298,  361,  788,  299,  115,  340,  1401, 983,  228,  1401, 115,
+    228,  115,  115,  115,  228,  115,  228,  115,  1401, 550,  1401, 228,  228,  297,
+    115,  298,  361,  788,  299,  115,  115,  340,  115,  228,  152,  228,  530,  115,
+    115,  115,  153,  115,  305,  1401, 115,  115,  115,  155,  228,  194,  194,  195,
+    196,  194,
+
+    195,  1401, 115,  1401, 1401, 115,  1401, 152,  228,  530,  115,  197,  153,  1401,
+    305,  198,  115,  115,  115,  155,  92,   228,  1401, 1401, 1401, 228,  1401, 92,
+    92,   92,   92,   92,   92,   92,   92,   811,  92,   92,   92,   92,   92,   93,
+    343,  115,  351,  115,  344,  115,  115,  115,  115,  228,  228,  345,  115,  362,
+    115,  228,  1401, 346,  525,  526,  811,  115,  115,  115,  115,  726,  92,   343,
+    115,  351,  115,  344,  115,  115,  115,  115,  228,  345,  115,  362,  115,  1401,
+    228,  346,  525,  526,  1401, 115,  115,  115,  115,  726,  92,   99,   100,  101,
+    100,  100,
+
+    100,  100,  99,   99,   102,  99,   99,   99,   99,   99,   115,  99,   99,   99,
+    99,   99,   103,  1401, 115,  1401, 115,  1401, 352,  1401, 115,  115,  228,  228,
+    466,  115,  366,  1401, 115,  363,  115,  115,  370,  115,  115,  744,  115,  228,
+    1401, 99,   115,  115,  115,  717,  352,  467,  115,  115,  115,  228,  228,  466,
+    115,  366,  115,  363,  115,  115,  370,  1401, 115,  744,  115,  1401, 228,  99,
+    92,   115,  1401, 1401, 717,  467,  115,  92,   92,   92,   92,   92,   92,   92,
+    92,   987,  92,   92,   92,   92,   92,   93,   115,  115,  115,  115,  364,  367,
+    115,  115,
+
+    228,  1401, 115,  115,  115,  371,  228,  1401, 368,  369,  764,  987,  115,  115,
+    115,  115,  513,  514,  1401, 115,  115,  115,  115,  364,  367,  115,  115,  228,
+    115,  115,  115,  371,  1401, 228,  368,  369,  1401, 764,  115,  115,  115,  115,
+    513,  514,  92,   92,   536,  228,  1401, 228,  1401, 1401, 92,   1401, 92,   92,
+    92,   92,   542,  92,   115,  92,   92,   92,   92,   92,   93,   1401, 115,  1401,
+    115,  228,  372,  536,  228,  373,  228,  203,  204,  115,  205,  203,  437,  115,
+    542,  228,  228,  115,  1401, 374,  552,  228,  1401, 207,  115,  551,  115,  228,
+    372,  115,
+
+    1401, 373,  1401, 558,  115,  324,  115,  1401, 115,  1401, 115,  93,   228,  228,
+    375,  374,  325,  552,  228,  92,   115,  551,  1401, 1401, 115,  115,  347,  348,
+    349,  558,  350,  115,  115,  440,  194,  115,  441,  440,  442,  228,  375,  555,
+    1401, 325,  995,  1401, 1401, 115,  115,  443,  115,  115,  347,  348,  349,  1401,
+    350,  115,  115,  115,  228,  560,  228,  1401, 380,  381,  228,  115,  555,  115,
+    995,  115,  353,  354,  228,  115,  203,  204,  115,  205,  203,  437,  716,  115,
+    754,  1401, 115,  228,  560,  228,  380,  381,  207,  115,  228,  115,  561,  115,
+    353,  354,
+
+    355,  228,  115,  356,  1401, 1401, 115,  1401, 716,  357,  754,  115,  115,  115,
+    1401, 115,  358,  228,  1401, 378,  376,  228,  115,  561,  115,  1401, 307,  355,
+    115,  115,  356,  307,  228,  115,  377,  357,  115,  115,  115,  115,  115,  115,
+    358,  228,  115,  378,  115,  376,  115,  115,  509,  115,  228,  379,  1401, 115,
+    115,  228,  228,  115,  377,  308,  115,  115,  510,  115,  1401, 115,  1401, 115,
+    115,  115,  115,  382,  566,  228,  115,  509,  383,  228,  379,  759,  115,  388,
+    228,  115,  115,  308,  1401, 115,  510,  115,  115,  115,  384,  115,  115,  115,
+    115,  382,
+
+    566,  228,  228,  115,  383,  1401, 1401, 1401, 759,  1401, 388,  400,  228,  115,
+    547,  401,  228,  115,  228,  115,  384,  402,  115,  753,  115,  115,  115,  228,
+    548,  115,  385,  115,  386,  387,  389,  115,  115,  115,  400,  228,  1401, 547,
+    401,  228,  228,  1401, 115,  402,  228,  753,  307,  1401, 115,  115,  548,  309,
+    385,  115,  386,  387,  389,  115,  115,  115,  1401, 228,  93,   115,  228,  228,
+    394,  228,  115,  115,  228,  392,  393,  115,  115,  553,  115,  115,  115,  115,
+    723,  310,  1401, 115,  727,  390,  554,  228,  391,  115,  115,  228,  228,  394,
+    228,  1018,
+
+    115,  392,  393,  115,  115,  553,  115,  115,  115,  115,  723,  310,  115,  115,
+    727,  390,  554,  1401, 391,  115,  115,  1401, 115,  1401, 115,  395,  1018, 1401,
+    1401, 115,  1401, 228,  1401, 397,  1401, 115,  1401, 1401, 1401, 115,  396,  115,
+    1401, 115,  228,  115,  115,  724,  115,  228,  115,  564,  395,  115,  115,  115,
+    115,  228,  228,  398,  397,  115,  399,  409,  115,  115,  396,  115,  757,  115,
+    228,  115,  93,   724,  115,  115,  228,  1019, 564,  115,  403,  115,  115,  115,
+    228,  1401, 398,  115,  399,  409,  115,  115,  1401, 115,  757,  422,  228,  1401,
+    528,  115,
+
+    115,  115,  228,  115,  1019, 115,  1401, 403,  210,  211,  115,  213,  210,  529,
+    115,  115,  445,  199,  199,  115,  200,  199,  422,  228,  446,  528,  115,  228,
+    228,  115,  404,  115,  115,  201,  1401, 405,  410,  228,  1176, 529,  115,  115,
+    115,  406,  1401, 115,  718,  115,  407,  1401, 1401, 408,  115,  228,  228,  1401,
+    565,  404,  228,  115,  435,  228,  405,  410,  228,  1176, 115,  531,  115,  406,
+    532,  115,  718,  115,  407,  740,  414,  408,  115,  115,  115,  228,  228,  565,
+    115,  228,  435,  411,  228,  115,  415,  562,  1401, 412,  531,  413,  532,  563,
+    228,  115,
+
+    115,  740,  1401, 414,  416,  228,  115,  115,  115,  228,  713,  115,  115,  411,
+    1401, 115,  415,  562,  115,  412,  228,  413,  711,  563,  228,  115,  115,  1401,
+    115,  1401, 115,  416,  228,  115,  115,  115,  228,  713,  417,  115,  115,  418,
+    1401, 115,  115,  1401, 419,  228,  115,  711,  115,  1401, 1401, 115,  115,  793,
+    115,  115,  115,  1401, 115,  115,  1401, 228,  417,  228,  115,  418,  115,  115,
+    1401, 768,  228,  419,  712,  115,  115,  115,  228,  115,  115,  793,  115,  115,
+    115,  115,  420,  115,  115,  423,  424,  115,  228,  115,  115,  1401, 725,  421,
+    768,  228,
+
+    115,  712,  1401, 115,  115,  228,  714,  115,  228,  228,  115,  115,  420,  115,
+    115,  423,  424,  115,  1401, 115,  115,  115,  725,  421,  427,  426,  115,  758,
+    115,  115,  115,  115,  115,  714,  115,  228,  228,  425,  1011, 1401, 115,  115,
+    228,  1401, 115,  428,  1401, 115,  115,  115,  1401, 427,  426,  758,  115,  115,
+    115,  115,  115,  729,  115,  228,  1401, 425,  1011, 115,  115,  115,  228,  115,
+    115,  228,  428,  943,  1401, 1401, 115,  429,  1401, 115,  431,  115,  944,  430,
+    115,  1401, 729,  228,  228,  115,  115,  115,  1401, 228,  432,  1401, 115,  228,
+    115,  943,
+
+    115,  228,  115,  429,  115,  115,  115,  431,  944,  430,  1401, 115,  115,  228,
+    115,  115,  115,  433,  737,  228,  228,  432,  115,  728,  115,  115,  115,  115,
+    228,  115,  115,  1401, 115,  115,  115,  115,  434,  115,  115,  594,  115,  337,
+    1401, 433,  115,  737,  228,  228,  115,  728,  115,  115,  1401, 1401, 115,  1401,
+    1401, 115,  115,  228,  115,  115,  434,  115,  228,  594,  795,  228,  337,  556,
+    557,  115,  1401, 228,  1401, 1401, 115,  194,  194,  195,  196,  194,  195,  115,
+    1401, 1401, 228,  812,  1401, 1401, 228,  1401, 795,  197,  228,  556,  557,  198,
+    193,  194,
+
+    194,  195,  196,  194,  195,  193,  193,  193,  193,  193,  193,  193,  193,  812,
+    193,  197,  193,  193,  193,  198,  199,  199,  1109, 200,  199,  203,  204,  1401,
+    205,  203,  437,  194,  194,  1401, 196,  194,  201,  1401, 1401, 203,  204,  207,
+    205,  203,  437,  1401, 193,  201,  1109, 210,  211,  212,  213,  210,  212,  207,
+    228,  214,  228,  228,  738,  746,  1401, 435,  518,  215,  519,  520,  438,  216,
+    228,  981,  193,  1401, 435,  194,  194,  195,  196,  194,  195,  444,  438,  228,
+    1401, 228,  228,  738,  746,  435,  518,  197,  519,  520,  438,  198,  228,  981,
+    210,  211,
+
+    435,  213,  210,  1401, 1401, 1401, 445,  1401, 438,  194,  194,  1401, 196,  194,
+    446,  210,  211,  1401, 213,  210,  1401, 1401, 1401, 445,  228,  201,  194,  194,
+    1401, 196,  194,  446,  1401, 194,  194,  195,  196,  194,  195,  1401, 1401, 447,
+    201,  210,  211,  212,  213,  210,  212,  197,  228,  214,  435,  198,  935,  690,
+    1401, 228,  447,  215,  1401, 440,  194,  216,  441,  440,  442,  447,  1401, 1401,
+    1401, 1401, 1401, 1401, 228,  1401, 1401, 443,  435,  1401, 935,  693,  690,  228,
+    447,  209,  210,  211,  212,  213,  210,  212,  209,  209,  214,  209,  209,  209,
+    209,  209,
+
+    228,  209,  215,  209,  209,  209,  216,  450,  194,  451,  452,  450,  451,  1401,
+    194,  194,  195,  196,  194,  195,  228,  228,  533,  453,  955,  1401, 534,  454,
+    220,  228,  197,  1401, 535,  209,  198,  228,  1401, 947,  741,  221,  194,  194,
+    195,  196,  194,  195,  1401, 228,  228,  533,  955,  455,  455,  534,  456,  228,
+    197,  228,  535,  209,  198,  228,  715,  947,  741,  1401, 221,  194,  194,  195,
+    196,  194,  195,  1401, 194,  194,  195,  196,  194,  195,  222,  219,  488,  197,
+    228,  489,  1401, 198,  220,  715,  197,  490,  223,  1401, 198,  1401, 1121, 1401,
+    491,  221,
+
+    194,  194,  195,  196,  194,  195,  1401, 194,  194,  488,  196,  194,  489,  228,
+    457,  228,  197,  490,  732,  223,  198,  775,  1121, 201,  491,  458,  221,  194,
+    194,  195,  196,  194,  195,  450,  194,  1401, 452,  450,  459,  459,  228,  460,
+    228,  197,  1401, 732,  1401, 198,  775,  706,  1401, 1401, 458,  193,  194,  194,
+    195,  196,  194,  195,  193,  193,  193,  193,  193,  193,  193,  193,  1401, 193,
+    197,  193,  193,  193,  198,  194,  194,  195,  196,  194,  195,  194,  194,  195,
+    196,  194,  195,  742,  228,  1401, 1401, 197,  1401, 93,   228,  198,  1177, 197,
+    1401, 1401,
+
+    1124, 198,  194,  194,  195,  196,  194,  195,  440,  194,  747,  441,  440,  442,
+    742,  228,  94,   94,   197,  94,   306,  228,  198,  1177, 443,  307,  1124, 193,
+    193,  194,  194,  195,  196,  194,  195,  193,  747,  193,  193,  193,  193,  229,
+    193,  228,  193,  197,  193,  193,  193,  198,  228,  1401, 480,  481,  482,  308,
+    483,  115,  1401, 544,  115,  751,  228,  228,  1401, 545,  115,  546,  735,  1401,
+    228,  736,  949,  380,  568,  228,  1401, 228,  480,  481,  482,  308,  483,  1401,
+    115,  544,  1401, 115,  751,  228,  228,  545,  115,  546,  1401, 735,  1401, 736,
+    949,  380,
+
+    568,  228,  193,  193,  194,  194,  195,  196,  194,  195,  193,  1401, 193,  193,
+    193,  193,  1401, 193,  1401, 193,  197,  193,  193,  193,  198,  576,  1401, 576,
+    576,  576,  576,  577,  320,  1128, 320,  320,  320,  320,  440,  194,  584,  441,
+    440,  442,  115,  578,  228,  1401, 752,  1401, 115,  1401, 321,  1401, 443,  1401,
+    1401, 1401, 693,  1128, 115,  1401, 1401, 1401, 1401, 1401, 1401, 584,  1401, 1401,
+    1401, 115,  1401, 228,  1401, 752,  115,  193,  193,  194,  194,  195,  196,  194,
+    195,  193,  115,  193,  193,  193,  193,  229,  193,  1134, 193,  197,  193,  193,
+    193,  198,
+
+    115,  115,  462,  585,  115,  115,  115,  115,  1401, 1401, 115,  115,  996,  115,
+    115,  1401, 616,  228,  115,  1134, 115,  115,  1401, 115,  1401, 1401, 1401, 115,
+    115,  462,  585,  115,  115,  115,  115,  228,  115,  115,  996,  115,  115,  115,
+    616,  228,  115,  115,  115,  115,  228,  115,  748,  115,  193,  537,  228,  228,
+    228,  1401, 538,  115,  1401, 115,  228,  115,  1401, 745,  539,  1401, 115,  115,
+    750,  540,  115,  765,  541,  228,  748,  115,  1401, 115,  537,  228,  228,  228,
+    1401, 538,  115,  115,  1401, 1401, 115,  745,  539,  228,  1401, 115,  750,  540,
+    1401, 765,
+
+    541,  115,  1401, 115,  115,  115,  586,  115,  1401, 773,  571,  210,  211,  115,
+    213,  210,  412,  115,  413,  445,  228,  203,  204,  115,  205,  203,  437,  446,
+    115,  1401, 115,  115,  228,  586,  115,  773,  571,  207,  1401, 115,  1401, 1401,
+    412,  115,  413,  92,   1401, 1401, 1401, 115,  694,  1401, 92,   92,   92,   92,
+    92,   92,   228,  573,  1401, 92,   92,   92,   92,   92,   93,   587,  115,  228,
+    115,  115,  115,  588,  115,  115,  228,  694,  115,  228,  115,  115,  228,  1401,
+    730,  731,  755,  1401, 115,  799,  115,  115,  756,  92,   587,  115,  228,  115,
+    115,  115,
+
+    588,  115,  115,  228,  115,  228,  115,  115,  1401, 228,  730,  731,  1401, 755,
+    115,  799,  115,  115,  756,  92,   99,   100,  101,  100,  100,  100,  100,  99,
+    99,   102,  99,   99,   99,   228,  580,  1401, 99,   99,   99,   99,   99,   103,
+    115,  115,  1401, 115,  115,  590,  115,  228,  228,  1401, 115,  115,  591,  595,
+    1401, 760,  115,  228,  589,  115,  115,  115,  115,  228,  1008, 770,  99,   115,
+    115,  115,  115,  115,  590,  115,  228,  228,  115,  115,  591,  1401, 595,  760,
+    228,  115,  589,  115,  115,  115,  115,  228,  1008, 770,  99,   319,  320,  115,
+    320,  320,
+
+    320,  320,  319,  319,  319,  319,  319,  319,  319,  319,  228,  319,  319,  319,
+    319,  319,  321,  592,  1401, 115,  115,  115,  115,  115,  228,  228,  1401, 115,
+    115,  115,  115,  1401, 593,  771,  783,  596,  597,  115,  115,  228,  617,  958,
+    115,  319,  592,  1401, 115,  115,  115,  115,  115,  228,  228,  115,  115,  115,
+    1401, 115,  593,  771,  783,  596,  597,  115,  115,  228,  617,  958,  115,  319,
+    92,   228,  1401, 963,  1401, 1401, 1401, 92,   92,   92,   92,   92,   92,   92,
+    92,   228,  92,   92,   92,   92,   92,   93,   115,  115,  115,  115,  115,  228,
+    115,  963,
+
+    794,  115,  115,  599,  115,  1401, 1401, 1401, 115,  115,  598,  1401, 228,  1401,
+    601,  115,  1401, 1401, 115,  115,  115,  115,  115,  115,  115,  115,  794,  115,
+    115,  599,  115,  115,  600,  228,  115,  115,  598,  766,  936,  602,  601,  228,
+    115,  115,  92,   115,  115,  115,  1401, 115,  115,  228,  1401, 115,  1401, 115,
+    808,  115,  600,  115,  228,  603,  604,  115,  766,  936,  602,  115,  228,  115,
+    115,  621,  228,  115,  115,  115,  115,  228,  115,  115,  605,  115,  808,  774,
+    115,  1401, 115,  603,  604,  115,  1401, 115,  606,  115,  228,  115,  607,  621,
+    1401, 228,
+
+    115,  1401, 115,  784,  115,  115,  115,  605,  608,  774,  115,  609,  1401, 1401,
+    115,  1401, 115,  115,  228,  606,  761,  228,  610,  607,  115,  228,  115,  115,
+    1401, 784,  115,  115,  115,  816,  611,  608,  115,  609,  115,  228,  115,  767,
+    115,  1401, 115,  228,  115,  761,  1401, 610,  115,  1401, 228,  115,  115,  612,
+    1401, 115,  115,  816,  1401, 611,  115,  1401, 115,  115,  228,  228,  767,  769,
+    115,  115,  115,  450,  194,  115,  452,  450,  115,  228,  115,  772,  612,  1401,
+    115,  115,  228,  228,  776,  706,  115,  115,  613,  1401, 228,  115,  769,  115,
+    115,  228,
+
+    1401, 785,  115,  1401, 115,  115,  228,  228,  772,  778,  115,  115,  614,  228,
+    228,  776,  707,  115,  613,  615,  115,  1401, 115,  115,  1401, 115,  228,  1401,
+    785,  115,  115,  115,  1401, 228,  1401, 778,  115,  115,  614,  115,  1401, 115,
+    707,  115,  1401, 618,  615,  115,  228,  1401, 115,  1401, 1401, 619,  1401, 115,
+    115,  115,  115,  777,  115,  115,  115,  115,  115,  115,  115,  115,  1401, 115,
+    115,  618,  1401, 115,  1401, 228,  115,  620,  210,  211,  619,  213,  210,  115,
+    115,  777,  445,  115,  115,  115,  1401, 115,  115,  228,  446,  622,  115,  115,
+    115,  115,
+
+    115,  1401, 115,  620,  115,  1401, 115,  703,  1401, 969,  1401, 115,  1401, 623,
+    228,  624,  228,  115,  762,  228,  115,  1401, 622,  228,  115,  115,  115,  115,
+    763,  228,  115,  625,  115,  115,  703,  115,  969,  115,  115,  623,  228,  115,
+    624,  228,  115,  762,  626,  115,  115,  228,  115,  115,  115,  941,  763,  228,
+    115,  1401, 625,  115,  228,  1401, 115,  627,  115,  115,  115,  115,  115,  1401,
+    115,  1401, 626,  1401, 115,  228,  115,  115,  630,  941,  115,  1401, 115,  115,
+    450,  194,  228,  452,  450,  627,  115,  228,  115,  1401, 115,  115,  628,  115,
+    1401, 228,
+
+    706,  228,  629,  115,  630,  115,  115,  115,  115,  115,  115,  1401, 1401, 803,
+    632,  1401, 787,  115,  228,  115,  115,  115,  115,  628,  631,  228,  228,  707,
+    629,  115,  115,  115,  1401, 115,  115,  1401, 115,  115,  115,  803,  633,  632,
+    787,  115,  115,  115,  115,  115,  634,  1401, 631,  228,  115,  707,  115,  1401,
+    115,  1401, 115,  1401, 1401, 115,  1401, 1401, 228,  115,  633,  1401, 115,  1401,
+    115,  1401, 635,  640,  1401, 634,  115,  115,  1401, 115,  115,  800,  636,  115,
+    115,  115,  115,  637,  228,  115,  115,  228,  115,  115,  115,  115,  115,  796,
+    1401, 635,
+
+    640,  638,  1401, 115,  115,  115,  115,  800,  636,  115,  1153, 1401, 115,  115,
+    637,  228,  115,  115,  115,  115,  1159, 115,  115,  796,  115,  115,  639,  638,
+    115,  641,  1401, 115,  115,  1164, 115,  115,  1153, 642,  115,  1401, 1401, 115,
+    115,  1401, 115,  115,  1159, 115,  115,  228,  1401, 115,  115,  639,  815,  115,
+    641,  115,  115,  1164, 115,  115,  115,  1401, 642,  115,  115,  1401, 115,  115,
+    115,  115,  115,  115,  115,  115,  228,  643,  1401, 115,  1401, 815,  115,  115,
+    115,  115,  1014, 115,  1401, 115,  228,  115,  1401, 115,  1401, 115,  1401, 115,
+    115,  1401,
+
+    228,  115,  115,  643,  115,  1401, 115,  115,  115,  1401, 644,  115,  1401, 1014,
+    115,  645,  228,  115,  115,  115,  786,  115,  228,  115,  1401, 115,  228,  956,
+    115,  115,  1401, 115,  115,  115,  228,  115,  644,  1401, 115,  228,  115,  791,
+    645,  115,  228,  646,  115,  786,  647,  228,  115,  115,  115,  115,  956,  964,
+    115,  648,  1401, 115,  228,  115,  1401, 115,  115,  649,  228,  115,  791,  115,
+    228,  646,  228,  115,  647,  115,  115,  115,  115,  228,  115,  115,  964,  115,
+    648,  115,  1167, 115,  798,  115,  1401, 650,  649,  115,  228,  115,  115,  651,
+    228,  115,
+
+    652,  115,  1401, 115,  115,  1401, 228,  1401, 115,  115,  115,  115,  1167, 115,
+    798,  1401, 115,  650,  1401, 115,  228,  115,  1401, 651,  1401, 228,  1401, 652,
+    228,  228,  115,  792,  1401, 440,  194,  115,  441,  440,  442,  801,  1401, 655,
+    115,  115,  115,  115,  115,  950,  115,  443,  115,  228,  115,  653,  656,  228,
+    228,  115,  792,  115,  1401, 115,  654,  228,  228,  801,  797,  228,  655,  802,
+    115,  115,  115,  115,  950,  115,  115,  228,  115,  653,  656,  115,  658,  115,
+    115,  115,  115,  115,  654,  228,  657,  228,  115,  797,  228,  228,  802,  115,
+    807,  1401,
+
+    228,  1401, 115,  228,  938,  1401, 659,  1401, 115,  658,  115,  115,  991,  115,
+    115,  1401, 657,  228,  115,  1236, 115,  228,  733,  115,  228,  807,  734,  228,
+    115,  228,  115,  938,  115,  659,  115,  1401, 115,  115,  115,  991,  1401, 115,
+    115,  228,  661,  1236, 115,  660,  1401, 733,  1401, 228,  115,  734,  115,  228,
+    115,  1401, 228,  115,  719,  115,  662,  115,  228,  115,  115,  1401, 115,  663,
+    661,  1401, 115,  660,  780,  720,  228,  1401, 115,  957,  115,  228,  115,  781,
+    664,  228,  665,  719,  115,  662,  115,  228,  228,  115,  115,  663,  115,  228,
+    115,  966,
+
+    780,  720,  228,  804,  115,  957,  115,  228,  115,  781,  1401, 664,  1401, 665,
+    115,  115,  1112, 115,  115,  228,  115,  1401, 115,  228,  115,  966,  228,  1123,
+    789,  804,  115,  666,  115,  228,  115,  790,  115,  1401, 670,  115,  115,  115,
+    115,  1112, 228,  115,  115,  115,  115,  115,  115,  667,  1401, 228,  1123, 789,
+    115,  666,  115,  228,  115,  790,  228,  115,  953,  670,  115,  115,  115,  115,
+    228,  954,  115,  115,  115,  115,  115,  667,  115,  1401, 115,  1401, 115,  115,
+    115,  668,  115,  228,  228,  998,  953,  1401, 669,  809,  1401, 115,  228,  115,
+    1401, 115,
+
+    115,  115,  115,  115,  115,  810,  115,  115,  1401, 671,  115,  668,  1401, 115,
+    228,  998,  115,  115,  669,  942,  809,  1401, 228,  1401, 115,  115,  115,  115,
+    115,  1401, 115,  810,  228,  115,  115,  671,  672,  1401, 115,  115,  115,  1401,
+    115,  115,  1401, 1401, 942,  674,  115,  115,  115,  115,  115,  115,  673,  1127,
+    228,  1401, 228,  675,  115,  115,  672,  115,  115,  115,  115,  115,  805,  115,
+    806,  115,  228,  674,  115,  115,  115,  115,  115,  115,  673,  676,  1127, 228,
+    933,  1401, 675,  228,  115,  967,  115,  115,  115,  228,  805,  115,  806,  115,
+    228,  677,
+
+    1401, 115,  1401, 115,  115,  115,  1401, 676,  115,  1401, 1401, 933,  945,  228,
+    678,  967,  679,  1401, 115,  228,  1401, 228,  680,  1401, 115,  677,  115,  115,
+    115,  115,  115,  115,  682,  115,  1401, 115,  115,  228,  115,  945,  678,  115,
+    679,  115,  683,  681,  115,  228,  115,  680,  115,  228,  946,  115,  1401, 115,
+    1401, 115,  965,  682,  115,  228,  115,  228,  115,  1401, 1401, 115,  228,  115,
+    683,  681,  115,  684,  115,  115,  115,  228,  115,  946,  115,  1401, 115,  1401,
+    115,  965,  1401, 228,  686,  115,  115,  115,  687,  1401, 228,  685,  1001, 1401,
+    228,  948,
+
+    684,  1401, 115,  115,  1401, 115,  1401, 115,  115,  813,  115,  228,  228,  814,
+    686,  115,  115,  115,  687,  115,  115,  685,  688,  1001, 689,  228,  948,  115,
+    115,  115,  115,  115,  115,  1401, 1401, 813,  1401, 228,  228,  814,  1401, 1401,
+    1401, 1401, 1401, 1401, 115,  115,  1401, 688,  689,  1401, 1401, 115,  115,  115,
+    115,  115,  115,  193,  194,  194,  195,  196,  194,  195,  193,  193,  193,  193,
+    193,  193,  228,  692,  972,  193,  197,  193,  193,  193,  198,  440,  194,  1401,
+    441,  440,  442,  440,  194,  1401, 441,  440,  442,  1401, 1401, 1401, 959,  443,
+    228,  960,
+
+    972,  1401, 228,  443,  1401, 228,  1401, 193,  228,  697,  194,  698,  699,  697,
+    698,  700,  450,  194,  451,  452,  450,  451,  1243, 959,  695,  701,  960,  939,
+    228,  702,  695,  228,  453,  193,  228,  576,  454,  576,  576,  576,  576,  577,
+    1401, 1401, 228,  1401, 228,  1401, 1243, 1401, 695,  1401, 1401, 940,  939,  578,
+    695,  209,  210,  211,  212,  213,  210,  212,  209,  209,  214,  209,  209,  209,
+    228,  705,  228,  209,  215,  209,  209,  209,  216,  450,  194,  451,  452,  450,
+    451,  1401, 194,  194,  195,  196,  194,  195,  973,  1401, 228,  453,  228,  1401,
+    979,  454,
+
+    456,  1401, 197,  1401, 228,  209,  198,  194,  194,  195,  196,  194,  195,  697,
+    194,  1401, 699,  697,  973,  921,  228,  456,  228,  197,  979,  1401, 1401, 198,
+    228,  922,  228,  209,  449,  450,  194,  451,  452,  450,  451,  449,  449,  449,
+    449,  449,  449,  449,  449,  1401, 449,  453,  449,  449,  449,  454,  228,  1401,
+    194,  194,  195,  196,  194,  195,  1401, 194,  194,  195,  196,  194,  195,  1401,
+    457,  228,  197,  980,  709,  709,  198,  710,  1401, 197,  449,  458,  1401, 198,
+    194,  194,  195,  196,  194,  195,  1401, 194,  194,  195,  196,  194,  195,  228,
+    460,  980,
+
+    197,  228,  1401, 1401, 198,  460,  449,  197,  458,  1401, 1252, 198,  193,  194,
+    194,  195,  196,  194,  195,  193,  193,  193,  193,  193,  193,  193,  193,  228,
+    193,  197,  193,  193,  193,  198,  635,  820,  1252, 1401, 115,  115,  1401, 999,
+    1401, 228,  817,  115,  1401, 576,  1401, 576,  576,  576,  576,  577,  115,  115,
+    962,  228,  1000, 228,  1401, 635,  820,  228,  228,  115,  115,  578,  999,  228,
+    817,  115,  697,  194,  698,  699,  697,  698,  700,  1401, 115,  115,  962,  228,
+    1000, 228,  193,  92,   701,  228,  228,  1401, 702,  1401, 92,   92,   92,   92,
+    92,   92,
+
+    1401, 573,  1401, 92,   92,   92,   92,   92,   93,   115,  1401, 115,  951,  115,
+    115,  831,  952,  971,  1401, 115,  824,  115,  115,  829,  115,  228,  830,  988,
+    228,  115,  228,  115,  228,  1107, 228,  92,   115,  978,  115,  951,  115,  115,
+    831,  952,  971,  115,  1401, 115,  115,  829,  115,  228,  830,  988,  228,  115,
+    228,  115,  228,  1107, 228,  92,   92,   978,  1401, 1401, 1401, 1253, 1401, 92,
+    92,   92,   92,   92,   92,   572,  573,  572,  92,   92,   92,   92,   92,   93,
+    115,  115,  834,  975,  115,  115,  115,  115,  1010, 1253, 115,  833,  115,  977,
+    1401, 835,
+
+    228,  115,  228,  115,  832,  115,  115,  228,  228,  1255, 92,   115,  115,  834,
+    975,  115,  115,  115,  115,  1010, 115,  833,  115,  1401, 977,  835,  228,  115,
+    228,  115,  832,  115,  115,  228,  228,  1255, 92,   314,  314,  1401, 314,  314,
+    314,  315,  314,  314,  314,  314,  314,  314,  314,  314,  228,  314,  314,  314,
+    314,  314,  314,  836,  115,  115,  115,  115,  115,  115,  115,  1401, 839,  115,
+    115,  115,  115,  228,  968,  982,  1401, 1108, 228,  115,  115,  115,  115,  228,
+    228,  314,  836,  115,  115,  115,  115,  115,  115,  115,  839,  115,  115,  115,
+    115,  228,
+
+    1401, 968,  982,  1108, 1401, 115,  115,  115,  115,  228,  228,  314,  575,  576,
+    1401, 576,  576,  576,  576,  577,  575,  575,  575,  575,  575,  575,  575,  1401,
+    575,  575,  575,  575,  575,  578,  1401, 837,  840,  115,  115,  115,  115,  115,
+    843,  115,  989,  1401, 115,  115,  115,  115,  997,  1007, 841,  228,  228,  228,
+    115,  115,  115,  115,  575,  838,  837,  840,  115,  115,  115,  115,  115,  843,
+    115,  989,  115,  115,  115,  115,  997,  1007, 841,  228,  228,  228,  115,  115,
+    115,  115,  575,  99,   100,  101,  100,  100,  100,  100,  99,   99,   102,  99,
+    99,   99,
+
+    1401, 580,  1401, 99,   99,   99,   99,   99,   103,  115,  115,  115,  1401, 115,
+    844,  115,  1401, 842,  228,  115,  115,  115,  1005, 450,  194,  990,  452,  450,
+    228,  115,  115,  115,  228,  1135, 228,  99,   115,  115,  115,  706,  115,  844,
+    115,  842,  228,  115,  115,  115,  1005, 1401, 1401, 1401, 990,  1401, 228,  115,
+    115,  115,  228,  1135, 228,  99,   99,   100,  101,  100,  100,  100,  100,  99,
+    99,   102,  99,   99,   99,   579,  580,  579,  99,   99,   99,   99,   99,   103,
+    115,  846,  115,  115,  115,  115,  115,  857,  992,  1401, 115,  115,  847,  115,
+    985,  845,
+
+    986,  228,  1114, 228,  115,  115,  115,  115,  228,  228,  99,   115,  846,  115,
+    115,  115,  115,  115,  857,  992,  115,  115,  847,  115,  985,  845,  986,  228,
+    1114, 228,  115,  115,  115,  115,  228,  228,  99,   319,  320,  1401, 320,  320,
+    320,  320,  319,  319,  319,  319,  319,  319,  228,  828,  1013, 319,  319,  319,
+    319,  319,  321,  848,  115,  849,  115,  1401, 858,  850,  115,  1401, 228,  1152,
+    115,  1401, 115,  115,  1401, 115,  228,  115,  1013, 1401, 115,  1401, 115,  1401,
+    1401, 319,  848,  115,  849,  115,  1401, 858,  850,  115,  228,  1152, 115,  115,
+    115,  115,
+
+    984,  115,  115,  115,  853,  115,  115,  115,  115,  115,  115,  319,  115,  228,
+    115,  228,  851,  994,  1401, 1009, 1401, 993,  1401, 852,  115,  1401, 228,  984,
+    228,  115,  853,  115,  854,  115,  228,  115,  115,  115,  115,  228,  115,  228,
+    851,  115,  994,  115,  1009, 115,  993,  115,  1401, 115,  228,  115,  228,  115,
+    1002, 1401, 855,  854,  228,  228,  228,  1111, 115,  1012, 115,  1401, 1401, 228,
+    115,  115,  1401, 115,  115,  115,  115,  115,  115,  115,  856,  115,  115,  1002,
+    855,  1006, 1401, 228,  228,  1111, 115,  1012, 115,  115,  115,  228,  228,  1401,
+    228,  1137,
+
+    115,  115,  115,  1401, 115,  115,  856,  1401, 859,  115,  228,  115,  1006, 115,
+    1015, 115,  115,  115,  115,  115,  115,  115,  228,  115,  228,  115,  1137, 228,
+    115,  1003, 1004, 1401, 115,  115,  859,  115,  228,  115,  1401, 1401, 115,  1015,
+    115,  228,  115,  228,  115,  115,  115,  115,  115,  115,  115,  228,  115,  1401,
+    1003, 1004, 860,  115,  115,  115,  194,  194,  1016, 196,  194,  1401, 115,  228,
+    115,  228,  115,  1401, 228,  115,  115,  115,  201,  115,  1122, 115,  115,  228,
+    860,  115,  115,  861,  863,  115,  1401, 1016, 115,  862,  115,  115,  115,  115,
+    1401, 115,
+
+    228,  115,  1401, 115,  1401, 115,  1122, 115,  115,  228,  1116, 1401, 115,  861,
+    228,  863,  115,  115,  115,  115,  862,  115,  115,  115,  115,  1401, 115,  1401,
+    115,  115,  1138, 115,  115,  115,  864,  1129, 1116, 865,  1401, 115,  228,  228,
+    115,  115,  115,  1401, 115,  228,  866,  115,  115,  867,  115,  115,  115,  115,
+    115,  1138, 115,  1401, 864,  1129, 115,  865,  115,  115,  115,  228,  115,  228,
+    115,  115,  115,  228,  1143, 866,  115,  115,  867,  115,  115,  1401, 228,  115,
+    1401, 115,  115,  115,  115,  868,  115,  228,  1401, 115,  1017, 228,  869,  115,
+    115,  115,
+
+    115,  1143, 115,  115,  115,  1401, 115,  228,  228,  115,  115,  115,  115,  115,
+    870,  868,  115,  228,  115,  115,  871,  1017, 115,  869,  1401, 228,  115,  115,
+    1401, 1401, 115,  115,  115,  228,  1401, 115,  1401, 115,  1401, 872,  870,  115,
+    115,  115,  115,  115,  871,  1113, 115,  115,  873,  228,  228,  1174, 115,  1110,
+    1401, 115,  115,  115,  115,  874,  228,  115,  875,  872,  1155, 115,  228,  115,
+    115,  115,  228,  115,  1113, 115,  115,  873,  228,  1174, 228,  115,  1110, 115,
+    1401, 115,  115,  874,  228,  1401, 115,  875,  115,  1155, 228,  115,  115,  115,
+    228,  115,
+
+    115,  115,  115,  115,  115,  115,  228,  115,  115,  1401, 876,  1115, 1401, 115,
+    1401, 228,  115,  1117, 115,  115,  115,  115,  115,  115,  228,  115,  115,  877,
+    115,  115,  115,  115,  1119, 115,  1401, 115,  876,  228,  1115, 1126, 115,  228,
+    115,  1117, 115,  228,  115,  115,  115,  115,  228,  115,  228,  877,  115,  1401,
+    115,  1401, 115,  1119, 115,  1401, 115,  228,  115,  1126, 115,  1401, 878,  1401,
+    1401, 228,  1401, 228,  1154, 115,  1401, 115,  228,  1401, 228,  115,  115,  115,
+    115,  115,  115,  115,  115,  881,  115,  115,  115,  115,  878,  115,  879,  115,
+    115,  228,
+
+    1154, 1401, 880,  1140, 115,  115,  228,  115,  115,  885,  115,  115,  1401, 115,
+    228,  881,  115,  115,  115,  115,  115,  115,  879,  1118, 115,  115,  115,  228,
+    882,  880,  1140, 115,  115,  115,  115,  885,  115,  1401, 115,  1401, 228,  115,
+    1401, 115,  115,  115,  1401, 115,  115,  1118, 1120, 115,  115,  228,  228,  882,
+    1132, 1401, 1273, 115,  228,  115,  115,  115,  115,  115,  1401, 115,  115,  888,
+    1401, 883,  115,  884,  115,  115,  1120, 115,  1401, 1274, 228,  115,  1132, 115,
+    1273, 115,  228,  115,  1401, 115,  115,  115,  115,  115,  115,  886,  888,  883,
+    1401, 884,
+
+    93,   115,  115,  887,  1125, 1274, 1401, 1401, 115,  115,  115,  115,  115,  228,
+    115,  115,  1401, 115,  889,  115,  1275, 886,  115,  115,  891,  1401, 115,  890,
+    115,  115,  887,  1125, 115,  115,  115,  1401, 115,  1401, 115,  228,  115,  1401,
+    115,  115,  115,  889,  1275, 228,  1401, 115,  115,  891,  115,  115,  890,  115,
+    892,  1401, 115,  115,  115,  576,  115,  576,  576,  576,  576,  1024, 115,  115,
+    115,  1401, 115,  228,  115,  1401, 115,  115,  115,  115,  115,  578,  228,  892,
+    115,  115,  895,  115,  115,  893,  1401, 1136, 1401, 1401, 115,  1401, 115,  1131,
+    115,  228,
+
+    228,  115,  1401, 115,  115,  115,  228,  115,  228,  115,  115,  115,  895,  115,
+    1161, 893,  894,  115,  1136, 115,  115,  115,  115,  1131, 115,  228,  228,  115,
+    115,  1401, 896,  228,  228,  1401, 115,  909,  115,  115,  228,  115,  1139, 1161,
+    894,  115,  115,  115,  897,  115,  115,  115,  1401, 115,  115,  115,  115,  115,
+    896,  228,  115,  115,  115,  909,  1401, 115,  228,  115,  1139, 1401, 115,  115,
+    115,  228,  1401, 897,  1401, 115,  115,  1401, 115,  115,  115,  115,  115,  1401,
+    115,  115,  898,  1401, 115,  115,  228,  115,  1141, 115,  115,  115,  910,  228,
+    115,  1401,
+
+    900,  899,  1401, 115,  115,  115,  1401, 115,  115,  115,  115,  1401, 898,  115,
+    115,  115,  228,  115,  1141, 115,  115,  1401, 910,  115,  115,  115,  1401, 900,
+    899,  115,  115,  115,  901,  902,  115,  115,  115,  115,  1401, 115,  228,  1401,
+    1145, 115,  228,  115,  115,  115,  1401, 115,  1156, 115,  115,  115,  903,  1401,
+    115,  115,  1401, 901,  902,  115,  1401, 1401, 115,  228,  228,  115,  1145, 115,
+    228,  115,  115,  1401, 115,  1244, 115,  1156, 115,  115,  903,  228,  115,  115,
+    904,  115,  115,  1130, 115,  115,  115,  228,  115,  115,  115,  905,  115,  1133,
+    1401, 115,
+
+    228,  1244, 1312, 115,  115,  115,  115,  228,  115,  1401, 228,  904,  115,  115,
+    1130, 115,  115,  115,  115,  115,  115,  905,  115,  115,  1133, 1401, 228,  1142,
+    1312, 115,  115,  115,  115,  115,  1401, 1147, 228,  115,  1401, 115,  228,  115,
+    1401, 115,  228,  907,  115,  906,  1144, 1401, 115,  115,  228,  115,  1142, 115,
+    1401, 1146, 228,  228,  115,  115,  1147, 1401, 115,  115,  228,  1401, 115,  115,
+    228,  1162, 907,  906,  908,  1144, 115,  115,  228,  115,  115,  115,  115,  1146,
+    228,  228,  115,  115,  228,  115,  115,  115,  115,  115,  115,  911,  115,  1401,
+    1162, 1401,
+
+    1401, 908,  1401, 115,  1149, 1401, 228,  115,  115,  115,  1401, 1401, 115,  228,
+    228,  115,  115,  115,  115,  115,  115,  911,  115,  912,  913,  115,  115,  1401,
+    115,  914,  115,  1149, 228,  115,  115,  115,  115,  115,  115,  228,  1401, 1157,
+    115,  1401, 115,  1401, 115,  228,  115,  1401, 912,  913,  115,  115,  228,  115,
+    914,  115,  115,  115,  115,  115,  115,  115,  228,  115,  1148, 115,  1157, 115,
+    115,  115,  115,  228,  115,  915,  1401, 115,  1150, 115,  228,  1401, 228,  1158,
+    115,  115,  1401, 115,  1401, 115,  228,  1401, 1148, 115,  115,  115,  228,  115,
+    115,  115,
+
+    1401, 115,  915,  115,  1150, 1160, 115,  115,  228,  115,  1158, 115,  1151, 115,
+    1242, 228,  115,  115,  228,  228,  115,  115,  228,  1401, 115,  115,  194,  194,
+    115,  196,  194,  1401, 1160, 115,  1401, 115,  1401, 228,  1151, 1401, 1242, 228,
+    201,  115,  228,  228,  1401, 1401, 1401, 203,  204,  1401, 205,  203,  437,  228,
+    697,  194,  698,  699,  697,  698,  700,  228,  1401, 207,  916,  697,  194,  1401,
+    699,  697,  701,  921,  697,  194,  702,  699,  697,  1401, 921,  228,  228,  922,
+    1401, 1401, 1401, 1401, 1401, 919,  922,  1401, 916,  193,  194,  194,  195,  196,
+    194,  195,
+
+    193,  193,  193,  193,  193,  193,  1401, 692,  228,  193,  197,  193,  193,  193,
+    198,  919,  228,  923,  1163, 1165, 697,  194,  698,  699,  697,  698,  700,  1169,
+    1401, 924,  228,  228,  1168, 228,  440,  194,  701,  441,  440,  442,  702,  193,
+    228,  923,  1163, 1401, 1165, 1401, 697,  194,  443,  699,  697,  1169, 921,  1401,
+    228,  228,  1168, 228,  1401, 1401, 1401, 920,  922,  1401, 1401, 193,  193,  194,
+    194,  195,  196,  194,  195,  193,  193,  193,  193,  193,  193,  691,  692,  691,
+    193,  197,  193,  193,  193,  198,  920,  923,  210,  211,  1401, 213,  210,  1401,
+    203,  204,
+
+    445,  205,  203,  437,  228,  1240, 1401, 1401, 446,  450,  194,  1232, 452,  450,
+    207,  228,  193,  923,  1401, 194,  194,  195,  196,  194,  195,  706,  1401, 1401,
+    1401, 1401, 228,  1240, 926,  710,  1401, 197,  1401, 1232, 928,  198,  1401, 228,
+    193,  439,  440,  194,  439,  441,  440,  442,  439,  439,  439,  439,  439,  439,
+    439,  439,  926,  439,  443,  439,  439,  439,  439,  928,  194,  194,  195,  196,
+    194,  195,  697,  194,  1171, 699,  697,  1401, 921,  1314, 710,  1166, 197,  1401,
+    228,  228,  198,  228,  922,  1401, 228,  439,  1401, 440,  194,  1401, 441,  440,
+    442,  210,
+
+    211,  1171, 213,  210,  1401, 1314, 1401, 445,  1166, 443,  228,  228,  1401, 228,
+    1401, 446,  228,  439,  696,  697,  194,  698,  699,  697,  698,  700,  696,  696,
+    696,  696,  696,  696,  696,  1099, 696,  701,  696,  696,  696,  702,  115,  1020,
+    115,  115,  115,  1100, 115,  115,  1170, 1401, 115,  1233, 115,  115,  228,  228,
+    1028, 1237, 1256, 1099, 115,  228,  115,  115,  228,  228,  696,  115,  1020, 115,
+    115,  115,  1401, 115,  115,  1170, 115,  1233, 115,  115,  228,  228,  1028, 1237,
+    1256, 1401, 115,  228,  115,  115,  228,  228,  696,  209,  210,  211,  212,  213,
+    210,  212,
+
+    209,  209,  214,  209,  209,  209,  228,  705,  1234, 209,  215,  209,  209,  209,
+    216,  115,  115,  115,  115,  115,  115,  115,  115,  1173, 1401, 115,  115,  115,
+    115,  1319, 1401, 1030, 228,  1029, 1234, 115,  115,  115,  115,  228,  228,  209,
+    115,  115,  115,  115,  115,  115,  115,  115,  1173, 115,  115,  115,  115,  1401,
+    1319, 1030, 1401, 1029, 1401, 115,  115,  115,  115,  228,  228,  209,  209,  210,
+    211,  212,  213,  210,  212,  209,  209,  214,  209,  209,  209,  704,  705,  704,
+    209,  215,  209,  209,  209,  216,  1031, 115,  115,  115,  115,  115,  115,  115,
+    1401, 1035,
+
+    115,  115,  115,  115,  1247, 228,  1032, 1238, 228,  1323, 115,  115,  115,  115,
+    228,  228,  209,  1031, 115,  115,  115,  115,  115,  115,  115,  1035, 115,  115,
+    115,  115,  1247, 228,  1032, 1238, 228,  1323, 115,  115,  115,  115,  228,  228,
+    209,  449,  450,  194,  451,  452,  450,  451,  449,  449,  449,  449,  449,  449,
+    1401, 930,  1401, 449,  453,  449,  449,  449,  454,  1033, 1034, 115,  115,  115,
+    1036, 115,  115,  115,  115,  1231, 1401, 115,  115,  115,  115,  228,  1250, 1246,
+    228,  1327, 228,  115,  115,  115,  115,  449,  1033, 1034, 115,  115,  115,  1036,
+    115,  115,
+
+    115,  115,  1231, 115,  115,  115,  115,  228,  1250, 1246, 228,  1327, 228,  115,
+    115,  115,  115,  449,  193,  194,  194,  195,  196,  194,  195,  193,  1401, 193,
+    193,  193,  193,  229,  193,  1401, 193,  197,  193,  193,  193,  198,  115,  115,
+    1172, 115,  115,  115,  1230, 115,  1401, 1037, 115,  115,  1039, 115,  228,  228,
+    1038, 228,  931,  228,  115,  115,  228,  115,  1249, 1258, 1401, 115,  115,  1172,
+    115,  115,  115,  1230, 115,  1037, 115,  115,  1039, 115,  228,  228,  1038, 228,
+    931,  228,  115,  115,  228,  115,  1249, 1258, 193,  193,  194,  194,  195,  196,
+    194,  195,
+
+    193,  1401, 193,  193,  193,  193,  229,  193,  1331, 193,  197,  193,  193,  193,
+    198,  1040, 1175, 115,  115,  115,  1401, 115,  115,  1235, 1401, 115,  1041, 115,
+    115,  1254, 1401, 1042, 932,  228,  1331, 115,  228,  115,  115,  228,  228,  1401,
+    1040, 1175, 115,  115,  115,  1308, 115,  115,  1235, 115,  1041, 115,  115,  1401,
+    1254, 1042, 932,  228,  1401, 115,  228,  115,  115,  228,  228,  193,  92,   1401,
+    1401, 1401, 1401, 1308, 1401, 92,   92,   92,   92,   92,   92,   572,  573,  572,
+    92,   92,   92,   92,   92,   93,   115,  115,  115,  115,  115,  115,  1046, 115,
+    1239, 1401,
+
+    1043, 115,  115,  115,  1045, 1251, 228,  228,  1047, 1263, 115,  115,  115,  115,
+    228,  228,  92,   115,  115,  115,  115,  115,  115,  1046, 115,  1239, 1043, 115,
+    115,  115,  1045, 1251, 228,  228,  1047, 1263, 115,  115,  115,  115,  228,  228,
+    92,   314,  314,  1401, 314,  314,  314,  315,  314,  314,  314,  314,  314,  314,
+    1401, 1022, 1401, 314,  314,  314,  314,  314,  314,  1044, 1048, 1051, 115,  115,
+    115,  115,  115,  115,  115,  1260, 1401, 115,  115,  115,  115,  1049, 1259, 228,
+    228,  1270, 228,  115,  115,  115,  115,  314,  1044, 1048, 1051, 115,  115,  115,
+    115,  115,
+
+    115,  115,  1260, 115,  115,  115,  115,  1049, 1259, 228,  228,  1270, 228,  115,
+    115,  115,  115,  314,  575,  576,  228,  576,  576,  576,  576,  577,  575,  575,
+    575,  575,  575,  1401, 1026, 1401, 575,  575,  575,  575,  575,  578,  115,  115,
+    1401, 1401, 115,  115,  228,  1050, 1241, 1401, 115,  1052, 228,  440,  194,  1355,
+    441,  440,  442,  1261, 115,  115,  228,  228,  1271, 228,  575,  115,  115,  443,
+    1401, 115,  115,  1050, 1401, 1241, 115,  1052, 228,  1401, 1401, 1355, 1401, 1401,
+    1401, 1261, 115,  115,  228,  228,  1271, 228,  575,  99,   100,  101,  100,  100,
+    100,  100,
+
+    99,   99,   102,  99,   99,   99,   579,  580,  579,  99,   99,   99,   99,   99,
+    103,  115,  1054, 115,  115,  115,  115,  115,  115,  1401, 1053, 115,  115,  115,
+    115,  1264, 1055, 228,  1056, 228,  1316, 115,  115,  115,  115,  228,  228,  99,
+    115,  1054, 115,  115,  115,  115,  115,  115,  1053, 115,  115,  115,  115,  1264,
+    1055, 228,  1056, 228,  1316, 115,  115,  115,  115,  228,  228,  99,   319,  320,
+    1401, 320,  320,  320,  320,  319,  319,  319,  319,  319,  319,  1360, 828,  1268,
+    319,  319,  319,  319,  319,  321,  1057, 115,  115,  115,  115,  115,  115,  115,
+    115,  1401,
+
+    228,  115,  115,  115,  115,  1267, 228,  1360, 1272, 228,  1268, 115,  115,  115,
+    115,  228,  319,  1057, 115,  115,  115,  115,  115,  115,  115,  115,  228,  115,
+    115,  115,  115,  1267, 228,  1401, 1272, 228,  1401, 115,  115,  115,  115,  228,
+    319,  319,  320,  228,  320,  320,  320,  320,  319,  319,  319,  319,  319,  319,
+    827,  828,  827,  319,  319,  319,  319,  319,  321,  115,  115,  1058, 1401, 115,
+    115,  228,  1401, 1401, 1401, 115,  115,  1401, 1401, 228,  1401, 1318, 228,  1401,
+    1401, 115,  115,  1401, 228,  1401, 1330, 319,  115,  115,  1058, 1059, 115,  115,
+    1248, 115,
+
+    115,  115,  115,  115,  115,  228,  1257, 1318, 228,  115,  115,  115,  115,  228,
+    228,  1060, 1330, 319,  1401, 115,  115,  228,  1059, 1269, 115,  1248, 115,  115,
+    115,  1401, 115,  115,  1401, 1257, 115,  115,  115,  228,  115,  228,  228,  1060,
+    115,  1401, 115,  115,  115,  228,  115,  1401, 1269, 115,  115,  1401, 1061, 115,
+    115,  1401, 115,  1401, 115,  1401, 115,  228,  1401, 115,  228,  1401, 1317, 115,
+    115,  1310, 115,  1401, 115,  228,  115,  1401, 1401, 115,  115,  1061, 228,  115,
+    115,  228,  115,  1266, 115,  115,  1063, 1401, 1401, 115,  115,  1317, 115,  1310,
+    115,  115,
+
+    115,  228,  228,  115,  1062, 1245, 1401, 115,  228,  115,  115,  228,  115,  1401,
+    1266, 1064, 115,  1063, 228,  115,  115,  115,  115,  115,  1401, 115,  115,  1401,
+    228,  115,  1062, 1357, 1245, 1401, 228,  115,  115,  115,  1401, 115,  1065, 115,
+    1064, 1401, 228,  228,  115,  115,  1262, 115,  115,  1401, 1401, 115,  1401, 115,
+    1401, 115,  1357, 115,  228,  228,  115,  1401, 115,  115,  115,  1065, 115,  115,
+    1401, 228,  115,  115,  115,  1262, 115,  1066, 1068, 1401, 115,  1401, 115,  115,
+    115,  115,  115,  228,  1401, 115,  115,  1401, 1401, 115,  115,  115,  115,  1067,
+    115,  228,
+
+    1401, 115,  228,  1066, 1325, 1068, 115,  228,  115,  1320, 115,  115,  1401, 115,
+    115,  115,  1401, 115,  1070, 1401, 115,  115,  115,  1067, 115,  228,  1069, 1369,
+    228,  228,  1325, 115,  115,  228,  115,  1320, 115,  1401, 115,  115,  115,  115,
+    115,  115,  1401, 1070, 115,  115,  1071, 115,  115,  1265, 1069, 1369, 228,  228,
+    115,  115,  1401, 115,  115,  115,  1401, 115,  228,  115,  115,  115,  1322, 115,
+    115,  115,  115,  115,  1071, 115,  1401, 228,  1265, 1072, 228,  115,  115,  450,
+    194,  115,  452,  450,  115,  115,  228,  228,  115,  1401, 115,  1322, 115,  115,
+    115,  706,
+
+    115,  228,  1326, 228,  115,  1072, 115,  115,  1073, 1401, 115,  1401, 1401, 228,
+    115,  115,  115,  228,  228,  1074, 1401, 115,  1401, 1401, 1401, 115,  115,  228,
+    115,  1326, 115,  1328, 115,  115,  1073, 1075, 1329, 115,  115,  228,  115,  228,
+    115,  228,  228,  1074, 228,  1401, 115,  1076, 115,  1077, 115,  115,  115,  115,
+    1401, 115,  1328, 115,  115,  1075, 1329, 115,  115,  1354, 1401, 228,  1401, 228,
+    115,  1401, 228,  115,  115,  1078, 1076, 115,  1077, 115,  115,  115,  228,  1079,
+    115,  115,  115,  115,  1401, 115,  1359, 1401, 1354, 115,  228,  115,  115,  1081,
+    1401, 115,
+
+    1401, 115,  1078, 115,  228,  115,  115,  115,  228,  115,  1079, 115,  1401, 1309,
+    115,  115,  1359, 115,  1080, 115,  228,  115,  1401, 1082, 1081, 115,  228,  115,
+    115,  115,  228,  115,  115,  115,  1332, 1311, 115,  115,  1362, 228,  1309, 115,
+    228,  115,  1080, 1083, 1401, 115,  228,  115,  1082, 115,  228,  115,  115,  228,
+    1401, 1313, 115,  115,  1332, 1401, 1311, 115,  1362, 228,  1401, 115,  228,  115,
+    228,  115,  1083, 115,  228,  1315, 115,  115,  1401, 115,  115,  228,  1084, 115,
+    1313, 115,  1401, 115,  228,  115,  228,  1401, 1085, 1356, 115,  115,  228,  115,
+    115,  115,
+
+    1401, 115,  1315, 115,  228,  228,  115,  115,  1084, 228,  115,  1380, 1361, 115,
+    228,  115,  228,  115,  1085, 115,  1356, 1086, 115,  1087, 115,  115,  115,  1321,
+    115,  115,  228,  228,  115,  115,  1384, 228,  228,  1380, 1361, 115,  228,  1401,
+    115,  115,  1401, 228,  115,  115,  1086, 115,  1087, 115,  1401, 115,  1321, 115,
+    228,  115,  115,  115,  115,  1384, 228,  115,  115,  115,  228,  115,  115,  115,
+    115,  228,  1088, 1401, 115,  1089, 1401, 1401, 115,  115,  115,  228,  228,  115,
+    1324, 1401, 115,  115,  1363, 1333, 115,  115,  228,  115,  1381, 115,  115,  228,
+    1088, 115,
+
+    1401, 1089, 228,  115,  1385, 115,  115,  228,  1090, 115,  228,  1324, 228,  1091,
+    1363, 228,  1333, 115,  228,  115,  1381, 115,  1401, 228,  228,  1386, 115,  115,
+    228,  115,  115,  1385, 1401, 115,  1090, 115,  228,  115,  228,  115,  1091, 228,
+    1092, 1401, 115,  115,  115,  1401, 115,  115,  228,  1386, 115,  115,  1093, 1401,
+    115,  1334, 115,  1401, 115,  228,  115,  115,  115,  115,  1401, 1358, 1094, 1092,
+    228,  1401, 115,  115,  115,  115,  115,  1401, 115,  1401, 228,  1093, 115,  1401,
+    1334, 115,  1401, 228,  115,  228,  115,  1401, 115,  1401, 1358, 1094, 228,  115,
+    1401, 115,
+
+    115,  115,  1401, 115,  228,  1096, 228,  115,  115,  115,  1401, 1095, 1364, 115,
+    1401, 228,  228,  115,  115,  115,  228,  115,  1365, 1401, 115,  115,  1401, 1401,
+    115,  115,  228,  115,  1096, 115,  228,  228,  115,  1095, 1364, 1401, 115,  115,
+    228,  115,  1401, 115,  228,  1401, 115,  1365, 697,  194,  115,  699,  697,  115,
+    1227, 115,  1401, 1401, 228,  228,  1401, 1401, 1401, 1401, 922,  115,  193,  194,
+    194,  195,  196,  194,  195,  193,  193,  193,  193,  193,  193,  691,  692,  691,
+    193,  197,  193,  193,  193,  198,  1401, 697,  194,  698,  699,  697,  698,  1102,
+    1401, 1366,
+
+    1401, 1401, 697,  194,  1401, 699,  697,  701,  921,  228,  1387, 702,  228,  1401,
+    1401, 1401, 193,  576,  922,  576,  576,  576,  576,  577,  697,  194,  1366, 699,
+    697,  1401, 921,  1101, 1401, 1401, 1401, 228,  1387, 578,  228,  1401, 922,  1401,
+    193,  439,  440,  194,  439,  441,  440,  442,  439,  439,  439,  439,  439,  439,
+    1401, 1098, 1101, 439,  443,  439,  439,  439,  439,  450,  194,  115,  452,  450,
+    1401, 115,  697,  194,  1382, 699,  697,  115,  921,  1401, 1394, 706,  1178, 228,
+    1401, 1401, 1401, 115,  922,  228,  824,  439,  1401, 1401, 115,  1401, 1401, 1100,
+    115,  1401,
+
+    1401, 1382, 1401, 115,  1401, 1105, 1394, 1401, 1178, 228,  1401, 1401, 1401, 115,
+    1401, 228,  1401, 439,  696,  697,  194,  698,  699,  697,  698,  700,  696,  696,
+    696,  696,  696,  1105, 1104, 1401, 696,  701,  696,  696,  696,  702,  115,  1182,
+    115,  115,  115,  115,  1183, 115,  1401, 228,  115,  115,  115,  115,  1401, 1397,
+    1368, 228,  228,  1401, 115,  115,  115,  115,  1383, 1401, 696,  115,  1182, 115,
+    115,  115,  115,  1183, 115,  228,  115,  115,  115,  115,  1401, 1397, 1368, 228,
+    228,  1401, 115,  115,  115,  115,  1383, 1401, 696,  209,  210,  211,  212,  213,
+    210,  212,
+
+    209,  209,  214,  209,  209,  209,  704,  705,  704,  209,  215,  209,  209,  209,
+    216,  115,  1367, 115,  115,  115,  1401, 115,  115,  1401, 1184, 115,  1185, 115,
+    115,  228,  1392, 1401, 1398, 1186, 1401, 115,  228,  115,  115,  228,  1401, 209,
+    115,  1367, 115,  115,  115,  1401, 115,  115,  1184, 115,  1185, 115,  115,  228,
+    1401, 1392, 1398, 1186, 1401, 115,  228,  115,  115,  228,  1401, 209,  449,  450,
+    194,  451,  452,  450,  451,  449,  449,  449,  449,  449,  449,  1401, 930,  1401,
+    449,  453,  449,  449,  449,  454,  1187, 115,  115,  115,  115,  115,  115,  115,
+    1393, 1401,
+
+    115,  115,  115,  115,  1188, 1400, 1401, 1401, 228,  228,  115,  115,  115,  115,
+    1401, 1401, 449,  1187, 115,  115,  115,  115,  115,  115,  115,  1393, 115,  115,
+    115,  115,  1188, 1400, 1401, 1401, 228,  228,  115,  115,  115,  115,  1401, 1401,
+    449,  449,  450,  194,  451,  452,  450,  451,  449,  449,  449,  449,  449,  449,
+    929,  930,  929,  449,  453,  449,  449,  449,  454,  115,  115,  115,  115,  115,
+    115,  115,  115,  1401, 1401, 115,  115,  115,  115,  1401, 1401, 1189, 1190, 1401,
+    1401, 115,  115,  115,  115,  1401, 1401, 449,  115,  115,  115,  115,  115,  115,
+    115,  115,
+
+    1401, 115,  115,  115,  115,  1401, 1401, 1189, 1190, 1401, 1401, 115,  115,  115,
+    115,  1401, 1401, 449,  314,  314,  1401, 314,  314,  314,  315,  314,  314,  314,
+    314,  314,  314,  1401, 1022, 1401, 314,  314,  314,  314,  314,  314,  1191, 115,
+    115,  115,  115,  115,  115,  115,  115,  1401, 1194, 115,  115,  115,  115,  1192,
+    1195, 1401, 1401, 1401, 1401, 115,  115,  115,  115,  1401, 314,  1191, 115,  115,
+    115,  115,  115,  115,  115,  115,  1194, 115,  115,  115,  115,  1192, 1195, 1401,
+    1401, 1401, 1401, 115,  115,  115,  115,  1401, 314,  314,  314,  1401, 314,  314,
+    314,  315,
+
+    314,  314,  314,  314,  314,  314,  1021, 1022, 1021, 314,  314,  314,  314,  314,
+    314,  1193, 1197, 115,  115,  115,  115,  115,  115,  115,  1401, 1196, 115,  115,
+    115,  115,  1401, 1401, 1198, 1401, 1401, 1401, 115,  115,  115,  115,  1401, 314,
+    1193, 1197, 115,  115,  115,  115,  115,  115,  115,  1196, 115,  115,  115,  115,
+    1401, 1401, 1198, 1401, 1401, 1401, 115,  115,  115,  115,  1401, 314,  575,  576,
+    1401, 576,  576,  576,  576,  577,  575,  575,  575,  575,  575,  1401, 1026, 1401,
+    575,  575,  575,  575,  575,  578,  115,  1200, 115,  115,  115,  1401, 115,  115,
+    1401, 1401,
+
+    115,  1199, 115,  115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 115,  115,
+    1401, 1401, 575,  115,  1200, 115,  115,  115,  1401, 115,  115,  1401, 115,  1199,
+    115,  115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 115,  115,  1401, 1401,
+    575,  575,  576,  1401, 576,  576,  576,  576,  577,  575,  575,  575,  575,  575,
+    1025, 1026, 1025, 575,  575,  575,  575,  575,  578,  115,  115,  115,  115,  115,
+    115,  115,  115,  1401, 1401, 115,  115,  115,  115,  1401, 1401, 1401, 1401, 1201,
+    1401, 115,  115,  115,  115,  1401, 1401, 575,  115,  115,  115,  115,  115,  115,
+    115,  115,
+
+    1401, 115,  115,  115,  115,  1401, 1401, 1401, 1401, 1201, 1401, 115,  115,  115,
+    115,  1401, 1401, 575,  319,  320,  1401, 320,  320,  320,  320,  319,  319,  319,
+    319,  319,  319,  827,  828,  827,  319,  319,  319,  319,  319,  321,  115,  115,
+    1401, 115,  115,  115,  1401, 115,  1401, 1202, 115,  115,  1203, 115,  1401, 1401,
+    1204, 1401, 1401, 1401, 115,  115,  1401, 115,  1401, 1401, 319,  115,  115,  1401,
+    115,  115,  115,  1401, 115,  1202, 115,  115,  1203, 115,  115,  115,  1204, 1401,
+    115,  115,  115,  115,  1401, 115,  115,  115,  319,  115,  115,  1401, 1206, 115,
+    115,  1401,
+
+    115,  115,  1401, 115,  115,  1401, 1205, 115,  115,  1401, 1401, 115,  115,  115,
+    115,  1401, 115,  115,  115,  1401, 115,  115,  115,  1206, 115,  115,  115,  115,
+    115,  115,  115,  115,  1205, 1401, 1401, 115,  1401, 1401, 115,  115,  115,  115,
+    1401, 1401, 1207, 115,  1401, 1401, 1401, 115,  1401, 115,  1401, 115,  115,  1401,
+    1401, 115,  115,  1209, 1401, 115,  115,  1208, 115,  115,  1401, 115,  1401, 1401,
+    1207, 115,  1401, 115,  1401, 115,  1401, 115,  1401, 115,  115,  115,  1401, 115,
+    115,  115,  1209, 115,  115,  1208, 1401, 1401, 115,  115,  1401, 115,  1401, 115,
+    1401, 115,
+
+    1401, 1401, 115,  115,  1210, 115,  115,  115,  115,  115,  115,  115,  115,  1401,
+    115,  115,  1401, 1211, 115,  115,  1401, 115,  1401, 1401, 1401, 115,  1401, 1401,
+    115,  115,  1210, 1401, 115,  1401, 1401, 115,  115,  1401, 115,  115,  1401, 115,
+    1212, 1211, 115,  1401, 115,  1401, 115,  1401, 115,  115,  1401, 1401, 115,  1401,
+    115,  1401, 115,  1401, 1214, 1401, 1401, 1401, 115,  115,  1213, 1401, 1401, 1212,
+    115,  1401, 1401, 115,  115,  1401, 1401, 115,  1401, 1401, 115,  1401, 115,  1401,
+    115,  115,  1401, 1214, 1401, 115,  1401, 115,  1213, 115,  1401, 115,  115,  115,
+    1401, 1401,
+
+    1401, 1215, 1401, 115,  1401, 115,  115,  1401, 1401, 1401, 1401, 1401, 115,  115,
+    1401, 1401, 115,  1401, 115,  1401, 115,  115,  115,  1401, 115,  1401, 115,  1215,
+    115,  115,  115,  115,  1401, 1401, 1401, 1216, 115,  1401, 115,  115,  1217, 1401,
+    1401, 1401, 115,  115,  115,  1401, 115,  115,  115,  1401, 115,  115,  115,  1401,
+    1401, 115,  115,  1401, 115,  1216, 115,  1401, 115,  1401, 1401, 1217, 115,  1401,
+    115,  115,  115,  1401, 115,  115,  115,  1401, 1401, 115,  115,  1218, 1401, 115,
+    115,  1401, 115,  115,  1401, 1401, 115,  1401, 1401, 115,  115,  115,  1401, 115,
+    1401, 115,
+
+    1401, 115,  1401, 115,  1401, 115,  115,  115,  1218, 1401, 115,  115,  1401, 1401,
+    115,  115,  115,  115,  1401, 115,  115,  1401, 115,  1401, 115,  1401, 115,  115,
+    1401, 115,  115,  115,  1401, 1401, 115,  1401, 1401, 1401, 115,  1401, 115,  115,
+    1401, 115,  1220, 115,  1401, 115,  115,  115,  1401, 115,  115,  115,  1219, 115,
+    115,  1401, 115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  115,  1401, 115,  1221,
+    1401, 1220, 115,  115,  1401, 115,  115,  115,  1401, 115,  1219, 115,  1401, 115,
+    115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 115,  115,  115,  1221, 115,
+    115,  115,
+
+    115,  115,  115,  1401, 115,  115,  1401, 115,  115,  115,  1222, 1401, 1223, 1401,
+    1401, 115,  1401, 115,  115,  115,  1401, 1401, 115,  1401, 115,  115,  115,  1401,
+    115,  115,  1401, 115,  1401, 115,  115,  115,  1222, 1401, 1223, 115,  1401, 115,
+    1401, 115,  115,  115,  1401, 115,  115,  1401, 1401, 115,  115,  1401, 1401, 115,
+    1401, 115,  115,  1401, 115,  1401, 115,  1224, 115,  1401, 115,  115,  115,  1401,
+    115,  115,  1401, 1225, 115,  115,  1401, 1401, 115,  115,  115,  115,  1401, 115,
+    115,  1401, 1401, 115,  1401, 1224, 1401, 115,  1401, 115,  115,  1401, 115,  1401,
+    1401, 1225,
+
+    1277, 1401, 1277, 1277, 1277, 1277, 115,  439,  440,  194,  439,  441,  440,  442,
+    439,  439,  439,  439,  439,  439,  1280, 1098, 1401, 439,  443,  439,  439,  439,
+    439,  1401, 1401, 1401, 1401, 115,  1401, 1401, 1401, 115,  697,  194,  1401, 699,
+    697,  115,  921,  697,  194,  698,  699,  697,  698,  700,  1401, 115,  922,  439,
+    1401, 1401, 1401, 1401, 115,  701,  1401, 1401, 115,  702,  1401, 1401, 1401, 115,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1228, 115,  1401, 439,  439,  440,
+    194,  439,  441,  440,  442,  439,  439,  439,  439,  439,  439,  1097, 1098, 1097,
+    439,  443,
+
+    439,  439,  439,  439,  1228, 115,  1401, 115,  1401, 115,  1401, 115,  1401, 1401,
+    1401, 115,  1401, 115,  924,  1277, 1401, 1277, 1277, 1277, 1277, 115,  1281, 115,
+    1401, 1401, 439,  1401, 115,  1401, 115,  1335, 115,  1401, 115,  1280, 1401, 115,
+    1401, 115,  1401, 1401, 1401, 1401, 1401, 1401, 1401, 115,  1281, 115,  1401, 1401,
+    439,  696,  697,  194,  698,  699,  697,  698,  700,  696,  696,  696,  696,  696,
+    1401, 1104, 1401, 696,  701,  696,  696,  696,  702,  115,  1282, 1401, 115,  115,
+    115,  1401, 115,  1401, 1401, 115,  115,  1283, 115,  1401, 1401, 1401, 1401, 1401,
+    1401, 115,
+
+    115,  1401, 115,  1401, 1401, 696,  115,  1282, 1401, 115,  115,  115,  1401, 115,
+    1401, 115,  115,  1283, 115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  115,  1401,
+    115,  1401, 1401, 696,  696,  697,  194,  698,  699,  697,  698,  700,  696,  696,
+    696,  696,  696,  1103, 1104, 1103, 696,  701,  696,  696,  696,  702,  115,  1284,
+    115,  115,  115,  115,  115,  115,  1401, 1401, 115,  115,  115,  115,  1401, 1401,
+    1285, 1401, 1401, 1401, 115,  115,  115,  115,  1401, 1401, 696,  115,  1284, 115,
+    115,  115,  115,  115,  115,  1401, 115,  115,  115,  115,  1401, 1401, 1285, 1401,
+    1401, 1401,
+
+    115,  115,  115,  115,  1401, 1401, 696,  449,  450,  194,  451,  452,  450,  451,
+    449,  449,  449,  449,  449,  449,  929,  930,  929,  449,  453,  449,  449,  449,
+    454,  1286, 115,  1288, 115,  115,  115,  115,  115,  1401, 1287, 115,  115,  115,
+    115,  1401, 1401, 1401, 1401, 1401, 1289, 115,  115,  115,  115,  1401, 1401, 449,
+    1286, 115,  1288, 115,  115,  115,  115,  115,  1287, 115,  115,  115,  115,  1401,
+    1401, 1401, 1401, 1401, 1289, 115,  115,  115,  115,  1401, 1401, 449,  1276, 1277,
+    1401, 1277, 1277, 1277, 1277, 1276, 1401, 1276, 1276, 1276, 1276, 1279, 1276, 1401,
+    1276, 1276,
+
+    1276, 1276, 1276, 1280, 115,  115,  115,  115,  115,  115,  115,  115,  1401, 1401,
+    115,  115,  115,  115,  1401, 1401, 1401, 1401, 1291, 1401, 115,  115,  115,  115,
+    1401, 1401, 1401, 115,  115,  115,  115,  115,  115,  115,  115,  1401, 115,  115,
+    115,  115,  1401, 1401, 1401, 1401, 1291, 1401, 115,  115,  115,  115,  1401, 1401,
+    1276, 314,  314,  1401, 314,  314,  314,  315,  314,  314,  314,  314,  314,  314,
+    1021, 1022, 1021, 314,  314,  314,  314,  314,  314,  1290, 115,  115,  115,  115,
+    115,  115,  115,  115,  1401, 1401, 115,  115,  115,  115,  1401, 1401, 1401, 1401,
+    1401, 1401,
+
+    115,  115,  1293, 115,  1401, 314,  1290, 115,  115,  115,  115,  115,  115,  115,
+    115,  1401, 115,  115,  115,  115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  115,
+    1293, 115,  1401, 314,  575,  576,  1401, 576,  576,  576,  576,  577,  575,  575,
+    575,  575,  575,  1025, 1026, 1025, 575,  575,  575,  575,  575,  578,  115,  115,
+    1294, 1292, 115,  115,  115,  1401, 1401, 1401, 115,  115,  115,  1401, 115,  1401,
+    1401, 1401, 1295, 1401, 115,  115,  115,  1401, 115,  1401, 575,  115,  115,  1294,
+    1292, 115,  115,  115,  115,  1401, 115,  115,  115,  1401, 1401, 115,  1401, 1401,
+    1401, 1295,
+
+    115,  115,  115,  115,  115,  1401, 575,  115,  1401, 1401, 1296, 115,  1401, 115,
+    115,  115,  1401, 1401, 1401, 1401, 1401, 115,  1401, 115,  1401, 1297, 1401, 1401,
+    1401, 115,  115,  115,  1401, 115,  115,  115,  1296, 115,  115,  115,  1401, 1401,
+    115,  115,  1401, 115,  1401, 115,  1401, 115,  1401, 1401, 1297, 115,  1401, 115,
+    115,  115,  115,  115,  115,  115,  115,  1401, 115,  1298, 1401, 1401, 115,  115,
+    1401, 115,  1401, 1401, 1401, 115,  1401, 1401, 115,  115,  1401, 1401, 115,  1401,
+    1401, 115,  115,  1401, 115,  115,  1299, 1298, 115,  1401, 115,  1401, 115,  1401,
+    115,  1401,
+
+    115,  115,  1401, 1401, 115,  1401, 115,  1401, 115,  1300, 1401, 1401, 1401, 1401,
+    1401, 115,  115,  1299, 1401, 115,  1401, 1401, 1401, 115,  115,  1401, 1401, 115,
+    1401, 1401, 1401, 1301, 115,  115,  115,  1300, 115,  115,  1401, 1401, 115,  1401,
+    115,  115,  1401, 1277, 115,  1277, 1277, 1277, 1277, 1401, 1401, 115,  1401, 1401,
+    115,  1401, 1301, 1401, 115,  1335, 1401, 115,  115,  1280, 1401, 115,  1401, 115,
+    115,  1401, 115,  115,  115,  1401, 1302, 115,  1401, 115,  115,  1401, 115,  115,
+    1401, 1401, 1401, 1401, 1303, 1401, 115,  1401, 1401, 115,  1401, 115,  1401, 115,
+    1401, 115,
+
+    115,  115,  1302, 1401, 115,  115,  115,  1401, 1304, 115,  1401, 1401, 1401, 115,
+    1303, 115,  115,  115,  1401, 115,  1401, 1305, 115,  115,  1401, 115,  115,  1401,
+    1401, 115,  1401, 115,  1401, 115,  1304, 115,  1401, 1401, 1306, 1401, 115,  115,
+    115,  1401, 115,  115,  1401, 1305, 115,  115,  1307, 1401, 115,  1401, 115,  1401,
+    115,  1401, 115,  115,  115,  115,  115,  1401, 1401, 1306, 115,  1401, 1401, 115,
+    115,  115,  115,  1401, 115,  1401, 1401, 1307, 1401, 1401, 1401, 115,  115,  1401,
+    115,  1401, 115,  1401, 1401, 115,  1401, 1401, 1401, 115,  1401, 1401, 115,  1401,
+    115,  1401,
+
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 115,  439,  440,  194,  439,  441,
+    440,  442,  439,  439,  439,  439,  439,  439,  1097, 1098, 1097, 439,  443,  439,
+    439,  439,  439,  1338, 115,  115,  1340, 115,  115,  115,  1401, 115,  1401, 1401,
+    115,  115,  1401, 115,  1339, 1401, 1401, 1401, 1401, 1401, 115,  115,  1401, 115,
+    1401, 439,  1338, 115,  115,  1340, 115,  115,  115,  1401, 115,  1401, 115,  115,
+    1401, 115,  1339, 1401, 1401, 1401, 1401, 1401, 115,  115,  1401, 115,  1401, 439,
+    696,  697,  194,  698,  699,  697,  698,  700,  696,  696,  696,  696,  696,  1103,
+    1104, 1103,
+
+    696,  701,  696,  696,  696,  702,  115,  1341, 115,  115,  115,  1401, 115,  115,
+    1401, 1401, 115,  1401, 115,  115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401,
+    115,  115,  1401, 1401, 696,  115,  1341, 115,  115,  115,  1401, 115,  115,  1401,
+    115,  1401, 115,  115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 115,  115,
+    1401, 1401, 696,  1276, 1277, 1401, 1277, 1277, 1277, 1277, 1276, 1401, 1276, 1276,
+    1276, 1276, 1279, 1276, 1401, 1276, 1335, 1276, 1276, 1276, 1280, 1342, 115,  1401,
+    115,  115,  115,  1401, 115,  1401, 1401, 115,  115,  1343, 115,  1401, 1401, 1401,
+    1401, 1401,
+
+    1401, 115,  115,  1401, 115,  1401, 1401, 1401, 1342, 115,  1401, 115,  115,  115,
+    1401, 115,  1401, 115,  115,  1343, 115,  1401, 1401, 1401, 1401, 1401, 1401, 115,
+    115,  1401, 115,  1401, 1401, 1276, 1276, 1277, 1401, 1277, 1277, 1277, 1277, 1276,
+    1401, 1276, 1276, 1276, 1276, 1401, 1276, 1401, 1276, 1335, 1276, 1276, 1276, 1280,
+    115,  115,  115,  1401, 115,  115,  115,  1401, 1401, 1401, 115,  115,  115,  1344,
+    1401, 1401, 1401, 1401, 1401, 1401, 115,  115,  1345, 1401, 1401, 1401, 1401, 115,
+    115,  115,  1401, 115,  115,  115,  1401, 1401, 115,  115,  115,  1344, 1401, 1401,
+    1401, 1401,
+
+    1401, 1401, 115,  115,  1345, 1401, 1401, 1401, 1276, 1276, 1277, 1401, 1277, 1277,
+    1277, 1277, 1276, 1276, 1276, 1276, 1276, 1276, 1276, 1276, 1401, 1276, 1335, 1276,
+    1276, 1276, 1280, 115,  115,  1401, 115,  115,  115,  1401, 115,  1401, 1401, 115,
+    115,  1346, 115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  115,  1401, 115,  1401,
+    1401, 1276, 115,  115,  1401, 115,  115,  115,  1401, 115,  1401, 115,  115,  1346,
+    115,  115,  115,  1401, 1401, 115,  115,  115,  115,  1401, 115,  115,  115,  1276,
+    115,  1349, 1401, 1401, 115,  115,  1401, 1347, 115,  1348, 115,  115,  1401, 1401,
+    115,  115,
+
+    1401, 1401, 115,  115,  115,  115,  1401, 115,  115,  1401, 1401, 115,  1349, 1401,
+    1401, 115,  115,  1347, 115,  1348, 115,  115,  1350, 1351, 115,  115,  115,  115,
+    115,  115,  115,  115,  115,  115,  115,  115,  1401, 1401, 1401, 1401, 1401, 1401,
+    115,  115,  115,  115,  1401, 1401, 1401, 1350, 1351, 115,  115,  115,  115,  115,
+    115,  1401, 115,  115,  115,  115,  115,  115,  1401, 1401, 115,  115,  115,  115,
+    115,  115,  115,  115,  1353, 115,  115,  1401, 1401, 115,  115,  1401, 1352, 115,
+    1401, 115,  115,  1401, 1401, 115,  115,  1401, 1401, 115,  115,  115,  115,  1401,
+    115,  115,
+
+    1353, 1401, 115,  115,  1401, 1401, 115,  115,  1352, 115,  1401, 115,  115,  1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 115,  115,  1276, 1277, 1401, 1277, 1277,
+    1277, 1277, 1276, 1276, 1276, 1276, 1276, 1276, 1401, 1371, 1401, 1276, 1335, 1276,
+    1276, 1276, 1280, 115,  115,  115,  115,  115,  115,  115,  115,  1401, 1401, 115,
+    115,  115,  115,  1401, 1372, 1401, 1373, 1401, 1401, 115,  115,  115,  115,  1401,
+    1401, 1276, 115,  115,  115,  115,  115,  115,  115,  115,  1401, 115,  115,  115,
+    115,  115,  1372, 1401, 1373, 115,  1401, 115,  115,  115,  115,  115,  1374, 1276,
+    115,  115,
+
+    1401, 1401, 115,  115,  1401, 115,  1401, 1401, 115,  115,  1401, 1401, 115,  1401,
+    1401, 1401, 115,  1401, 115,  1375, 1401, 115,  1401, 1374, 1401, 115,  115,  1401,
+    115,  115,  115,  115,  115,  1401, 115,  115,  1401, 1401, 115,  1401, 1401, 1401,
+    1401, 1401, 115,  1375, 1401, 1401, 115,  1401, 115,  1401, 1376, 1401, 115,  115,
+    1401, 1401, 1401, 115,  115,  1401, 115,  115,  115,  1377, 115,  115,  1401, 1401,
+    115,  1401, 115,  115,  115,  1401, 1401, 115,  1401, 1376, 1401, 115,  115,  115,
+    1401, 1401, 115,  115,  1401, 115,  115,  115,  1377, 115,  115,  1401, 115,  115,
+    115,  115,
+
+    1401, 1378, 1401, 1401, 1401, 1401, 1401, 115,  115,  115,  1401, 115,  115,  1401,
+    115,  115,  115,  1401, 115,  1401, 1401, 115,  115,  115,  115,  1401, 1379, 1378,
+    115,  1401, 1401, 115,  115,  115,  115,  1401, 115,  1401, 115,  115,  115,  1401,
+    115,  115,  115,  1401, 115,  115,  115,  1401, 1401, 115,  1379, 1401, 1401, 115,
+    115,  115,  115,  1401, 115,  1401, 1401, 115,  1401, 1401, 1401, 115,  1401, 1401,
+    115,  1401, 115,  1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 115,  1276,
+    1277, 1401, 1277, 1277, 1277, 1277, 1276, 1276, 1276, 1276, 1276, 1276, 1401, 1371,
+    1401, 1276,
+
+    1335, 1276, 1276, 1276, 1280, 115,  1401, 115,  115,  1389, 1390, 115,  115,  1401,
+    1401, 115,  1401, 115,  115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 115,
+    115,  1401, 1401, 1276, 115,  1401, 115,  115,  1389, 1390, 115,  115,  1401, 115,
+    1401, 115,  115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 115,  115,  1401,
+    1401, 1276, 1276, 1277, 1401, 1277, 1277, 1277, 1277, 1276, 1276, 1276, 1276, 1276,
+    1276, 1370, 1371, 1370, 1276, 1335, 1276, 1276, 1276, 1280, 115,  115,  115,  115,
+    115,  115,  115,  115,  1401, 1401, 115,  115,  1391, 115,  1401, 1401, 1401, 1401,
+    1401, 1401,
+
+    115,  115,  115,  115,  1401, 1401, 1276, 115,  115,  115,  115,  115,  115,  115,
+    115,  1401, 115,  115,  1391, 115,  115,  1401, 1401, 1401, 115,  1401, 115,  115,
+    115,  115,  115,  1401, 1276, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 115,  1401,
+    1401, 1401, 1401, 1401, 1401, 115,  1401, 1401, 1401, 115,  1401, 1401, 1401, 1401,
+    115,  1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 115,  1276, 1277, 1401,
+    1277, 1277, 1277, 1277, 1276, 1276, 1276, 1276, 1276, 1276, 1370, 1371, 1370, 1276,
+    1335, 1276, 1276, 1276, 1280, 115,  115,  1401, 115,  115,  115,  1401, 115,  1401,
+    1401, 1395,
+
+    115,  1396, 115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  115,  1401, 115,  1401,
+    1401, 1276, 115,  115,  1401, 115,  115,  115,  1401, 115,  1401, 1395, 115,  1396,
+    115,  1401, 115,  1401, 1401, 115,  115,  115,  115,  115,  115,  1399, 115,  1276,
+    1401, 115,  1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 1401, 115,  1401, 1401,
+    1401, 115,  115,  1401, 115,  115,  115,  1401, 115,  1399, 115,  1401, 115,  115,
+    1401, 1401, 1401, 1401, 1401, 1401, 115,  1401, 115,  115,  1401, 1401, 1401, 1401,
+    1401, 115,  1401, 1401, 1401, 115,  1401, 1401, 1401, 1401, 115,  1401, 1401, 1401,
+    1401, 1401,
+
+    1401, 1401, 1401, 1401, 115,  95,   95,   95,   99,   99,   99,   193,  193,  193,
+    195,  195,  195,  202,  202,  202,  209,  209,  209,  224,  224,  224,  314,  314,
+    100,  100,  100,  318,  318,  318,  319,  319,  436,  436,  436,  202,  202,  202,
+    439,  439,  439,  209,  209,  209,  212,  212,  212,  448,  448,  448,  449,  449,
+    449,  461,  461,  461,  228,  228,  228,  229,  229,  229,  314,  314,  575,  575,
+    579,  579,  579,  320,  320,  581,  581,  691,  691,  691,  696,  696,  696,  704,
+    704,  704,  451,  451,  451,  708,  708,  708,  461,  461,  461,  822,  822,  575,
+    575,  576,
+
+    576,  825,  825,  579,  579,  579,  826,  826,  826,  827,  827,  917,  917,  917,
+    918,  918,  918,  202,  202,  202,  439,  439,  439,  696,  696,  696,  698,  698,
+    698,  925,  925,  925,  212,  212,  212,  704,  704,  704,  927,  927,  927,  451,
+    451,  451,  929,  929,  929,  193,  193,  193,  228,  228,  228,  1021, 1021, 576,
+    576,  575,  575,  1025, 1025, 826,  826,  826,  827,  827,  1027, 1027, 195,  195,
+    195,  1097, 1097, 1097, 1103, 1103, 1103, 1106, 1106, 1106, 1179, 1179, 1181, 1181,
+    1226, 1226, 1226, 1229, 1229, 1229, 1278, 1278, 1277, 1277, 1276, 1276, 1279, 1279,
+    1337, 1337,
+
+    1370, 1370, 1388, 1388, 11,   1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401};
+
+static const flex_int16_t yy_chk[12581] = {
+    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    3,    4,    13,   13,   1463, 13,   13,   14,
+    14,   16,   14,   14,   98,   16,   20,   20,   20,   25,   25,   25,   95,   27,
+    20,   27,   95,
+
+    1441, 98,   3,    4,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+    5,    5,    5,    5,    5,    5,    5,    5,    5,    7,    8,    9,    10,   17,
+    49,   91,   9,    10,   18,   18,   18,   18,   18,   18,   21,   235,  18,   100,
+    231,  231,
+
+    21,   240,  22,   22,   100,  21,   7,    8,    18,   22,   49,   46,   91,   90,
+    22,   1434, 9,    10,   90,   46,   313,  46,   235,  46,   46,   231,  231,  1428,
+    240,  90,   51,   51,   21,   51,   51,   313,  17,   1417, 46,   1416, 1411, 22,
+    9,    10,   23,   46,   51,   46,   90,   46,   46,   23,   23,   23,   23,   23,
+    23,   23,   23,   23,   23,   23,   23,   23,   23,   23,   34,   37,   39,   241,
+    34,   265,  39,   232,  90,   37,   34,   37,   39,   34,   108,  108,  232,  108,
+    39,   241,  34,   37,   39,   108,  232,  569,  23,   34,   37,   39,   241,  34,
+    265,  39,
+
+    232,  37,   34,   37,   39,   34,   110,  110,  232,  110,  39,   241,  34,   37,
+    39,   110,  232,  569,  23,   28,   94,   94,   1405, 94,   94,   1402, 28,   28,
+    28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+    28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+    28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+    28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+    28,   28,   28,   28,   28,   28,   28,   28,   28,   28,   29,   29,   29,   252,
+    52,   52,
+
+    29,   52,   52,   29,   315,  29,   29,   252,  1336, 29,   29,   322,  29,   236,
+    52,   823,  29,   322,  1277, 315,  1180, 29,   29,   29,   252,  1023, 268,  29,
+    105,  29,   236,  29,   29,   252,  105,  29,   29,   277,  29,   105,  236,  35,
+    29,   30,   234,  35,   239,  30,   238,  35,   30,   30,   238,  268,  30,   35,
+    236,  30,   239,  234,  30,   295,  576,  30,   277,  35,   105,  30,   35,   314,
+    30,   234,  35,   239,  30,   238,  35,   30,   30,   238,  30,   35,   823,  30,
+    239,  234,  30,   1180, 295,  30,   114,  35,   38,   30,   31,   43,   38,   40,
+    31,   43,
+
+    38,   40,   31,   253,  323,  43,   38,   40,   31,   253,  323,  31,   719,  40,
+    31,   43,   38,   40,   31,   38,   308,  31,   43,   38,   40,   31,   43,   38,
+    40,   31,   253,  43,   38,   40,   31,   113,  253,  31,   719,  40,   31,   43,
+    38,   40,   31,   32,   32,   308,  53,   53,   32,   53,   53,   32,   326,  32,
+    32,   112,  48,   102,  326,  48,   48,   107,  53,   32,   32,   97,   48,   107,
+    327,  92,   32,   32,   107,  246,  327,  32,   48,   32,   26,   32,   32,   54,
+    54,   48,   54,   54,   48,   48,   246,  32,   32,   33,   48,   24,   19,   33,
+    264,  54,
+
+    33,   107,  246,  33,   48,   12,   33,   50,   50,   50,   50,   50,   50,   33,
+    47,   582,  246,  264,  47,   11,   33,   582,  47,   50,   33,   264,  33,   50,
+    47,   33,   55,   55,   33,   55,   55,   55,   258,  0,    47,   33,   36,   47,
+    36,   264,  463,  47,   55,   0,    36,   47,   36,   258,  73,   237,  47,   36,
+    73,   464,  76,   0,    36,   0,    73,   258,  47,   73,   76,   36,   76,   36,
+    237,  463,  73,   245,  36,   245,  36,   258,  76,   73,   237,  36,   0,    73,
+    464,  76,   36,   41,   73,   41,   0,    73,   76,   0,    76,   41,   237,  41,
+    73,   41,
+
+    245,  41,   245,  466,  76,   0,    0,    41,   58,   58,   58,   58,   58,   58,
+    41,   104,  41,   104,  104,  104,  104,  41,   720,  41,   58,   41,   109,  41,
+    58,   0,    466,  310,  109,  41,   42,   104,  310,  109,  106,  106,  728,  583,
+    42,   42,   42,   106,  42,   583,  720,  42,   106,  57,   57,   57,   57,   57,
+    57,   247,  242,  57,   242,  42,   242,  310,  109,  0,    728,  57,   42,   42,
+    42,   57,   42,   247,  247,  42,   44,   106,  44,   467,  0,    44,   44,   0,
+    247,  242,  44,   242,  44,   242,  44,   56,   56,   56,   56,   56,   56,   0,
+    44,   247,
+
+    247,  249,  0,    44,   0,    44,   467,  56,   44,   44,   276,  56,   44,   276,
+    44,   0,    44,   249,  63,   63,   63,   63,   63,   63,   44,   45,   0,    74,
+    249,  45,   266,  74,   45,   45,   63,   74,   266,  276,  63,   45,   276,  74,
+    45,   249,  325,  325,  0,    325,  0,    45,   739,  74,   45,   325,  74,   0,
+    45,   266,  74,   45,   45,   250,  74,   266,  56,   45,   0,    74,   45,   59,
+    59,   59,   59,   59,   59,   45,   739,  74,   0,    250,  470,  59,   59,   59,
+    288,  59,   288,  0,    250,  59,   60,   60,   60,   60,   60,   60,   0,    0,
+    64,   64,
+
+    64,   64,   64,   64,   60,   250,  60,   470,  0,    477,  60,   288,  743,  288,
+    64,   60,   64,   64,   64,   65,   65,   65,   65,   65,   65,   89,   89,   0,
+    89,   89,   0,    491,  0,    0,    89,   65,   477,  0,    743,  65,   0,    0,
+    60,   61,   61,   61,   61,   61,   61,   66,   66,   66,   66,   66,   66,   270,
+    61,   61,   491,  61,   255,  255,  499,  61,   89,   66,   270,  66,   61,   66,
+    0,    99,   99,   99,   99,   99,   99,   195,  195,  99,   195,  195,  270,  0,
+    0,    0,    0,    255,  255,  499,  89,   99,   270,  195,  0,    61,   62,   62,
+    62,   62,
+
+    62,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+    62,   62,   62,   62,   77,   78,   79,   82,   77,   78,   79,   82,   77,   254,
+    0,    78,   79,   82,   77,   502,  0,    78,   79,   521,  0,    78,   79,   82,
+    77,   254,  62,   77,   78,   79,   82,   77,   78,   79,   82,   77,   254,  78,
+    79,   82,   77,   0,    502,  78,   79,   0,    521,  78,   79,   82,   77,   254,
+    62,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
+    67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
+    67,   67,
+
+    67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
+    67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
+    67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
+    67,   67,   67,   67,   68,   68,   68,   269,  136,  251,  68,   136,  0,    68,
+    744,  68,   68,   136,  269,  68,   68,   251,  68,   269,  136,  0,    68,   0,
+    0,    0,    0,    68,   68,   68,   269,  136,  251,  68,   136,  68,   744,  68,
+    68,   136,  269,  68,   68,   251,  68,   269,  136,  86,   68,   69,   243,  86,
+    260,  69,
+
+    523,  86,   69,   69,   256,  0,    69,   86,   243,  69,   256,  0,    69,   260,
+    243,  69,   260,  86,   0,    69,   86,   256,  69,   243,  86,   260,  69,   523,
+    86,   69,   69,   256,  69,   86,   243,  69,   0,    256,  69,   260,  243,  69,
+    260,  86,   259,  69,   70,   256,  87,   115,  70,   87,   87,   261,  70,   570,
+    259,  115,  87,   115,  70,   115,  714,  70,   746,  261,  70,   570,  87,   714,
+    70,   259,  0,    70,   0,    87,   115,  70,   87,   87,   261,  70,   259,  115,
+    87,   115,  70,   115,  714,  70,   746,  261,  70,   570,  87,   714,  70,   71,
+    71,   257,
+
+    117,  495,  71,   117,  0,    71,   742,  71,   71,   262,  0,    117,  742,  117,
+    495,  117,  257,  71,   71,   201,  201,  262,  201,  201,  71,   71,   257,  117,
+    495,  71,   117,  71,   742,  71,   71,   201,  262,  117,  742,  117,  495,  117,
+    257,  71,   71,   72,   0,    262,  754,  72,   297,  0,    72,   118,  0,    72,
+    297,  0,    72,   119,  0,    118,  0,    118,  755,  72,   0,    119,  0,    119,
+    304,  0,    72,   118,  754,  119,  72,   297,  72,   119,  118,  72,   0,    297,
+    72,   304,  119,  118,  120,  118,  755,  72,   75,   119,  75,   119,  120,  304,
+    120,  118,
+
+    75,   119,  75,   0,    0,    119,  761,  75,   120,  120,  0,    304,  75,   194,
+    194,  120,  194,  194,  524,  75,   0,    75,   120,  0,    120,  0,    75,   141,
+    75,   194,  141,  476,  761,  75,   120,  120,  141,  121,  75,   80,   121,  80,
+    0,    141,  763,  524,  476,  80,   121,  80,   121,  80,   121,  80,   141,  0,
+    194,  141,  476,  80,   0,    126,  141,  0,    121,  126,  80,   121,  80,   141,
+    763,  126,  476,  80,   121,  80,   121,  80,   121,  80,   0,    126,  194,  127,
+    0,    80,   81,   127,  126,  285,  81,   273,  126,  127,  285,  0,    81,   126,
+    0,    81,
+
+    273,  0,    81,   127,  0,    0,    81,   126,  196,  196,  127,  196,  196,  81,
+    127,  765,  285,  81,   273,  127,  0,    285,  81,   717,  196,  81,   273,  717,
+    81,   127,  533,  122,  81,   83,   122,  83,   272,  272,  83,   83,   123,  765,
+    122,  83,   122,  83,   122,  83,   123,  717,  123,  196,  123,  717,  123,  83,
+    535,  533,  122,  767,  83,   122,  83,   272,  272,  83,   83,   123,  122,  83,
+    122,  83,   122,  83,   123,  274,  123,  196,  123,  771,  123,  83,   84,   535,
+    128,  767,  84,   0,    128,  84,   84,   0,    274,  759,  128,  274,  84,   759,
+    128,  84,
+
+    124,  0,    274,  0,    128,  771,  84,   0,    124,  84,   124,  128,  124,  84,
+    124,  128,  84,   84,   274,  759,  128,  274,  84,   759,  128,  84,   772,  124,
+    137,  289,  128,  137,  84,   85,   124,  541,  124,  137,  124,  289,  124,  85,
+    774,  85,   137,  85,   137,  541,  85,   125,  125,  0,    772,  85,   0,    137,
+    289,  125,  137,  125,  85,   125,  541,  137,  0,    289,  0,    85,   774,  85,
+    137,  85,   137,  541,  85,   155,  125,  125,  155,  85,   88,   279,  279,  125,
+    155,  125,  88,   125,  88,   0,    88,   155,  88,   88,   546,  193,  193,  193,
+    193,  193,
+
+    193,  0,    155,  0,    0,    155,  0,    88,   279,  279,  155,  193,  88,   0,
+    88,   193,  88,   155,  88,   88,   93,   546,  0,    0,    0,    551,  0,    93,
+    93,   93,   93,   93,   93,   93,   93,   563,  93,   93,   93,   93,   93,   93,
+    129,  130,  132,  138,  129,  130,  132,  138,  129,  275,  551,  130,  132,  138,
+    129,  481,  0,    130,  275,  275,  563,  130,  132,  138,  129,  481,  93,   129,
+    130,  132,  138,  129,  130,  132,  138,  129,  275,  130,  132,  138,  129,  0,
+    481,  130,  275,  275,  0,    130,  132,  138,  129,  481,  93,   103,  103,  103,
+    103,  103,
+
+    103,  103,  103,  103,  103,  103,  103,  103,  103,  103,  133,  103,  103,  103,
+    103,  103,  103,  0,    133,  0,    133,  0,    133,  0,    145,  139,  496,  233,
+    233,  139,  142,  0,    145,  139,  145,  139,  145,  133,  142,  496,  142,  473,
+    0,    103,  133,  139,  133,  473,  133,  233,  142,  145,  139,  496,  233,  233,
+    139,  142,  145,  139,  145,  139,  145,  0,    142,  496,  142,  0,    473,  103,
+    111,  139,  0,    0,    473,  233,  142,  111,  111,  111,  111,  111,  111,  111,
+    111,  776,  111,  111,  111,  111,  111,  111,  140,  143,  144,  146,  140,  143,
+    144,  146,
+
+    267,  0,    140,  143,  144,  146,  515,  0,    143,  144,  515,  776,  140,  143,
+    144,  146,  267,  267,  0,    140,  143,  144,  146,  140,  143,  144,  146,  267,
+    140,  143,  144,  146,  0,    515,  143,  144,  0,    515,  140,  143,  144,  146,
+    267,  267,  111,  116,  282,  282,  0,    284,  0,    0,    116,  0,    116,  116,
+    116,  116,  284,  116,  147,  116,  116,  116,  116,  116,  116,  0,    147,  0,
+    147,  784,  147,  282,  282,  147,  284,  202,  202,  148,  202,  202,  202,  148,
+    284,  296,  290,  147,  0,    148,  291,  291,  0,    202,  147,  290,  147,  784,
+    147,  148,
+
+    0,    147,  0,    296,  149,  324,  148,  0,    149,  0,    148,  324,  296,  290,
+    149,  148,  324,  291,  291,  116,  131,  290,  0,    0,    149,  148,  131,  131,
+    131,  296,  131,  149,  131,  206,  206,  149,  206,  206,  206,  293,  149,  293,
+    0,    324,  785,  0,    0,    131,  154,  206,  149,  154,  131,  131,  131,  0,
+    131,  154,  131,  134,  298,  298,  472,  0,    154,  154,  293,  134,  293,  134,
+    785,  134,  134,  134,  507,  154,  207,  207,  154,  207,  207,  207,  472,  154,
+    507,  0,    134,  298,  298,  472,  154,  154,  207,  134,  299,  134,  299,  134,
+    134,  134,
+
+    135,  507,  151,  135,  0,    0,    151,  0,    472,  135,  507,  135,  151,  135,
+    0,    135,  135,  789,  0,    151,  150,  299,  151,  299,  150,  0,    307,  135,
+    150,  151,  135,  307,  795,  151,  150,  135,  152,  135,  151,  135,  152,  135,
+    135,  789,  150,  151,  152,  150,  151,  153,  263,  150,  263,  153,  0,    150,
+    152,  303,  795,  153,  150,  307,  156,  152,  263,  156,  0,    152,  0,    153,
+    150,  156,  152,  156,  303,  511,  153,  263,  156,  263,  153,  511,  152,  159,
+    303,  153,  157,  307,  0,    156,  263,  159,  156,  159,  157,  153,  157,  156,
+    157,  156,
+
+    303,  797,  511,  159,  156,  0,    0,    0,    511,  0,    159,  168,  506,  157,
+    287,  168,  287,  159,  800,  159,  157,  168,  157,  506,  157,  158,  160,  797,
+    287,  159,  158,  168,  158,  158,  160,  158,  160,  158,  168,  506,  0,    287,
+    168,  287,  800,  0,    160,  168,  801,  506,  309,  0,    158,  160,  287,  309,
+    158,  168,  158,  158,  160,  158,  160,  158,  0,    808,  309,  162,  478,  292,
+    163,  482,  160,  161,  801,  162,  162,  162,  163,  292,  163,  161,  163,  161,
+    478,  309,  0,    162,  482,  161,  292,  808,  161,  161,  162,  478,  292,  163,
+    482,  818,
+
+    161,  162,  162,  162,  163,  292,  163,  161,  163,  161,  478,  309,  164,  162,
+    482,  161,  292,  0,    161,  161,  164,  0,    164,  0,    164,  165,  818,  0,
+    0,    165,  0,    479,  0,    166,  0,    165,  0,    0,    0,    164,  165,  166,
+    0,    166,  812,  165,  164,  479,  164,  301,  164,  301,  165,  166,  167,  171,
+    165,  509,  479,  167,  166,  165,  167,  171,  167,  171,  165,  166,  509,  166,
+    812,  165,  819,  479,  167,  171,  301,  819,  301,  166,  169,  167,  171,  169,
+    509,  0,    167,  169,  167,  171,  167,  171,  0,    169,  509,  180,  278,  0,
+    278,  180,
+
+    167,  171,  813,  169,  819,  180,  0,    169,  212,  212,  169,  212,  212,  278,
+    169,  180,  212,  199,  199,  169,  199,  199,  180,  278,  212,  278,  180,  815,
+    813,  169,  170,  180,  172,  199,  0,    170,  172,  474,  1018, 278,  172,  180,
+    172,  170,  0,    170,  474,  170,  170,  0,    0,    170,  172,  815,  302,  0,
+    302,  170,  492,  172,  199,  280,  170,  172,  474,  1018, 172,  280,  172,  170,
+    280,  170,  474,  170,  170,  492,  174,  170,  172,  173,  174,  302,  300,  302,
+    174,  492,  199,  173,  280,  173,  174,  300,  0,    173,  280,  173,  280,  300,
+    816,  173,
+
+    174,  492,  0,    174,  175,  468,  173,  174,  175,  300,  468,  174,  175,  173,
+    0,    173,  174,  300,  175,  173,  462,  173,  462,  300,  816,  173,  174,  0,
+    175,  0,    176,  175,  468,  177,  176,  175,  545,  468,  176,  175,  176,  177,
+    0,    177,  175,  0,    178,  462,  178,  462,  176,  0,    0,    177,  175,  545,
+    178,  176,  178,  0,    177,  176,  0,    545,  176,  519,  176,  177,  178,  177,
+    0,    519,  465,  178,  465,  178,  176,  179,  480,  177,  181,  545,  178,  182,
+    178,  179,  179,  179,  181,  181,  181,  182,  519,  182,  178,  0,    480,  179,
+    519,  465,
+
+    181,  465,  0,    182,  179,  480,  469,  181,  469,  510,  182,  179,  179,  179,
+    181,  181,  181,  182,  0,    182,  183,  184,  480,  179,  185,  184,  181,  510,
+    183,  182,  183,  184,  185,  469,  185,  469,  510,  183,  805,  0,    183,  184,
+    805,  0,    185,  186,  0,    183,  184,  186,  0,    185,  184,  510,  183,  186,
+    183,  184,  185,  484,  185,  484,  0,    183,  805,  186,  183,  184,  805,  187,
+    185,  724,  186,  724,  0,    0,    186,  187,  0,    187,  188,  186,  725,  187,
+    188,  0,    484,  725,  484,  187,  188,  186,  0,    932,  189,  0,    187,  724,
+    189,  724,
+
+    188,  483,  190,  187,  189,  187,  190,  188,  725,  187,  0,    188,  190,  725,
+    189,  187,  188,  190,  489,  932,  489,  189,  190,  483,  191,  189,  188,  343,
+    483,  190,  189,  0,    191,  190,  191,  343,  191,  343,  190,  343,  189,  192,
+    0,    190,  192,  489,  548,  489,  190,  483,  192,  191,  0,    0,    343,  0,
+    0,    192,  191,  294,  191,  343,  191,  343,  934,  343,  548,  564,  192,  294,
+    294,  192,  0,    548,  0,    0,    192,  197,  197,  197,  197,  197,  197,  192,
+    0,    0,    294,  564,  0,    0,    934,  0,    548,  197,  564,  294,  294,  197,
+    198,  198,
+
+    198,  198,  198,  198,  198,  198,  198,  198,  198,  198,  198,  198,  198,  564,
+    198,  198,  198,  198,  198,  198,  200,  200,  935,  200,  200,  203,  203,  0,
+    203,  203,  203,  204,  204,  0,    204,  204,  200,  0,    0,    205,  205,  203,
+    205,  205,  205,  0,    198,  204,  935,  209,  209,  209,  209,  209,  209,  205,
+    271,  209,  490,  498,  490,  498,  0,    200,  271,  209,  271,  271,  203,  209,
+    769,  769,  198,  0,    204,  208,  208,  208,  208,  208,  208,  208,  205,  271,
+    0,    490,  498,  490,  498,  200,  271,  208,  271,  271,  203,  208,  769,  769,
+    210,  210,
+
+    204,  210,  210,  0,    0,    0,    210,  0,    205,  211,  211,  0,    211,  211,
+    210,  213,  213,  0,    213,  213,  0,    0,    0,    213,  941,  211,  435,  435,
+    0,    435,  435,  213,  0,    214,  214,  214,  214,  214,  214,  0,    0,    210,
+    435,  215,  215,  215,  215,  215,  215,  214,  941,  215,  211,  214,  715,  435,
+    0,    715,  213,  215,  0,    437,  437,  215,  437,  437,  437,  210,  0,    0,
+    0,    0,    0,    0,    942,  0,    0,    437,  211,  0,    715,  437,  435,  715,
+    213,  216,  216,  216,  216,  216,  216,  216,  216,  216,  216,  216,  216,  216,
+    216,  216,
+
+    942,  216,  216,  216,  216,  216,  216,  217,  217,  217,  217,  217,  217,  0,
+    218,  218,  218,  218,  218,  218,  281,  493,  281,  217,  735,  0,    281,  217,
+    218,  735,  218,  0,    281,  216,  218,  729,  0,    729,  493,  218,  221,  221,
+    221,  221,  221,  221,  0,    281,  493,  281,  735,  221,  221,  281,  221,  735,
+    221,  471,  281,  216,  221,  729,  471,  729,  493,  0,    218,  219,  219,  219,
+    219,  219,  219,  0,    220,  220,  220,  220,  220,  220,  219,  219,  248,  219,
+    471,  248,  0,    219,  220,  471,  220,  248,  219,  0,    220,  0,    949,  0,
+    248,  220,
+
+    222,  222,  222,  222,  222,  222,  0,    445,  445,  248,  445,  445,  248,  486,
+    222,  529,  222,  248,  486,  219,  222,  529,  949,  445,  248,  222,  220,  223,
+    223,  223,  223,  223,  223,  451,  451,  0,    451,  451,  223,  223,  486,  223,
+    529,  223,  0,    486,  0,    223,  529,  451,  0,    0,    222,  224,  224,  224,
+    224,  224,  224,  224,  224,  224,  224,  224,  224,  224,  224,  224,  0,    224,
+    224,  224,  224,  224,  224,  225,  225,  225,  225,  225,  225,  226,  226,  226,
+    226,  226,  226,  494,  494,  0,    0,    225,  0,    1019, 500,  225,  1019, 226,
+    0,    0,
+
+    952,  226,  227,  227,  227,  227,  227,  227,  439,  439,  500,  439,  439,  439,
+    494,  494,  306,  306,  227,  306,  306,  500,  227,  1019, 439,  306,  952,  224,
+    228,  228,  228,  228,  228,  228,  228,  228,  500,  228,  228,  228,  228,  228,
+    228,  244,  228,  228,  228,  228,  228,  228,  286,  0,    244,  244,  244,  306,
+    244,  305,  0,    286,  305,  504,  488,  504,  0,    286,  305,  286,  488,  0,
+    244,  488,  731,  305,  305,  731,  0,    286,  244,  244,  244,  306,  244,  0,
+    305,  286,  0,    305,  504,  488,  504,  286,  305,  286,  0,    488,  0,    488,
+    731,  305,
+
+    305,  731,  228,  229,  229,  229,  229,  229,  229,  229,  229,  0,    229,  229,
+    229,  229,  0,    229,  0,    229,  229,  229,  229,  229,  229,  316,  0,    316,
+    316,  316,  316,  316,  319,  956,  319,  319,  319,  319,  442,  442,  329,  442,
+    442,  442,  329,  316,  505,  0,    505,  0,    329,  0,    319,  0,    442,  0,
+    0,    0,    442,  956,  329,  0,    0,    0,    0,    0,    0,    329,  0,    0,
+    0,    329,  0,    505,  0,    505,  329,  229,  230,  230,  230,  230,  230,  230,
+    230,  230,  329,  230,  230,  230,  230,  230,  230,  962,  230,  230,  230,  230,
+    230,  230,
+
+    330,  331,  230,  332,  330,  331,  362,  332,  0,    0,    330,  331,  786,  332,
+    362,  0,    362,  786,  362,  962,  330,  331,  0,    332,  0,    0,    0,    330,
+    331,  230,  332,  330,  331,  362,  332,  501,  330,  331,  786,  332,  362,  333,
+    362,  786,  362,  333,  330,  331,  497,  332,  501,  333,  230,  283,  503,  283,
+    516,  0,    283,  334,  0,    333,  501,  334,  0,    497,  283,  0,    333,  334,
+    503,  283,  333,  516,  283,  497,  501,  333,  0,    334,  283,  503,  283,  516,
+    0,    283,  334,  333,  0,    0,    334,  497,  283,  527,  0,    334,  503,  283,
+    0,    516,
+
+    283,  311,  0,    335,  311,  334,  335,  335,  0,    527,  311,  446,  446,  335,
+    446,  446,  311,  311,  311,  446,  527,  438,  438,  335,  438,  438,  438,  446,
+    311,  0,    335,  311,  965,  335,  335,  527,  311,  438,  0,    335,  0,    0,
+    311,  311,  311,  312,  0,    0,    0,    335,  438,  0,    312,  312,  312,  312,
+    312,  312,  965,  312,  0,    312,  312,  312,  312,  312,  312,  336,  337,  485,
+    338,  336,  337,  338,  338,  336,  553,  438,  337,  966,  338,  336,  508,  0,
+    485,  485,  508,  0,    337,  553,  338,  336,  508,  312,  336,  337,  485,  338,
+    336,  337,
+
+    338,  338,  336,  553,  337,  966,  338,  336,  0,    508,  485,  485,  0,    508,
+    337,  553,  338,  336,  508,  312,  318,  318,  318,  318,  318,  318,  318,  318,
+    318,  318,  318,  318,  318,  967,  318,  0,    318,  318,  318,  318,  318,  318,
+    339,  340,  0,    341,  339,  340,  341,  512,  522,  0,    339,  340,  341,  344,
+    0,    512,  344,  967,  339,  341,  339,  340,  344,  802,  802,  522,  318,  339,
+    340,  344,  341,  339,  340,  341,  512,  522,  339,  340,  341,  0,    344,  512,
+    969,  344,  339,  341,  339,  340,  344,  802,  802,  522,  318,  321,  321,  344,
+    321,  321,
+
+    321,  321,  321,  321,  321,  321,  321,  321,  321,  321,  969,  321,  321,  321,
+    321,  321,  321,  342,  0,    345,  346,  342,  345,  346,  525,  536,  0,    342,
+    345,  346,  363,  0,    342,  525,  536,  345,  346,  342,  363,  738,  363,  738,
+    363,  321,  342,  0,    345,  346,  342,  345,  346,  525,  536,  342,  345,  346,
+    0,    363,  342,  525,  536,  345,  346,  342,  363,  738,  363,  738,  363,  321,
+    328,  747,  0,    747,  0,    0,    0,    328,  328,  328,  328,  328,  328,  328,
+    328,  547,  328,  328,  328,  328,  328,  328,  347,  348,  350,  347,  348,  747,
+    350,  747,
+
+    547,  347,  348,  348,  350,  0,    0,    0,    347,  348,  347,  0,    547,  0,
+    350,  349,  0,    0,    349,  347,  348,  350,  347,  348,  349,  350,  547,  347,
+    348,  348,  350,  349,  349,  517,  347,  348,  347,  517,  716,  351,  350,  561,
+    349,  351,  328,  349,  352,  351,  0,    352,  349,  716,  0,    351,  0,    352,
+    561,  349,  349,  368,  517,  352,  352,  351,  517,  716,  351,  368,  561,  368,
+    351,  368,  528,  352,  351,  353,  352,  716,  353,  351,  353,  352,  561,  528,
+    353,  0,    368,  352,  352,  351,  0,    353,  354,  368,  537,  368,  354,  368,
+    0,    528,
+
+    354,  0,    353,  537,  355,  353,  354,  353,  355,  528,  353,  355,  0,    0,
+    355,  0,    354,  353,  513,  354,  513,  537,  356,  354,  355,  567,  356,  354,
+    0,    537,  356,  355,  354,  567,  357,  355,  356,  355,  357,  518,  355,  518,
+    354,  0,    357,  513,  356,  513,  0,    356,  355,  0,    567,  356,  357,  358,
+    0,    356,  358,  567,  0,    357,  356,  0,    358,  357,  518,  520,  518,  520,
+    357,  358,  356,  450,  450,  359,  450,  450,  359,  526,  357,  526,  358,  0,
+    359,  358,  530,  532,  530,  450,  358,  359,  359,  0,    520,  360,  520,  358,
+    360,  538,
+
+    0,    538,  359,  0,    360,  359,  526,  972,  526,  532,  359,  360,  360,  530,
+    532,  530,  450,  359,  359,  361,  361,  0,    360,  361,  0,    360,  538,  0,
+    538,  361,  360,  364,  0,    972,  0,    532,  361,  360,  360,  364,  0,    364,
+    450,  364,  0,    364,  361,  361,  531,  0,    361,  0,    0,    365,  0,    361,
+    366,  365,  364,  531,  366,  367,  361,  365,  367,  364,  366,  364,  0,    364,
+    367,  364,  0,    365,  0,    531,  366,  367,  447,  447,  365,  447,  447,  366,
+    365,  531,  447,  366,  367,  365,  0,    367,  366,  973,  447,  369,  367,  370,
+    369,  365,
+
+    370,  0,    366,  367,  369,  0,    370,  447,  0,    753,  0,    369,  0,    370,
+    975,  371,  514,  371,  514,  973,  371,  0,    369,  753,  370,  369,  371,  370,
+    514,  980,  369,  372,  370,  371,  447,  372,  753,  369,  373,  370,  975,  372,
+    371,  514,  371,  514,  373,  371,  373,  753,  373,  372,  371,  722,  514,  980,
+    374,  0,    372,  371,  722,  0,    372,  374,  374,  373,  374,  372,  374,  0,
+    376,  0,    373,  0,    373,  987,  373,  372,  376,  722,  376,  0,    376,  374,
+    452,  452,  722,  452,  452,  374,  374,  557,  374,  0,    374,  375,  375,  376,
+    0,    540,
+
+    452,  987,  375,  375,  376,  375,  376,  375,  376,  377,  378,  0,    0,    557,
+    378,  0,    540,  377,  557,  377,  378,  377,  375,  375,  377,  988,  540,  452,
+    375,  375,  378,  375,  0,    375,  379,  0,    377,  378,  379,  557,  379,  378,
+    540,  377,  379,  377,  378,  377,  380,  0,    377,  988,  380,  452,  379,  0,
+    378,  0,    380,  0,    0,    379,  0,    0,    554,  379,  379,  0,    380,  0,
+    379,  0,    381,  385,  0,    380,  381,  385,  0,    380,  379,  554,  381,  385,
+    380,  382,  383,  382,  549,  382,  383,  554,  381,  385,  380,  382,  383,  549,
+    0,    381,
+
+    385,  383,  0,    381,  385,  382,  383,  554,  381,  385,  991,  0,    382,  383,
+    382,  549,  382,  383,  381,  385,  997,  382,  383,  549,  384,  386,  384,  383,
+    384,  386,  0,    382,  383,  1002, 384,  386,  991,  387,  388,  0,    0,    387,
+    388,  0,    384,  386,  997,  387,  388,  566,  0,    384,  386,  384,  566,  384,
+    386,  387,  388,  1002, 384,  386,  389,  0,    387,  388,  389,  0,    387,  388,
+    384,  386,  389,  387,  388,  390,  566,  389,  0,    390,  0,    566,  389,  387,
+    388,  390,  809,  391,  0,    389,  1003, 391,  0,    389,  0,    390,  0,    391,
+    389,  0,
+
+    809,  392,  390,  389,  392,  0,    390,  391,  389,  0,    392,  390,  0,    809,
+    391,  393,  1003, 392,  391,  393,  539,  390,  539,  391,  0,    393,  809,  736,
+    392,  394,  0,    392,  394,  391,  1006, 393,  392,  0,    394,  543,  395,  543,
+    393,  392,  736,  394,  393,  539,  395,  539,  395,  393,  395,  396,  736,  748,
+    394,  396,  0,    394,  1006, 393,  0,    396,  394,  397,  543,  395,  543,  397,
+    736,  394,  748,  396,  395,  397,  395,  399,  395,  552,  396,  399,  748,  398,
+    396,  397,  1007, 399,  552,  396,  0,    398,  397,  398,  1011, 398,  397,  399,
+    748,  396,
+
+    400,  397,  0,    400,  399,  0,    552,  0,    399,  400,  398,  397,  1007, 399,
+    552,  0,    400,  398,  0,    398,  1011, 398,  0,    399,  0,    1017, 0,    400,
+    555,  544,  400,  544,  0,    443,  443,  400,  443,  443,  443,  555,  0,    402,
+    400,  401,  402,  403,  401,  732,  403,  443,  402,  1017, 401,  401,  403,  555,
+    544,  402,  544,  401,  0,    403,  401,  732,  550,  555,  550,  556,  402,  556,
+    401,  402,  403,  401,  732,  403,  402,  1107, 401,  401,  403,  404,  405,  402,
+    404,  401,  405,  403,  401,  732,  404,  550,  405,  550,  556,  1111, 556,  404,
+    560,  0,
+
+    560,  0,    405,  1107, 718,  0,    406,  0,    404,  405,  406,  404,  780,  405,
+    406,  0,    404,  718,  405,  1115, 406,  1111, 487,  404,  487,  560,  487,  560,
+    405,  780,  406,  718,  407,  406,  408,  0,    407,  406,  408,  780,  0,    406,
+    407,  718,  408,  1115, 406,  407,  0,    487,  0,    487,  407,  487,  408,  780,
+    406,  0,    475,  407,  475,  408,  409,  407,  534,  408,  409,  0,    407,  409,
+    408,  0,    409,  407,  534,  475,  737,  0,    407,  737,  408,  1116, 409,  534,
+    410,  475,  411,  475,  410,  409,  411,  534,  558,  409,  410,  409,  411,  750,
+    409,  750,
+
+    534,  475,  737,  558,  410,  737,  411,  1116, 409,  534,  0,    410,  0,    411,
+    412,  410,  938,  411,  412,  558,  410,  0,    411,  750,  412,  750,  542,  951,
+    542,  558,  410,  412,  411,  938,  412,  542,  413,  0,    417,  414,  413,  412,
+    417,  938,  951,  412,  413,  414,  417,  414,  412,  414,  0,    542,  951,  542,
+    413,  412,  417,  938,  412,  542,  734,  413,  734,  417,  414,  413,  415,  417,
+    951,  734,  413,  414,  417,  414,  415,  414,  415,  0,    415,  0,    413,  416,
+    417,  415,  416,  562,  734,  788,  734,  0,    416,  562,  0,    415,  788,  418,
+    0,    416,
+
+    419,  418,  415,  419,  415,  562,  415,  418,  0,    419,  416,  415,  0,    416,
+    562,  788,  419,  418,  416,  723,  562,  0,    788,  0,    418,  416,  420,  419,
+    418,  0,    419,  562,  723,  418,  420,  419,  420,  0,    420,  422,  421,  0,
+    419,  418,  0,    0,    723,  422,  421,  422,  421,  422,  421,  420,  421,  955,
+    559,  0,    723,  423,  420,  424,  420,  423,  420,  424,  422,  421,  559,  423,
+    559,  424,  955,  422,  421,  422,  421,  422,  421,  423,  421,  424,  955,  559,
+    713,  0,    423,  751,  424,  751,  423,  425,  424,  713,  559,  423,  559,  424,
+    955,  425,
+
+    0,    425,  0,    425,  426,  423,  0,    424,  426,  0,    0,    713,  726,  751,
+    426,  751,  426,  0,    425,  713,  0,    726,  427,  0,    426,  425,  427,  425,
+    429,  425,  427,  426,  429,  428,  0,    426,  427,  1117, 429,  726,  426,  428,
+    426,  428,  429,  428,  427,  726,  429,  427,  426,  1119, 727,  427,  0,    429,
+    0,    427,  749,  429,  428,  727,  427,  1117, 429,  0,    0,    428,  749,  428,
+    429,  428,  427,  430,  429,  431,  430,  1119, 431,  727,  432,  0,    430,  0,
+    431,  749,  0,    727,  432,  430,  432,  431,  432,  0,    749,  431,  792,  0,
+    565,  730,
+
+    430,  0,    431,  430,  0,    431,  0,    432,  430,  565,  431,  792,  730,  565,
+    432,  430,  432,  431,  432,  434,  433,  431,  433,  792,  434,  565,  730,  434,
+    433,  434,  433,  434,  433,  0,    0,    565,  0,    792,  730,  565,  0,    0,
+    0,    0,    0,    0,    434,  433,  0,    433,  434,  0,    0,    434,  433,  434,
+    433,  434,  433,  436,  436,  436,  436,  436,  436,  436,  436,  436,  436,  436,
+    436,  436,  757,  436,  757,  436,  436,  436,  436,  436,  436,  440,  440,  0,
+    440,  440,  440,  441,  441,  0,    441,  441,  441,  0,    0,    0,    740,  440,
+    757,  741,
+
+    757,  0,    1121, 441,  0,    740,  0,    436,  741,  444,  444,  444,  444,  444,
+    444,  444,  449,  449,  449,  449,  449,  449,  1126, 740,  440,  444,  741,  721,
+    1121, 444,  441,  740,  449,  436,  741,  575,  449,  575,  575,  575,  575,  575,
+    0,    0,    721,  0,    1130, 0,    1126, 0,    440,  0,    0,    721,  721,  575,
+    441,  448,  448,  448,  448,  448,  448,  448,  448,  448,  448,  448,  448,  448,
+    721,  448,  1130, 448,  448,  448,  448,  448,  448,  453,  453,  453,  453,  453,
+    453,  0,    455,  455,  455,  455,  455,  455,  758,  0,    758,  453,  766,  0,
+    766,  453,
+
+    455,  0,    455,  0,    1133, 448,  455,  456,  456,  456,  456,  456,  456,  698,
+    698,  0,    698,  698,  758,  698,  758,  456,  766,  456,  766,  0,    0,    456,
+    1134, 698,  1133, 448,  454,  454,  454,  454,  454,  454,  454,  454,  454,  454,
+    454,  454,  454,  454,  454,  0,    454,  454,  454,  454,  454,  454,  1134, 0,
+    457,  457,  457,  457,  457,  457,  0,    458,  458,  458,  458,  458,  458,  0,
+    457,  768,  457,  768,  458,  458,  457,  458,  0,    458,  454,  457,  0,    458,
+    459,  459,  459,  459,  459,  459,  0,    460,  460,  460,  460,  460,  460,  768,
+    459,  768,
+
+    459,  1135, 0,    0,    459,  460,  454,  460,  457,  0,    1139, 460,  461,  461,
+    461,  461,  461,  461,  461,  461,  461,  461,  461,  461,  461,  461,  461,  1135,
+    461,  461,  461,  461,  461,  461,  568,  571,  1139, 0,    568,  571,  0,    790,
+    0,    1140, 568,  571,  0,    577,  0,    577,  577,  577,  577,  577,  568,  571,
+    745,  790,  791,  745,  0,    568,  571,  791,  1141, 568,  571,  577,  790,  1140,
+    568,  571,  696,  696,  696,  696,  696,  696,  696,  0,    568,  571,  745,  790,
+    791,  745,  461,  572,  696,  791,  1141, 0,    696,  0,    572,  572,  572,  572,
+    572,  572,
+
+    0,    572,  0,    572,  572,  572,  572,  572,  572,  584,  0,    586,  733,  584,
+    585,  586,  733,  756,  0,    584,  577,  586,  585,  584,  585,  777,  585,  777,
+    733,  584,  756,  586,  931,  931,  764,  572,  584,  764,  586,  733,  584,  585,
+    586,  733,  756,  584,  0,    586,  585,  584,  585,  777,  585,  777,  733,  584,
+    756,  586,  931,  931,  764,  572,  573,  764,  0,    0,    0,    1142, 0,    573,
+    573,  573,  573,  573,  573,  573,  573,  573,  573,  573,  573,  573,  573,  573,
+    587,  588,  589,  760,  587,  588,  589,  590,  804,  1142, 587,  588,  589,  762,
+    0,    590,
+
+    760,  590,  1144, 590,  587,  588,  589,  804,  762,  1145, 573,  587,  588,  589,
+    760,  587,  588,  589,  590,  804,  587,  588,  589,  0,    762,  590,  760,  590,
+    1144, 590,  587,  588,  589,  804,  762,  1145, 573,  574,  574,  0,    574,  574,
+    574,  574,  574,  574,  574,  574,  574,  574,  574,  574,  1148, 574,  574,  574,
+    574,  574,  574,  591,  592,  593,  595,  591,  592,  593,  595,  0,    595,  591,
+    592,  593,  595,  933,  752,  770,  0,    933,  1148, 591,  592,  593,  595,  752,
+    770,  574,  591,  592,  593,  595,  591,  592,  593,  595,  595,  591,  592,  593,
+    595,  933,
+
+    0,    752,  770,  933,  0,    591,  592,  593,  595,  752,  770,  574,  578,  578,
+    0,    578,  578,  578,  578,  578,  578,  578,  578,  578,  578,  578,  578,  0,
+    578,  578,  578,  578,  578,  578,  0,    594,  596,  597,  599,  594,  596,  597,
+    599,  594,  778,  0,    596,  597,  599,  594,  787,  799,  597,  787,  799,  778,
+    596,  597,  599,  594,  578,  594,  594,  596,  597,  599,  594,  596,  597,  599,
+    594,  778,  596,  597,  599,  594,  787,  799,  597,  787,  799,  778,  596,  597,
+    599,  594,  578,  579,  579,  579,  579,  579,  579,  579,  579,  579,  579,  579,
+    579,  579,
+
+    0,    579,  0,    579,  579,  579,  579,  579,  579,  598,  600,  601,  0,    598,
+    600,  601,  0,    598,  1150, 598,  600,  601,  796,  706,  706,  779,  706,  706,
+    796,  598,  600,  601,  963,  963,  779,  579,  598,  600,  601,  706,  598,  600,
+    601,  598,  1150, 598,  600,  601,  796,  0,    0,    0,    779,  0,    796,  598,
+    600,  601,  963,  963,  779,  579,  580,  580,  580,  580,  580,  580,  580,  580,
+    580,  580,  580,  580,  580,  580,  580,  580,  580,  580,  580,  580,  580,  580,
+    602,  603,  604,  613,  602,  603,  604,  613,  781,  0,    602,  603,  604,  613,
+    775,  602,
+
+    775,  781,  940,  775,  602,  603,  604,  613,  940,  1156, 580,  602,  603,  604,
+    613,  602,  603,  604,  613,  781,  602,  603,  604,  613,  775,  602,  775,  781,
+    940,  775,  602,  603,  604,  613,  940,  1156, 580,  581,  581,  0,    581,  581,
+    581,  581,  581,  581,  581,  581,  581,  581,  807,  581,  807,  581,  581,  581,
+    581,  581,  581,  605,  614,  606,  605,  0,    614,  606,  605,  0,    990,  990,
+    614,  0,    605,  606,  0,    606,  807,  606,  807,  0,    614,  0,    605,  0,
+    0,    581,  605,  614,  606,  605,  0,    614,  606,  605,  990,  990,  614,  608,
+    605,  606,
+
+    773,  606,  607,  606,  608,  608,  614,  608,  605,  608,  607,  581,  607,  773,
+    607,  1158, 607,  783,  0,    803,  0,    782,  0,    607,  608,  0,    783,  773,
+    803,  607,  608,  608,  609,  608,  782,  608,  607,  609,  607,  773,  607,  1158,
+    607,  610,  783,  609,  803,  609,  782,  609,  0,    610,  783,  610,  803,  610,
+    793,  0,    610,  609,  782,  937,  806,  937,  609,  806,  611,  0,    0,    793,
+    610,  609,  0,    609,  611,  609,  611,  610,  611,  610,  611,  610,  612,  793,
+    610,  798,  0,    937,  806,  937,  612,  806,  612,  611,  612,  793,  1160, 0,
+    798,  968,
+
+    611,  615,  611,  0,    611,  615,  611,  0,    615,  612,  968,  615,  798,  616,
+    810,  617,  612,  616,  612,  617,  612,  615,  1160, 616,  798,  617,  968,  810,
+    615,  794,  794,  0,    615,  616,  615,  617,  968,  615,  0,    0,    616,  810,
+    617,  794,  616,  1162, 617,  615,  618,  616,  619,  617,  618,  810,  619,  0,
+    794,  794,  618,  616,  619,  617,  916,  916,  811,  916,  916,  0,    618,  794,
+    619,  1162, 620,  0,    811,  618,  620,  619,  916,  618,  950,  619,  620,  950,
+    618,  622,  619,  620,  622,  622,  0,    811,  620,  621,  618,  622,  619,  621,
+    0,    620,
+
+    811,  621,  0,    620,  0,    622,  950,  621,  620,  950,  944,  0,    622,  620,
+    944,  622,  622,  621,  620,  623,  621,  622,  624,  623,  621,  0,    624,  0,
+    621,  623,  970,  622,  624,  621,  623,  957,  944,  624,  0,    623,  944,  957,
+    624,  621,  625,  0,    623,  970,  625,  624,  623,  626,  626,  624,  625,  623,
+    626,  970,  624,  0,    623,  957,  626,  624,  625,  623,  627,  957,  624,  1163,
+    627,  625,  626,  970,  978,  625,  627,  628,  626,  626,  625,  0,    1164, 626,
+    0,    628,  627,  628,  626,  628,  625,  978,  0,    627,  814,  1163, 629,  627,
+    626,  630,
+
+    629,  978,  627,  630,  628,  0,    629,  814,  1164, 630,  631,  628,  627,  628,
+    630,  628,  629,  978,  631,  630,  631,  814,  631,  629,  0,    1165, 630,  629,
+    0,    0,    630,  632,  629,  814,  0,    630,  0,    631,  0,    632,  630,  632,
+    629,  632,  631,  630,  631,  939,  631,  634,  633,  1165, 1015, 1015, 633,  936,
+    0,    634,  632,  634,  633,  634,  939,  635,  635,  632,  993,  632,  936,  632,
+    633,  635,  1171, 635,  939,  635,  634,  633,  1015, 1015, 993,  633,  936,  634,
+    0,    634,  633,  634,  939,  0,    635,  635,  636,  993,  936,  637,  633,  635,
+    1171, 635,
+
+    636,  635,  636,  637,  636,  637,  993,  637,  638,  0,    637,  943,  0,    639,
+    0,    945,  638,  945,  638,  636,  638,  639,  637,  639,  943,  639,  636,  639,
+    636,  637,  636,  637,  947,  637,  0,    638,  637,  954,  943,  954,  639,  945,
+    638,  945,  638,  947,  638,  639,  640,  639,  943,  639,  1172, 639,  641,  0,
+    640,  0,    640,  947,  640,  0,    641,  954,  641,  954,  641,  0,    641,  0,
+    0,    947,  0,    1174, 992,  640,  0,    645,  1172, 0,    992,  641,  640,  642,
+    640,  645,  640,  645,  641,  645,  641,  642,  641,  642,  641,  642,  642,  649,
+    643,  1174,
+
+    992,  0,    643,  974,  645,  649,  992,  649,  643,  649,  642,  645,  0,    645,
+    974,  645,  644,  642,  643,  642,  644,  642,  642,  946,  649,  643,  644,  946,
+    646,  643,  974,  649,  646,  649,  643,  649,  644,  0,    646,  0,    974,  647,
+    0,    644,  643,  647,  0,    644,  646,  946,  948,  647,  644,  946,  948,  646,
+    960,  0,    1175, 646,  960,  647,  644,  648,  646,  652,  0,    648,  647,  652,
+    0,    648,  647,  648,  646,  652,  948,  647,  0,    1176, 948,  650,  960,  648,
+    1175, 652,  960,  647,  0,    650,  648,  650,  652,  650,  648,  650,  652,  648,
+    0,    648,
+
+    1177, 652,  651,  651,  953,  1176, 0,    0,    650,  648,  651,  652,  651,  953,
+    651,  650,  0,    650,  653,  650,  1177, 650,  653,  654,  655,  0,    653,  654,
+    655,  651,  651,  953,  653,  654,  655,  0,    651,  0,    651,  953,  651,  0,
+    653,  654,  655,  653,  1177, 1230, 0,    653,  654,  655,  656,  653,  654,  655,
+    656,  0,    653,  654,  655,  824,  656,  824,  824,  824,  824,  824,  653,  654,
+    655,  0,    656,  1230, 657,  0,    660,  658,  657,  656,  660,  824,  1232, 656,
+    657,  658,  660,  658,  656,  658,  0,    964,  0,    0,    657,  0,    660,  959,
+    656,  1233,
+
+    959,  657,  0,    660,  658,  657,  964,  660,  1232, 659,  657,  658,  660,  658,
+    999,  658,  659,  659,  964,  659,  657,  659,  660,  959,  661,  1233, 959,  678,
+    661,  0,    661,  999,  964,  0,    661,  678,  659,  678,  971,  678,  971,  999,
+    659,  659,  661,  659,  663,  659,  662,  663,  0,    661,  662,  663,  678,  661,
+    661,  999,  662,  663,  661,  678,  0,    678,  971,  678,  971,  0,    662,  663,
+    661,  1236, 0,    663,  0,    662,  663,  0,    664,  662,  663,  679,  664,  0,
+    662,  663,  664,  0,    664,  679,  976,  679,  976,  679,  662,  663,  679,  1236,
+    664,  0,
+
+    666,  665,  0,    665,  666,  664,  0,    665,  679,  664,  666,  0,    664,  665,
+    664,  679,  976,  679,  976,  679,  666,  0,    679,  665,  664,  668,  0,    666,
+    665,  668,  665,  666,  667,  667,  665,  668,  666,  667,  0,    665,  981,  0,
+    981,  667,  1238, 668,  666,  669,  0,    665,  994,  669,  668,  667,  669,  0,
+    668,  669,  0,    667,  667,  668,  0,    0,    667,  994,  981,  669,  981,  667,
+    1238, 668,  670,  0,    669,  1127, 670,  994,  669,  667,  669,  1127, 670,  669,
+    671,  672,  673,  958,  671,  672,  673,  994,  670,  669,  671,  672,  673,  961,
+    0,    670,
+
+    958,  1127, 1239, 670,  671,  672,  673,  1127, 670,  0,    961,  671,  672,  673,
+    958,  671,  672,  673,  670,  674,  671,  672,  673,  674,  961,  0,    958,  977,
+    1239, 674,  671,  672,  673,  675,  0,    983,  961,  675,  0,    674,  977,  676,
+    0,    675,  983,  676,  674,  675,  979,  0,    674,  676,  1244, 675,  977,  674,
+    0,    982,  979,  982,  675,  676,  983,  0,    675,  674,  977,  0,    676,  675,
+    983,  1000, 676,  675,  677,  979,  677,  676,  1244, 675,  677,  680,  681,  982,
+    979,  982,  677,  676,  1000, 680,  681,  680,  681,  680,  681,  680,  677,  0,
+    1000, 0,
+
+    0,    677,  0,    677,  985,  0,    1245, 677,  680,  681,  0,    0,    677,  985,
+    1000, 680,  681,  680,  681,  680,  681,  680,  677,  682,  683,  682,  684,  0,
+    683,  684,  684,  985,  1245, 682,  683,  682,  684,  682,  685,  985,  0,    995,
+    685,  0,    683,  0,    684,  1246, 685,  0,    682,  683,  682,  684,  995,  683,
+    684,  684,  685,  682,  683,  682,  684,  682,  984,  685,  984,  686,  995,  685,
+    683,  686,  684,  1246, 685,  687,  0,    686,  986,  687,  995,  0,    986,  996,
+    685,  687,  0,    686,  0,    688,  984,  0,    984,  688,  686,  687,  996,  689,
+    686,  688,
+
+    0,    689,  687,  686,  986,  998,  687,  689,  986,  688,  996,  687,  989,  686,
+    1125, 989,  688,  689,  998,  1125, 688,  687,  996,  0,    689,  688,  690,  690,
+    689,  690,  690,  0,    998,  689,  0,    688,  0,    1249, 989,  0,    1125, 989,
+    690,  689,  998,  1125, 0,    0,    0,    694,  694,  0,    694,  694,  694,  1250,
+    700,  700,  700,  700,  700,  700,  700,  1249, 0,    694,  690,  922,  922,  0,
+    922,  922,  700,  922,  697,  697,  700,  697,  697,  0,    697,  1250, 1253, 922,
+    0,    0,    0,    0,    0,    694,  697,  0,    690,  691,  691,  691,  691,  691,
+    691,  691,
+
+    691,  691,  691,  691,  691,  691,  0,    691,  1253, 691,  691,  691,  691,  691,
+    691,  694,  1001, 697,  1001, 1004, 701,  701,  701,  701,  701,  701,  701,  1009,
+    0,    700,  1008, 1009, 1008, 1004, 695,  695,  701,  695,  695,  695,  701,  691,
+    1001, 697,  1001, 0,    1004, 0,    699,  699,  695,  699,  699,  1009, 699,  0,
+    1008, 1009, 1008, 1004, 0,    0,    0,    695,  699,  0,    0,    691,  692,  692,
+    692,  692,  692,  692,  692,  692,  692,  692,  692,  692,  692,  692,  692,  692,
+    692,  692,  692,  692,  692,  692,  695,  699,  703,  703,  0,    703,  703,  0,
+    919,  919,
+
+    703,  919,  919,  919,  1123, 1123, 0,    0,    703,  707,  707,  1110, 707,  707,
+    919,  1110, 692,  699,  0,    709,  709,  709,  709,  709,  709,  707,  0,    0,
+    0,    0,    1123, 1123, 703,  709,  0,    709,  0,    1110, 707,  709,  0,    1110,
+    692,  693,  693,  693,  693,  693,  693,  693,  693,  693,  693,  693,  693,  693,
+    693,  693,  703,  693,  693,  693,  693,  693,  693,  707,  710,  710,  710,  710,
+    710,  710,  921,  921,  1012, 921,  921,  0,    921,  1241, 710,  1005, 710,  0,
+    1241, 1257, 710,  1012, 921,  0,    1005, 693,  0,    920,  920,  0,    920,  920,
+    920,  926,
+
+    926,  1012, 926,  926,  0,    1241, 0,    926,  1005, 920,  1241, 1257, 0,    1012,
+    0,    926,  1005, 693,  702,  702,  702,  702,  702,  702,  702,  702,  702,  702,
+    702,  702,  702,  702,  702,  920,  702,  702,  702,  702,  702,  702,  817,  820,
+    829,  820,  817,  921,  829,  820,  1010, 0,    817,  1112, 829,  820,  1118, 1112,
+    829,  1118, 1146, 920,  817,  1146, 829,  820,  1259, 1010, 702,  817,  820,  829,
+    820,  817,  0,    829,  820,  1010, 817,  1112, 829,  820,  1118, 1112, 829,  1118,
+    1146, 0,    817,  1146, 829,  820,  1259, 1010, 702,  704,  704,  704,  704,  704,
+    704,  704,
+
+    704,  704,  704,  704,  704,  704,  1113, 704,  1113, 704,  704,  704,  704,  704,
+    704,  830,  831,  832,  833,  830,  831,  832,  833,  1014, 0,    830,  831,  832,
+    833,  1251, 0,    833,  1113, 831,  1113, 830,  831,  832,  833,  1251, 1014, 704,
+    830,  831,  832,  833,  830,  831,  832,  833,  1014, 830,  831,  832,  833,  0,
+    1251, 833,  0,    831,  0,    830,  831,  832,  833,  1251, 1014, 704,  705,  705,
+    705,  705,  705,  705,  705,  705,  705,  705,  705,  705,  705,  705,  705,  705,
+    705,  705,  705,  705,  705,  705,  834,  835,  838,  839,  834,  835,  838,  839,
+    0,    838,
+
+    834,  835,  838,  839,  1131, 1120, 835,  1120, 1131, 1256, 834,  835,  838,  839,
+    1261, 1256, 705,  834,  835,  838,  839,  834,  835,  838,  839,  838,  834,  835,
+    838,  839,  1131, 1120, 835,  1120, 1131, 1256, 834,  835,  838,  839,  1261, 1256,
+    705,  708,  708,  708,  708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
+    0,    708,  0,    708,  708,  708,  708,  708,  708,  836,  837,  840,  837,  836,
+    841,  840,  837,  836,  841,  1109, 0,    840,  837,  836,  841,  1129, 1137, 1129,
+    1109, 1263, 1137, 840,  837,  836,  841,  708,  836,  837,  840,  837,  836,  841,
+    840,  837,
+
+    836,  841,  1109, 840,  837,  836,  841,  1129, 1137, 1129, 1109, 1263, 1137, 840,
+    837,  836,  841,  708,  711,  711,  711,  711,  711,  711,  711,  711,  0,    711,
+    711,  711,  711,  711,  711,  0,    711,  711,  711,  711,  711,  711,  842,  843,
+    1013, 844,  842,  843,  1108, 844,  0,    842,  842,  843,  844,  844,  1265, 1013,
+    843,  1149, 711,  1108, 842,  843,  1136, 844,  1136, 1149, 0,    842,  843,  1013,
+    844,  842,  843,  1108, 844,  842,  842,  843,  844,  844,  1265, 1013, 843,  1149,
+    711,  1108, 842,  843,  1136, 844,  1136, 1149, 711,  712,  712,  712,  712,  712,
+    712,  712,
+
+    712,  0,    712,  712,  712,  712,  712,  712,  1268, 712,  712,  712,  712,  712,
+    712,  845,  1016, 846,  847,  845,  0,    846,  847,  1114, 0,    845,  846,  846,
+    847,  1143, 0,    847,  712,  1016, 1268, 845,  1114, 846,  847,  1231, 1143, 0,
+    845,  1016, 846,  847,  845,  1231, 846,  847,  1114, 845,  846,  846,  847,  0,
+    1143, 847,  712,  1016, 0,    845,  1114, 846,  847,  1231, 1143, 712,  821,  0,
+    0,    0,    0,    1231, 0,    821,  821,  821,  821,  821,  821,  821,  821,  821,
+    821,  821,  821,  821,  821,  821,  848,  850,  851,  852,  848,  850,  851,  852,
+    1122, 0,
+
+    848,  850,  851,  852,  850,  1138, 1155, 1138, 852,  1155, 848,  850,  851,  852,
+    1270, 1122, 821,  848,  850,  851,  852,  848,  850,  851,  852,  1122, 848,  850,
+    851,  852,  850,  1138, 1155, 1138, 852,  1155, 848,  850,  851,  852,  1270, 1122,
+    821,  822,  822,  0,    822,  822,  822,  822,  822,  822,  822,  822,  822,  822,
+    0,    822,  0,    822,  822,  822,  822,  822,  822,  849,  853,  856,  854,  849,
+    853,  856,  854,  849,  853,  1152, 0,    856,  854,  849,  853,  854,  1151, 1169,
+    1152, 1169, 1151, 856,  854,  849,  853,  822,  849,  853,  856,  854,  849,  853,
+    856,  854,
+
+    849,  853,  1152, 856,  854,  849,  853,  854,  1151, 1169, 1152, 1169, 1151, 856,
+    854,  849,  853,  822,  825,  825,  1273, 825,  825,  825,  825,  825,  825,  825,
+    825,  825,  825,  0,    825,  0,    825,  825,  825,  825,  825,  825,  855,  857,
+    0,    0,    855,  857,  1273, 855,  1124, 0,    855,  857,  1153, 1099, 1099, 1309,
+    1099, 1099, 1099, 1153, 855,  857,  1170, 1311, 1170, 1124, 825,  855,  857,  1099,
+    0,    855,  857,  855,  0,    1124, 855,  857,  1153, 0,    0,    1309, 0,    0,
+    0,    1153, 855,  857,  1170, 1311, 1170, 1124, 825,  826,  826,  826,  826,  826,
+    826,  826,
+
+    826,  826,  826,  826,  826,  826,  826,  826,  826,  826,  826,  826,  826,  826,
+    826,  858,  859,  860,  861,  858,  859,  860,  861,  0,    858,  858,  859,  860,
+    861,  1157, 860,  1243, 861,  1157, 1243, 858,  859,  860,  861,  1313, 1315, 826,
+    858,  859,  860,  861,  858,  859,  860,  861,  858,  858,  859,  860,  861,  1157,
+    860,  1243, 861,  1157, 1243, 858,  859,  860,  861,  1313, 1315, 826,  827,  827,
+    0,    827,  827,  827,  827,  827,  827,  827,  827,  827,  827,  1317, 827,  1167,
+    827,  827,  827,  827,  827,  827,  862,  863,  862,  864,  865,  863,  862,  864,
+    865,  0,
+
+    1167, 863,  862,  864,  865,  1166, 1173, 1317, 1173, 1166, 1167, 863,  862,  864,
+    865,  1318, 827,  862,  863,  862,  864,  865,  863,  862,  864,  865,  1167, 863,
+    862,  864,  865,  1166, 1173, 0,    1173, 1166, 0,    863,  862,  864,  865,  1318,
+    827,  828,  828,  1320, 828,  828,  828,  828,  828,  828,  828,  828,  828,  828,
+    828,  828,  828,  828,  828,  828,  828,  828,  828,  866,  867,  866,  0,    866,
+    867,  1320, 0,    0,    0,    866,  867,  0,    0,    1248, 0,    1248, 1321, 0,
+    0,    866,  867,  0,    1267, 0,    1267, 828,  866,  867,  866,  868,  866,  867,
+    1132, 868,
+
+    869,  866,  867,  868,  869,  1248, 1147, 1248, 1321, 868,  869,  866,  867,  1132,
+    1267, 869,  1267, 828,  0,    868,  869,  1147, 868,  1168, 870,  1132, 868,  869,
+    870,  0,    868,  869,  0,    1147, 870,  868,  869,  1324, 871,  1132, 1168, 869,
+    871,  0,    870,  868,  869,  1147, 871,  0,    1168, 870,  872,  0,    872,  870,
+    872,  0,    871,  0,    870,  0,    872,  1324, 0,    871,  1168, 0,    1247, 871,
+    870,  1235, 872,  0,    871,  1235, 873,  0,    0,    872,  873,  872,  1329, 872,
+    871,  1247, 873,  1161, 872,  874,  875,  0,    0,    874,  875,  1247, 873,  1235,
+    872,  874,
+
+    875,  1235, 1161, 873,  874,  1128, 0,    873,  1329, 874,  875,  1247, 873,  0,
+    1161, 876,  874,  875,  1128, 876,  874,  875,  873,  876,  0,    874,  875,  0,
+    1161, 876,  874,  1312, 1128, 0,    1330, 874,  875,  877,  0,    876,  877,  877,
+    876,  0,    1128, 1312, 876,  877,  1154, 878,  876,  0,    0,    878,  0,    876,
+    0,    877,  1312, 878,  1330, 1154, 879,  0,    877,  876,  879,  877,  877,  878,
+    0,    1312, 879,  877,  881,  1154, 878,  879,  881,  0,    878,  0,    879,  877,
+    881,  878,  880,  1154, 0,    879,  880,  0,    0,    879,  881,  878,  880,  880,
+    879,  1333,
+
+    0,    881,  1252, 879,  1260, 881,  880,  1260, 879,  1252, 881,  882,  0,    880,
+    883,  882,  0,    880,  883,  0,    881,  882,  880,  880,  883,  1333, 882,  1332,
+    1252, 1332, 1260, 882,  880,  1260, 883,  1252, 885,  0,    882,  884,  885,  883,
+    882,  884,  0,    883,  885,  882,  884,  884,  883,  1159, 882,  1332, 1334, 1332,
+    885,  882,  0,    884,  883,  886,  0,    885,  1159, 886,  884,  885,  1255, 887,
+    884,  886,  885,  887,  884,  884,  0,    1255, 1159, 887,  1334, 886,  885,  1105,
+    1105, 884,  1105, 1105, 886,  887,  1159, 1355, 886,  0,    888,  1255, 887,  886,
+    888,  1105,
+
+    887,  1357, 1262, 1255, 888,  887,  889,  886,  888,  0,    889,  0,    0,    1262,
+    888,  887,  889,  1355, 1358, 889,  0,    888,  0,    0,    0,    888,  889,  1357,
+    890,  1262, 888,  1264, 890,  889,  888,  890,  1266, 889,  890,  1262, 888,  1361,
+    889,  1266, 1358, 889,  1264, 0,    890,  891,  891,  892,  889,  892,  891,  890,
+    0,    892,  1264, 890,  891,  890,  1266, 892,  890,  1308, 0,    1361, 0,    1266,
+    891,  0,    1264, 892,  890,  893,  891,  891,  892,  893,  892,  891,  1308, 894,
+    892,  893,  891,  894,  0,    892,  1316, 0,    1308, 894,  1316, 893,  891,  896,
+    0,    892,
+
+    0,    896,  893,  894,  1364, 895,  893,  896,  1308, 895,  894,  893,  0,    1234,
+    894,  895,  1316, 896,  895,  894,  1316, 893,  0,    897,  896,  895,  1234, 897,
+    896,  894,  1364, 897,  895,  896,  1269, 1237, 895,  897,  1322, 1269, 1234, 895,
+    1322, 896,  895,  898,  0,    897,  1237, 898,  897,  895,  1234, 898,  897,  1366,
+    0,    1240, 897,  898,  1269, 0,    1237, 897,  1322, 1269, 0,    899,  1322, 898,
+    1240, 899,  898,  897,  1237, 1242, 898,  899,  0,    900,  898,  1366, 899,  900,
+    1240, 898,  0,    899,  1242, 900,  1368, 0,    900,  1310, 899,  898,  1240, 901,
+    899,  900,
+
+    0,    901,  1242, 899,  1310, 1319, 900,  901,  899,  1354, 900,  1354, 1319, 899,
+    1242, 900,  1368, 901,  900,  903,  1310, 902,  902,  903,  901,  900,  902,  1254,
+    901,  903,  1310, 1319, 902,  901,  1362, 1354, 1369, 1354, 1319, 903,  1254, 0,
+    902,  901,  0,    1362, 903,  904,  902,  902,  903,  904,  0,    902,  1254, 903,
+    1382, 904,  902,  905,  906,  1362, 1369, 905,  906,  903,  1254, 904,  902,  905,
+    906,  1362, 905,  0,    904,  906,  0,    0,    904,  905,  906,  1323, 1382, 904,
+    1258, 0,    905,  906,  1323, 1271, 905,  906,  1356, 904,  1356, 905,  906,  1258,
+    905,  907,
+
+    0,    906,  1271, 907,  1363, 905,  906,  1323, 907,  907,  1383, 1258, 1384, 908,
+    1323, 1363, 1271, 908,  1356, 907,  1356, 908,  0,    1258, 1365, 1365, 907,  908,
+    1271, 909,  907,  1363, 0,    909,  907,  907,  1383, 908,  1384, 909,  908,  1363,
+    910,  0,    908,  907,  910,  0,    908,  909,  1365, 1365, 910,  908,  911,  0,
+    909,  1272, 911,  0,    909,  1386, 910,  908,  911,  909,  0,    1314, 912,  910,
+    1272, 0,    912,  910,  911,  909,  912,  0,    910,  0,    1314, 911,  912,  0,
+    1272, 911,  0,    1386, 910,  1387, 911,  0,    912,  0,    1314, 912,  1272, 913,
+    0,    912,
+
+    911,  913,  0,    912,  1393, 914,  1314, 913,  912,  914,  0,    913,  1325, 914,
+    0,    1387, 1325, 913,  912,  914,  1398, 915,  1326, 0,    913,  915,  0,    0,
+    913,  914,  1393, 915,  914,  913,  1400, 1326, 914,  913,  1325, 0,    914,  915,
+    1325, 913,  0,    914,  1398, 0,    915,  1326, 1100, 1100, 915,  1100, 1100, 914,
+    1100, 915,  0,    0,    1400, 1326, 0,    0,    0,    0,    1100, 915,  917,  917,
+    917,  917,  917,  917,  917,  917,  917,  917,  917,  917,  917,  917,  917,  917,
+    917,  917,  917,  917,  917,  917,  0,    924,  924,  924,  924,  924,  924,  924,
+    0,    1327,
+
+    0,    0,    923,  923,  0,    923,  923,  924,  923,  1367, 1367, 924,  1327, 0,
+    0,    0,    917,  1024, 923,  1024, 1024, 1024, 1024, 1024, 1227, 1227, 1327, 1227,
+    1227, 0,    1227, 923,  0,    0,    0,    1367, 1367, 1024, 1327, 0,    1227, 0,
+    917,  918,  918,  918,  918,  918,  918,  918,  918,  918,  918,  918,  918,  918,
+    0,    918,  923,  918,  918,  918,  918,  918,  918,  928,  928,  1020, 928,  928,
+    0,    1020, 1228, 1228, 1359, 1228, 1228, 1020, 1228, 0,    1385, 928,  1020, 1385,
+    0,    0,    0,    1020, 1228, 1359, 1024, 918,  0,    0,    1020, 0,    0,    1227,
+    1020, 0,
+
+    0,    1359, 0,    1020, 0,    928,  1385, 0,    1020, 1385, 0,    0,    0,    1020,
+    0,    1359, 0,    918,  925,  925,  925,  925,  925,  925,  925,  925,  925,  925,
+    925,  925,  925,  928,  925,  0,    925,  925,  925,  925,  925,  925,  1028, 1029,
+    1030, 1032, 1028, 1029, 1030, 1032, 0,    1331, 1028, 1029, 1030, 1032, 0,    1392,
+    1331, 1360, 1392, 0,    1028, 1029, 1030, 1032, 1360, 0,    925,  1028, 1029, 1030,
+    1032, 1028, 1029, 1030, 1032, 1331, 1028, 1029, 1030, 1032, 0,    1392, 1331, 1360,
+    1392, 0,    1028, 1029, 1030, 1032, 1360, 0,    925,  927,  927,  927,  927,  927,
+    927,  927,
+
+    927,  927,  927,  927,  927,  927,  927,  927,  927,  927,  927,  927,  927,  927,
+    927,  1031, 1328, 1033, 1034, 1031, 0,    1033, 1034, 0,    1031, 1031, 1033, 1033,
+    1034, 1328, 1380, 0,    1394, 1034, 0,    1031, 1394, 1033, 1034, 1380, 0,    927,
+    1031, 1328, 1033, 1034, 1031, 0,    1033, 1034, 1031, 1031, 1033, 1033, 1034, 1328,
+    0,    1380, 1394, 1034, 0,    1031, 1394, 1033, 1034, 1380, 0,    927,  929,  929,
+    929,  929,  929,  929,  929,  929,  929,  929,  929,  929,  929,  0,    929,  0,
+    929,  929,  929,  929,  929,  929,  1035, 1036, 1037, 1038, 1035, 1036, 1037, 1038,
+    1381, 0,
+
+    1035, 1036, 1037, 1038, 1036, 1397, 0,    0,    1381, 1397, 1035, 1036, 1037, 1038,
+    0,    0,    929,  1035, 1036, 1037, 1038, 1035, 1036, 1037, 1038, 1381, 1035, 1036,
+    1037, 1038, 1036, 1397, 0,    0,    1381, 1397, 1035, 1036, 1037, 1038, 0,    0,
+    929,  930,  930,  930,  930,  930,  930,  930,  930,  930,  930,  930,  930,  930,
+    930,  930,  930,  930,  930,  930,  930,  930,  930,  1039, 1040, 1041, 1042, 1039,
+    1040, 1041, 1042, 0,    0,    1039, 1040, 1041, 1042, 0,    0,    1039, 1041, 0,
+    0,    1039, 1040, 1041, 1042, 0,    0,    930,  1039, 1040, 1041, 1042, 1039, 1040,
+    1041, 1042,
+
+    0,    1039, 1040, 1041, 1042, 0,    0,    1039, 1041, 0,    0,    1039, 1040, 1041,
+    1042, 0,    0,    930,  1021, 1021, 0,    1021, 1021, 1021, 1021, 1021, 1021, 1021,
+    1021, 1021, 1021, 0,    1021, 0,    1021, 1021, 1021, 1021, 1021, 1021, 1043, 1044,
+    1046, 1047, 1043, 1044, 1046, 1047, 1043, 0,    1046, 1044, 1046, 1047, 1043, 1044,
+    1047, 0,    0,    0,    0,    1044, 1046, 1047, 1043, 0,    1021, 1043, 1044, 1046,
+    1047, 1043, 1044, 1046, 1047, 1043, 1046, 1044, 1046, 1047, 1043, 1044, 1047, 0,
+    0,    0,    0,    1044, 1046, 1047, 1043, 0,    1021, 1022, 1022, 0,    1022, 1022,
+    1022, 1022,
+
+    1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+    1022, 1045, 1049, 1050, 1048, 1045, 1049, 1050, 1048, 1045, 0,    1048, 1049, 1050,
+    1048, 1045, 0,    0,    1050, 0,    0,    0,    1049, 1050, 1048, 1045, 0,    1022,
+    1045, 1049, 1050, 1048, 1045, 1049, 1050, 1048, 1045, 1048, 1049, 1050, 1048, 1045,
+    0,    0,    1050, 0,    0,    0,    1049, 1050, 1048, 1045, 0,    1022, 1025, 1025,
+    0,    1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 0,    1025, 0,
+    1025, 1025, 1025, 1025, 1025, 1025, 1051, 1053, 1052, 1053, 1051, 0,    1052, 1053,
+    0,    0,
+
+    1051, 1052, 1052, 1053, 0,    0,    0,    0,    0,    0,    1051, 0,    1052, 1053,
+    0,    0,    1025, 1051, 1053, 1052, 1053, 1051, 0,    1052, 1053, 0,    1051, 1052,
+    1052, 1053, 0,    0,    0,    0,    0,    0,    1051, 0,    1052, 1053, 0,    0,
+    1025, 1026, 1026, 0,    1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026,
+    1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1054, 1055, 1056, 1057, 1054,
+    1055, 1056, 1057, 0,    0,    1054, 1055, 1056, 1057, 0,    0,    0,    0,    1057,
+    0,    1054, 1055, 1056, 1057, 0,    0,    1026, 1054, 1055, 1056, 1057, 1054, 1055,
+    1056, 1057,
+
+    0,    1054, 1055, 1056, 1057, 0,    0,    0,    0,    1057, 0,    1054, 1055, 1056,
+    1057, 0,    0,    1026, 1027, 1027, 0,    1027, 1027, 1027, 1027, 1027, 1027, 1027,
+    1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 1058, 1059,
+    0,    1060, 1058, 1059, 0,    1060, 0,    1058, 1058, 1059, 1059, 1060, 0,    0,
+    1060, 0,    0,    0,    1058, 1059, 0,    1060, 0,    0,    1027, 1058, 1059, 0,
+    1060, 1058, 1059, 0,    1060, 1058, 1058, 1059, 1059, 1060, 1061, 1062, 1060, 0,
+    1061, 1062, 1058, 1059, 0,    1060, 1061, 1062, 1027, 1063, 1064, 0,    1064, 1063,
+    1064, 0,
+
+    1061, 1062, 0,    1063, 1064, 0,    1063, 1061, 1062, 0,    0,    1061, 1062, 1063,
+    1064, 0,    1061, 1062, 1065, 0,    1063, 1064, 1065, 1064, 1063, 1064, 1061, 1062,
+    1065, 1063, 1064, 1066, 1063, 0,    0,    1066, 0,    0,    1065, 1063, 1064, 1066,
+    0,    0,    1066, 1065, 0,    0,    0,    1065, 0,    1066, 0,    1067, 1065, 0,
+    0,    1067, 1066, 1068, 0,    1068, 1066, 1067, 1065, 1068, 0,    1066, 0,    0,
+    1066, 1068, 0,    1067, 0,    1069, 0,    1066, 0,    1069, 1067, 1068, 0,    1070,
+    1067, 1069, 1068, 1070, 1068, 1067, 0,    0,    1068, 1070, 0,    1069, 0,    1068,
+    0,    1067,
+
+    0,    0,    1069, 1070, 1070, 1071, 1069, 1068, 1072, 1071, 1070, 1069, 1072, 0,
+    1070, 1071, 0,    1072, 1072, 1070, 0,    1069, 0,    0,    0,    1071, 0,    0,
+    1072, 1070, 1070, 0,    1071, 0,    0,    1072, 1071, 0,    1073, 1072, 0,    1071,
+    1073, 1072, 1072, 0,    1074, 0,    1073, 0,    1074, 1071, 0,    0,    1072, 0,
+    1074, 0,    1073, 0,    1075, 0,    0,    0,    1075, 1073, 1074, 0,    0,    1073,
+    1075, 0,    0,    1074, 1073, 0,    0,    1074, 0,    0,    1075, 0,    1074, 0,
+    1073, 1076, 0,    1075, 0,    1076, 0,    1075, 1074, 1077, 0,    1076, 1075, 1077,
+    0,    0,
+
+    0,    1076, 0,    1077, 0,    1076, 1075, 0,    0,    0,    0,    0,    1076, 1077,
+    0,    0,    1076, 0,    1079, 0,    1077, 1076, 1079, 0,    1077, 0,    1078, 1076,
+    1079, 1077, 1078, 1076, 0,    0,    0,    1078, 1078, 0,    1079, 1077, 1080, 0,
+    0,    0,    1080, 1079, 1078, 0,    1081, 1079, 1080, 0,    1081, 1078, 1079, 0,
+    0,    1078, 1081, 0,    1080, 1078, 1078, 0,    1079, 0,    0,    1080, 1081, 0,
+    1083, 1080, 1078, 0,    1083, 1081, 1080, 0,    0,    1081, 1083, 1082, 0,    1082,
+    1081, 0,    1080, 1082, 0,    0,    1083, 0,    0,    1082, 1081, 1084, 0,    1083,
+    0,    1084,
+
+    0,    1083, 0,    1082, 0,    1084, 1083, 1085, 1082, 0,    1082, 1085, 0,    0,
+    1082, 1084, 1083, 1085, 0,    1082, 1086, 0,    1084, 0,    1086, 0,    1084, 1085,
+    0,    1082, 1086, 1084, 0,    0,    1085, 0,    0,    0,    1085, 0,    1086, 1084,
+    0,    1085, 1088, 1087, 0,    1086, 1088, 1087, 0,    1086, 1088, 1085, 1087, 1087,
+    1086, 0,    1088, 0,    0,    0,    0,    0,    0,    1087, 1086, 0,    1088, 1089,
+    0,    1088, 1087, 1089, 0,    1088, 1087, 1089, 0,    1088, 1087, 1087, 0,    1089,
+    1088, 0,    0,    0,    0,    0,    0,    1087, 0,    1089, 1088, 1090, 1089, 1091,
+    1092, 1090,
+
+    1089, 1091, 1092, 0,    1089, 1090, 0,    1091, 1092, 1089, 1090, 0,    1091, 0,
+    0,    1090, 0,    1091, 1092, 1089, 0,    0,    1090, 0,    1091, 1092, 1090, 0,
+    1091, 1092, 0,    1090, 0,    1091, 1092, 1093, 1090, 0,    1091, 1093, 0,    1090,
+    0,    1091, 1092, 1093, 0,    1095, 1094, 0,    0,    1095, 1094, 0,    0,    1093,
+    0,    1095, 1094, 0,    1096, 0,    1093, 1094, 1096, 0,    1093, 1095, 1094, 0,
+    1096, 1093, 0,    1096, 1095, 1094, 0,    0,    1095, 1094, 1096, 1093, 0,    1095,
+    1094, 0,    0,    1096, 0,    1094, 0,    1096, 0,    1095, 1094, 0,    1096, 0,
+    0,    1096,
+
+    1275, 0,    1275, 1275, 1275, 1275, 1096, 1097, 1097, 1097, 1097, 1097, 1097, 1097,
+    1097, 1097, 1097, 1097, 1097, 1097, 1275, 1097, 0,    1097, 1097, 1097, 1097, 1097,
+    1097, 0,    0,    0,    0,    1182, 0,    0,    0,    1182, 1101, 1101, 0,    1101,
+    1101, 1182, 1101, 1102, 1102, 1102, 1102, 1102, 1102, 1102, 0,    1182, 1101, 1097,
+    0,    0,    0,    0,    1182, 1102, 0,    0,    1182, 1102, 0,    0,    0,    1182,
+    0,    0,    0,    0,    0,    0,    0,    0,    1101, 1182, 0,    1097, 1098, 1098,
+    1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098, 1098,
+    1098, 1098,
+
+    1098, 1098, 1098, 1098, 1101, 1183, 0,    1184, 0,    1183, 0,    1184, 0,    0,
+    0,    1183, 0,    1184, 1102, 1276, 0,    1276, 1276, 1276, 1276, 1183, 1183, 1184,
+    0,    0,    1098, 0,    1183, 0,    1184, 1276, 1183, 0,    1184, 1276, 0,    1183,
+    0,    1184, 0,    0,    0,    0,    0,    0,    0,    1183, 1183, 1184, 0,    0,
+    1098, 1103, 1103, 1103, 1103, 1103, 1103, 1103, 1103, 1103, 1103, 1103, 1103, 1103,
+    0,    1103, 0,    1103, 1103, 1103, 1103, 1103, 1103, 1185, 1186, 0,    1187, 1185,
+    1186, 0,    1187, 0,    0,    1185, 1186, 1187, 1187, 0,    0,    0,    0,    0,
+    0,    1185,
+
+    1186, 0,    1187, 0,    0,    1103, 1185, 1186, 0,    1187, 1185, 1186, 0,    1187,
+    0,    1185, 1186, 1187, 1187, 0,    0,    0,    0,    0,    0,    1185, 1186, 0,
+    1187, 0,    0,    1103, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104,
+    1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1104, 1188, 1189,
+    1190, 1191, 1188, 1189, 1190, 1191, 0,    0,    1188, 1189, 1190, 1191, 0,    0,
+    1191, 0,    0,    0,    1188, 1189, 1190, 1191, 0,    0,    1104, 1188, 1189, 1190,
+    1191, 1188, 1189, 1190, 1191, 0,    1188, 1189, 1190, 1191, 0,    0,    1191, 0,
+    0,    0,
+
+    1188, 1189, 1190, 1191, 0,    0,    1104, 1106, 1106, 1106, 1106, 1106, 1106, 1106,
+    1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106,
+    1106, 1192, 1193, 1194, 1195, 1192, 1193, 1194, 1195, 0,    1193, 1192, 1193, 1194,
+    1195, 0,    0,    0,    0,    0,    1195, 1192, 1193, 1194, 1195, 0,    0,    1106,
+    1192, 1193, 1194, 1195, 1192, 1193, 1194, 1195, 1193, 1192, 1193, 1194, 1195, 0,
+    0,    0,    0,    0,    1195, 1192, 1193, 1194, 1195, 0,    0,    1106, 1178, 1178,
+    0,    1178, 1178, 1178, 1178, 1178, 0,    1178, 1178, 1178, 1178, 1178, 1178, 0,
+    1178, 1178,
+
+    1178, 1178, 1178, 1178, 1196, 1197, 1198, 1200, 1196, 1197, 1198, 1200, 0,    0,
+    1196, 1197, 1198, 1200, 0,    0,    0,    0,    1200, 0,    1196, 1197, 1198, 1200,
+    0,    0,    0,    1196, 1197, 1198, 1200, 1196, 1197, 1198, 1200, 0,    1196, 1197,
+    1198, 1200, 0,    0,    0,    0,    1200, 0,    1196, 1197, 1198, 1200, 0,    0,
+    1178, 1179, 1179, 0,    1179, 1179, 1179, 1179, 1179, 1179, 1179, 1179, 1179, 1179,
+    1179, 1179, 1179, 1179, 1179, 1179, 1179, 1179, 1179, 1199, 1201, 1202, 1204, 1199,
+    1201, 1202, 1204, 1199, 0,    0,    1201, 1202, 1204, 1199, 0,    0,    0,    0,
+    0,    0,
+
+    1201, 1202, 1204, 1199, 0,    1179, 1199, 1201, 1202, 1204, 1199, 1201, 1202, 1204,
+    1199, 0,    1201, 1202, 1204, 1199, 0,    0,    0,    0,    0,    0,    1201, 1202,
+    1204, 1199, 0,    1179, 1181, 1181, 0,    1181, 1181, 1181, 1181, 1181, 1181, 1181,
+    1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1203, 1205,
+    1206, 1203, 1203, 1205, 1206, 0,    0,    0,    1203, 1205, 1206, 0,    1207, 0,
+    0,    0,    1207, 0,    1203, 1205, 1206, 0,    1207, 0,    1181, 1203, 1205, 1206,
+    1203, 1203, 1205, 1206, 1207, 0,    1203, 1205, 1206, 0,    0,    1207, 0,    0,
+    0,    1207,
+
+    1203, 1205, 1206, 1208, 1207, 0,    1181, 1208, 0,    0,    1208, 1209, 0,    1208,
+    1207, 1209, 0,    0,    0,    0,    0,    1209, 0,    1208, 0,    1210, 0,    0,
+    0,    1210, 1208, 1209, 0,    1211, 1208, 1210, 1208, 1211, 1209, 1208, 0,    0,
+    1209, 1211, 0,    1210, 0,    1209, 0,    1208, 0,    0,    1210, 1211, 0,    1212,
+    1210, 1209, 1213, 1212, 1211, 1210, 1213, 0,    1211, 1212, 0,    0,    1213, 1211,
+    0,    1210, 0,    0,    0,    1212, 0,    0,    1213, 1211, 0,    0,    1212, 0,
+    0,    1213, 1212, 0,    1214, 1213, 1214, 1212, 1214, 0,    1213, 0,    1215, 0,
+    1214, 0,
+
+    1215, 1212, 0,    0,    1213, 0,    1215, 0,    1214, 1215, 0,    0,    0,    0,
+    0,    1214, 1215, 1214, 0,    1214, 0,    0,    0,    1215, 1214, 0,    0,    1215,
+    0,    0,    0,    1216, 1215, 1216, 1214, 1215, 1217, 1216, 0,    0,    1217, 0,
+    1215, 1216, 0,    1335, 1217, 1335, 1335, 1335, 1335, 0,    0,    1216, 0,    0,
+    1217, 0,    1216, 0,    1216, 1335, 0,    1217, 1216, 1335, 0,    1217, 0,    1216,
+    1218, 0,    1217, 1219, 1218, 0,    1218, 1219, 0,    1216, 1218, 0,    1217, 1219,
+    0,    0,    0,    0,    1219, 0,    1218, 0,    0,    1219, 0,    1220, 0,    1218,
+    0,    1220,
+
+    1219, 1218, 1218, 0,    1219, 1220, 1218, 0,    1220, 1219, 0,    0,    0,    1221,
+    1219, 1220, 1218, 1221, 0,    1219, 0,    1221, 1220, 1221, 0,    1222, 1220, 0,
+    0,    1222, 0,    1220, 0,    1221, 1220, 1222, 0,    0,    1223, 0,    1221, 1220,
+    1223, 0,    1221, 1222, 0,    1221, 1223, 1221, 1224, 0,    1222, 0,    1224, 0,
+    1222, 0,    1223, 1221, 1224, 1222, 1225, 0,    0,    1223, 1225, 0,    0,    1223,
+    1224, 1222, 1225, 0,    1223, 0,    0,    1224, 0,    0,    0,    1224, 1225, 0,
+    1223, 0,    1224, 0,    0,    1225, 0,    0,    0,    1225, 0,    0,    1224, 0,
+    1225, 0,
+
+    0,    0,    0,    0,    0,    0,    0,    0,    1225, 1226, 1226, 1226, 1226, 1226,
+    1226, 1226, 1226, 1226, 1226, 1226, 1226, 1226, 1226, 1226, 1226, 1226, 1226, 1226,
+    1226, 1226, 1226, 1281, 1283, 1282, 1283, 1281, 1283, 1282, 0,    1281, 0,    0,
+    1283, 1282, 0,    1281, 1282, 0,    0,    0,    0,    0,    1283, 1282, 0,    1281,
+    0,    1226, 1281, 1283, 1282, 1283, 1281, 1283, 1282, 0,    1281, 0,    1283, 1282,
+    0,    1281, 1282, 0,    0,    0,    0,    0,    1283, 1282, 0,    1281, 0,    1226,
+    1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229,
+    1229, 1229,
+
+    1229, 1229, 1229, 1229, 1229, 1229, 1284, 1285, 1285, 1286, 1284, 0,    1285, 1286,
+    0,    0,    1284, 0,    1285, 1286, 0,    0,    0,    0,    0,    0,    1284, 0,
+    1285, 1286, 0,    0,    1229, 1284, 1285, 1285, 1286, 1284, 0,    1285, 1286, 0,
+    1284, 0,    1285, 1286, 0,    0,    0,    0,    0,    0,    1284, 0,    1285, 1286,
+    0,    0,    1229, 1278, 1278, 0,    1278, 1278, 1278, 1278, 1278, 0,    1278, 1278,
+    1278, 1278, 1278, 1278, 0,    1278, 1278, 1278, 1278, 1278, 1278, 1287, 1288, 0,
+    1289, 1287, 1288, 0,    1289, 0,    0,    1287, 1288, 1289, 1289, 0,    0,    0,
+    0,    0,
+
+    0,    1287, 1288, 0,    1289, 0,    0,    0,    1287, 1288, 0,    1289, 1287, 1288,
+    0,    1289, 0,    1287, 1288, 1289, 1289, 0,    0,    0,    0,    0,    0,    1287,
+    1288, 0,    1289, 0,    0,    1278, 1279, 1279, 0,    1279, 1279, 1279, 1279, 1279,
+    0,    1279, 1279, 1279, 1279, 0,    1279, 0,    1279, 1279, 1279, 1279, 1279, 1279,
+    1290, 1291, 1292, 0,    1290, 1291, 1292, 0,    0,    0,    1290, 1291, 1292, 1290,
+    0,    0,    0,    0,    0,    0,    1290, 1291, 1292, 0,    0,    0,    0,    1290,
+    1291, 1292, 0,    1290, 1291, 1292, 0,    0,    1290, 1291, 1292, 1290, 0,    0,
+    0,    0,
+
+    0,    0,    1290, 1291, 1292, 0,    0,    0,    1279, 1280, 1280, 0,    1280, 1280,
+    1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 0,    1280, 1280, 1280,
+    1280, 1280, 1280, 1293, 1294, 0,    1295, 1293, 1294, 0,    1295, 0,    0,    1293,
+    1294, 1295, 1295, 0,    0,    0,    0,    0,    0,    1293, 1294, 0,    1295, 0,
+    0,    1280, 1293, 1294, 0,    1295, 1293, 1294, 0,    1295, 0,    1293, 1294, 1295,
+    1295, 1296, 1297, 0,    0,    1296, 1297, 1293, 1294, 0,    1295, 1296, 1297, 1280,
+    1298, 1299, 0,    0,    1298, 1299, 0,    1296, 1297, 1298, 1298, 1299, 0,    0,
+    1296, 1297,
+
+    0,    0,    1296, 1297, 1298, 1299, 0,    1296, 1297, 0,    0,    1298, 1299, 0,
+    0,    1298, 1299, 1296, 1297, 1298, 1298, 1299, 1300, 1301, 1302, 1303, 1300, 1301,
+    1302, 1303, 1298, 1299, 1300, 1301, 1302, 1303, 0,    0,    0,    0,    0,    0,
+    1300, 1301, 1302, 1303, 0,    0,    0,    1300, 1301, 1302, 1303, 1300, 1301, 1302,
+    1303, 0,    1300, 1301, 1302, 1303, 1304, 1305, 0,    0,    1304, 1305, 1300, 1301,
+    1302, 1303, 1304, 1305, 1305, 1306, 1307, 0,    0,    1306, 1307, 0,    1304, 1305,
+    0,    1306, 1307, 0,    0,    1304, 1305, 0,    0,    1304, 1305, 1306, 1307, 0,
+    1304, 1305,
+
+    1305, 0,    1306, 1307, 0,    0,    1306, 1307, 1304, 1305, 0,    1306, 1307, 0,
+    0,    0,    0,    0,    0,    0,    0,    1306, 1307, 1337, 1337, 0,    1337, 1337,
+    1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 0,    1337, 0,    1337, 1337, 1337,
+    1337, 1337, 1337, 1338, 1339, 1340, 1341, 1338, 1339, 1340, 1341, 0,    0,    1338,
+    1339, 1340, 1341, 0,    1338, 0,    1340, 0,    0,    1338, 1339, 1340, 1341, 0,
+    0,    1337, 1338, 1339, 1340, 1341, 1338, 1339, 1340, 1341, 0,    1338, 1339, 1340,
+    1341, 1342, 1338, 0,    1340, 1342, 0,    1338, 1339, 1340, 1341, 1342, 1343, 1337,
+    1343, 1344,
+
+    0,    0,    1343, 1344, 0,    1342, 0,    0,    1343, 1344, 0,    0,    1342, 0,
+    0,    0,    1342, 0,    1343, 1344, 0,    1342, 0,    1343, 0,    1343, 1344, 0,
+    1345, 1343, 1344, 1342, 1345, 0,    1343, 1344, 0,    0,    1345, 0,    0,    0,
+    0,    0,    1343, 1344, 0,    0,    1345, 0,    1346, 0,    1346, 0,    1346, 1345,
+    0,    0,    0,    1345, 1346, 0,    1348, 1347, 1345, 1347, 1348, 1347, 0,    0,
+    1346, 0,    1348, 1347, 1345, 0,    0,    1346, 0,    1346, 0,    1346, 1348, 1347,
+    0,    0,    1346, 1349, 0,    1348, 1347, 1349, 1347, 1348, 1347, 0,    1346, 1349,
+    1348, 1347,
+
+    0,    1349, 0,    0,    0,    0,    0,    1349, 1348, 1347, 0,    1350, 1351, 0,
+    1349, 1350, 1351, 0,    1349, 0,    0,    1350, 1351, 1349, 1352, 0,    1351, 1349,
+    1352, 0,    0,    1350, 1351, 1349, 1352, 0,    1353, 0,    1350, 1351, 1353, 0,
+    1350, 1351, 1352, 0,    1353, 1350, 1351, 0,    0,    1352, 1351, 0,    0,    1352,
+    1353, 1350, 1351, 0,    1352, 0,    0,    1353, 0,    0,    0,    1353, 0,    0,
+    1352, 0,    1353, 0,    0,    0,    0,    0,    0,    0,    0,    0,    1353, 1370,
+    1370, 0,    1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 0,    1370,
+    0,    1370,
+
+    1370, 1370, 1370, 1370, 1370, 1372, 0,    1373, 1374, 1372, 1373, 1373, 1374, 0,
+    0,    1372, 0,    1373, 1374, 0,    0,    0,    0,    0,    0,    1372, 0,    1373,
+    1374, 0,    0,    1370, 1372, 0,    1373, 1374, 1372, 1373, 1373, 1374, 0,    1372,
+    0,    1373, 1374, 0,    0,    0,    0,    0,    0,    1372, 0,    1373, 1374, 0,
+    0,    1370, 1371, 1371, 0,    1371, 1371, 1371, 1371, 1371, 1371, 1371, 1371, 1371,
+    1371, 1371, 1371, 1371, 1371, 1371, 1371, 1371, 1371, 1371, 1375, 1376, 1377, 1378,
+    1375, 1376, 1377, 1378, 0,    0,    1375, 1376, 1377, 1378, 0,    0,    0,    0,
+    0,    0,
+
+    1375, 1376, 1377, 1378, 0,    0,    1371, 1375, 1376, 1377, 1378, 1375, 1376, 1377,
+    1378, 0,    1375, 1376, 1377, 1378, 1379, 0,    0,    0,    1379, 0,    1375, 1376,
+    1377, 1378, 1379, 0,    1371, 0,    0,    0,    0,    0,    0,    0,    1379, 0,
+    0,    0,    0,    0,    0,    1379, 0,    0,    0,    1379, 0,    0,    0,    0,
+    1379, 0,    0,    0,    0,    0,    0,    0,    0,    0,    1379, 1388, 1388, 0,
+    1388, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1388,
+    1388, 1388, 1388, 1388, 1388, 1389, 1390, 0,    1391, 1389, 1390, 0,    1391, 0,
+    0,    1389,
+
+    1390, 1391, 1391, 0,    0,    0,    0,    0,    0,    1389, 1390, 0,    1391, 0,
+    0,    1388, 1389, 1390, 0,    1391, 1389, 1390, 0,    1391, 0,    1389, 1390, 1391,
+    1391, 0,    1395, 0,    0,    1396, 1395, 1389, 1390, 1396, 1391, 1395, 1395, 1388,
+    0,    1396, 0,    0,    0,    0,    0,    0,    1395, 0,    0,    1396, 0,    0,
+    0,    1395, 1399, 0,    1396, 1395, 1399, 0,    1396, 1395, 1395, 0,    1399, 1396,
+    0,    0,    0,    0,    0,    0,    1395, 0,    1399, 1396, 0,    0,    0,    0,
+    0,    1399, 0,    0,    0,    1399, 0,    0,    0,    0,    1399, 0,    0,    0,
+    0,    0,
+
+    0,    0,    0,    0,    1399, 1403, 1403, 1403, 1404, 1404, 1404, 1406, 1406, 1406,
+    1407, 1407, 1407, 1408, 1408, 1408, 1409, 1409, 1409, 1410, 1410, 1410, 1412, 1412,
+    1413, 1413, 1413, 1414, 1414, 1414, 1415, 1415, 1418, 1418, 1418, 1419, 1419, 1419,
+    1420, 1420, 1420, 1421, 1421, 1421, 1422, 1422, 1422, 1423, 1423, 1423, 1424, 1424,
+    1424, 1425, 1425, 1425, 1426, 1426, 1426, 1427, 1427, 1427, 1429, 1429, 1430, 1430,
+    1431, 1431, 1431, 1432, 1432, 1433, 1433, 1435, 1435, 1435, 1436, 1436, 1436, 1437,
+    1437, 1437, 1438, 1438, 1438, 1439, 1439, 1439, 1440, 1440, 1440, 1442, 1442, 1443,
+    1443, 1444,
+
+    1444, 1445, 1445, 1446, 1446, 1446, 1447, 1447, 1447, 1448, 1448, 1449, 1449, 1449,
+    1450, 1450, 1450, 1451, 1451, 1451, 1452, 1452, 1452, 1453, 1453, 1453, 1454, 1454,
+    1454, 1455, 1455, 1455, 1456, 1456, 1456, 1457, 1457, 1457, 1458, 1458, 1458, 1459,
+    1459, 1459, 1460, 1460, 1460, 1461, 1461, 1461, 1462, 1462, 1462, 1464, 1464, 1465,
+    1465, 1466, 1466, 1467, 1467, 1468, 1468, 1468, 1469, 1469, 1470, 1470, 1471, 1471,
+    1471, 1472, 1472, 1472, 1473, 1473, 1473, 1474, 1474, 1474, 1475, 1475, 1476, 1476,
+    1477, 1477, 1477, 1478, 1478, 1478, 1479, 1479, 1480, 1480, 1481, 1481, 1482, 1482,
+    1483, 1483,
+
+    1484, 1484, 1485, 1485, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401,
+    1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401, 1401};
+
+/* Table of booleans, true if rule could match eol. */
+static const flex_int32_t yy_rule_can_match_eol[168] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
+};
+
+static const flex_int16_t yy_rule_linenum[167] = {
+    0,   29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
+    45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,
+    62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,
+    79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
+    96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
+    113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,
+
+    129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,
+    146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162,
+    163, 164, 168, 169, 170, 171, 172, 173, 175, 177, 180, 183, 189, 192, 195, 199, 200,
+    201, 214, 215, 216, 219, 228, 243, 258, 269, 317, 319, 370, 377, 379, 382};
+
+#define REJECT                                                       \
+  {                                                                  \
+    *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
+    yy_cp = (yy_full_match); /* restore poss. backed-over text */    \
+    ++(yy_lp);                                                       \
+    goto find_rule;                                                  \
+  }
+
+#define yymore() ((yy_more_flag) = 1)
+#define YY_MORE_ADJ (yy_more_len)
+#define YY_RESTORE_YY_MORE_OFFSET
+
+#undef yyFlexLexer
+#include <boost/algorithm/string/trim.hpp>
+#include <cstdint>
+#include <cstdio>
+#include "../Shared/sqldefs.h"
+#include "parser.h"
+
+#define yylval (dynamic_cast<SQLLexer*>(this)->yylval)
+#define parsed_str_tokens_ (dynamic_cast<SQLLexer*>(this)->parsed_str_tokens_)
+
+using namespace std;
+
+/* macro to save the text and return a token */
+#define TOK(name) \
+  { return SQLParser::name; }
+
+#define INITIAL 0
+#define STATE_CREATE 1
+#define STATE_CREATE_AS 2
+#define STATE_INSERT 3
+#define STATE_INSERT_INTO 4
+
+//#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+//#include <unistd.h>
+/* %endif */
+//#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void*
+#endif
+
+/* %if-c-only Reentrant structure and macros (non-C++). */
+/* %if-reentrant */
+/* %if-c-only */
+/* %endif */
+/* %if-reentrant */
+/* %endif */
+/* %endif End reentrant structures and macros. */
+/* %if-bison-bridge */
+/* %endif */
+/* %not-for-header */
+/* %ok-for-header */
+
+/* %endif */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy(char*, const char*, int);
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen(const char*);
+#endif
+
+#ifndef YY_NO_INPUT
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+/* %ok-for-header */
+
+/* %endif */
+#endif
+
+/* %if-c-only */
+/* %endif */
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* %if-c-only Standard (non-C++) definition */
+/* %endif */
+/* %if-c++-only C++ definition */
+#define ECHO LexerOutput(yytext, yyleng)
+/* %endif */
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf, result, max_size)                                                \
+  /* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ \
+   */                                                                                  \
+                                                                                       \
+  /* %if-c++-only C++ definition \ */                                                  \
+  if ((int)(result = LexerInput((char*)buf, max_size)) < 0)                            \
+    YY_FATAL_ERROR("input in flex scanner failed");
+/* %endif */
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+#define YY_FATAL_ERROR(msg) LexerError(msg)
+/* %endif */
+#endif
+
+/* %if-tables-serialization structures and prototypes */
+/* %not-for-header */
+/* %ok-for-header */
+
+/* %not-for-header */
+/* %tables-yydmap generated elements */
+/* %endif */
+/* end tables serialization structures and prototypes */
+
+/* %ok-for-header */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+/* %if-c-only Standard (non-C++) definition */
+/* %endif */
+/* %if-c++-only C++ definition */
+#define YY_DECL int yyFlexLexer::yylex()
+/* %endif */
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK /*LINTED*/ break;
+#endif
+
+/* %% [6.0] YY_RULE_SETUP definition goes here */
+#define YY_RULE_SETUP YY_USER_ACTION
+
+/* %not-for-header */
+/** The main scanner function which does all the work.
+ */
+YY_DECL {
+  yy_state_type yy_current_state;
+  char *yy_cp, *yy_bp;
+  int yy_act;
+
+  if (!(yy_init)) {
+    (yy_init) = 1;
+
+#ifdef YY_USER_INIT
+    YY_USER_INIT;
+#endif
+
+    /* Create the reject buffer large enough to save one state per allowed character. */
+    if (!(yy_state_buf))
+      (yy_state_buf) = (yy_state_type*)yyalloc(YY_STATE_BUF_SIZE);
+    if (!(yy_state_buf))
+      YY_FATAL_ERROR("out of dynamic memory in yylex()");
+
+    if (!(yy_start))
+      (yy_start) = 1; /* first start state */
+
+    if (!yyin)
+      /* %if-c-only */
+      /* %endif */
+      /* %if-c++-only */
+      yyin.rdbuf(std::cin.rdbuf());
+    /* %endif */
+
+    if (!yyout)
+      /* %if-c-only */
+      /* %endif */
+      /* %if-c++-only */
+      yyout.rdbuf(std::cout.rdbuf());
+    /* %endif */
+
+    if (!YY_CURRENT_BUFFER) {
+      yyensure_buffer_stack();
+      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
+    }
+
+    yy_load_buffer_state();
+  }
+
+  {
+    /* %% [7.0] user's declarations go here */
+
+    /* literal keyword tokens */
+
+    while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
+    {
+      /* %% [8.0] yymore()-related code goes here */
+      (yy_more_len) = 0;
+      if ((yy_more_flag)) {
+        (yy_more_len) = (int)((yy_c_buf_p) - (yytext_ptr));
+        (yy_more_flag) = 0;
+      }
+      yy_cp = (yy_c_buf_p);
+
+      /* Support of yytext. */
+      *yy_cp = (yy_hold_char);
+
+      /* yy_bp points to the position in yy_ch_buf of the start of
+       * the current run.
+       */
+      yy_bp = yy_cp;
+
+      /* %% [9.0] code to set up and find next match goes here */
+      yy_current_state = (yy_start);
+
+      (yy_state_ptr) = (yy_state_buf);
+      *(yy_state_ptr)++ = yy_current_state;
+
+    yy_match:
+      do {
+        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
+          yy_current_state = (int)yy_def[yy_current_state];
+          if (yy_current_state >= 1402)
+            yy_c = yy_meta[yy_c];
+        }
+        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+        *(yy_state_ptr)++ = yy_current_state;
+        ++yy_cp;
+      } while (yy_base[yy_current_state] != 12505);
+
+    yy_find_action:
+      /* %% [10.0] code to find the action number goes here */
+      yy_current_state = *--(yy_state_ptr);
+      (yy_lp) = yy_accept[yy_current_state];
+
+    find_rule: /* we branch to this label when backing up */
+
+      for (;;) /* until we find what rule we matched */
+      {
+        if ((yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1]) {
+          yy_act = yy_acclist[(yy_lp)];
+          {
+            (yy_full_match) = yy_cp;
+            break;
+          }
+        }
+        --yy_cp;
+        yy_current_state = *--(yy_state_ptr);
+        (yy_lp) = yy_accept[yy_current_state];
+      }
+
+      YY_DO_BEFORE_ACTION;
+
+      /* %% [11.0] code for yylineno update goes here */
+
+      if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act]) {
+        int yyl;
+        for (yyl = (yy_more_len); yyl < yyleng; ++yyl)
+          if (yytext[yyl] == '\n')
+
+            yylineno++;
+        ;
+      }
+
+    do_action: /* This label is used only to access EOF actions. */
+
+      /* %% [12.0] debug code goes here */
+      if (yy_flex_debug) {
+        if (yy_act == 0)
+          std::cerr << "--scanner backing up\n";
+        else if (yy_act < 167)
+          std::cerr << "--accepting rule at line " << yy_rule_linenum[yy_act] << "(\""
+                    << yytext << "\")\n";
+        else if (yy_act == 167)
+          std::cerr << "--accepting default rule (\"" << yytext << "\")\n";
+        else if (yy_act == 168)
+          std::cerr << "--(end of buffer or a NUL)\n";
+        else
+          std::cerr << "--EOF (start condition " << YY_START << ")\n";
+      }
+
+      switch (yy_act) { /* beginning of action switch */
+        /* %% [13.0] actions go here */
+        case 1:
+          YY_RULE_SETUP
+
+          TOK(ACCESS)
+          YY_BREAK
+        case 2:
+          YY_RULE_SETUP
+
+          {
+            yylval.qualval = kALL;
+            TOK(ALL)
+          }
+          YY_BREAK
+        case 3:
+          YY_RULE_SETUP
+
+          TOK(ALTER)
+          YY_BREAK
+        case 4:
+          YY_RULE_SETUP
+
+          TOK(ADD)
+          YY_BREAK
+        case 5:
+          YY_RULE_SETUP
+
+          TOK(AND)
+          YY_BREAK
+        case 6:
+          YY_RULE_SETUP
+
+          {
+            yylval.qualval = kANY;
+            TOK(ANY)
+          }
+          YY_BREAK
+        case 7:
+          YY_RULE_SETUP
+
+          TOK(ARCHIVE)
+          YY_BREAK
+        case 8:
+          YY_RULE_SETUP
+
+          TOK(ARRAY)
+          YY_BREAK
+        case 9:
+          YY_RULE_SETUP
+
+          {
+            BEGIN STATE_CREATE_AS;
+            return SQLParser::AS;
+          }
+          YY_BREAK
+        case 10:
+          YY_RULE_SETUP
+
+          TOK(AS)
+          YY_BREAK
+        case 11:
+          YY_RULE_SETUP
+
+          TOK(ASC)
+          YY_BREAK
+        case 12:
+          YY_RULE_SETUP
+
+          TOK(AUTHORIZATION)
+          YY_BREAK
+        case 13:
+          YY_RULE_SETUP
+
+          TOK(BETWEEN)
+          YY_BREAK
+        case 14:
+          YY_RULE_SETUP
+
+          TOK(BIGINT)
+          YY_BREAK
+        case 15:
+          YY_RULE_SETUP
+
+          TOK(BOOLEAN)
+          YY_BREAK
+        case 16:
+          YY_RULE_SETUP
+
+          TOK(BY)
+          YY_BREAK
+        case 17:
+          YY_RULE_SETUP
+
+          TOK(CASE)
+          YY_BREAK
+        case 18:
+          YY_RULE_SETUP
+
+          TOK(CAST)
+          YY_BREAK
+        case 19:
+          YY_RULE_SETUP
+
+          TOK(CHAR_LENGTH)
+          YY_BREAK
+        case 20:
+          YY_RULE_SETUP
+
+          TOK(CHARACTER)
+          YY_BREAK
+        case 21:
+          YY_RULE_SETUP
+
+          TOK(CHECK)
+          YY_BREAK
+        case 22:
+          YY_RULE_SETUP
+
+          TOK(CLOSE)
+          YY_BREAK
+        case 23:
+          YY_RULE_SETUP
+
+          TOK(COLUMN)
+          YY_BREAK
+        case 24:
+          YY_RULE_SETUP
+
+          TOK(COMMIT)
+          YY_BREAK
+        case 25:
+          YY_RULE_SETUP
+
+          TOK(CONTINUE)
+          YY_BREAK
+        case 26:
+          YY_RULE_SETUP
+
+          TOK(COPY);
+          YY_BREAK
+        case 27:
+          YY_RULE_SETUP
+
+          {
+            BEGIN STATE_CREATE;
+            return SQLParser::CREATE;
+          }
+          YY_BREAK
+        case 28:
+          YY_RULE_SETUP
+
+          TOK(CURRENT)
+          YY_BREAK
+        case 29:
+          YY_RULE_SETUP
+
+          TOK(CURSOR)
+          YY_BREAK
+        case 30:
+          YY_RULE_SETUP
+
+          TOK(DASHBOARD)
+          YY_BREAK
+        case 31:
+          YY_RULE_SETUP
+
+          TOK(DATABASE)
+          YY_BREAK
+        case 32:
+          YY_RULE_SETUP
+
+          TOK(DATAFRAME)
+          YY_BREAK
+        case 33:
+          YY_RULE_SETUP
+
+          TOK(DATE)
+          YY_BREAK
+        case 34:
+          YY_RULE_SETUP
+
+          TOK(DATETIME)
+          YY_BREAK
+        case 35:
+          YY_RULE_SETUP
+
+          TOK(DATE_TRUNC)
+          YY_BREAK
+        case 36:
+          YY_RULE_SETUP
+
+          TOK(DECIMAL)
+          YY_BREAK
+        case 37:
+          YY_RULE_SETUP
+
+          TOK(DECLARE)
+          YY_BREAK
+        case 38:
+          YY_RULE_SETUP
+
+          TOK(DEFAULT)
+          YY_BREAK
+        case 39:
+          YY_RULE_SETUP
+
+          TOK(DELETE)
+          YY_BREAK
+        case 40:
+          YY_RULE_SETUP
+
+          TOK(DESC)
+          YY_BREAK
+        case 41:
+          YY_RULE_SETUP
+
+          TOK(DICTIONARY)
+          YY_BREAK
+        case 42:
+          YY_RULE_SETUP
+
+          TOK(DISTINCT)
+          YY_BREAK
+        case 43:
+          YY_RULE_SETUP
+
+          TOK(DOUBLE)
+          YY_BREAK
+        case 44:
+          YY_RULE_SETUP
+
+          TOK(DROP)
+          YY_BREAK
+        case 45:
+          YY_RULE_SETUP
+
+          TOK(DUMP)
+          YY_BREAK
+        case 46:
+          YY_RULE_SETUP
+
+          TOK(EDIT)
+          YY_BREAK
+        case 47:
+          YY_RULE_SETUP
+
+          TOK(EDITOR)
+          YY_BREAK
+        case 48:
+          YY_RULE_SETUP
+
+          TOK(ELSE)
+          YY_BREAK
+        case 49:
+          YY_RULE_SETUP
+
+          TOK(END)
+          YY_BREAK
+        case 50:
+          YY_RULE_SETUP
+
+          TOK(EXISTS)
+          YY_BREAK
+        case 51:
+          YY_RULE_SETUP
+
+          TOK(EXTRACT)
+          YY_BREAK
+        case 52:
+          YY_RULE_SETUP
+
+          TOK(FETCH)
+          YY_BREAK
+        case 53:
+          YY_RULE_SETUP
+
+          TOK(FIRST)
+          YY_BREAK
+        case 54:
+          YY_RULE_SETUP
+
+          TOK(FLOAT)
+          YY_BREAK
+        case 55:
+          YY_RULE_SETUP
+
+          TOK(FOR)
+          YY_BREAK
+        case 56:
+          YY_RULE_SETUP
+
+          TOK(FOREIGN)
+          YY_BREAK
+        case 57:
+          YY_RULE_SETUP
+
+          TOK(FOUND)
+          YY_BREAK
+        case 58:
+          YY_RULE_SETUP
+
+          TOK(FROM)
+          YY_BREAK
+        case 59:
+          YY_RULE_SETUP
+
+          TOK(GEOGRAPHY)
+          YY_BREAK
+        case 60:
+          YY_RULE_SETUP
+
+          TOK(GEOMETRY)
+          YY_BREAK
+        case 61:
+          YY_RULE_SETUP
+
+          TOK(GRANT)
+          YY_BREAK
+        case 62:
+          YY_RULE_SETUP
+
+          TOK(GROUP)
+          YY_BREAK
+        case 63:
+          YY_RULE_SETUP
+
+          TOK(HAVING)
+          YY_BREAK
+        case 64:
+          YY_RULE_SETUP
+
+          TOK(IF)
+          YY_BREAK
+        case 65:
+          YY_RULE_SETUP
+
+          TOK(ILIKE)
+          YY_BREAK
+        case 66:
+          YY_RULE_SETUP
+
+          TOK(IN)
+          YY_BREAK
+        case 67:
+          YY_RULE_SETUP
+
+          {
+            BEGIN STATE_INSERT;
+            return SQLParser::INSERT;
+          }
+          YY_BREAK
+        case 68:
+          YY_RULE_SETUP
+
+          TOK(INTEGER)
+          YY_BREAK
+        case 69:
+          YY_RULE_SETUP
+
+          {
+            BEGIN STATE_INSERT_INTO;
+            return SQLParser::INTO;
+          }
+          YY_BREAK
+        case 70:
+          YY_RULE_SETUP
+
+          TOK(INTO)
+          YY_BREAK
+        case 71:
+          YY_RULE_SETUP
+
+          TOK(IS)
+          YY_BREAK
+        case 72:
+          YY_RULE_SETUP
+
+          TOK(LANGUAGE)
+          YY_BREAK
+        case 73:
+          YY_RULE_SETUP
+
+          TOK(LAST)
+          YY_BREAK
+        case 74:
+          YY_RULE_SETUP
+
+          TOK(LENGTH)
+          YY_BREAK
+        case 75:
+          YY_RULE_SETUP
+
+          TOK(LIKE)
+          YY_BREAK
+        case 76:
+          YY_RULE_SETUP
+
+          TOK(LIMIT)
+          YY_BREAK
+        case 77:
+          YY_RULE_SETUP
+
+          TOK(LINESTRING)
+          YY_BREAK
+        case 78:
+          YY_RULE_SETUP
+
+          TOK(MOD)
+          YY_BREAK
+        case 79:
+          YY_RULE_SETUP
+
+          TOK(MULTIPOLYGON)
+          YY_BREAK
+        case 80:
+          YY_RULE_SETUP
+
+          TOK(NOT)
+          YY_BREAK
+        case 81:
+          YY_RULE_SETUP
+
+          TOK(NOW)
+          YY_BREAK
+        case 82:
+          YY_RULE_SETUP
+
+          TOK(NULLX)
+          YY_BREAK
+        case 83:
+          YY_RULE_SETUP
+
+          TOK(NUMERIC)
+          YY_BREAK
+        case 84:
+          YY_RULE_SETUP
+
+          TOK(OF)
+          YY_BREAK
+        case 85:
+          YY_RULE_SETUP
+
+          TOK(OFFSET)
+          YY_BREAK
+        case 86:
+          YY_RULE_SETUP
+
+          TOK(ON)
+          YY_BREAK
+        case 87:
+          YY_RULE_SETUP
+
+          TOK(OPEN)
+          YY_BREAK
+        case 88:
+          YY_RULE_SETUP
+
+          TOK(OPTION)
+          YY_BREAK
+        case 89:
+          YY_RULE_SETUP
+
+          TOK(OPTIMIZE)
+          YY_BREAK
+        case 90:
+          YY_RULE_SETUP
+
+          TOK(OR)
+          YY_BREAK
+        case 91:
+          YY_RULE_SETUP
+
+          TOK(ORDER)
+          YY_BREAK
+        case 92:
+          YY_RULE_SETUP
+
+          TOK(POINT)
+          YY_BREAK
+        case 93:
+          YY_RULE_SETUP
+
+          TOK(POLYGON)
+          YY_BREAK
+        case 94:
+          YY_RULE_SETUP
+
+          TOK(PRECISION)
+          YY_BREAK
+        case 95:
+          YY_RULE_SETUP
+
+          TOK(PRIMARY)
+          YY_BREAK
+        case 96:
+          YY_RULE_SETUP
+
+          TOK(PRIVILEGES)
+          YY_BREAK
+        case 97:
+          YY_RULE_SETUP
+
+          TOK(PROCEDURE)
+          YY_BREAK
+        case 98:
+          YY_RULE_SETUP
+
+          TOK(PUBLIC)
+          YY_BREAK
+        case 99:
+          YY_RULE_SETUP
+
+          TOK(REAL)
+          YY_BREAK
+        case 100:
+          YY_RULE_SETUP
+
+          TOK(REFERENCES)
+          YY_BREAK
+        case 101:
+          YY_RULE_SETUP
+
+          TOK(RENAME)
+          YY_BREAK
+        case 102:
+          YY_RULE_SETUP
+
+          TOK(RESTORE)
+          YY_BREAK
+        case 103:
+          YY_RULE_SETUP
+
+          TOK(REVOKE)
+          YY_BREAK
+        case 104:
+          YY_RULE_SETUP
+
+          TOK(ROLE)
+          YY_BREAK
+        case 105:
+          YY_RULE_SETUP
+
+          TOK(ROLLBACK)
+          YY_BREAK
+        case 106:
+          YY_RULE_SETUP
+
+          TOK(SCHEMA)
+          YY_BREAK
+        case 107:
+          YY_RULE_SETUP
+
+          TOK(SELECT)
+          YY_BREAK
+        case 108:
+          YY_RULE_SETUP
+
+          TOK(SERVER)
+          YY_BREAK
+        case 109:
+          YY_RULE_SETUP
+
+          TOK(SET)
+          YY_BREAK
+        case 110:
+          YY_RULE_SETUP
+
+          TOK(SHARD)
+          YY_BREAK
+        case 111:
+          YY_RULE_SETUP
+
+          TOK(SHARED)
+          YY_BREAK
+        case 112:
+          YY_RULE_SETUP
+
+          TOK(SHOW)
+          YY_BREAK
+        case 113:
+          YY_RULE_SETUP
+
+          TOK(SMALLINT)
+          YY_BREAK
+        case 114:
+          YY_RULE_SETUP
+
+          {
+            yylval.qualval = kANY;
+            TOK(SOME)
+          } /* SOME = ANY */
+          YY_BREAK
+        case 115:
+          YY_RULE_SETUP
+
+          TOK(SQL)
+          YY_BREAK
+        case 116:
+          YY_RULE_SETUP
+
+          TOK(TABLE)
+          YY_BREAK
+        case 117:
+          YY_RULE_SETUP
+
+          TOK(TEMPORARY)
+          YY_BREAK
+        case 118:
+          YY_RULE_SETUP
+
+          TOK(TEXT)
+          YY_BREAK
+        case 119:
+          YY_RULE_SETUP
+
+          TOK(THEN)
+          YY_BREAK
+        case 120:
+          YY_RULE_SETUP
+
+          TOK(TIME)
+          YY_BREAK
+        case 121:
+          YY_RULE_SETUP
+
+          TOK(TIMESTAMP)
+          YY_BREAK
+        case 122:
+          YY_RULE_SETUP
+
+          TOK(TINYINT)
+          YY_BREAK
+        case 123:
+          YY_RULE_SETUP
+
+          TOK(TO)
+          YY_BREAK
+        case 124:
+          YY_RULE_SETUP
+
+          TOK(TRUNCATE)
+          YY_BREAK
+        case 125:
+          YY_RULE_SETUP
+
+          TOK(UNION)
+          YY_BREAK
+        case 126:
+          YY_RULE_SETUP
+
+          TOK(UNIQUE)
+          YY_BREAK
+        case 127:
+          YY_RULE_SETUP
+
+          TOK(UPDATE)
+          YY_BREAK
+        case 128:
+          YY_RULE_SETUP
+
+          TOK(USER)
+          YY_BREAK
+        case 129:
+          YY_RULE_SETUP
+
+          {
+            BEGIN 0;
+            return SQLParser::VALUES;
+          }
+          YY_BREAK
+        case 130:
+          YY_RULE_SETUP
+
+          TOK(VALIDATE)
+          YY_BREAK
+        case 131:
+          YY_RULE_SETUP
+
+          TOK(CHARACTER) /* XXX don't distinguish char and varchar for now */
+          YY_BREAK
+        case 132:
+          YY_RULE_SETUP
+
+          TOK(VIEW)
+          YY_BREAK
+        case 133:
+          YY_RULE_SETUP
+
+          TOK(WHEN)
+          YY_BREAK
+        case 134:
+          YY_RULE_SETUP
+
+          TOK(WHERE)
+          YY_BREAK
+        case 135:
+          YY_RULE_SETUP
+
+          TOK(WITH)
+          YY_BREAK
+        case 136:
+          YY_RULE_SETUP
+
+          TOK(WORK)
+          YY_BREAK
+        /* punctuation */
+        case 137:
+          YY_RULE_SETUP
+
+          {
+            yylval.opval = kEQ;
+            TOK(EQUAL);
+          }
+          YY_BREAK
+        case 138:
+          YY_RULE_SETUP
+
+          {
+            yylval.opval = kNE;
+            TOK(COMPARISON);
+          }
+          YY_BREAK
+        case 139:
+          YY_RULE_SETUP
+
+          {
+            yylval.opval = kLT;
+            TOK(COMPARISON);
+          }
+          YY_BREAK
+        case 140:
+          YY_RULE_SETUP
+
+          {
+            yylval.opval = kGT;
+            TOK(COMPARISON);
+          }
+          YY_BREAK
+        case 141:
+          YY_RULE_SETUP
+
+          {
+            yylval.opval = kLE;
+            TOK(COMPARISON);
+          }
+          YY_BREAK
+        case 142:
+          YY_RULE_SETUP
+
+          {
+            yylval.opval = kGE;
+            TOK(COMPARISON);
+          }
+          YY_BREAK
+        case 143:
+          YY_RULE_SETUP
+
+          {
+            return yytext[0];
+          }
+          YY_BREAK
+        case 144:
+          YY_RULE_SETUP
+
+          {
+            BEGIN 0;
+            return yytext[0];
+          }
+          YY_BREAK
+        /* validate type */
+        case 145:
+          YY_RULE_SETUP
+
+          {
+            yylval.stringval = TrackedPtr<std::string>::make(parsed_str_tokens_, yytext);
+            TOK(CLUSTER)
+          }
+          YY_BREAK
+        /* names */
+        case 146:
+          YY_RULE_SETUP
+
+          {
+            yylval.stringval = TrackedPtr<std::string>::make(parsed_str_tokens_, yytext);
+            TOK(NAME)
+          }
+          YY_BREAK
+        /* names with dashes */
+        case 147:
+          YY_RULE_SETUP
+
+          {
+            yylval.stringval = TrackedPtr<std::string>::make(parsed_str_tokens_, yytext);
+            TOK(DASHEDNAME)
+          }
+          YY_BREAK
+        /* emails */
+        case 148:
+          YY_RULE_SETUP
+
+          {
+            yylval.stringval = TrackedPtr<std::string>::make(parsed_str_tokens_, yytext);
+            TOK(EMAIL)
+          }
+          YY_BREAK
+        /* parameters */
+        case 149:
+          YY_RULE_SETUP
+
+          TOK(PARAMETER)
+          YY_BREAK
+        /* numbers */
+        case 150:
+          YY_RULE_SETUP
+
+          {
+            yylval.intval = atoll(yytext);
+            TOK(INTNUM)
+          }
+          YY_BREAK
+        case 151:
+
+        case 152:
+          YY_RULE_SETUP
+
+          {
+            yylval.stringval = TrackedPtr<std::string>::make(parsed_str_tokens_, yytext);
+            // numeric and decimal precisions cannot exceed 19
+            if (yylval.stringval->get()->length() < 20) {
+              return SQLParser::FIXEDNUM;
+            }
+            delete yylval.stringval->release();
+            // otherwise return as double
+            yylval.doubleval = std::stod(yytext);
+            return SQLParser::DOUBLE;
+          }
+          YY_BREAK
+        /* TODO: handle FLOAT v.s. DOUBLE */
+        case 153:
+
+        case 154:
+
+        case 155:
+          YY_RULE_SETUP
+
+          {
+            yylval.doubleval = atof(yytext);
+            TOK(DOUBLE)
+          }
+          YY_BREAK
+        /* strings */
+        case 156:
+          /* rule 156 can match eol */
+          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
+          YY_LINENO_REWIND_TO(yy_cp - 3);
+          (yy_c_buf_p) = yy_cp -= 3;
+          YY_DO_BEFORE_ACTION; /* set up yytext again */
+          YY_RULE_SETUP
+
+          {
+            int len = yyleng;
+            yylval.stringval =
+                TrackedPtr<std::string>::make(parsed_str_tokens_, yytext, len);
+            boost::trim(*yylval.stringval->get());
+
+            BEGIN 0;
+            return SQLParser::SELECTSTRING;
+          }
+          YY_BREAK
+        case 157:
+          /* rule 157 can match eol */
+          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
+          YY_LINENO_REWIND_TO(yy_cp - 1);
+          (yy_c_buf_p) = yy_cp -= 1;
+          YY_DO_BEFORE_ACTION; /* set up yytext again */
+          YY_RULE_SETUP
+
+          {
+            int len = yyleng;
+            std::string tmp(yytext, len);
+            boost::regex keyword{"\\swith", boost::regex::icase};
+            boost::smatch what;
+            if (boost::regex_search(tmp, what, keyword)) {
+              REJECT;
+            } else {
+              yylval.stringval =
+                  TrackedPtr<std::string>::make(parsed_str_tokens_, yytext, len);
+              boost::trim(*yylval.stringval->get());
+              BEGIN 0;
+              return SQLParser::SELECTSTRING;
+            }
+          }
+          YY_BREAK
+        case 158:
+          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
+          (yy_c_buf_p) = yy_cp -= 1;
+          YY_DO_BEFORE_ACTION; /* set up yytext again */
+          YY_RULE_SETUP
+
+          {
+            int len = yyleng;
+            std::string tmp(yytext, len);
+            boost::regex keyword{"\\svalues", boost::regex::icase};
+            boost::smatch what;
+            if (boost::regex_search(tmp, what, keyword)) {
+              REJECT;
+            } else {
+              yylval.stringval =
+                  TrackedPtr<std::string>::make(parsed_str_tokens_, yytext, len);
+              boost::trim(*yylval.stringval->get());
+              BEGIN 0;
+              return SQLParser::SELECTSTRING;
+            }
+          }
+          YY_BREAK
+        case 159:
+          YY_RULE_SETUP
+
+          {
+            int len = yyleng - 6;
+            if (len > 0) {
+              yylval.stringval =
+                  TrackedPtr<std::string>::make(parsed_str_tokens_, yytext + 3, len);
+              boost::trim(*yylval.stringval->get());
+            } else {
+              yylval.stringval = TrackedPtr<std::string>::make(parsed_str_tokens_, "");
+            }
+            return SQLParser::FWDSTR;
+          }
+          YY_BREAK
+        case 160:
+          YY_RULE_SETUP
+
+          {
+            int c = yyFlexLexer::yyinput();
+
+            unput(c); /* just peeking */
+            if (c != '\'') {
+              /* remove quotes */
+              std::vector<char> escape_removed(yyleng - 1);
+              char* p = yytext + 1;
+              int j = 0;
+              int len = yyleng - 2;
+              for (int i = 0; i < len; i++) {
+                if (p[i] == '\\') {
+                  if (p[i + 1] == 't') {
+                    escape_removed[j++] = '\t';
+                    i++;
+                    continue;
+                  } else if (p[i + 1] == 'n') {
+                    escape_removed[j++] = '\n';
+                    i++;
+                    continue;
+                  } else if (p[i + 1] == '\\') {
+                    escape_removed[j++] = '\\';
+                    i++;
+                    continue;
+                  } else if (p[i + 1] == 'x' && i + 3 < len) {
+                    char s[3];
+                    s[0] = p[i + 2];
+                    s[1] = p[i + 3];
+                    s[2] = '\0';
+                    int c;
+                    sscanf(s, "%x", &c);
+                    escape_removed[j++] = (char)c;
+                    i += 3;
+                    continue;
+                  }
+                }
+                if (p[i] != '\'' || p[i + 1] != '\'')
+                  escape_removed[j++] = p[i];
+              }
+              escape_removed[j] = '\0';
+
+              yylval.stringval = TrackedPtr<std::string>::make(
+                  parsed_str_tokens_, std::string{escape_removed.data()});
+              return SQLParser::STRING;
+            } else
+              yymore();
+          }
+          YY_BREAK
+        case 161:
+          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
+          (yy_c_buf_p) = yy_cp -= 1;
+          YY_DO_BEFORE_ACTION; /* set up yytext again */
+          YY_RULE_SETUP
+
+          {
+            throw std::runtime_error("Unterminated string");
+          }
+          YY_BREAK
+        case 162:
+          YY_RULE_SETUP
+
+          {
+            int c = yyFlexLexer::yyinput();
+
+            unput(c); /* just peeking */
+            if (c != '"') {
+              /* remove quotes */
+              std::vector<char> escape_removed(yyleng - 1);
+              char* p = yytext + 1;
+              int j = 0;
+              int len = yyleng - 2;
+              for (int i = 0; i < len; i++) {
+                if (p[i] == '\\') {
+                  if (p[i + 1] == 't') {
+                    escape_removed[j++] = '\t';
+                    i++;
+                    continue;
+                  } else if (p[i + 1] == 'n') {
+                    escape_removed[j++] = '\n';
+                    i++;
+                    continue;
+                  } else if (p[i + 1] == '\\') {
+                    escape_removed[j++] = '\\';
+                    i++;
+                    continue;
+                  } else if (p[i + 1] == '"') {
+                    escape_removed[j++] = '"';
+                    i++;
+                    continue;
+                  } else if (p[i + 1] == 'x' && i + 3 < len) {
+                    char s[3];
+                    s[0] = p[i + 2];
+                    s[1] = p[i + 3];
+                    s[2] = '\0';
+                    int c;
+                    sscanf(s, "%x", &c);
+                    escape_removed[j++] = (char)c;
+                    i += 3;
+                    continue;
+                  }
+                }
+                escape_removed[j++] = p[i];
+              }
+              escape_removed[j] = '\0';
+
+              yylval.stringval = TrackedPtr<std::string>::make(
+                  parsed_str_tokens_, std::string{escape_removed.data()});
+              return SQLParser::QUOTED_IDENTIFIER;
+            } else
+              yymore();
+          }
+          YY_BREAK
+        case 163:
+          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
+          (yy_c_buf_p) = yy_cp -= 1;
+          YY_DO_BEFORE_ACTION; /* set up yytext again */
+          YY_RULE_SETUP
+
+          {
+            throw std::runtime_error("Unterminated string");
+          }
+          YY_BREAK
+        /*
+        \n		{ lineno++; }
+                */
+        case 164:
+          /* rule 164 can match eol */
+          YY_RULE_SETUP
+
+              ; /* white space */
+          YY_BREAK
+        case 165:
+          YY_RULE_SETUP
+
+              ; /* comment */
+          YY_BREAK
+        case 166:
+          YY_RULE_SETUP
+
+          {
+            return yytext[0];
+          } /* random non-SQL text.  cause error in parser */
+          YY_BREAK
+        case YY_STATE_EOF(INITIAL):
+        case YY_STATE_EOF(STATE_CREATE):
+        case YY_STATE_EOF(STATE_CREATE_AS):
+        case YY_STATE_EOF(STATE_INSERT):
+        case YY_STATE_EOF(STATE_INSERT_INTO):
+
+        {
+          yyterminate();
+        }
+          YY_BREAK
+        case 167:
+          YY_RULE_SETUP
+
+          ECHO;
+          YY_BREAK
+
+        case YY_END_OF_BUFFER: {
+          /* Amount of text matched not including the EOB char. */
+          int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;
+
+          /* Undo the effects of YY_DO_BEFORE_ACTION. */
+          *yy_cp = (yy_hold_char);
+          YY_RESTORE_YY_MORE_OFFSET
+
+          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW) {
+            /* We're scanning a new file or input source.  It's
+             * possible that this happened because the user
+             * just pointed yyin at a new source and called
+             * yylex().  If so, then we have to assure
+             * consistency between YY_CURRENT_BUFFER and our
+             * globals.  Here is the right place to do so, because
+             * this is the first action (other than possibly a
+             * back-up) that will match for the new input source.
+             */
+            (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+            /* %if-c-only */
+            /* %endif */
+            /* %if-c++-only */
+            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin.rdbuf();
+            /* %endif */
+            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+          }
+
+          /* Note that here we test for yy_c_buf_p "<=" to the position
+           * of the first EOB in the buffer, since yy_c_buf_p will
+           * already have been incremented past the NUL character
+           * (since all states make transitions on EOB to the
+           * end-of-buffer state).  Contrast this with the test
+           * in input().
+           */
+          if ((yy_c_buf_p) <=
+              &YY_CURRENT_BUFFER_LVALUE
+                   ->yy_ch_buf[(yy_n_chars)]) { /* This was really a NUL. */
+            yy_state_type yy_next_state;
+
+            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+            yy_current_state = yy_get_previous_state();
+
+            /* Okay, we're now positioned to make the NUL
+             * transition.  We couldn't have
+             * yy_get_previous_state() go ahead and do it
+             * for us because it doesn't know how to deal
+             * with the possibility of jamming (and we don't
+             * want to build jamming into it because then it
+             * will run more slowly).
+             */
+
+            yy_next_state = yy_try_NUL_trans(yy_current_state);
+
+            yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+            if (yy_next_state) {
+              /* Consume the NUL. */
+              yy_cp = ++(yy_c_buf_p);
+              yy_current_state = yy_next_state;
+              goto yy_match;
+            }
+
+            else {
+              /* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes
+               * here */
+              yy_cp = (yy_c_buf_p);
+              goto yy_find_action;
+            }
+          }
+
+          else
+            switch (yy_get_next_buffer()) {
+              case EOB_ACT_END_OF_FILE: {
+                (yy_did_buffer_switch_on_eof) = 0;
+
+                if (yywrap()) {
+                  /* Note: because we've taken care in
+                   * yy_get_next_buffer() to have set up
+                   * yytext, we can now set up
+                   * yy_c_buf_p so that if some total
+                   * hoser (like flex itself) wants to
+                   * call the scanner after we return the
+                   * YY_NULL, it'll still work - another
+                   * YY_NULL will get returned.
+                   */
+                  (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+                  yy_act = YY_STATE_EOF(YY_START);
+                  goto do_action;
+                }
+
+                else {
+                  if (!(yy_did_buffer_switch_on_eof))
+                    YY_NEW_FILE;
+                }
+                break;
+              }
+
+              case EOB_ACT_CONTINUE_SCAN:
+                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+                yy_current_state = yy_get_previous_state();
+
+                yy_cp = (yy_c_buf_p);
+                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+                goto yy_match;
+
+              case EOB_ACT_LAST_MATCH:
+                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+                yy_current_state = yy_get_previous_state();
+
+                yy_cp = (yy_c_buf_p);
+                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+                goto yy_find_action;
+            }
+          break;
+        }
+
+        default:
+          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
+      } /* end of action switch */
+    }   /* end of scanning one token */
+  }     /* end of user's declarations */
+} /* end of yylex */
+/* %ok-for-header */
+
+/* %if-c++-only */
+/* %not-for-header */
+/* The contents of this function are C++ specific, so the () macro is not used.
+ * This constructor simply maintains backward compatibility.
+ * DEPRECATED
+ */
+yyFlexLexer::yyFlexLexer(std::istream* arg_yyin, std::ostream* arg_yyout)
+    : yyin(arg_yyin ? arg_yyin->rdbuf() : std::cin.rdbuf())
+    , yyout(arg_yyout ? arg_yyout->rdbuf() : std::cout.rdbuf()) {
+  ctor_common();
+}
+
+/* The contents of this function are C++ specific, so the () macro is not used.
+ */
+yyFlexLexer::yyFlexLexer(std::istream& arg_yyin, std::ostream& arg_yyout)
+    : yyin(arg_yyin.rdbuf()), yyout(arg_yyout.rdbuf()) {
+  ctor_common();
+}
+
+/* The contents of this function are C++ specific, so the () macro is not used.
+ */
+void yyFlexLexer::ctor_common() {
+  yy_c_buf_p = 0;
+  yy_init = 0;
+  yy_start = 0;
+  yy_flex_debug = 0;
+  yylineno = 1;  // this will only get updated if %option yylineno
+
+  yy_did_buffer_switch_on_eof = 0;
+
+  yy_looking_for_trail_begin = 0;
+  yy_more_flag = 0;
+  yy_more_len = 0;
+  yy_more_offset = yy_prev_more_offset = 0;
+
+  yy_start_stack_ptr = yy_start_stack_depth = 0;
+  yy_start_stack = NULL;
+
+  yy_buffer_stack = NULL;
+  yy_buffer_stack_top = 0;
+  yy_buffer_stack_max = 0;
+
+  yy_state_buf = new yy_state_type[YY_STATE_BUF_SIZE];
+}
+
+/* The contents of this function are C++ specific, so the () macro is not used.
+ */
+yyFlexLexer::~yyFlexLexer() {
+  delete[] yy_state_buf;
+  yyfree(yy_start_stack);
+  yy_delete_buffer(YY_CURRENT_BUFFER);
+  yyfree(yy_buffer_stack);
+}
+
+/* The contents of this function are C++ specific, so the () macro is not used.
+ */
+void yyFlexLexer::switch_streams(std::istream& new_in, std::ostream& new_out) {
+  // was if( new_in )
+  yy_delete_buffer(YY_CURRENT_BUFFER);
+  yy_switch_to_buffer(yy_create_buffer(new_in, YY_BUF_SIZE));
+
+  // was if( new_out )
+  yyout.rdbuf(new_out.rdbuf());
+}
+
+/* The contents of this function are C++ specific, so the () macro is not used.
+ */
+void yyFlexLexer::switch_streams(std::istream* new_in, std::ostream* new_out) {
+  if (!new_in) {
+    new_in = &yyin;
+  }
+
+  if (!new_out) {
+    new_out = &yyout;
+  }
+
+  switch_streams(*new_in, *new_out);
+}
+
+#ifdef YY_INTERACTIVE
+int yyFlexLexer::LexerInput(char* buf, int /* max_size */)
+#else
+int yyFlexLexer::LexerInput(char* buf, int max_size)
+#endif
+{
+  if (yyin.eof() || yyin.fail())
+    return 0;
+
+#ifdef YY_INTERACTIVE
+  yyin.get(buf[0]);
+
+  if (yyin.eof())
+    return 0;
+
+  if (yyin.bad())
+    return -1;
+
+  return 1;
+
+#else
+  (void)yyin.read(buf, max_size);
+
+  if (yyin.bad())
+    return -1;
+  else
+    return yyin.gcount();
+#endif
+}
+
+void yyFlexLexer::LexerOutput(const char* buf, int size) {
+  (void)yyout.write(buf, size);
+}
+/* %ok-for-header */
+
+/* %endif */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+int yyFlexLexer::yy_get_next_buffer()
+/* %endif */
+{
+  char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+  char* source = (yytext_ptr);
+  int number_to_move, i;
+  int ret_val;
+
+  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
+    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");
+
+  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer ==
+      0) { /* Don't try to fill the buffer, so this is an EOF. */
+    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1) {
+      /* We matched a single character, the EOB, so
+       * treat this as a final EOF.
+       */
+      return EOB_ACT_END_OF_FILE;
+    }
+
+    else {
+      /* We matched some text prior to the EOB, first
+       * process it.
+       */
+      return EOB_ACT_LAST_MATCH;
+    }
+  }
+
+  /* Try to read more data. */
+
+  /* First move last chars to start of buffer. */
+  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);
+
+  for (i = 0; i < number_to_move; ++i)
+    *(dest++) = *(source++);
+
+  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
+    /* don't do the read, it's not guaranteed to return an EOF,
+     * just force an EOF
+     */
+    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+  else {
+    int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+    while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */
+
+      YY_FATAL_ERROR(
+          "input buffer overflow, can't enlarge buffer because scanner uses REJECT");
+    }
+
+    if (num_to_read > YY_READ_BUF_SIZE)
+      num_to_read = YY_READ_BUF_SIZE;
+
+    /* Read in more data. */
+    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+             (yy_n_chars),
+             num_to_read);
+
+    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+  }
+
+  if ((yy_n_chars) == 0) {
+    if (number_to_move == YY_MORE_ADJ) {
+      ret_val = EOB_ACT_END_OF_FILE;
+      yyrestart(yyin);
+    }
+
+    else {
+      ret_val = EOB_ACT_LAST_MATCH;
+      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
+    }
+  }
+
+  else
+    ret_val = EOB_ACT_CONTINUE_SCAN;
+
+  if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+    /* Extend the array by 50%, plus the number we really need. */
+    int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
+        (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
+    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
+      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
+    /* "- 2" to take care of EOB's */
+    YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
+  }
+
+  (yy_n_chars) += number_to_move;
+  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+  return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+/* %if-c-only */
+/* %not-for-header */
+/* %endif */
+/* %if-c++-only */
+yy_state_type yyFlexLexer::yy_get_previous_state()
+/* %endif */
+{
+  yy_state_type yy_current_state;
+  char* yy_cp;
+
+  /* %% [15.0] code to get the start state into yy_current_state goes here */
+  yy_current_state = (yy_start);
+
+  (yy_state_ptr) = (yy_state_buf);
+  *(yy_state_ptr)++ = yy_current_state;
+
+  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp) {
+    /* %% [16.0] code to find the next state goes here */
+    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
+      yy_current_state = (int)yy_def[yy_current_state];
+      if (yy_current_state >= 1402)
+        yy_c = yy_meta[yy_c];
+    }
+    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+    *(yy_state_ptr)++ = yy_current_state;
+  }
+
+  return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+yy_state_type yyFlexLexer::yy_try_NUL_trans(yy_state_type yy_current_state)
+/* %endif */
+{
+  int yy_is_jam;
+  /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
+
+  YY_CHAR yy_c = 1;
+  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
+    yy_current_state = (int)yy_def[yy_current_state];
+    if (yy_current_state >= 1402)
+      yy_c = yy_meta[yy_c];
+  }
+  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+  yy_is_jam = (yy_current_state == 1401);
+  if (!yy_is_jam)
+    *(yy_state_ptr)++ = yy_current_state;
+
+  return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_UNPUT
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yyunput(int c, char* yy_bp)
+/* %endif */
+{
+  char* yy_cp;
+
+  yy_cp = (yy_c_buf_p);
+
+  /* undo effects of setting up yytext */
+  *yy_cp = (yy_hold_char);
+
+  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf +
+                  2) { /* need to shift things up to make room */
+    /* +2 for EOB chars. */
+    int number_to_move = (yy_n_chars) + 2;
+    char* dest =
+        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+    char* source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
+      *--dest = *--source;
+
+    yy_cp += (int)(dest - source);
+    yy_bp += (int)(dest - source);
+    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
+        (int)YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
+      YY_FATAL_ERROR("flex scanner push-back overflow");
+  }
+
+  *--yy_cp = (char)c;
+
+  /* %% [18.0] update yylineno here */
+
+  if (c == '\n') {
+    --yylineno;
+  }
+
+  (yytext_ptr) = yy_bp;
+  (yy_hold_char) = *yy_cp;
+  (yy_c_buf_p) = yy_cp;
+}
+/* %if-c-only */
+/* %endif */
+#endif
+
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+int yyFlexLexer::yyinput()
+/* %endif */
+{
+  int c;
+
+  *(yy_c_buf_p) = (yy_hold_char);
+
+  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
+    /* yy_c_buf_p now points to the character we want to return.
+     * If this occurs *before* the EOB characters, then it's a
+     * valid NUL; if not, then we've hit the end of the buffer.
+     */
+    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
+      /* This was really a NUL. */
+      *(yy_c_buf_p) = '\0';
+
+    else { /* need more input */
+      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
+      ++(yy_c_buf_p);
+
+      switch (yy_get_next_buffer()) {
+        case EOB_ACT_LAST_MATCH:
+          /* This happens because yy_g_n_b()
+           * sees that we've accumulated a
+           * token and flags that we need to
+           * try matching the token before
+           * proceeding.  But for input(),
+           * there's no matching to consider.
+           * So convert the EOB_ACT_LAST_MATCH
+           * to EOB_ACT_END_OF_FILE.
+           */
+
+          /* Reset buffer status. */
+          yyrestart(yyin);
+
+          /*FALLTHROUGH*/
+
+        case EOB_ACT_END_OF_FILE: {
+          if (yywrap())
+            return 0;
+
+          if (!(yy_did_buffer_switch_on_eof))
+            YY_NEW_FILE;
+#ifdef __cplusplus
+          return yyinput();
+#else
+          return input();
+#endif
+        }
+
+        case EOB_ACT_CONTINUE_SCAN:
+          (yy_c_buf_p) = (yytext_ptr) + offset;
+          break;
+      }
+    }
+  }
+
+  c = *(unsigned char*)(yy_c_buf_p); /* cast for 8-bit char's */
+  *(yy_c_buf_p) = '\0';              /* preserve yytext */
+  (yy_hold_char) = *++(yy_c_buf_p);
+
+  /* %% [19.0] update BOL and yylineno */
+  if (c == '\n')
+
+    yylineno++;
+  ;
+
+  return c;
+}
+/* %if-c-only */
+/* %endif */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ *
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yyrestart(std::istream& input_file)
+/* %endif */
+{
+  if (!YY_CURRENT_BUFFER) {
+    yyensure_buffer_stack();
+    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
+  }
+
+  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
+  yy_load_buffer_state();
+}
+
+/* %if-c++-only */
+/** Delegate to the new version that takes an istream reference.
+ * @param input_file A readable stream.
+ *
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+void yyFlexLexer::yyrestart(std::istream* input_file) {
+  if (!input_file) {
+    input_file = &yyin;
+  }
+  yyrestart(*input_file);
+}
+/* %endif */
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ *
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
+/* %endif */
+{
+  /* TODO. We should be able to replace this entire function body
+   * with
+   *		yypop_buffer_state();
+   *		yypush_buffer_state(new_buffer);
+   */
+  yyensure_buffer_stack();
+  if (YY_CURRENT_BUFFER == new_buffer)
+    return;
+
+  if (YY_CURRENT_BUFFER) {
+    /* Flush out information for old buffer. */
+    *(yy_c_buf_p) = (yy_hold_char);
+    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+  }
+
+  YY_CURRENT_BUFFER_LVALUE = new_buffer;
+  yy_load_buffer_state();
+
+  /* We don't actually know whether we did this switch during
+   * EOF (yywrap()) processing, but the only time this flag
+   * is looked at is after yywrap() is called, so it's safe
+   * to go ahead and always set it.
+   */
+  (yy_did_buffer_switch_on_eof) = 1;
+}
+
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yy_load_buffer_state()
+/* %endif */
+{
+  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+  /* %if-c-only */
+  /* %endif */
+  /* %if-c++-only */
+  yyin.rdbuf(YY_CURRENT_BUFFER_LVALUE->yy_input_file);
+  /* %endif */
+  (yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ *
+ * @return the allocated buffer state.
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+YY_BUFFER_STATE yyFlexLexer::yy_create_buffer(std::istream& file, int size)
+/* %endif */
+{
+  YY_BUFFER_STATE b;
+
+  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
+  if (!b)
+    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");
+
+  b->yy_buf_size = size;
+
+  /* yy_ch_buf has to be 2 characters longer than the size given because
+   * we need to put in 2 end-of-buffer characters.
+   */
+  b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2));
+  if (!b->yy_ch_buf)
+    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");
+
+  b->yy_is_our_buffer = 1;
+
+  yy_init_buffer(b, file);
+
+  return b;
+}
+
+/* %if-c++-only */
+/** Delegate creation of buffers to the new version that takes an istream reference.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ *
+ * @return the allocated buffer state.
+ */
+YY_BUFFER_STATE yyFlexLexer::yy_create_buffer(std::istream* file, int size) {
+  return yy_create_buffer(*file, size);
+}
+/* %endif */
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ *
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yy_delete_buffer(YY_BUFFER_STATE b)
+/* %endif */
+{
+  if (!b)
+    return;
+
+  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
+    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;
+
+  if (b->yy_is_our_buffer)
+    yyfree((void*)b->yy_ch_buf);
+
+  yyfree((void*)b);
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yy_init_buffer(YY_BUFFER_STATE b, std::istream& file)
+/* %endif */
+
+{
+  int oerrno = errno;
+
+  yy_flush_buffer(b);
+
+  /* %if-c-only */
+  /* %endif */
+  /* %if-c++-only */
+  b->yy_input_file = file.rdbuf();
+  /* %endif */
+  b->yy_fill_buffer = 1;
+
+  /* If b is the current buffer, then yy_init_buffer was _probably_
+   * called from yyrestart() or through yy_get_next_buffer.
+   * In that case, we don't want to reset the lineno or column.
+   */
+  if (b != YY_CURRENT_BUFFER) {
+    b->yy_bs_lineno = 1;
+    b->yy_bs_column = 0;
+  }
+
+  /* %if-c-only */
+  /* %endif */
+  /* %if-c++-only */
+  b->yy_is_interactive = 0;
+  /* %endif */
+  errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ *
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yy_flush_buffer(YY_BUFFER_STATE b)
+/* %endif */
+{
+  if (!b)
+    return;
+
+  b->yy_n_chars = 0;
+
+  /* We always need two end-of-buffer characters.  The first causes
+   * a transition to the end-of-buffer state.  The second causes
+   * a jam in that state.
+   */
+  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+  b->yy_buf_pos = &b->yy_ch_buf[0];
+
+  b->yy_at_bol = 1;
+  b->yy_buffer_status = YY_BUFFER_NEW;
+
+  if (b == YY_CURRENT_BUFFER)
+    yy_load_buffer_state();
+}
+
+/* %if-c-or-c++ */
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yypush_buffer_state(YY_BUFFER_STATE new_buffer)
+/* %endif */
+{
+  if (new_buffer == NULL)
+    return;
+
+  yyensure_buffer_stack();
+
+  /* This block is copied from yy_switch_to_buffer. */
+  if (YY_CURRENT_BUFFER) {
+    /* Flush out information for old buffer. */
+    *(yy_c_buf_p) = (yy_hold_char);
+    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+  }
+
+  /* Only push if top exists. Otherwise, replace top. */
+  if (YY_CURRENT_BUFFER)
+    (yy_buffer_stack_top)++;
+  YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+  /* copied from yy_switch_to_buffer. */
+  yy_load_buffer_state();
+  (yy_did_buffer_switch_on_eof) = 1;
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yypop_buffer_state(void)
+/* %endif */
+{
+  if (!YY_CURRENT_BUFFER)
+    return;
+
+  yy_delete_buffer(YY_CURRENT_BUFFER);
+  YY_CURRENT_BUFFER_LVALUE = NULL;
+  if ((yy_buffer_stack_top) > 0)
+    --(yy_buffer_stack_top);
+
+  if (YY_CURRENT_BUFFER) {
+    yy_load_buffer_state();
+    (yy_did_buffer_switch_on_eof) = 1;
+  }
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yyensure_buffer_stack(void)
+/* %endif */
+{
+  yy_size_t num_to_alloc;
+
+  if (!(yy_buffer_stack)) {
+    /* First allocation is just for 2 elements, since we don't know if this
+     * scanner will even need a stack. We use 2 instead of 1 to avoid an
+     * immediate realloc on the next call.
+     */
+    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+    (yy_buffer_stack) =
+        (struct yy_buffer_state**)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state*));
+    if (!(yy_buffer_stack))
+      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");
+
+    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+    (yy_buffer_stack_max) = num_to_alloc;
+    (yy_buffer_stack_top) = 0;
+    return;
+  }
+
+  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {
+    /* Increase the buffer to prepare for a possible push. */
+    yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+    num_to_alloc = (yy_buffer_stack_max) + grow_size;
+    (yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc(
+        (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state*));
+    if (!(yy_buffer_stack))
+      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");
+
+    /* zero only the new slots.*/
+    memset((yy_buffer_stack) + (yy_buffer_stack_max),
+           0,
+           grow_size * sizeof(struct yy_buffer_state*));
+    (yy_buffer_stack_max) = num_to_alloc;
+  }
+}
+/* %endif */
+
+/* %if-c-only */
+/* %endif */
+
+/* %if-c-only */
+/* %endif */
+
+/* %if-c-only */
+/* %endif */
+
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yy_push_state(int _new_state)
+/* %endif */
+{
+  if ((yy_start_stack_ptr) >= (yy_start_stack_depth)) {
+    yy_size_t new_size;
+
+    (yy_start_stack_depth) += YY_START_STACK_INCR;
+    new_size = (yy_size_t)(yy_start_stack_depth) * sizeof(int);
+
+    if (!(yy_start_stack))
+      (yy_start_stack) = (int*)yyalloc(new_size);
+
+    else
+      (yy_start_stack) = (int*)yyrealloc((void*)(yy_start_stack), new_size);
+
+    if (!(yy_start_stack))
+      YY_FATAL_ERROR("out of memory expanding start-condition stack");
+  }
+
+  (yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;
+
+  BEGIN(_new_state);
+}
+
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::yy_pop_state()
+/* %endif */
+{
+  if (--(yy_start_stack_ptr) < 0)
+    YY_FATAL_ERROR("start-condition stack underflow");
+
+  BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
+}
+
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+int yyFlexLexer::yy_top_state()
+/* %endif */
+{
+  return (yy_start_stack)[(yy_start_stack_ptr)-1];
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+/* %if-c-only */
+/* %endif */
+/* %if-c++-only */
+void yyFlexLexer::LexerError(const char* msg) {
+  std::cerr << msg << std::endl;
+  exit(YY_EXIT_FAILURE);
+}
+/* %endif */
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n)                             \
+  do {                                        \
+    /* Undo effects of setting up yytext. */  \
+    int yyless_macro_arg = (n);               \
+    YY_LESS_LINENO(yyless_macro_arg);         \
+    yytext[yyleng] = (yy_hold_char);          \
+    (yy_c_buf_p) = yytext + yyless_macro_arg; \
+    (yy_hold_char) = *(yy_c_buf_p);           \
+    *(yy_c_buf_p) = '\0';                     \
+    yyleng = yyless_macro_arg;                \
+  } while (0)
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/* %if-c-only */
+/* %if-reentrant */
+/* %endif */
+/* %if-reentrant */
+/* %endif */
+/* %endif */
+
+/* %if-reentrant */
+/* %if-bison-bridge */
+/* %endif */
+/* %endif if-c-only */
+
+/* %if-c-only */
+/* %endif */
+
+/* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
+/* %if-reentrant */
+/* %endif */
+/* %endif */
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy(char* s1, const char* s2, int n) {
+  int i;
+  for (i = 0; i < n; ++i)
+    s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen(const char* s) {
+  int n;
+  for (n = 0; s[n]; ++n)
+    ;
+
+  return n;
+}
+#endif
+
+void* yyalloc(yy_size_t size) {
+  return malloc(size);
+}
+
+void* yyrealloc(void* ptr, yy_size_t size) {
+  /* The cast to (char *) in the following accommodates both
+   * implementations that use char* generic pointers, and those
+   * that use void* generic pointers.  It works with the latter
+   * because both ANSI C and C++ allow castless assignment from
+   * any pointer type to void*, and deal with argument conversions
+   * as though doing an assignment.
+   */
+  return realloc(ptr, size);
+}
+
+void yyfree(void* ptr) {
+  free((char*)ptr); /* see yyrealloc() for (char *) cast */
+}
+
+/* %if-tables-serialization definitions */
+/* %define-yytables   The name for this specific scanner's tables. */
+#define YYTABLES_NAME "yytables"
+/* %endif */
+
+/* %ok-for-header */
diff -Naur ./Parser/parser_wnd_pregen.h ../omniscidb-master/Parser/parser_wnd_pregen.h
--- ./Parser/parser_wnd_pregen.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Parser/parser_wnd_pregen.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,797 @@
+#ifndef YY_Parser_h_included
+#define YY_Parser_h_included
+
+/* before anything */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+#ifdef __cplusplus
+#ifndef YY_USE_CLASS
+#define YY_USE_CLASS
+#endif
+#else
+#endif
+#include <stdio.h>
+
+#define YY_Parser_CLASS SQLParser
+#define YY_Parser_LVAL yylval
+#define YY_Parser_CONSTRUCTOR_INIT  : lexer(yylval)
+#define YY_Parser_MEMBERS                                                                     \
+  virtual ~SQLParser() {}                                                                     \
+  int parse(const std::string& inputStrOrig,                                                  \
+            std::list<std::unique_ptr<Stmt>>& parseTrees,                                     \
+            std::string& lastParsed) {                                                        \
+    auto inputStr = boost::algorithm::trim_right_copy_if(                                     \
+                        inputStrOrig, boost::is_any_of(";") || boost::is_space()) +           \
+                    ";";                                                                      \
+    boost::regex create_view_expr{                                                            \
+        R"(CREATE\s+VIEW\s+(IF\s+NOT\s+EXISTS\s+)?([A-Za-z_][A-Za-z0-9\$_]*)\s+AS\s+(.*);?)", \
+        boost::regex::extended | boost::regex::icase};                                        \
+    std::lock_guard<std::mutex> lock(mutex_);                                                 \
+    boost::smatch what;                                                                       \
+    const auto trimmed_input = boost::algorithm::trim_copy(inputStr);                         \
+    if (boost::regex_match(                                                                   \
+            trimmed_input.cbegin(), trimmed_input.cend(), what, create_view_expr)) {          \
+      const bool if_not_exists = what[1].length() > 0;                                        \
+      const auto view_name = what[2].str();                                                   \
+      const auto select_query = what[3].str();                                                \
+      parseTrees.emplace_back(                                                                \
+          new CreateViewStmt(view_name, select_query, if_not_exists));                        \
+      return 0;                                                                               \
+    }                                                                                         \
+    std::istringstream ss(inputStr);                                                          \
+    lexer.switch_streams(&ss, 0);                                                             \
+    yyparse(parseTrees);                                                                      \
+    lastParsed = lexer.YYText();                                                              \
+    if (!errors_.empty()) {                                                                   \
+      throw std::runtime_error(errors_[0]);                                                   \
+    }                                                                                         \
+    return yynerrs;                                                                           \
+  }                                                                                           \
+                                                                                              \
+ private:                                                                                     \
+  SQLLexer lexer;                                                                             \
+  std::mutex mutex_;                                                                          \
+  std::vector<std::string> errors_;
+#define YY_Parser_LEX_BODY \
+  { return lexer.yylex(); }
+#define YY_Parser_ERROR_BODY                                                            \
+  {} /*{ std::cerr << "Syntax error on line " << lexer.lineno() << ". Last word parsed: \
+        " << lexer.YYText() << std::endl; } */
+
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/trim.hpp>
+#include <boost/regex.hpp>
+#include <cstdlib>
+#include <fstream>
+#include <iostream>
+#include <list>
+#include <mutex>
+#include <sstream>
+#include <stdexcept>
+#include <string>
+#include <utility>
+#include "Parser/FlexLexer.h"
+#include "ParserNode.h"
+#include "ReservedKeywords.h"
+#include "TrackedPtr.h"
+
+#ifdef DELETE
+#undef DELETE
+#endif
+
+#ifdef IN
+#undef IN
+#endif
+
+using namespace Parser;
+#define YY_Parser_PARSE_PARAM std::list<std::unique_ptr<Stmt>>& parseTrees
+
+typedef union {
+  bool boolval;
+  int64_t intval;
+  float floatval;
+  double doubleval;
+  TrackedPtr<std::string>* stringval;
+  SQLOps opval;
+  SQLQualifier qualval;
+  TrackedListPtr<Node>* listval;
+  TrackedListPtr<std::string>* slistval;
+  TrackedPtr<Node>* nodeval;
+} yy_Parser_stype;
+#define YY_Parser_STYPE yy_Parser_stype
+
+class SQLLexer : public yyFlexLexer {
+ public:
+  SQLLexer(YY_Parser_STYPE& lval) : yylval(lval){};
+  YY_Parser_STYPE& yylval;
+  std::vector<std::unique_ptr<TrackedPtr<std::string>>> parsed_str_tokens_{};
+  std::vector<std::unique_ptr<TrackedListPtr<std::string>>> parsed_str_list_tokens_{};
+  std::vector<std::unique_ptr<TrackedPtr<Node>>> parsed_node_tokens_{};
+  std::vector<std::unique_ptr<TrackedListPtr<Node>>> parsed_node_list_tokens_{};
+};
+
+/* %{ and %header{ and %union, during decl */
+#ifndef YY_Parser_COMPATIBILITY
+#ifndef YY_USE_CLASS
+#define YY_Parser_COMPATIBILITY 1
+#else
+#define YY_Parser_COMPATIBILITY 0
+#endif
+#endif
+
+#if YY_Parser_COMPATIBILITY != 0
+/* backward compatibility */
+#ifdef YYLTYPE
+#ifndef YY_Parser_LTYPE
+#define YY_Parser_LTYPE YYLTYPE
+/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header */
+/* use %define LTYPE */
+#endif
+#endif
+#ifdef YYSTYPE
+#ifndef YY_Parser_STYPE
+#define YY_Parser_STYPE YYSTYPE
+/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header */
+/* use %define STYPE */
+#endif
+#endif
+#ifdef YYDEBUG
+#ifndef YY_Parser_DEBUG
+#define YY_Parser_DEBUG YYDEBUG
+/* WARNING obsolete !!! user defined YYDEBUG not reported into generated header */
+/* use %define DEBUG */
+#endif
+#endif
+#ifdef YY_Parser_STYPE
+#ifndef yystype
+#define yystype YY_Parser_STYPE
+#endif
+#endif
+/* use goto to be compatible */
+#ifndef YY_Parser_USE_GOTO
+#define YY_Parser_USE_GOTO 1
+#endif
+#endif
+
+/* use no goto to be clean in C++ */
+#ifndef YY_Parser_USE_GOTO
+#define YY_Parser_USE_GOTO 0
+#endif
+
+#ifndef YY_Parser_PURE
+
+/* YY_Parser_PURE */
+#endif
+
+/* prefix */
+#ifndef YY_Parser_DEBUG
+
+/* YY_Parser_DEBUG */
+#endif
+#ifndef YY_Parser_LSP_NEEDED
+
+/* YY_Parser_LSP_NEEDED*/
+#endif
+/* DEFAULT LTYPE*/
+#ifdef YY_Parser_LSP_NEEDED
+#ifndef YY_Parser_LTYPE
+typedef struct yyltype {
+  int timestamp;
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+  char* text;
+} yyltype;
+
+#define YY_Parser_LTYPE yyltype
+#endif
+#endif
+/* DEFAULT STYPE*/
+#ifndef YY_Parser_STYPE
+#define YY_Parser_STYPE int
+#endif
+/* DEFAULT MISCELANEOUS */
+#ifndef YY_Parser_PARSE
+#define YY_Parser_PARSE yyparse
+#endif
+#ifndef YY_Parser_LEX
+#define YY_Parser_LEX yylex
+#endif
+#ifndef YY_Parser_LVAL
+#define YY_Parser_LVAL yylval
+#endif
+#ifndef YY_Parser_LLOC
+#define YY_Parser_LLOC yylloc
+#endif
+#ifndef YY_Parser_CHAR
+#define YY_Parser_CHAR yychar
+#endif
+#ifndef YY_Parser_NERRS
+#define YY_Parser_NERRS yynerrs
+#endif
+#ifndef YY_Parser_DEBUG_FLAG
+#define YY_Parser_DEBUG_FLAG yydebug
+#endif
+#ifndef YY_Parser_ERROR
+#define YY_Parser_ERROR yyerror
+#endif
+
+#ifndef YY_Parser_PARSE_PARAM
+#ifndef __STDC__
+#ifndef __cplusplus
+#ifndef YY_USE_CLASS
+#define YY_Parser_PARSE_PARAM
+#ifndef YY_Parser_PARSE_PARAM_DEF
+#define YY_Parser_PARSE_PARAM_DEF
+#endif
+#endif
+#endif
+#endif
+#ifndef YY_Parser_PARSE_PARAM
+#define YY_Parser_PARSE_PARAM void
+#endif
+#endif
+
+/* TOKEN C */
+#ifndef YY_USE_CLASS
+
+#ifndef YY_Parser_PURE
+extern YY_Parser_STYPE YY_Parser_LVAL;
+#endif
+
+#define NAME 258
+#define DASHEDNAME 259
+#define EMAIL 260
+#define STRING 261
+#define FWDSTR 262
+#define SELECTSTRING 263
+#define QUOTED_IDENTIFIER 264
+#define INTNUM 265
+#define FIXEDNUM 266
+#define OR 267
+#define AND 268
+#define NOT 269
+#define EQUAL 270
+#define COMPARISON 271
+#define UMINUS 272
+#define ADD 273
+#define ALL 274
+#define ALTER 275
+#define AMMSC 276
+#define ANY 277
+#define ARCHIVE 278
+#define ARRAY 279
+#define AS 280
+#define ASC 281
+#define AUTHORIZATION 282
+#define BETWEEN 283
+#define BIGINT 284
+#define BOOLEAN 285
+#define BY 286
+#define CASE 287
+#define CAST 288
+#define CHAR_LENGTH 289
+#define CHARACTER 290
+#define CHECK 291
+#define CLOSE 292
+#define CLUSTER 293
+#define COLUMN 294
+#define COMMIT 295
+#define CONTINUE 296
+#define COPY 297
+#define CREATE 298
+#define CURRENT 299
+#define CURSOR 300
+#define DATABASE 301
+#define DATAFRAME 302
+#define DATE 303
+#define DATETIME 304
+#define DATE_TRUNC 305
+#define DECIMAL 306
+#define DECLARE 307
+#define DEFAULT 308
+#define DELETE 309
+#define DESC 310
+#define DICTIONARY 311
+#define DISTINCT 312
+#define DOUBLE 313
+#define DROP 314
+#define DUMP 315
+#define ELSE 316
+#define END 317
+#define EXISTS 318
+#define EXTRACT 319
+#define FETCH 320
+#define FIRST 321
+#define FLOAT 322
+#define FOR 323
+#define FOREIGN 324
+#define FOUND 325
+#define FROM 326
+#define GEOGRAPHY 327
+#define GEOMETRY 328
+#define GRANT 329
+#define GROUP 330
+#define HAVING 331
+#define IF 332
+#define ILIKE 333
+#define IN 334
+#define INSERT 335
+#define INTEGER 336
+#define INTO 337
+#define IS 338
+#define LANGUAGE 339
+#define LAST 340
+#define LENGTH 341
+#define LIKE 342
+#define LIMIT 343
+#define LINESTRING 344
+#define MOD 345
+#define MULTIPOLYGON 346
+#define NOW 347
+#define NULLX 348
+#define NUMERIC 349
+#define OF 350
+#define OFFSET 351
+#define ON 352
+#define OPEN 353
+#define OPTIMIZE 354
+#define OPTIMIZED 355
+#define OPTION 356
+#define ORDER 357
+#define PARAMETER 358
+#define POINT 359
+#define POLYGON 360
+#define PRECISION 361
+#define PRIMARY 362
+#define PRIVILEGES 363
+#define PROCEDURE 364
+#define SERVER 365
+#define SMALLINT 366
+#define SOME 367
+#define TABLE 368
+#define TEMPORARY 369
+#define TEXT 370
+#define THEN 371
+#define TIME 372
+#define TIMESTAMP 373
+#define TINYINT 374
+#define TO 375
+#define TRUNCATE 376
+#define UNION 377
+#define PUBLIC 378
+#define REAL 379
+#define REFERENCES 380
+#define RENAME 381
+#define RESTORE 382
+#define REVOKE 383
+#define ROLE 384
+#define ROLLBACK 385
+#define SCHEMA 386
+#define SELECT 387
+#define SET 388
+#define SHARD 389
+#define SHARED 390
+#define SHOW 391
+#define UNIQUE 392
+#define UPDATE 393
+#define USER 394
+#define VALIDATE 395
+#define VALUES 396
+#define VIEW 397
+#define WHEN 398
+#define WHENEVER 399
+#define WHERE 400
+#define WITH 401
+#define WORK 402
+#define EDIT 403
+#define ACCESS 404
+#define DASHBOARD 405
+#define SQL 406
+#define EDITOR 407
+
+/* #defines token */
+/* after #define tokens, before const tokens S5*/
+#else
+#ifndef YY_Parser_CLASS
+#define YY_Parser_CLASS Parser
+#endif
+
+#ifndef YY_Parser_INHERIT
+#define YY_Parser_INHERIT
+#endif
+#ifndef YY_Parser_MEMBERS
+#define YY_Parser_MEMBERS
+#endif
+#ifndef YY_Parser_LEX_BODY
+#define YY_Parser_LEX_BODY
+#endif
+#ifndef YY_Parser_ERROR_BODY
+#define YY_Parser_ERROR_BODY
+#endif
+#ifndef YY_Parser_CONSTRUCTOR_PARAM
+#define YY_Parser_CONSTRUCTOR_PARAM
+#endif
+/* choose between enum and const */
+#ifndef YY_Parser_USE_CONST_TOKEN
+#define YY_Parser_USE_CONST_TOKEN 0
+/* yes enum is more compatible with flex,  */
+/* so by default we use it */
+#endif
+#if YY_Parser_USE_CONST_TOKEN != 0
+#ifndef YY_Parser_ENUM_TOKEN
+#define YY_Parser_ENUM_TOKEN yy_Parser_enum_token
+#endif
+#endif
+
+class YY_Parser_CLASS YY_Parser_INHERIT {
+ public:
+#if YY_Parser_USE_CONST_TOKEN != 0
+  /* static const int token ... */
+
+  static const int NAME;
+  static const int DASHEDNAME;
+  static const int EMAIL;
+  static const int STRING;
+  static const int FWDSTR;
+  static const int SELECTSTRING;
+  static const int QUOTED_IDENTIFIER;
+  static const int INTNUM;
+  static const int FIXEDNUM;
+  static const int OR;
+  static const int AND;
+  static const int NOT;
+  static const int EQUAL;
+  static const int COMPARISON;
+  static const int UMINUS;
+  static const int ADD;
+  static const int ALL;
+  static const int ALTER;
+  static const int AMMSC;
+  static const int ANY;
+  static const int ARCHIVE;
+  static const int ARRAY;
+  static const int AS;
+  static const int ASC;
+  static const int AUTHORIZATION;
+  static const int BETWEEN;
+  static const int BIGINT;
+  static const int BOOLEAN;
+  static const int BY;
+  static const int CASE;
+  static const int CAST;
+  static const int CHAR_LENGTH;
+  static const int CHARACTER;
+  static const int CHECK;
+  static const int CLOSE;
+  static const int CLUSTER;
+  static const int COLUMN;
+  static const int COMMIT;
+  static const int CONTINUE;
+  static const int COPY;
+  static const int CREATE;
+  static const int CURRENT;
+  static const int CURSOR;
+  static const int DATABASE;
+  static const int DATAFRAME;
+  static const int DATE;
+  static const int DATETIME;
+  static const int DATE_TRUNC;
+  static const int DECIMAL;
+  static const int DECLARE;
+  static const int DEFAULT;
+  static const int DELETE;
+  static const int DESC;
+  static const int DICTIONARY;
+  static const int DISTINCT;
+  static const int DOUBLE;
+  static const int DROP;
+  static const int DUMP;
+  static const int ELSE;
+  static const int END;
+  static const int EXISTS;
+  static const int EXTRACT;
+  static const int FETCH;
+  static const int FIRST;
+  static const int FLOAT;
+  static const int FOR;
+  static const int FOREIGN;
+  static const int FOUND;
+  static const int FROM;
+  static const int GEOGRAPHY;
+  static const int GEOMETRY;
+  static const int GRANT;
+  static const int GROUP;
+  static const int HAVING;
+  static const int IF;
+  static const int ILIKE;
+  static const int IN;
+  static const int INSERT;
+  static const int INTEGER;
+  static const int INTO;
+  static const int IS;
+  static const int LANGUAGE;
+  static const int LAST;
+  static const int LENGTH;
+  static const int LIKE;
+  static const int LIMIT;
+  static const int LINESTRING;
+  static const int MOD;
+  static const int MULTIPOLYGON;
+  static const int NOW;
+  static const int NULLX;
+  static const int NUMERIC;
+  static const int OF;
+  static const int OFFSET;
+  static const int ON;
+  static const int OPEN;
+  static const int OPTIMIZE;
+  static const int OPTIMIZED;
+  static const int OPTION;
+  static const int ORDER;
+  static const int PARAMETER;
+  static const int POINT;
+  static const int POLYGON;
+  static const int PRECISION;
+  static const int PRIMARY;
+  static const int PRIVILEGES;
+  static const int PROCEDURE;
+  static const int SERVER;
+  static const int SMALLINT;
+  static const int SOME;
+  static const int TABLE;
+  static const int TEMPORARY;
+  static const int TEXT;
+  static const int THEN;
+  static const int TIME;
+  static const int TIMESTAMP;
+  static const int TINYINT;
+  static const int TO;
+  static const int TRUNCATE;
+  static const int UNION;
+  static const int PUBLIC;
+  static const int REAL;
+  static const int REFERENCES;
+  static const int RENAME;
+  static const int RESTORE;
+  static const int REVOKE;
+  static const int ROLE;
+  static const int ROLLBACK;
+  static const int SCHEMA;
+  static const int SELECT;
+  static const int SET;
+  static const int SHARD;
+  static const int SHARED;
+  static const int SHOW;
+  static const int UNIQUE;
+  static const int UPDATE;
+  static const int USER;
+  static const int VALIDATE;
+  static const int VALUES;
+  static const int VIEW;
+  static const int WHEN;
+  static const int WHENEVER;
+  static const int WHERE;
+  static const int WITH;
+  static const int WORK;
+  static const int EDIT;
+  static const int ACCESS;
+  static const int DASHBOARD;
+  static const int SQL;
+  static const int EDITOR;
+
+  /* decl const */
+#else
+  enum YY_Parser_ENUM_TOKEN {
+    YY_Parser_NULL_TOKEN = 0
+
+    ,
+    NAME = 258,
+    DASHEDNAME = 259,
+    EMAIL = 260,
+    STRING = 261,
+    FWDSTR = 262,
+    SELECTSTRING = 263,
+    QUOTED_IDENTIFIER = 264,
+    INTNUM = 265,
+    FIXEDNUM = 266,
+    OR = 267,
+    AND = 268,
+    NOT = 269,
+    EQUAL = 270,
+    COMPARISON = 271,
+    UMINUS = 272,
+    ADD = 273,
+    ALL = 274,
+    ALTER = 275,
+    AMMSC = 276,
+    ANY = 277,
+    ARCHIVE = 278,
+    ARRAY = 279,
+    AS = 280,
+    ASC = 281,
+    AUTHORIZATION = 282,
+    BETWEEN = 283,
+    BIGINT = 284,
+    BOOLEAN = 285,
+    BY = 286,
+    CASE = 287,
+    CAST = 288,
+    CHAR_LENGTH = 289,
+    CHARACTER = 290,
+    CHECK = 291,
+    CLOSE = 292,
+    CLUSTER = 293,
+    COLUMN = 294,
+    COMMIT = 295,
+    CONTINUE = 296,
+    COPY = 297,
+    CREATE = 298,
+    CURRENT = 299,
+    CURSOR = 300,
+    DATABASE = 301,
+    DATAFRAME = 302,
+    DATE = 303,
+    DATETIME = 304,
+    DATE_TRUNC = 305,
+    DECIMAL = 306,
+    DECLARE = 307,
+    DEFAULT = 308,
+    DELETE = 309,
+    DESC = 310,
+    DICTIONARY = 311,
+    DISTINCT = 312,
+    DOUBLE = 313,
+    DROP = 314,
+    DUMP = 315,
+    ELSE = 316,
+    END = 317,
+    EXISTS = 318,
+    EXTRACT = 319,
+    FETCH = 320,
+    FIRST = 321,
+    FLOAT = 322,
+    FOR = 323,
+    FOREIGN = 324,
+    FOUND = 325,
+    FROM = 326,
+    GEOGRAPHY = 327,
+    GEOMETRY = 328,
+    GRANT = 329,
+    GROUP = 330,
+    HAVING = 331,
+    IF = 332,
+    ILIKE = 333,
+    IN = 334,
+    INSERT = 335,
+    INTEGER = 336,
+    INTO = 337,
+    IS = 338,
+    LANGUAGE = 339,
+    LAST = 340,
+    LENGTH = 341,
+    LIKE = 342,
+    LIMIT = 343,
+    LINESTRING = 344,
+    MOD = 345,
+    MULTIPOLYGON = 346,
+    NOW = 347,
+    NULLX = 348,
+    NUMERIC = 349,
+    OF = 350,
+    OFFSET = 351,
+    ON = 352,
+    OPEN = 353,
+    OPTIMIZE = 354,
+    OPTIMIZED = 355,
+    OPTION = 356,
+    ORDER = 357,
+    PARAMETER = 358,
+    POINT = 359,
+    POLYGON = 360,
+    PRECISION = 361,
+    PRIMARY = 362,
+    PRIVILEGES = 363,
+    PROCEDURE = 364,
+    SERVER = 365,
+    SMALLINT = 366,
+    SOME = 367,
+    TABLE = 368,
+    TEMPORARY = 369,
+    TEXT = 370,
+    THEN = 371,
+    TIME = 372,
+    TIMESTAMP = 373,
+    TINYINT = 374,
+    TO = 375,
+    TRUNCATE = 376,
+    UNION = 377,
+    PUBLIC = 378,
+    REAL = 379,
+    REFERENCES = 380,
+    RENAME = 381,
+    RESTORE = 382,
+    REVOKE = 383,
+    ROLE = 384,
+    ROLLBACK = 385,
+    SCHEMA = 386,
+    SELECT = 387,
+    SET = 388,
+    SHARD = 389,
+    SHARED = 390,
+    SHOW = 391,
+    UNIQUE = 392,
+    UPDATE = 393,
+    USER = 394,
+    VALIDATE = 395,
+    VALUES = 396,
+    VIEW = 397,
+    WHEN = 398,
+    WHENEVER = 399,
+    WHERE = 400,
+    WITH = 401,
+    WORK = 402,
+    EDIT = 403,
+    ACCESS = 404,
+    DASHBOARD = 405,
+    SQL = 406,
+    EDITOR = 407
+
+    /* enum token */
+  }; /* end of enum declaration */
+#endif
+ public:
+  int YY_Parser_PARSE(YY_Parser_PARSE_PARAM);
+  virtual void YY_Parser_ERROR(const char* msg) YY_Parser_ERROR_BODY;
+#ifdef YY_Parser_PURE
+#ifdef YY_Parser_LSP_NEEDED
+  virtual int YY_Parser_LEX(YY_Parser_STYPE* YY_Parser_LVAL,
+                            YY_Parser_LTYPE* YY_Parser_LLOC) YY_Parser_LEX_BODY;
+#else
+  virtual int YY_Parser_LEX(YY_Parser_STYPE* YY_Parser_LVAL) YY_Parser_LEX_BODY;
+#endif
+#else
+  virtual int YY_Parser_LEX() YY_Parser_LEX_BODY;
+  YY_Parser_STYPE YY_Parser_LVAL;
+#ifdef YY_Parser_LSP_NEEDED
+  YY_Parser_LTYPE YY_Parser_LLOC;
+#endif
+  int YY_Parser_NERRS;
+  int YY_Parser_CHAR;
+#endif
+#if YY_Parser_DEBUG != 0
+ public:
+  int YY_Parser_DEBUG_FLAG; /*  nonzero means print parse trace	*/
+#endif
+ public:
+  YY_Parser_CLASS(YY_Parser_CONSTRUCTOR_PARAM);
+
+ public:
+  YY_Parser_MEMBERS
+};
+/* other declare folow */
+#endif
+
+#if YY_Parser_COMPATIBILITY != 0
+/* backward compatibility */
+#ifndef YYSTYPE
+#define YYSTYPE YY_Parser_STYPE
+#endif
+
+#ifndef YYLTYPE
+#define YYLTYPE YY_Parser_LTYPE
+#endif
+#ifndef YYDEBUG
+#ifdef YY_Parser_DEBUG
+#define YYDEBUG YY_Parser_DEBUG
+#endif
+#endif
+
+#endif
+/* END */
+
+#endif
diff -Naur ./QueryEngine/AggregateUtils.h ../omniscidb-master/QueryEngine/AggregateUtils.h
--- ./QueryEngine/AggregateUtils.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/AggregateUtils.h	2021-04-21 00:02:57.000000000 +0300
@@ -70,7 +70,7 @@
     const std::vector<int64_t>& init_vec,
     const QueryMemoryDescriptor& query_mem_desc) {
   std::vector<int64_t> cmpt_res(cmpt_size, 0);
-  int8_t* buffer_ptr = reinterpret_cast<int8_t*>(&cmpt_res[0]);
+  int8_t* buffer_ptr = reinterpret_cast<int8_t*>(cmpt_res.data());
   for (size_t col_idx = 0, init_vec_idx = 0, col_count = query_mem_desc.getSlotCount();
        col_idx < col_count;
        ++col_idx) {
diff -Naur ./QueryEngine/ArrayOps.cpp ../omniscidb-master/QueryEngine/ArrayOps.cpp
--- ./QueryEngine/ArrayOps.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ArrayOps.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -29,9 +29,9 @@
 
 #ifdef EXECUTE_INCLUDE
 
-extern "C" DEVICE int32_t array_size(int8_t* chunk_iter_,
-                                     const uint64_t row_pos,
-                                     const uint32_t elem_log_sz) {
+extern "C" DEVICE RUNTIME_EXPORT int32_t array_size(int8_t* chunk_iter_,
+                                                    const uint64_t row_pos,
+                                                    const uint32_t elem_log_sz) {
   ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);
   ArrayDatum ad;
   bool is_end;
@@ -39,10 +39,10 @@
   return ad.is_null ? 0 : ad.length >> elem_log_sz;
 }
 
-extern "C" DEVICE int32_t array_size_nullable(int8_t* chunk_iter_,
-                                              const uint64_t row_pos,
-                                              const uint32_t elem_log_sz,
-                                              const int32_t null_val) {
+extern "C" DEVICE RUNTIME_EXPORT int32_t array_size_nullable(int8_t* chunk_iter_,
+                                                             const uint64_t row_pos,
+                                                             const uint32_t elem_log_sz,
+                                                             const int32_t null_val) {
   ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);
   ArrayDatum ad;
   bool is_end;
@@ -50,7 +50,8 @@
   return ad.is_null ? null_val : ad.length >> elem_log_sz;
 }
 
-extern "C" DEVICE bool array_is_null(int8_t* chunk_iter_, const uint64_t row_pos) {
+extern "C" DEVICE RUNTIME_EXPORT bool array_is_null(int8_t* chunk_iter_,
+                                                    const uint64_t row_pos) {
   ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);
   ArrayDatum ad;
   bool is_end;
@@ -58,8 +59,8 @@
   return ad.is_null;
 }
 
-extern "C" DEVICE bool point_coord_array_is_null(int8_t* chunk_iter_,
-                                                 const uint64_t row_pos) {
+extern "C" DEVICE RUNTIME_EXPORT bool point_coord_array_is_null(int8_t* chunk_iter_,
+                                                                const uint64_t row_pos) {
   ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);
   ArrayDatum ad;
   bool is_end;
@@ -68,7 +69,7 @@
 }
 
 #define ARRAY_AT(type)                                                        \
-  extern "C" DEVICE type array_at_##type(                                     \
+  extern "C" DEVICE RUNTIME_EXPORT type array_at_##type(                      \
       int8_t* chunk_iter_, const uint64_t row_pos, const uint32_t elem_idx) { \
     ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);        \
     ArrayDatum ad;                                                            \
@@ -87,7 +88,7 @@
 #undef ARRAY_AT
 
 #define VARLEN_ARRAY_AT(type)                                                 \
-  extern "C" DEVICE type varlen_array_at_##type(                              \
+  extern "C" DEVICE RUNTIME_EXPORT type varlen_array_at_##type(               \
       int8_t* chunk_iter_, const uint64_t row_pos, const uint32_t elem_idx) { \
     ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);        \
     ArrayDatum ad;                                                            \
@@ -106,7 +107,7 @@
 #undef VARLEN_ARRAY_AT
 
 #define VARLEN_NOTNULL_ARRAY_AT(type)                                         \
-  extern "C" DEVICE type varlen_notnull_array_at_##type(                      \
+  extern "C" DEVICE RUNTIME_EXPORT type varlen_notnull_array_at_##type(       \
       int8_t* chunk_iter_, const uint64_t row_pos, const uint32_t elem_idx) { \
     ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);        \
     ArrayDatum ad;                                                            \
@@ -124,44 +125,44 @@
 
 #undef VARLEN_NOTNULL_ARRAY_AT
 
-#define ARRAY_ANY(type, needle_type, oper_name, oper)                    \
-  extern "C" DEVICE bool array_any_##oper_name##_##type##_##needle_type( \
-      int8_t* chunk_iter_,                                               \
-      const uint64_t row_pos,                                            \
-      const needle_type needle,                                          \
-      const type null_val) {                                             \
-    ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);   \
-    ArrayDatum ad;                                                       \
-    bool is_end;                                                         \
-    ChunkIter_get_nth(chunk_iter, row_pos, &ad, &is_end);                \
-    const size_t elem_count = ad.length / sizeof(type);                  \
-    for (size_t i = 0; i < elem_count; ++i) {                            \
-      const needle_type val = reinterpret_cast<type*>(ad.pointer)[i];    \
-      if (val != null_val && val oper needle) {                          \
-        return true;                                                     \
-      }                                                                  \
-    }                                                                    \
-    return false;                                                        \
+#define ARRAY_ANY(type, needle_type, oper_name, oper)                                   \
+  extern "C" DEVICE RUNTIME_EXPORT bool array_any_##oper_name##_##type##_##needle_type( \
+      int8_t* chunk_iter_,                                                              \
+      const uint64_t row_pos,                                                           \
+      const needle_type needle,                                                         \
+      const type null_val) {                                                            \
+    ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);                  \
+    ArrayDatum ad;                                                                      \
+    bool is_end;                                                                        \
+    ChunkIter_get_nth(chunk_iter, row_pos, &ad, &is_end);                               \
+    const size_t elem_count = ad.length / sizeof(type);                                 \
+    for (size_t i = 0; i < elem_count; ++i) {                                           \
+      const needle_type val = reinterpret_cast<type*>(ad.pointer)[i];                   \
+      if (val != null_val && val oper needle) {                                         \
+        return true;                                                                    \
+      }                                                                                 \
+    }                                                                                   \
+    return false;                                                                       \
   }
 
-#define ARRAY_ALL(type, needle_type, oper_name, oper)                    \
-  extern "C" DEVICE bool array_all_##oper_name##_##type##_##needle_type( \
-      int8_t* chunk_iter_,                                               \
-      const uint64_t row_pos,                                            \
-      const needle_type needle,                                          \
-      const type null_val) {                                             \
-    ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);   \
-    ArrayDatum ad;                                                       \
-    bool is_end;                                                         \
-    ChunkIter_get_nth(chunk_iter, row_pos, &ad, &is_end);                \
-    const size_t elem_count = ad.length / sizeof(type);                  \
-    for (size_t i = 0; i < elem_count; ++i) {                            \
-      const needle_type val = reinterpret_cast<type*>(ad.pointer)[i];    \
-      if (!(val != null_val && val oper needle)) {                       \
-        return false;                                                    \
-      }                                                                  \
-    }                                                                    \
-    return true;                                                         \
+#define ARRAY_ALL(type, needle_type, oper_name, oper)                                   \
+  extern "C" DEVICE RUNTIME_EXPORT bool array_all_##oper_name##_##type##_##needle_type( \
+      int8_t* chunk_iter_,                                                              \
+      const uint64_t row_pos,                                                           \
+      const needle_type needle,                                                         \
+      const type null_val) {                                                            \
+    ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);                  \
+    ArrayDatum ad;                                                                      \
+    bool is_end;                                                                        \
+    ChunkIter_get_nth(chunk_iter, row_pos, &ad, &is_end);                               \
+    const size_t elem_count = ad.length / sizeof(type);                                 \
+    for (size_t i = 0; i < elem_count; ++i) {                                           \
+      const needle_type val = reinterpret_cast<type*>(ad.pointer)[i];                   \
+      if (!(val != null_val && val oper needle)) {                                      \
+        return false;                                                                   \
+      }                                                                                 \
+    }                                                                                   \
+    return true;                                                                        \
   }
 
 #define ARRAY_ALL_ANY_ALL_TYPES(oper_name, oper, needle_type) \
@@ -225,10 +226,11 @@
 #undef ARRAY_ANY
 
 #define ARRAY_AT_CHECKED(type)                                                    \
-  extern "C" DEVICE type array_at_##type##_checked(int8_t* chunk_iter_,           \
-                                                   const uint64_t row_pos,        \
-                                                   const int64_t elem_idx,        \
-                                                   const type null_val) {         \
+  extern "C" DEVICE RUNTIME_EXPORT type array_at_##type##_checked(                \
+      int8_t* chunk_iter_,                                                        \
+      const uint64_t row_pos,                                                     \
+      const int64_t elem_idx,                                                     \
+      const type null_val) {                                                      \
     if (elem_idx <= 0) {                                                          \
       return null_val;                                                            \
     }                                                                             \
@@ -251,8 +253,8 @@
 
 #undef ARRAY_AT_CHECKED
 
-extern "C" DEVICE int8_t* allocate_varlen_buffer(int64_t element_count,
-                                                 int64_t element_size) {
+extern "C" DEVICE RUNTIME_EXPORT int8_t* allocate_varlen_buffer(int64_t element_count,
+                                                                int64_t element_size) {
 #ifndef __CUDACC__
   int8_t* varlen_buffer =
       reinterpret_cast<int8_t*>(checked_malloc((element_count + 1) * element_size));
@@ -262,21 +264,23 @@
 #endif
 }
 
-extern "C" DEVICE ALWAYS_INLINE int32_t
+extern "C" DEVICE RUNTIME_EXPORT ALWAYS_INLINE int32_t
 fast_fixlen_array_size(int8_t* chunk_iter_, const uint32_t elem_log_sz) {
   ChunkIter* it = reinterpret_cast<ChunkIter*>(chunk_iter_);
   return it->skip_size >> elem_log_sz;
 }
 
-extern "C" DEVICE ALWAYS_INLINE int8_t* fast_fixlen_array_buff(int8_t* chunk_iter_,
-                                                               const uint64_t row_pos) {
+extern "C" DEVICE RUNTIME_EXPORT ALWAYS_INLINE int8_t* fast_fixlen_array_buff(
+    int8_t* chunk_iter_,
+    const uint64_t row_pos) {
   ChunkIter* it = reinterpret_cast<ChunkIter*>(chunk_iter_);
   auto n = static_cast<int>(row_pos);
   int8_t* current_pos = it->start_pos + n * it->skip_size;
   return current_pos;
 }
 
-extern "C" DEVICE int8_t* array_buff(int8_t* chunk_iter_, const uint64_t row_pos) {
+extern "C" DEVICE RUNTIME_EXPORT int8_t* array_buff(int8_t* chunk_iter_,
+                                                    const uint64_t row_pos) {
   ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);
   ArrayDatum ad;
   bool is_end;
@@ -288,33 +292,33 @@
 
 #include <set>
 
-extern "C" ALWAYS_INLINE int64_t elem_bitcast_int8_t(const int8_t val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE int64_t elem_bitcast_int8_t(const int8_t val) {
   return val;
 }
 
-extern "C" ALWAYS_INLINE int64_t elem_bitcast_int16_t(const int16_t val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE int64_t elem_bitcast_int16_t(const int16_t val) {
   return val;
 }
 
-extern "C" ALWAYS_INLINE int64_t elem_bitcast_int32_t(const int32_t val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE int64_t elem_bitcast_int32_t(const int32_t val) {
   return val;
 }
 
-extern "C" ALWAYS_INLINE int64_t elem_bitcast_int64_t(const int64_t val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE int64_t elem_bitcast_int64_t(const int64_t val) {
   return val;
 }
 
-extern "C" ALWAYS_INLINE int64_t elem_bitcast_float(const float val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE int64_t elem_bitcast_float(const float val) {
   const double dval{val};
   return *reinterpret_cast<const int64_t*>(may_alias_ptr(&dval));
 }
 
-extern "C" ALWAYS_INLINE int64_t elem_bitcast_double(const double val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE int64_t elem_bitcast_double(const double val) {
   return *reinterpret_cast<const int64_t*>(may_alias_ptr(&val));
 }
 
 #define COUNT_DISTINCT_ARRAY(type)                                                      \
-  extern "C" void agg_count_distinct_array_##type(                                      \
+  extern "C" RUNTIME_EXPORT void agg_count_distinct_array_##type(                       \
       int64_t* agg, int8_t* chunk_iter_, const uint64_t row_pos, const type null_val) { \
     ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);                  \
     ArrayDatum ad;                                                                      \
@@ -340,16 +344,17 @@
 
 #include <string>
 
-extern "C" uint64_t string_decompress(const int32_t string_id,
-                                      const int64_t string_dict_handle);
+extern "C" RUNTIME_EXPORT uint64_t string_decompress(const int32_t string_id,
+                                                     const int64_t string_dict_handle);
 
 #define ARRAY_STR_ANY(type, oper_name, oper)                                           \
-  extern "C" bool array_any_##oper_name##_str_##type(int8_t* chunk_iter_,              \
-                                                     const uint64_t row_pos,           \
-                                                     const char* needle_ptr,           \
-                                                     const uint32_t needle_len,        \
-                                                     const int64_t string_dict_handle, \
-                                                     const type null_val) {            \
+  extern "C" RUNTIME_EXPORT bool array_any_##oper_name##_str_##type(                   \
+      int8_t* chunk_iter_,                                                             \
+      const uint64_t row_pos,                                                          \
+      const char* needle_ptr,                                                          \
+      const uint32_t needle_len,                                                       \
+      const int64_t string_dict_handle,                                                \
+      const type null_val) {                                                           \
     ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);                 \
     ArrayDatum ad;                                                                     \
     bool is_end;                                                                       \
@@ -371,33 +376,34 @@
     return false;                                                                      \
   }
 
-#define ARRAY_STR_ALL(type, oper_name, oper)                                           \
-  extern "C" bool array_all_##oper_name##_str_##type(int8_t* chunk_iter_,              \
-                                                     const uint64_t row_pos,           \
-                                                     const char* needle_ptr,           \
-                                                     const uint32_t needle_len,        \
-                                                     const int64_t string_dict_handle, \
-                                                     const type null_val) {            \
-    ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);                 \
-    ArrayDatum ad;                                                                     \
-    bool is_end;                                                                       \
-    ChunkIter_get_nth(chunk_iter, row_pos, &ad, &is_end);                              \
-    const size_t elem_count = ad.length / sizeof(type);                                \
-    std::string needle_str(needle_ptr, needle_len);                                    \
-    for (size_t i = 0; i < elem_count; ++i) {                                          \
-      const type val = reinterpret_cast<type*>(ad.pointer)[i];                         \
-      if (val == null_val) {                                                           \
-        return false;                                                                  \
-      }                                                                                \
-      uint64_t str_and_len = string_decompress(val, string_dict_handle);               \
-      const char* str = reinterpret_cast<const char*>(str_and_len & 0xffffffffffff);   \
-      const uint16_t len = str_and_len >> 48;                                          \
-      std::string val_str(str, len);                                                   \
-      if (!(val_str oper needle_str)) {                                                \
-        return false;                                                                  \
-      }                                                                                \
-    }                                                                                  \
-    return true;                                                                       \
+#define ARRAY_STR_ALL(type, oper_name, oper)                                         \
+  extern "C" RUNTIME_EXPORT bool array_all_##oper_name##_str_##type(                 \
+      int8_t* chunk_iter_,                                                           \
+      const uint64_t row_pos,                                                        \
+      const char* needle_ptr,                                                        \
+      const uint32_t needle_len,                                                     \
+      const int64_t string_dict_handle,                                              \
+      const type null_val) {                                                         \
+    ChunkIter* chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);               \
+    ArrayDatum ad;                                                                   \
+    bool is_end;                                                                     \
+    ChunkIter_get_nth(chunk_iter, row_pos, &ad, &is_end);                            \
+    const size_t elem_count = ad.length / sizeof(type);                              \
+    std::string needle_str(needle_ptr, needle_len);                                  \
+    for (size_t i = 0; i < elem_count; ++i) {                                        \
+      const type val = reinterpret_cast<type*>(ad.pointer)[i];                       \
+      if (val == null_val) {                                                         \
+        return false;                                                                \
+      }                                                                              \
+      uint64_t str_and_len = string_decompress(val, string_dict_handle);             \
+      const char* str = reinterpret_cast<const char*>(str_and_len & 0xffffffffffff); \
+      const uint16_t len = str_and_len >> 48;                                        \
+      std::string val_str(str, len);                                                 \
+      if (!(val_str oper needle_str)) {                                              \
+        return false;                                                                \
+      }                                                                              \
+    }                                                                                \
+    return true;                                                                     \
   }
 
 #define ARRAY_STR_ALL_ANY_ALL_TYPES(oper_name, oper) \
diff -Naur ./QueryEngine/ArrowResultSet.h ../omniscidb-master/QueryEngine/ArrowResultSet.h
--- ./QueryEngine/ArrowResultSet.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ArrowResultSet.h	2021-04-21 00:02:57.000000000 +0300
@@ -206,7 +206,6 @@
     SQLTypes physical_type;
   };
 
- private:
   ArrowResultSetConverter(const std::shared_ptr<ResultSet>& results,
                           const std::vector<std::string>& col_names,
                           const int32_t first_n)
@@ -214,6 +213,7 @@
 
   std::shared_ptr<arrow::RecordBatch> convertToArrow() const;
 
+ private:
   std::shared_ptr<arrow::RecordBatch> getArrowBatch(
       const std::shared_ptr<arrow::Schema>& schema) const;
 
@@ -246,11 +246,6 @@
   int32_t top_n_;
   ArrowTransport transport_method_;
 
-  // Here we hold temporary buffers for arrow arrays when
-  // array builders are not used.
-  mutable std::vector<std::unique_ptr<int8_t[]>> values_;
-  mutable std::vector<std::unique_ptr<uint8_t[]>> is_valid_;
-
   friend class ArrowResultSet;
 };
 
diff -Naur ./QueryEngine/ArrowResultSetConverter.cpp ../omniscidb-master/QueryEngine/ArrowResultSetConverter.cpp
--- ./QueryEngine/ArrowResultSetConverter.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ArrowResultSetConverter.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -60,6 +60,18 @@
 
 namespace {
 
+/* We can create Arrow buffers which refer memory owned by ResultSet.
+   For safe memory access we should keep a ResultSetPtr to keep
+   data live while buffer lives. Use this custom buffer for that. */
+class ResultSetBuffer : public Buffer {
+ public:
+  ResultSetBuffer(const uint8_t* buf, size_t size, ResultSetPtr rs)
+      : Buffer(buf, size), _rs(rs) {}
+
+ private:
+  ResultSetPtr _rs;
+};
+
 inline SQLTypes get_dict_index_type(const SQLTypeInfo& ti) {
   CHECK(ti.is_dict_encoded_string());
   switch (ti.get_size()) {
@@ -166,28 +178,35 @@
 template <typename C_TYPE, typename ARROW_TYPE = typename CTypeTraits<C_TYPE>::ArrowType>
 void convert_column(ResultSetPtr result,
                     size_t col,
-                    std::unique_ptr<int8_t[]>& values,
-                    std::unique_ptr<uint8_t[]>& is_valid,
                     size_t entry_count,
                     std::shared_ptr<Array>& out) {
   CHECK(sizeof(C_TYPE) == result->getColType(col).get_size());
-  CHECK(!values);
-  CHECK(!is_valid);
 
-  const int8_t* data_ptr;
+  std::shared_ptr<arrow::Buffer> values;
+  std::shared_ptr<arrow::Buffer> is_valid;
+  const int64_t buf_size = entry_count * sizeof(C_TYPE);
   if (result->isZeroCopyColumnarConversionPossible(col)) {
-    data_ptr = result->getColumnarBuffer(col);
+    values.reset(new ResultSetBuffer(
+        reinterpret_cast<const uint8_t*>(result->getColumnarBuffer(col)),
+        buf_size,
+        result));
   } else {
-    values.reset(new int8_t[entry_count * sizeof(C_TYPE)]);
-    result->copyColumnIntoBuffer(col, values.get(), entry_count * sizeof(C_TYPE));
-    data_ptr = values.get();
+    auto res = arrow::AllocateBuffer(buf_size);
+    CHECK(res.ok());
+    values = std::move(res).ValueOrDie();
+    result->copyColumnIntoBuffer(
+        col, reinterpret_cast<int8_t*>(values->mutable_data()), buf_size);
   }
 
   int64_t null_count = 0;
-  is_valid.reset(new uint8_t[(entry_count + 7) / 8]);
+  auto res = arrow::AllocateBuffer((entry_count + 7) / 8);
+  CHECK(res.ok());
+  is_valid = std::move(res).ValueOrDie();
+
+  auto is_valid_data = is_valid->mutable_data();
 
   const null_type_t<C_TYPE>* vals =
-      reinterpret_cast<const null_type_t<C_TYPE>*>(data_ptr);
+      reinterpret_cast<const null_type_t<C_TYPE>*>(values->data());
   null_type_t<C_TYPE> null_val = null_type<C_TYPE>::value;
 
   size_t unroll_count = entry_count & 0xFFFFFFFFFFFFFFF8ULL;
@@ -218,7 +237,7 @@
     valid = vals[i + 7] != null_val;
     valid_byte |= valid << 7;
     null_count += !valid;
-    is_valid[i >> 3] = valid_byte;
+    is_valid_data[i >> 3] = valid_byte;
   }
   if (unroll_count != entry_count) {
     uint8_t valid_byte = 0;
@@ -227,7 +246,7 @@
       valid_byte |= valid << (i & 7);
       null_count += !valid;
     }
-    is_valid[unroll_count >> 3] = valid_byte;
+    is_valid_data[unroll_count >> 3] = valid_byte;
   }
 
   if (!null_count) {
@@ -236,14 +255,10 @@
 
   // TODO: support date/time + scaling
   // TODO: support booleans
-  std::shared_ptr<Buffer> data(new Buffer(reinterpret_cast<const uint8_t*>(data_ptr),
-                                          entry_count * sizeof(C_TYPE)));
   if (null_count) {
-    std::shared_ptr<Buffer> null_bitmap(
-        new Buffer(is_valid.get(), (entry_count + 7) / 8));
-    out.reset(new NumericArray<ARROW_TYPE>(entry_count, data, null_bitmap, null_count));
+    out.reset(new NumericArray<ARROW_TYPE>(entry_count, values, is_valid, null_count));
   } else {
-    out.reset(new NumericArray<ARROW_TYPE>(entry_count, data));
+    out.reset(new NumericArray<ARROW_TYPE>(entry_count, values));
   }
 }
 
@@ -701,9 +716,7 @@
     return seg_row_count;
   };
 
-  auto convert_columns = [&](std::vector<std::unique_ptr<int8_t[]>>& values,
-                             std::vector<std::unique_ptr<uint8_t[]>>& is_valid,
-                             std::vector<std::shared_ptr<arrow::Array>>& result,
+  auto convert_columns = [&](std::vector<std::shared_ptr<arrow::Array>>& result,
                              const std::vector<bool>& non_lazy_cols,
                              const size_t start_col,
                              const size_t end_col) {
@@ -715,28 +728,22 @@
       const auto& column = builders[col];
       switch (column.physical_type) {
         case kTINYINT:
-          convert_column<int8_t>(
-              results_, col, values[col], is_valid[col], entry_count, result[col]);
+          convert_column<int8_t>(results_, col, entry_count, result[col]);
           break;
         case kSMALLINT:
-          convert_column<int16_t>(
-              results_, col, values[col], is_valid[col], entry_count, result[col]);
+          convert_column<int16_t>(results_, col, entry_count, result[col]);
           break;
         case kINT:
-          convert_column<int32_t>(
-              results_, col, values[col], is_valid[col], entry_count, result[col]);
+          convert_column<int32_t>(results_, col, entry_count, result[col]);
           break;
         case kBIGINT:
-          convert_column<int64_t>(
-              results_, col, values[col], is_valid[col], entry_count, result[col]);
+          convert_column<int64_t>(results_, col, entry_count, result[col]);
           break;
         case kFLOAT:
-          convert_column<float>(
-              results_, col, values[col], is_valid[col], entry_count, result[col]);
+          convert_column<float>(results_, col, entry_count, result[col]);
           break;
         case kDOUBLE:
-          convert_column<double>(
-              results_, col, values[col], is_valid[col], entry_count, result[col]);
+          convert_column<double>(results_, col, entry_count, result[col]);
           break;
         default:
           throw std::runtime_error(column.col_type.get_type_name() +
@@ -793,8 +800,6 @@
       non_lazy_col_pos.emplace_back(col_count);
     }
 
-    values_.resize(col_count);
-    is_valid_.resize(col_count);
     std::vector<std::future<void>> child_threads;
     size_t num_threads =
         std::min(multithreaded ? (size_t)cpu_threads() : (size_t)1, non_lazy_col_count);
@@ -810,8 +815,6 @@
           non_lazy_col_pos.empty() ? end_col : non_lazy_col_pos[end_col];
       child_threads.push_back(std::async(std::launch::async,
                                          convert_columns,
-                                         std::ref(values_),
-                                         std::ref(is_valid_),
                                          std::ref(result_columns),
                                          non_lazy_cols,
                                          phys_start_col,
diff -Naur ./QueryEngine/CMakeLists.txt ../omniscidb-master/QueryEngine/CMakeLists.txt
--- ./QueryEngine/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -141,6 +141,7 @@
 )
 
 if(ENABLE_CUDA)
+  message(DEBUG "QueryEngine CUDA_COMPILATION_ARCH: ${CUDA_COMPILATION_ARCH}")
   set(MAPD_DEFINITIONS "-DHAVE_CUDA")
   set(NVCC_BUILD_TYPE_ARGS)
   string(TOUPPER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_UPPERCASE)
@@ -224,10 +225,14 @@
         ${CMAKE_CURRENT_BINARY_DIR}/GeosRuntime.bc
     )
 
+set(TABLE_FUNCTION_HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/TableFunctions/TableFunctions.hpp ${CMAKE_CURRENT_SOURCE_DIR}/TableFunctions/TableFunctionsTesting.hpp)
+if(ENABLE_MLPACK)
+  list(APPEND TABLE_FUNCTION_HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/TableFunctions/MLFunctions.hpp)
+endif()
 add_custom_command(
-    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/TableFunctions/TableFunctions.hpp ${CMAKE_CURRENT_SOURCE_DIR}/TableFunctions/TableFunctionsTesting.hpp
+    DEPENDS ${TABLE_FUNCTION_HEADERS} 
     OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/TableFunctionsFactory_init.cpp
-    COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/scripts/generate_TableFunctionsFactory_init.py ${CMAKE_CURRENT_SOURCE_DIR}/TableFunctions/TableFunctions.hpp ${CMAKE_CURRENT_SOURCE_DIR}/TableFunctions/TableFunctionsTesting.hpp ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/TableFunctionsFactory_init.cpp)
+    COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/scripts/generate_TableFunctionsFactory_init.py ${TABLE_FUNCTION_HEADERS} ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/TableFunctionsFactory_init.cpp)
 
 add_custom_target(QueryEngineTableFunctionsFactory_init
     DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/TableFunctionsFactory_init.cpp)
diff -Naur ./QueryEngine/CgenState.cpp ../omniscidb-master/QueryEngine/CgenState.cpp
--- ./QueryEngine/CgenState.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/CgenState.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -17,6 +17,7 @@
 #include "CgenState.h"
 #include "OutputBufferInitialization.h"
 
+#include <llvm/IR/InstIterator.h>
 #include <llvm/Transforms/Utils/Cloning.h>
 
 extern std::unique_ptr<llvm::Module> g_rt_module;
@@ -139,26 +140,45 @@
   return ir_builder_.CreateFPCast(val, dst_type);
 }
 
+void CgenState::maybeCloneFunctionRecursive(llvm::Function* fn) {
+  CHECK(fn);
+  if (!fn->isDeclaration()) {
+    return;
+  }
+
+  // Get the implementation from the runtime module.
+  auto func_impl = g_rt_module->getFunction(fn->getName());
+  CHECK(func_impl) << fn->getName().str();
+
+  if (func_impl->isDeclaration()) {
+    return;
+  }
+
+  auto DestI = fn->arg_begin();
+  for (auto arg_it = func_impl->arg_begin(); arg_it != func_impl->arg_end(); ++arg_it) {
+    DestI->setName(arg_it->getName());
+    vmap_[&*arg_it] = &*DestI++;
+  }
+
+  llvm::SmallVector<llvm::ReturnInst*, 8> Returns;  // Ignore returns cloned.
+  llvm::CloneFunctionInto(fn, func_impl, vmap_, /*ModuleLevelChanges=*/true, Returns);
+
+  for (auto it = llvm::inst_begin(fn), e = llvm::inst_end(fn); it != e; ++it) {
+    if (llvm::isa<llvm::CallInst>(*it)) {
+      auto& call = llvm::cast<llvm::CallInst>(*it);
+      maybeCloneFunctionRecursive(call.getCalledFunction());
+    }
+  }
+}
+
 llvm::Value* CgenState::emitCall(const std::string& fname,
                                  const std::vector<llvm::Value*>& args) {
-  // Get the implementation from the runtime module.
-  auto func_impl = g_rt_module->getFunction(fname);
-  CHECK(func_impl) << fname;
   // Get the function reference from the query module.
   auto func = module_->getFunction(fname);
   CHECK(func);
   // If the function called isn't external, clone the implementation from the runtime
   // module.
-  if (func->isDeclaration() && !func_impl->isDeclaration()) {
-    auto DestI = func->arg_begin();
-    for (auto arg_it = func_impl->arg_begin(); arg_it != func_impl->arg_end(); ++arg_it) {
-      DestI->setName(arg_it->getName());
-      vmap_[&*arg_it] = &*DestI++;
-    }
-
-    llvm::SmallVector<llvm::ReturnInst*, 8> Returns;  // Ignore returns cloned.
-    llvm::CloneFunctionInto(func, func_impl, vmap_, /*ModuleLevelChanges=*/true, Returns);
-  }
+  maybeCloneFunctionRecursive(func);
 
   return ir_builder_.CreateCall(func, args);
 }
diff -Naur ./QueryEngine/CgenState.h ../omniscidb-master/QueryEngine/CgenState.h
--- ./QueryEngine/CgenState.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/CgenState.h	2021-04-21 00:02:57.000000000 +0300
@@ -412,6 +412,8 @@
     return literal_bytes_[device_id] - lit_bytes;
   }
 
+  void maybeCloneFunctionRecursive(llvm::Function* fn);
+
   std::unordered_map<int, LiteralValues> literals_;
   std::unordered_map<int, size_t> literal_bytes_;
 };
diff -Naur ./QueryEngine/ColumnFetcher.cpp ../omniscidb-master/QueryEngine/ColumnFetcher.cpp
--- ./QueryEngine/ColumnFetcher.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ColumnFetcher.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -58,19 +58,24 @@
     std::vector<std::shared_ptr<Chunk_NS::Chunk>>& chunks_owner,
     ColumnCacheMap& column_cache) {
   static std::mutex columnar_conversion_mutex;
+  auto timer = DEBUG_TIMER(__func__);
   if (fragment.isEmptyPhysicalFragment()) {
     return {nullptr, 0};
   }
   const auto table_id = hash_col.get_table_id();
-  auto chunk_meta_it = fragment.getChunkMetadataMap().find(hash_col.get_column_id());
-  CHECK(chunk_meta_it != fragment.getChunkMetadataMap().end());
   const auto& catalog = *executor->getCatalog();
   const auto cd =
       get_column_descriptor_maybe(hash_col.get_column_id(), table_id, catalog);
   CHECK(!cd || !(cd->isVirtualCol));
   const int8_t* col_buff = nullptr;
-
   if (cd) {  // real table
+    /* chunk_meta_it is used here to retrieve chunk numBytes and
+       numElements. Apparently, their values are often zeros. If we
+       knew how to predict the zero values, calling
+       getChunkMetadataMap could be avoided to skip
+       synthesize_metadata calls. */
+    auto chunk_meta_it = fragment.getChunkMetadataMap().find(hash_col.get_column_id());
+    CHECK(chunk_meta_it != fragment.getChunkMetadataMap().end());
     ChunkKey chunk_key{catalog.getCurrentDB().dbId,
                        fragment.physicalTableId,
                        hash_col.get_column_id(),
@@ -277,7 +282,7 @@
   const InputColDescriptor col_desc(col_id, table_id, int(0));
   CHECK(col_desc.getScanDesc().getSourceType() == InputSourceType::TABLE);
   {
-    std::lock_guard<std::mutex> columnar_conversion_guard(columnar_conversion_mutex_);
+    std::lock_guard<std::mutex> columnar_conversion_guard(columnar_fetch_mutex_);
     auto column_it = columnarized_scan_table_cache_.find(col_desc);
     if (column_it == columnarized_scan_table_cache_.end()) {
       for (size_t frag_id = 0; frag_id < frag_count; ++frag_id) {
@@ -341,6 +346,127 @@
                             thread_idx);
 }
 
+const int8_t* ColumnFetcher::linearizeColumnFragments(
+    const int table_id,
+    const int col_id,
+    const std::map<int, const TableFragments*>& all_tables_fragments,
+    std::list<std::shared_ptr<Chunk_NS::Chunk>>& chunk_holder,
+    std::list<ChunkIter>& chunk_iter_holder,
+    const Data_Namespace::MemoryLevel memory_level,
+    const int device_id,
+    DeviceAllocator* device_allocator,
+    const size_t thread_idx) const {
+  // todo(yoonmin): True varlen col linearization
+  const auto fragments_it = all_tables_fragments.find(table_id);
+  CHECK(fragments_it != all_tables_fragments.end());
+  const auto fragments = fragments_it->second;
+  const auto frag_count = fragments->size();
+  const InputColDescriptor col_desc(col_id, table_id, int(0));
+  const auto& cat = *executor_->getCatalog();
+  auto cd = get_column_descriptor(col_id, table_id, cat);
+  CHECK(cd);
+  CHECK(col_desc.getScanDesc().getSourceType() == InputSourceType::TABLE);
+  CHECK_GT(table_id, 0);
+  size_t total_num_tuples = 0;
+  size_t total_data_buf_size = 0;
+  size_t total_idx_buf_size = 0;
+
+  std::lock_guard<std::mutex> linearize_guard(columnar_fetch_mutex_);
+  auto linearized_iter_it = linearized_multi_frag_chunk_iter_cache_.find(col_desc);
+  if (linearized_iter_it != linearized_multi_frag_chunk_iter_cache_.end()) {
+    if (memory_level == CPU_LEVEL) {
+      return getChunkiter(col_desc, 0);
+    } else {
+      // todo(yoonmin): D2D copy of merged chunk and its iter?
+      if (linearized_iter_it->second.find(device_id) !=
+          linearized_iter_it->second.end()) {
+        auto chunk_iter_gpu = device_allocator->alloc(sizeof(ChunkIter));
+        device_allocator->copyToDevice(
+            chunk_iter_gpu, getChunkiter(col_desc, device_id), sizeof(ChunkIter));
+        return chunk_iter_gpu;
+      }
+    }
+  }
+
+  // collect target fragments
+  // in GPU execution, we first load chunks in CPU, and only merge them in GPU
+  std::shared_ptr<Chunk_NS::Chunk> chunk;
+  std::list<std::shared_ptr<Chunk_NS::Chunk>> local_chunk_holder;
+  std::list<ChunkIter> local_chunk_iter_holder;
+  for (size_t frag_id = 0; frag_id < frag_count; ++frag_id) {
+    const auto& fragment = (*fragments)[frag_id];
+    if (fragment.isEmptyPhysicalFragment()) {
+      continue;
+    }
+    auto chunk_meta_it = fragment.getChunkMetadataMap().find(col_id);
+    CHECK(chunk_meta_it != fragment.getChunkMetadataMap().end());
+    ChunkKey chunk_key{
+        cat.getCurrentDB().dbId, fragment.physicalTableId, col_id, fragment.fragmentId};
+    chunk = Chunk_NS::Chunk::getChunk(cd,
+                                      &cat.getDataMgr(),
+                                      chunk_key,
+                                      Data_Namespace::CPU_LEVEL,
+                                      0,
+                                      chunk_meta_it->second->numBytes,
+                                      chunk_meta_it->second->numElements);
+    local_chunk_holder.push_back(chunk);
+    local_chunk_iter_holder.push_back(chunk->begin_iterator(chunk_meta_it->second));
+    total_num_tuples += fragment.getNumTuples();
+    total_data_buf_size += chunk->getBuffer()->size();
+    if (chunk->getIndexBuf()) {
+      total_idx_buf_size += chunk->getIndexBuf()->size();
+    }
+  }
+  // linearize collected fragments
+  // todo(yoonmin): parallelize this step
+  auto merged_chunk_buffer =
+      cat.getDataMgr().alloc(memory_level,
+                             memory_level == Data_Namespace::CPU_LEVEL ? 0 : device_id,
+                             total_data_buf_size);
+  size_t sum_chunk_sizes = 0;
+  for (auto chunk_holder_it = local_chunk_holder.begin();
+       chunk_holder_it != local_chunk_holder.end();
+       chunk_holder_it++) {
+    if (g_enable_non_kernel_time_query_interrupt && check_interrupt()) {
+      cat.getDataMgr().free(merged_chunk_buffer);
+      throw QueryExecutionError(Executor::ERR_INTERRUPTED);
+    }
+    auto target_chunk = chunk_holder_it->get();
+    auto target_chunk_buffer = target_chunk->getBuffer();
+    merged_chunk_buffer->append(
+        target_chunk_buffer->getMemoryPtr(),
+        target_chunk_buffer->size(),
+        Data_Namespace::CPU_LEVEL,
+        memory_level == Data_Namespace::CPU_LEVEL ? 0 : device_id);
+    sum_chunk_sizes += target_chunk_buffer->size();
+  }
+  // check whether each chunk's data buffer is clean under chunk merging
+  CHECK_EQ(total_data_buf_size, sum_chunk_sizes);
+
+  // make ChunkIter for the linearized chunk
+  // todo(yoonmin): cache for merged chunk?
+  auto merged_chunk = std::make_shared<Chunk_NS::Chunk>(merged_chunk_buffer, nullptr, cd);
+  auto merged_chunk_iter = prepareChunkIter(
+      merged_chunk_buffer, *(chunk_iter_holder.begin()), total_num_tuples);
+  chunk_holder.push_back(merged_chunk);
+  chunk_iter_holder.push_back(merged_chunk_iter);
+  auto merged_chunk_iter_ptr = reinterpret_cast<int8_t*>(&(chunk_iter_holder.back()));
+  if (memory_level == MemoryLevel::CPU_LEVEL) {
+    addMergedChunk(col_desc, 0, merged_chunk, merged_chunk_iter_ptr);
+    return merged_chunk_iter_ptr;
+  } else {
+    CHECK_EQ(Data_Namespace::GPU_LEVEL, memory_level);
+    CHECK(device_allocator);
+    auto ab = merged_chunk->getBuffer();
+    ab->pin();
+    addMergedChunk(col_desc, device_id, merged_chunk, merged_chunk_iter_ptr);
+    auto chunk_iter_gpu = device_allocator->alloc(sizeof(ChunkIter));
+    device_allocator->copyToDevice(
+        chunk_iter_gpu, merged_chunk_iter_ptr, sizeof(ChunkIter));
+    return chunk_iter_gpu;
+  }
+}
+
 const int8_t* ColumnFetcher::transferColumnIfNeeded(
     const ColumnarResults* columnar_results,
     const int col_id,
@@ -364,6 +490,78 @@
   return col_buffers[col_id];
 }
 
+void ColumnFetcher::addMergedChunk(const InputColDescriptor col_desc,
+                                   const int device_id,
+                                   std::shared_ptr<Chunk_NS::Chunk> chunk_ptr,
+                                   int8_t* chunk_iter_ptr) const {
+  // 1. merged_chunk_ptr
+  auto chunk_it = linearized_multi_frag_table_cache_.find(col_desc);
+  if (chunk_it != linearized_multi_frag_table_cache_.end()) {
+    auto chunk_device_it = chunk_it->second.find(device_id);
+    if (chunk_device_it == chunk_it->second.end()) {
+      VLOG(2) << "Additional merged chunk for col_desc (tbl: "
+              << col_desc.getScanDesc().getTableId() << ", col: " << col_desc.getColId()
+              << "), device: " << device_id;
+      chunk_it->second.emplace(device_id, chunk_ptr);
+    }
+  } else {
+    DeviceMergedChunkMap chunk_m;
+    chunk_m.emplace(device_id, chunk_ptr);
+    VLOG(2) << "New merged chunk for col_desc (tbl: "
+            << col_desc.getScanDesc().getTableId() << ", col: " << col_desc.getColId()
+            << "), device: " << device_id;
+    linearized_multi_frag_table_cache_.emplace(col_desc, chunk_m);
+  }
+
+  // 2. merged_chunk_iter_ptr
+  auto iter_it = linearized_multi_frag_chunk_iter_cache_.find(col_desc);
+  if (iter_it != linearized_multi_frag_chunk_iter_cache_.end()) {
+    auto iter_device_it = iter_it->second.find(device_id);
+    if (iter_device_it == iter_it->second.end()) {
+      VLOG(2) << "Additional merged chunk_iter for col_desc (tbl: "
+              << col_desc.getScanDesc().getTableId() << ", col: " << col_desc.getColId()
+              << "), device: " << device_id;
+      iter_it->second.emplace(device_id, chunk_iter_ptr);
+    }
+  } else {
+    DeviceMergedChunkIterMap iter_m;
+    iter_m.emplace(device_id, chunk_iter_ptr);
+    VLOG(2) << "New merged chunk_iter for col_desc (tbl: "
+            << col_desc.getScanDesc().getTableId() << ", col: " << col_desc.getColId()
+            << "), device: " << device_id;
+    linearized_multi_frag_chunk_iter_cache_.emplace(col_desc, iter_m);
+  }
+}
+
+const int8_t* ColumnFetcher::getChunkiter(const InputColDescriptor col_desc,
+                                          const int device_id) const {
+  auto linearized_chunk_iter_it = linearized_multi_frag_chunk_iter_cache_.find(col_desc);
+  if (linearized_chunk_iter_it != linearized_multi_frag_chunk_iter_cache_.end()) {
+    auto dev_iter_map_it = linearized_chunk_iter_it->second.find(device_id);
+    if (dev_iter_map_it != linearized_chunk_iter_it->second.end()) {
+      VLOG(2) << "Recycle merged chunk_iter for col_desc (tbl: "
+              << col_desc.getScanDesc().getTableId() << ", col: " << col_desc.getColId()
+              << "), device: " << device_id;
+      return dev_iter_map_it->second;
+    }
+  }
+  return nullptr;
+}
+
+ChunkIter ColumnFetcher::prepareChunkIter(AbstractBuffer* merged,
+                                          ChunkIter& chunk_iter,
+                                          const size_t total_num_tuples) const {
+  ChunkIter merged_chunk_iter;
+  merged_chunk_iter.start_pos = merged->getMemoryPtr();
+  merged_chunk_iter.current_pos = merged_chunk_iter.start_pos;
+  merged_chunk_iter.end_pos = merged->getMemoryPtr() + merged->size();
+  merged_chunk_iter.num_elems = total_num_tuples;
+  merged_chunk_iter.skip = chunk_iter.skip;
+  merged_chunk_iter.skip_size = chunk_iter.skip_size;
+  merged_chunk_iter.type_info = chunk_iter.type_info;
+  return merged_chunk_iter;
+}
+
 const int8_t* ColumnFetcher::getResultSetColumn(
     const ResultSetPtr& buffer,
     const int table_id,
@@ -374,7 +572,7 @@
     const size_t thread_idx) const {
   const ColumnarResults* result{nullptr};
   {
-    std::lock_guard<std::mutex> columnar_conversion_guard(columnar_conversion_mutex_);
+    std::lock_guard<std::mutex> columnar_conversion_guard(columnar_fetch_mutex_);
     if (columnarized_table_cache_.empty() || !columnarized_table_cache_.count(table_id)) {
       columnarized_table_cache_.insert(std::make_pair(
           table_id, std::unordered_map<int, std::shared_ptr<const ColumnarResults>>()));
diff -Naur ./QueryEngine/ColumnFetcher.h ../omniscidb-master/QueryEngine/ColumnFetcher.h
--- ./QueryEngine/ColumnFetcher.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ColumnFetcher.h	2021-04-21 00:02:57.000000000 +0300
@@ -99,6 +99,17 @@
                                    DeviceAllocator* device_allocator,
                                    const size_t thread_idx) const;
 
+  const int8_t* linearizeColumnFragments(
+      const int table_id,
+      const int col_id,
+      const std::map<int, const TableFragments*>& all_tables_fragments,
+      std::list<std::shared_ptr<Chunk_NS::Chunk>>& chunk_holder,
+      std::list<ChunkIter>& chunk_iter_holder,
+      const Data_Namespace::MemoryLevel memory_level,
+      const int device_id,
+      DeviceAllocator* device_allocator,
+      const size_t thread_idx) const;
+
  private:
   static const int8_t* transferColumnIfNeeded(
       const ColumnarResults* columnar_results,
@@ -108,6 +119,18 @@
       const int device_id,
       DeviceAllocator* device_allocator);
 
+  void addMergedChunk(const InputColDescriptor col_desc,
+                      const int device_id,
+                      std::shared_ptr<Chunk_NS::Chunk> chunk_ptr,
+                      int8_t* chunk_iter_ptr) const;
+
+  const int8_t* getChunkiter(const InputColDescriptor col_desc,
+                             const int device_id = 0) const;
+
+  ChunkIter prepareChunkIter(AbstractBuffer* merged,
+                             ChunkIter& chunk_iter,
+                             const size_t total_num_tuples) const;
+
   const int8_t* getResultSetColumn(const ResultSetPtr& buffer,
                                    const int table_id,
                                    const int col_id,
@@ -118,7 +141,7 @@
 
   Executor* executor_;
   using CacheKey = std::vector<int>;
-  mutable std::mutex columnar_conversion_mutex_;
+  mutable std::mutex columnar_fetch_mutex_;
   mutable ColumnCacheMap columnarized_table_cache_;
   mutable std::unordered_map<
       InputColDescriptor,
@@ -126,6 +149,12 @@
       columnarized_ref_table_cache_;
   mutable std::unordered_map<InputColDescriptor, std::unique_ptr<const ColumnarResults>>
       columnarized_scan_table_cache_;
+  using DeviceMergedChunkMap = std::unordered_map<int, std::shared_ptr<Chunk_NS::Chunk>>;
+  mutable std::unordered_map<InputColDescriptor, DeviceMergedChunkMap>
+      linearized_multi_frag_table_cache_;
+  using DeviceMergedChunkIterMap = std::unordered_map<int, int8_t*>;
+  mutable std::unordered_map<InputColDescriptor, DeviceMergedChunkIterMap>
+      linearized_multi_frag_chunk_iter_cache_;
 
   friend class QueryCompilationDescriptor;
   friend class TableFunctionExecutionContext;  // TODO(adb)
diff -Naur ./QueryEngine/ColumnIR.cpp ../omniscidb-master/QueryEngine/ColumnIR.cpp
--- ./QueryEngine/ColumnIR.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ColumnIR.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -577,6 +577,10 @@
           // physical col without geospatial type info
           return nullptr;
         }
+        if (is_constructed_point(eq_left_op)) {
+          // skip cast for a constructed point lhs
+          return nullptr;
+        }
         const auto eq_left_op_col = dynamic_cast<const Analyzer::ColumnVar*>(eq_left_op);
         CHECK(eq_left_op_col);
         if (eq_left_op_col->get_rte_idx() != 0) {
diff -Naur ./QueryEngine/DateAdd.cpp ../omniscidb-master/QueryEngine/DateAdd.cpp
--- ./QueryEngine/DateAdd.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/DateAdd.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -75,9 +75,9 @@
 
 }  // namespace
 
-extern "C" ALWAYS_INLINE DEVICE int64_t DateAdd(DateaddField field,
-                                                const int64_t number,
-                                                const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t DateAdd(DateaddField field,
+                                                               const int64_t number,
+                                                               const int64_t timeval) {
   switch (field) {
     case daSECOND:
       return timeval + number;
@@ -113,10 +113,11 @@
 }
 
 // The dimension of the return value is always equal to the timeval dimension.
-extern "C" ALWAYS_INLINE DEVICE int64_t DateAddHighPrecision(DateaddField field,
-                                                             const int64_t number,
-                                                             const int64_t timeval,
-                                                             const int32_t dim) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+DateAddHighPrecision(DateaddField field,
+                     const int64_t number,
+                     const int64_t timeval,
+                     const int32_t dim) {
   // Valid only for i=0, 3, 6, 9.
   constexpr unsigned pow10[10]{
       1, 0, 0, 1000, 0, 0, 1000 * 1000, 0, 0, 1000 * 1000 * 1000};
@@ -141,17 +142,18 @@
   }
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t DateAddNullable(const DateaddField field,
-                                                        const int64_t number,
-                                                        const int64_t timeval,
-                                                        const int64_t null_val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+DateAddNullable(const DateaddField field,
+                const int64_t number,
+                const int64_t timeval,
+                const int64_t null_val) {
   if (timeval == null_val) {
     return null_val;
   }
   return DateAdd(field, number, timeval);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 DateAddHighPrecisionNullable(const DateaddField field,
                              const int64_t number,
                              const int64_t timeval,
diff -Naur ./QueryEngine/DateTruncate.cpp ../omniscidb-master/QueryEngine/DateTruncate.cpp
--- ./QueryEngine/DateTruncate.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/DateTruncate.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -30,19 +30,20 @@
 #include <iostream>
 #include <limits>
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_minute(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t datetrunc_minute(int64_t timeval) {
   return timeval - unsigned_mod(timeval, kSecsPerMin);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_hour(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t datetrunc_hour(int64_t timeval) {
   return timeval - unsigned_mod(timeval, kSecsPerHour);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_quarterday(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+datetrunc_quarterday(int64_t timeval) {
   return timeval - unsigned_mod(timeval, kSecsPerQuarterDay);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_day(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t datetrunc_day(int64_t timeval) {
   return timeval - unsigned_mod(timeval, kSecsPerDay);
 }
 
@@ -59,20 +60,23 @@
   return timeval - unsigned_mod(timeval + OFFSET * kSecsPerDay, 7 * kSecsPerDay);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_week_monday(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+datetrunc_week_monday(int64_t timeval) {
   return datetrunc_week<dtMONDAY>(timeval);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_week_sunday(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+datetrunc_week_sunday(int64_t timeval) {
   return datetrunc_week<dtSUNDAY>(timeval);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_week_saturday(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+datetrunc_week_saturday(int64_t timeval) {
   return datetrunc_week<dtSATURDAY>(timeval);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_month(int64_t timeval) {
-  if (timeval >= 0L && timeval <= UINT32_MAX - (kEpochOffsetYear1900)) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t datetrunc_month(int64_t timeval) {
+  if (timeval >= 0LL && timeval <= UINT32_MAX - (kEpochOffsetYear1900)) {
     STATIC_QUAL const uint32_t cumulative_month_epoch_starts[kMonsPerYear] = {0,
                                                                               2678400,
                                                                               5270400,
@@ -119,8 +123,9 @@
   }
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_quarter(int64_t timeval) {
-  if (timeval >= 0L && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+datetrunc_quarter(int64_t timeval) {
+  if (timeval >= 0LL && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
     STATIC_QUAL const uint32_t cumulative_quarter_epoch_starts[4] = {
         0, 7776000, 15638400, 23587200};
     STATIC_QUAL const uint32_t cumulative_quarter_epoch_starts_leap_year[4] = {
@@ -162,8 +167,8 @@
   }
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_year(int64_t timeval) {
-  if (timeval >= 0L && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t datetrunc_year(int64_t timeval) {
+  if (timeval >= 0LL && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
     // Handles times from Thu 01 Jan 1970 00:00:00 - Thu 07 Feb 2036 06:28:15.
     uint32_t seconds_1900 = static_cast<uint32_t>(timeval) + kEpochOffsetYear1900;
     uint32_t leap_years = (seconds_1900 - kSecsJanToMar1900) / kSecondsPer4YearCycle;
@@ -187,7 +192,7 @@
   }
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_decade(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t datetrunc_decade(int64_t timeval) {
   // Number of days from x00301 to (x+1)00101. Always includes exactly two leap days.
   constexpr unsigned decmarjan = MARJAN + 9 * 365 + 2;
   int64_t const day = floor_div(timeval, kSecsPerDay);
@@ -205,7 +210,8 @@
   return (day - days_after_decade) * kSecsPerDay;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_century(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+datetrunc_century(int64_t timeval) {
   int64_t const day = floor_div(timeval, kSecsPerDay);
   unsigned const doe = unsigned_mod(day - kEpochAdjustedDays, kDaysPer400Years);
   // Day-of-century = Days since last 010101 (Jan 1 1901, 2001, 2101, etc.)
@@ -213,7 +219,8 @@
   return (day - doc) * kSecsPerDay;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t datetrunc_millennium(int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+datetrunc_millennium(int64_t timeval) {
   constexpr unsigned millennium2001 = 365242;  // Days from Jan 1 2001 to 3001.
   int64_t const day = floor_div(timeval, kSecsPerDay);
   // lcm(400, 1000) = 2000 so use 5*400-year eras at a time.
@@ -274,12 +281,12 @@
 }
 
 // scale is 10^{3,6,9}
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 DateTruncateHighPrecisionToDate(const int64_t timeval, const int64_t scale) {
   return floor_div(timeval, scale * kSecsPerDay) * kSecsPerDay;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 DateTruncateHighPrecisionToDateNullable(const int64_t timeval,
                                         const int64_t scale,
                                         const int64_t null_val) {
@@ -386,9 +393,9 @@
 
 }  // namespace
 
-extern "C" DEVICE int64_t DateDiff(const DatetruncField datepart,
-                                   const int64_t startdate,
-                                   const int64_t enddate) {
+extern "C" RUNTIME_EXPORT DEVICE int64_t DateDiff(const DatetruncField datepart,
+                                                  const int64_t startdate,
+                                                  const int64_t enddate) {
   switch (datepart) {
     case dtNANOSECOND:
       return (enddate - startdate) * kNanoSecsPerSec;
@@ -415,11 +422,12 @@
   }
 }
 
-extern "C" DEVICE int64_t DateDiffHighPrecision(const DatetruncField datepart,
-                                                const int64_t startdate,
-                                                const int64_t enddate,
-                                                const int32_t start_dim,
-                                                const int32_t end_dim) {
+extern "C" RUNTIME_EXPORT DEVICE int64_t
+DateDiffHighPrecision(const DatetruncField datepart,
+                      const int64_t startdate,
+                      const int64_t enddate,
+                      const int32_t start_dim,
+                      const int32_t end_dim) {
   // Return pow(10,i). Only valid for i = 0, 3, 6, 9.
   constexpr int pow10[10]{1, 0, 0, 1000, 0, 0, 1000 * 1000, 0, 0, 1000 * 1000 * 1000};
   switch (datepart) {
@@ -450,22 +458,23 @@
   }
 }
 
-extern "C" DEVICE int64_t DateDiffNullable(const DatetruncField datepart,
-                                           const int64_t startdate,
-                                           const int64_t enddate,
-                                           const int64_t null_val) {
+extern "C" RUNTIME_EXPORT DEVICE int64_t DateDiffNullable(const DatetruncField datepart,
+                                                          const int64_t startdate,
+                                                          const int64_t enddate,
+                                                          const int64_t null_val) {
   if (startdate == null_val || enddate == null_val) {
     return null_val;
   }
   return DateDiff(datepart, startdate, enddate);
 }
 
-extern "C" DEVICE int64_t DateDiffHighPrecisionNullable(const DatetruncField datepart,
-                                                        const int64_t startdate,
-                                                        const int64_t enddate,
-                                                        const int32_t start_dim,
-                                                        const int32_t end_dim,
-                                                        const int64_t null_val) {
+extern "C" RUNTIME_EXPORT DEVICE int64_t
+DateDiffHighPrecisionNullable(const DatetruncField datepart,
+                              const int64_t startdate,
+                              const int64_t enddate,
+                              const int32_t start_dim,
+                              const int32_t end_dim,
+                              const int64_t null_val) {
   if (startdate == null_val || enddate == null_val) {
     return null_val;
   }
diff -Naur ./QueryEngine/DateTruncate.h ../omniscidb-master/QueryEngine/DateTruncate.h
--- ./QueryEngine/DateTruncate.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/DateTruncate.h	2021-04-21 00:02:57.000000000 +0300
@@ -71,7 +71,7 @@
 
 int64_t DateTruncate(DatetruncField field, const int64_t timeval);
 
-extern "C" DEVICE int64_t DateTruncateHighPrecisionToDate(const int64_t timeval,
-                                                          const int64_t scale);
+extern "C" RUNTIME_EXPORT DEVICE int64_t
+DateTruncateHighPrecisionToDate(const int64_t timeval, const int64_t scale);
 
 #endif  // QUERYENGINE_DATETRUNCATE_H
diff -Naur ./QueryEngine/DecodersImpl.h ../omniscidb-master/QueryEngine/DecodersImpl.h
--- ./QueryEngine/DecodersImpl.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/DecodersImpl.h	2021-04-21 00:02:57.000000000 +0300
@@ -48,8 +48,12 @@
 #ifdef __CUDACC__
       return -1;
 #else
+#ifdef _WIN32
+      return LLONG_MIN + 1;
+#else
       return std::numeric_limits<int64_t>::min() + 1;
 #endif
+#endif
   }
 }
 
@@ -74,8 +78,12 @@
 #ifdef __CUDACC__
       return -1;
 #else
+#ifdef _WIN32
+      return LLONG_MIN + 1;
+#else
       return std::numeric_limits<int64_t>::min() + 1;
 #endif
+#endif
   }
 }
 
diff -Naur ./QueryEngine/Descriptors/QueryCompilationDescriptor.cpp ../omniscidb-master/QueryEngine/Descriptors/QueryCompilationDescriptor.cpp
--- ./QueryEngine/Descriptors/QueryCompilationDescriptor.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/Descriptors/QueryCompilationDescriptor.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -43,7 +43,8 @@
         co,
         eo,
         cat->getDataMgr().getCudaMgr(),
-        co.allow_lazy_fetch,  // TODO(adb): remove param and just read from CO
+        g_enable_lazy_fetch &&
+            co.allow_lazy_fetch,  // TODO(adb): remove param and just read from CO
         executor->row_set_mem_owner_,
         max_groups_buffer_entry_guess,
         crt_min_byte_width,
diff -Naur ./QueryEngine/Descriptors/QueryMemoryDescriptor.cpp ../omniscidb-master/QueryEngine/Descriptors/QueryMemoryDescriptor.cpp
--- ./QueryEngine/Descriptors/QueryMemoryDescriptor.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/Descriptors/QueryMemoryDescriptor.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -1154,6 +1154,7 @@
   str += "\tOutput Columnar: " + ::toString(output_columnar_) + "\n";
   str += "\tRender Output: " + ::toString(render_output_) + "\n";
   str += "\tUse Baseline Sort: " + ::toString(must_use_baseline_sort_) + "\n";
+  str += "\tIs Table Function: " + ::toString(is_table_function_) + "\n";
   return str;
 }
 
diff -Naur ./QueryEngine/Descriptors/RelAlgExecutionDescriptor.cpp ../omniscidb-master/QueryEngine/Descriptors/RelAlgExecutionDescriptor.cpp
--- ./QueryEngine/Descriptors/RelAlgExecutionDescriptor.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/Descriptors/RelAlgExecutionDescriptor.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -22,25 +22,36 @@
 #include "QueryEngine/RelAlgDagBuilder.h"
 
 ExecutionResult::ExecutionResult()
-    : result_(), targets_meta_(), filter_push_down_enabled_(false) {
-  std::vector<TargetInfo> target_infos;
-  result_ = nullptr;
-}
+    : filter_push_down_enabled_(false)
+    , success_(true)
+    , execution_time_ms_(0)
+    , type_(QueryResult) {}
 
 ExecutionResult::ExecutionResult(const std::shared_ptr<ResultSet>& rows,
                                  const std::vector<TargetMetaInfo>& targets_meta)
-    : result_(rows), targets_meta_(targets_meta), filter_push_down_enabled_(false) {}
+    : result_(rows)
+    , targets_meta_(targets_meta)
+    , filter_push_down_enabled_(false)
+    , success_(true)
+    , execution_time_ms_(0)
+    , type_(QueryResult) {}
 
 ExecutionResult::ExecutionResult(ResultSetPtr&& result,
                                  const std::vector<TargetMetaInfo>& targets_meta)
-    : targets_meta_(targets_meta), filter_push_down_enabled_(false) {
-  result_ = std::move(result);
-}
+    : result_(std::move(result))
+    , targets_meta_(targets_meta)
+    , filter_push_down_enabled_(false)
+    , success_(true)
+    , execution_time_ms_(0)
+    , type_(QueryResult) {}
 
 ExecutionResult::ExecutionResult(const ExecutionResult& that)
     : targets_meta_(that.targets_meta_)
     , pushed_down_filter_info_(that.pushed_down_filter_info_)
-    , filter_push_down_enabled_(that.filter_push_down_enabled_) {
+    , filter_push_down_enabled_(that.filter_push_down_enabled_)
+    , success_(true)
+    , execution_time_ms_(0)
+    , type_(QueryResult) {
   if (!pushed_down_filter_info_.empty() ||
       (filter_push_down_enabled_ && pushed_down_filter_info_.empty())) {
     return;
@@ -51,7 +62,10 @@
 ExecutionResult::ExecutionResult(ExecutionResult&& that)
     : targets_meta_(std::move(that.targets_meta_))
     , pushed_down_filter_info_(std::move(that.pushed_down_filter_info_))
-    , filter_push_down_enabled_(std::move(that.filter_push_down_enabled_)) {
+    , filter_push_down_enabled_(std::move(that.filter_push_down_enabled_))
+    , success_(true)
+    , execution_time_ms_(0)
+    , type_(QueryResult) {
   if (!pushed_down_filter_info_.empty() ||
       (filter_push_down_enabled_ && pushed_down_filter_info_.empty())) {
     return;
@@ -63,7 +77,10 @@
     const std::vector<PushedDownFilterInfo>& pushed_down_filter_info,
     bool filter_push_down_enabled)
     : pushed_down_filter_info_(pushed_down_filter_info)
-    , filter_push_down_enabled_(filter_push_down_enabled) {}
+    , filter_push_down_enabled_(filter_push_down_enabled)
+    , success_(true)
+    , execution_time_ms_(0)
+    , type_(QueryResult) {}
 
 ExecutionResult& ExecutionResult::operator=(const ExecutionResult& that) {
   if (!that.pushed_down_filter_info_.empty() ||
@@ -74,6 +91,9 @@
   }
   result_ = that.result_;
   targets_meta_ = that.targets_meta_;
+  success_ = that.success_;
+  execution_time_ms_ = that.execution_time_ms_;
+  type_ = that.type_;
   return *this;
 }
 
@@ -82,6 +102,23 @@
   return pushed_down_filter_info_;
 }
 
+void ExecutionResult::updateResultSet(const std::string& query,
+                                      RType type,
+                                      bool success) {
+  targets_meta_.clear();
+  pushed_down_filter_info_.clear();
+  success_ = success;
+  type_ = type;
+  result_ = std::make_shared<ResultSet>(query);
+}
+
+std::string ExecutionResult::getExplanation() {
+  if (!empty()) {
+    return getRows()->getExplanation();
+  }
+  return {};
+}
+
 void RaExecutionDesc::setResult(const ExecutionResult& result) {
   result_ = result;
   body_->setContextData(this);
diff -Naur ./QueryEngine/Descriptors/RelAlgExecutionDescriptor.h ../omniscidb-master/QueryEngine/Descriptors/RelAlgExecutionDescriptor.h
--- ./QueryEngine/Descriptors/RelAlgExecutionDescriptor.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/Descriptors/RelAlgExecutionDescriptor.h	2021-04-21 00:02:57.000000000 +0300
@@ -66,6 +66,20 @@
            ::toString(targets_meta_) + ")";
   }
 
+  enum RType { QueryResult, SimpleResult, Explaination, CalciteDdl };
+
+  std::string getExplanation();
+  void updateResultSet(const std::string& query_ra, RType type, bool success = true);
+  RType getResultType() const { return type_; }
+  void setResultType(RType type) { type_ = type; }
+  int64_t getExecutionTime() const { return execution_time_ms_; }
+  void setExecutionTime(int64_t execution_time_ms) {
+    execution_time_ms_ = execution_time_ms;
+  }
+  void addExecutionTime(int64_t execution_time_ms) {
+    execution_time_ms_ += execution_time_ms;
+  }
+
  private:
   ResultSetPtr result_;
   std::vector<TargetMetaInfo> targets_meta_;
@@ -73,6 +87,10 @@
   std::vector<PushedDownFilterInfo> pushed_down_filter_info_;
   // whether or not it was allowed to look for filters to push down
   bool filter_push_down_enabled_;
+
+  bool success_;
+  uint64_t execution_time_ms_;
+  RType type_;
 };
 
 class RelAlgNode;
diff -Naur ./QueryEngine/DynamicWatchdog.cpp ../omniscidb-master/QueryEngine/DynamicWatchdog.cpp
--- ./QueryEngine/DynamicWatchdog.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/DynamicWatchdog.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -33,7 +33,7 @@
 #endif
 }
 
-extern "C" uint64_t dynamic_watchdog_init(unsigned ms_budget) {
+extern "C" RUNTIME_EXPORT uint64_t dynamic_watchdog_init(unsigned ms_budget) {
   static uint64_t dw_cycle_start = 0ULL;
   static uint64_t dw_cycle_budget = 0ULL;
   static std::atomic_bool dw_abort{false};
@@ -67,7 +67,7 @@
 }
 
 // timeout detection
-extern "C" bool dynamic_watchdog() {
+extern "C" RUNTIME_EXPORT bool dynamic_watchdog() {
   auto clock = read_cycle_counter();
   auto dw_deadline = dynamic_watchdog_init(static_cast<unsigned>(DW_DEADLINE));
   if (clock > dw_deadline) {
diff -Naur ./QueryEngine/DynamicWatchdog.h ../omniscidb-master/QueryEngine/DynamicWatchdog.h
--- ./QueryEngine/DynamicWatchdog.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/DynamicWatchdog.h	2021-04-21 00:02:57.000000000 +0300
@@ -17,12 +17,14 @@
 #ifndef QUERYENGINE_DYNAMICWATCHDOG_H
 #define QUERYENGINE_DYNAMICWATCHDOG_H
 
+#include "Shared/funcannotations.h"
+
 #include <cstdint>
 
 enum DynamicWatchdogFlags { DW_DEADLINE = 0, DW_ABORT = -1, DW_RESET = -2 };
 
-extern "C" uint64_t dynamic_watchdog_init(unsigned ms_budget);
+extern "C" RUNTIME_EXPORT uint64_t dynamic_watchdog_init(unsigned ms_budget);
 
-extern "C" bool dynamic_watchdog();
+extern "C" RUNTIME_EXPORT bool dynamic_watchdog();
 
 #endif  // QUERYENGINE_DYNAMICWATCHDOG_H
diff -Naur ./QueryEngine/Execute.cpp ../omniscidb-master/QueryEngine/Execute.cpp
--- ./QueryEngine/Execute.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/Execute.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -110,6 +110,7 @@
 double g_bump_allocator_step_reduction{0.75};
 bool g_enable_direct_columnarization{true};
 extern bool g_enable_experimental_string_functions;
+bool g_enable_lazy_fetch{true};
 bool g_enable_runtime_query_interrupt{false};
 bool g_enable_non_kernel_time_query_interrupt{true};
 bool g_use_estimator_result_cache{true};
@@ -161,7 +162,7 @@
     const ExecutorId executor_id,
     const std::string& debug_dir,
     const std::string& debug_file,
-    const SystemParameters system_parameters) {
+    const SystemParameters& system_parameters) {
   INJECT_TIMER(getExecutor);
 
   mapd_unique_lock<mapd_shared_mutex> write_lock(executors_cache_mutex_);
@@ -1526,11 +1527,9 @@
       } catch (QueryExecutionError& e) {
         if (eo.with_dynamic_watchdog && interrupted_.load() &&
             e.getErrorCode() == ERR_OUT_OF_TIME) {
-          resetInterrupt();
           throw QueryExecutionError(ERR_INTERRUPTED);
         }
         if (e.getErrorCode() == ERR_INTERRUPTED) {
-          resetInterrupt();
           throw QueryExecutionError(ERR_INTERRUPTED);
         }
         if (e.getErrorCode() == ERR_OVERFLOW_OR_UNDERFLOW &&
@@ -2401,6 +2400,26 @@
   return fragments.size() > 1;
 }
 
+bool Executor::needLinearizeAllFragments(
+    const ColumnDescriptor* cd,
+    const InputColDescriptor& inner_col_desc,
+    const RelAlgExecutionUnit& ra_exe_unit,
+    const FragmentsList& selected_fragments,
+    const Data_Namespace::MemoryLevel memory_level) const {
+  const int nest_level = inner_col_desc.getScanDesc().getNestLevel();
+  const int table_id = inner_col_desc.getScanDesc().getTableId();
+  CHECK_LT(static_cast<size_t>(nest_level), selected_fragments.size());
+  CHECK_EQ(table_id, selected_fragments[nest_level].table_id);
+  const auto& fragments = selected_fragments[nest_level].fragment_ids;
+  auto need_linearize = cd->columnType.is_fixlen_array();
+  if (memory_level == MemoryLevel::GPU_LEVEL) {
+    // we disable multi-frag linearization for GPU case until we find the reason of
+    // CUDA 'misaligned address' issue, see #5245
+    need_linearize = false;
+  }
+  return table_id > 0 && need_linearize && fragments.size() > 1;
+}
+
 std::ostream& operator<<(std::ostream& os, FetchResult const& fetch_result) {
   return os << "col_buffers" << shared::printContainer(fetch_result.col_buffers)
             << " num_rows" << shared::printContainer(fetch_result.num_rows)
@@ -2450,12 +2469,10 @@
               checkIsQuerySessionInterrupted(query_session, session_read_lock);
         }
         if (isInterrupted) {
-          resetInterrupt();
           throw QueryExecutionError(ERR_INTERRUPTED);
         }
       }
       if (g_enable_dynamic_watchdog && interrupted_.load()) {
-        resetInterrupt();
         throw QueryExecutionError(ERR_INTERRUPTED);
       }
       CHECK(col_id);
@@ -2492,14 +2509,35 @@
                                               thread_idx);
       } else {
         if (needFetchAllFragments(*col_id, ra_exe_unit, selected_fragments)) {
-          frag_col_buffers[it->second] =
-              column_fetcher.getAllTableColumnFragments(table_id,
+          // determine if we need special treatment to linearlize multi-frag table
+          // i.e., a column that is classified as varlen type, i.e., array
+          // for now, we only support fixed-length array that contains
+          // geo point coordianates but we can support more types in this way
+          if (needLinearizeAllFragments(cd,
+                                        *col_id,
+                                        ra_exe_unit,
+                                        selected_fragments,
+                                        memory_level_for_column)) {
+            frag_col_buffers[it->second] =
+                column_fetcher.linearizeColumnFragments(table_id,
                                                         col_id->getColId(),
                                                         all_tables_fragments,
+                                                        chunks,
+                                                        chunk_iterators,
                                                         memory_level_for_column,
                                                         device_id,
                                                         device_allocator,
                                                         thread_idx);
+          } else {
+            frag_col_buffers[it->second] =
+                column_fetcher.getAllTableColumnFragments(table_id,
+                                                          col_id->getColId(),
+                                                          all_tables_fragments,
+                                                          memory_level_for_column,
+                                                          device_id,
+                                                          device_allocator,
+                                                          thread_idx);
+          }
         } else {
           frag_col_buffers[it->second] =
               column_fetcher.getOneTableColumnFragment(table_id,
@@ -2599,7 +2637,6 @@
               checkIsQuerySessionInterrupted(query_session, session_read_lock);
         }
         if (isInterrupted) {
-          resetInterrupt();
           throw QueryExecutionError(ERR_INTERRUPTED);
         }
       }
@@ -2675,6 +2712,15 @@
     all_frag_offsets.insert(
         all_frag_offsets.end(), frag_offsets.begin(), frag_offsets.end());
   }
+  // The hack below assumes a particular table traversal order which is not
+  // always achieved due to unordered map in the outermost loop. According
+  // to the code below we expect NULLs in even positions of all_frag_col_buffers[0]
+  // and odd positions of all_frag_col_buffers[1]. As an additional hack we
+  // swap these vectors if NULLs are not on expected positions.
+  if (all_frag_col_buffers[0].size() > 1 && all_frag_col_buffers[0][0] &&
+      !all_frag_col_buffers[0][1]) {
+    std::swap(all_frag_col_buffers[0], all_frag_col_buffers[1]);
+  }
   // UNION ALL hacks.
   VLOG(2) << "all_frag_col_buffers=" << shared::printContainer(all_frag_col_buffers);
   for (size_t i = 0; i < all_frag_col_buffers.front().size(); ++i) {
@@ -2838,12 +2884,10 @@
       isInterrupted = checkIsQuerySessionInterrupted(query_session, session_read_lock);
     }
     if (isInterrupted) {
-      resetInterrupt();
       throw QueryExecutionError(ERR_INTERRUPTED);
     }
   }
   if (g_enable_dynamic_watchdog && interrupted_.load()) {
-    resetInterrupt();
     throw QueryExecutionError(ERR_INTERRUPTED);
   }
   if (device_type == ExecutorDeviceType::CPU) {
@@ -3046,7 +3090,6 @@
       isInterrupted = checkIsQuerySessionInterrupted(query_session, session_read_lock);
     }
     if (isInterrupted) {
-      resetInterrupt();
       throw QueryExecutionError(ERR_INTERRUPTED);
     }
   }
@@ -3250,7 +3293,6 @@
     return {nullptr, "Overlaps hash join disabled, attempting to fall back to loop join"};
   }
   if (g_enable_dynamic_watchdog && interrupted_.load()) {
-    resetInterrupt();
     throw QueryExecutionError(ERR_INTERRUPTED);
   }
   try {
diff -Naur ./QueryEngine/Execute.h ../omniscidb-master/QueryEngine/Execute.h
--- ./QueryEngine/Execute.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/Execute.h	2021-04-21 00:02:57.000000000 +0300
@@ -22,6 +22,7 @@
 #include "CartesianProduct.h"
 #include "CgenState.h"
 #include "CodeCache.h"
+#include "CompilationOptions.h"
 #include "DateTimeUtils.h"
 #include "Descriptors/QueryFragmentDescriptor.h"
 #include "ExecutionKernel.h"
@@ -42,6 +43,7 @@
 
 #include "../Logger/Logger.h"
 #include "../Shared/SystemParameters.h"
+#include "../Shared/funcannotations.h"
 #include "../Shared/mapd_shared_mutex.h"
 #include "../Shared/measure.h"
 #include "../Shared/thread_count.h"
@@ -375,7 +377,7 @@
       const ExecutorId id,
       const std::string& debug_dir = "",
       const std::string& debug_file = "",
-      const SystemParameters system_parameters = SystemParameters());
+      const SystemParameters& system_parameters = SystemParameters());
 
   static void nukeCacheOfExecutors() {
     mapd_unique_lock<mapd_shared_mutex> flush_lock(
@@ -526,6 +528,12 @@
                              const RelAlgExecutionUnit& ra_exe_unit,
                              const FragmentsList& selected_fragments) const;
 
+  bool needLinearizeAllFragments(const ColumnDescriptor* cd,
+                                 const InputColDescriptor& inner_col_desc,
+                                 const RelAlgExecutionUnit& ra_exe_unit,
+                                 const FragmentsList& selected_fragments,
+                                 const Data_Namespace::MemoryLevel memory_level) const;
+
   using PerFragmentCallBack =
       std::function<void(ResultSetPtr, const Fragmenter_Namespace::FragmentInfo&)>;
 
@@ -1165,6 +1173,13 @@
          static_cast<const Analyzer::UOper*>(expr)->get_optype() == kUNNEST;
 }
 
+inline bool is_constructed_point(const Analyzer::Expr* expr) {
+  auto uoper = dynamic_cast<const Analyzer::UOper*>(expr);
+  auto oper = (uoper && uoper->get_optype() == kCAST) ? uoper->get_operand() : expr;
+  auto arr = dynamic_cast<const Analyzer::ArrayExpr*>(oper);
+  return (arr && arr->isLocalAlloc() && arr->get_type_info().is_fixlen_array());
+}
+
 bool is_trivial_loop_join(const std::vector<InputTableInfo>& query_infos,
                           const RelAlgExecutionUnit& ra_exe_unit);
 
@@ -1174,7 +1189,8 @@
                          const size_t cpu_count,
                          const size_t gpu_count);
 
-extern "C" void register_buffer_with_executor_rsm(int64_t exec, int8_t* buffer);
+extern "C" RUNTIME_EXPORT void register_buffer_with_executor_rsm(int64_t exec,
+                                                                 int8_t* buffer);
 
 const Analyzer::Expr* remove_cast_to_int(const Analyzer::Expr* expr);
 
diff -Naur ./QueryEngine/ExpressionRewrite.cpp ../omniscidb-master/QueryEngine/ExpressionRewrite.cpp
--- ./QueryEngine/ExpressionRewrite.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ExpressionRewrite.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -818,7 +818,7 @@
       CHECK(rewritten_lhs);
       const auto& lhs_ti = rewritten_lhs->get_type_info();
 
-      if (!lhs_ti.is_geometry()) {
+      if (!lhs_ti.is_geometry() && !is_constructed_point(rewritten_lhs.get())) {
         // TODO(adb): If ST_Contains is passed geospatial literals instead of columns, the
         // function will be expanded during translation rather than during code
         // generation. While this scenario does not make sense for the overlaps join, we
@@ -828,8 +828,8 @@
         // mean the function has not been expanded to the physical types, yet.
 
         LOG(INFO) << "Unable to rewrite " << func_oper->getName()
-                  << " to overlaps conjunction. LHS input type is not a geospatial "
-                     "type. Are both inputs geospatial columns?\n"
+                  << " to overlaps conjunction. LHS input type is neither a geospatial "
+                     "column nor a constructed point\n"
                   << func_oper->toString();
 
         return boost::none;
diff -Naur ./QueryEngine/ExtensionFunctionsArray.hpp ../omniscidb-master/QueryEngine/ExtensionFunctionsArray.hpp
--- ./QueryEngine/ExtensionFunctionsArray.hpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ExtensionFunctionsArray.hpp	2021-04-21 00:02:57.000000000 +0300
@@ -23,6 +23,18 @@
 
 #endif
 
+#ifdef _WIN32
+// MSVC doesn't allow extern "C" function using template type
+// without explicit instantiation
+template struct Array<bool>;
+template struct Array<int8_t>;
+template struct Array<int16_t>;
+template struct Array<int32_t>;
+template struct Array<int64_t>;
+template struct Array<float>;
+template struct Array<double>;
+#endif
+
 EXTENSION_NOINLINE Array<int64_t> array_append(const Array<int64_t> in_arr,
                                                const int64_t val) {
 #ifndef __CUDACC__
diff -Naur ./QueryEngine/ExtensionsIR.cpp ../omniscidb-master/QueryEngine/ExtensionsIR.cpp
--- ./QueryEngine/ExtensionsIR.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ExtensionsIR.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -221,7 +221,8 @@
 
 }  // namespace
 
-extern "C" void register_buffer_with_executor_rsm(int64_t exec, int8_t* buffer) {
+extern "C" RUNTIME_EXPORT void register_buffer_with_executor_rsm(int64_t exec,
+                                                                 int8_t* buffer) {
   Executor* exec_ptr = reinterpret_cast<Executor*>(exec);
   if (buffer != nullptr) {
     exec_ptr->getRowSetMemoryOwner()->addVarlenBuffer(buffer);
diff -Naur ./QueryEngine/ExtractFromTime.cpp ../omniscidb-master/QueryEngine/ExtractFromTime.cpp
--- ./QueryEngine/ExtractFromTime.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ExtractFromTime.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -45,37 +45,45 @@
 
 }  // namespace
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_hour(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_hour(const int64_t lcltime) {
   return unsigned_mod(lcltime, kSecsPerDay) / kSecsPerHour;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_minute(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_minute(const int64_t lcltime) {
   return unsigned_mod(lcltime, kSecsPerHour) / kSecsPerMin;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_second(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_second(const int64_t lcltime) {
   return unsigned_mod(lcltime, kSecsPerMin);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_millisecond(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_millisecond(const int64_t lcltime) {
   return unsigned_mod(lcltime, kSecsPerMin * kMilliSecsPerSec);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_microsecond(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_microsecond(const int64_t lcltime) {
   return unsigned_mod(lcltime, kSecsPerMin * kMicroSecsPerSec);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_nanosecond(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_nanosecond(const int64_t lcltime) {
   return unsigned_mod(lcltime, kSecsPerMin * kNanoSecsPerSec);
 }
 
 // First day of epoch is Thursday, so + 4 to have Sunday=0.
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_dow(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_dow(const int64_t lcltime) {
   int64_t const days_past_epoch = floor_div(lcltime, kSecsPerDay);
   return unsigned_mod(days_past_epoch + 4, kDaysPerWeek);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_quarterday(const int64_t lcltime) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_quarterday(const int64_t lcltime) {
   return unsigned_mod(lcltime, kSecsPerDay) / kSecsPerQuarterDay + 1;
 }
 
@@ -144,21 +152,25 @@
   return year;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_epoch(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_epoch(const int64_t timeval) {
   return timeval;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_dateepoch(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_dateepoch(const int64_t timeval) {
   return timeval - unsigned_mod(timeval, kSecsPerDay);
 }
 
 // First day of epoch is Thursday, so + 3 to have Monday=0, then + 1 at the end.
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_isodow(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_isodow(const int64_t timeval) {
   int64_t const days_past_epoch = floor_div(timeval, kSecsPerDay);
   return unsigned_mod(days_past_epoch + 3, kDaysPerWeek) + 1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_day(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_day(const int64_t timeval) {
   int64_t const day = floor_div(timeval, kSecsPerDay);
   unsigned const doe = unsigned_mod(day - kEpochAdjustedDays, kDaysPer400Years);
   unsigned const yoe = (doe - doe / 1460 + doe / 36524 - (doe == 146096)) / 365;
@@ -167,7 +179,8 @@
   return doy - (153 * moy + 2) / 5 + 1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_day_of_year(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_day_of_year(const int64_t timeval) {
   int64_t const day = floor_div(timeval, kSecsPerDay);
   unsigned const doe = unsigned_mod(day - kEpochAdjustedDays, kDaysPer400Years);
   unsigned const yoe = (doe - doe / 1460 + doe / 36524 - (doe == 146096)) / 365;
@@ -193,20 +206,24 @@
   return (doe - week_start) / 7 + 1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_week_monday(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_week_monday(const int64_t timeval) {
   return extract_week<MONDAY>(timeval);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_week_sunday(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_week_sunday(const int64_t timeval) {
   return extract_week<SUNDAY>(timeval);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_week_saturday(const int64_t timeval) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_week_saturday(const int64_t timeval) {
   return extract_week<SATURDAY>(timeval);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_month(const int64_t timeval) {
-  if (timeval >= 0L && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_month(const int64_t timeval) {
+  if (timeval >= 0LL && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
     return extract_month_fast(timeval);
   }
   int64_t const day = floor_div(timeval, kSecsPerDay);
@@ -217,8 +234,9 @@
   return moy + (moy < 10 ? 3 : -9);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_quarter(const int64_t timeval) {
-  if (timeval >= 0L && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_quarter(const int64_t timeval) {
+  if (timeval >= 0LL && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
     return extract_quarter_fast(timeval);
   }
   constexpr int64_t quarter[12]{1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1, 1};
@@ -230,8 +248,9 @@
   return quarter[moy];
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t extract_year(const int64_t timeval) {
-  if (timeval >= 0L && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+extract_year(const int64_t timeval) {
+  if (timeval >= 0LL && timeval <= UINT32_MAX - kEpochOffsetYear1900) {
     return extract_year_fast(timeval);
   }
   int64_t const day = floor_div(timeval, kSecsPerDay);
diff -Naur ./QueryEngine/FromTableReordering.cpp ../omniscidb-master/QueryEngine/FromTableReordering.cpp
--- ./QueryEngine/FromTableReordering.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/FromTableReordering.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -29,6 +29,7 @@
 using node_t = size_t;
 
 static std::unordered_map<SQLTypes, cost_t> GEO_TYPE_COSTS{{kPOINT, 60},
+                                                           {kARRAY, 60},
                                                            {kLINESTRING, 70},
                                                            {kPOLYGON, 80},
                                                            {kMULTIPOLYGON, 90}};
@@ -42,7 +43,7 @@
     for (size_t i = 0; i < func_oper->getArity(); i++) {
       const auto arg_expr = func_oper->getArg(i);
       const auto& ti = arg_expr->get_type_info();
-      if (ti.is_geometry()) {
+      if (ti.is_geometry() || is_constructed_point(arg_expr)) {
         geo_types_for_func.push_back(ti.get_type());
       }
     }
diff -Naur ./QueryEngine/GeosRuntime.cpp ../omniscidb-master/QueryEngine/GeosRuntime.cpp
--- ./QueryEngine/GeosRuntime.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/GeosRuntime.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -268,35 +268,36 @@
 }
 #endif
 
-extern "C" bool Geos_Wkb_Wkb(int op,
-                             int arg1_type,
-                             int8_t* arg1_coords,
-                             int64_t arg1_coords_size,
-                             int32_t* arg1_meta1,
-                             int64_t arg1_meta1_size,
-                             int32_t* arg1_meta2,
-                             int64_t arg1_meta2_size,
-                             // TODO: add meta3 args to support generic geometries
-                             int32_t arg1_ic,
-                             int32_t arg1_srid,
-                             int arg2_type,
-                             int8_t* arg2_coords,
-                             int64_t arg2_coords_size,
-                             int32_t* arg2_meta1,
-                             int64_t arg2_meta1_size,
-                             int32_t* arg2_meta2,
-                             int64_t arg2_meta2_size,
-                             // TODO: add meta3 args to support generic geometries
-                             int32_t arg2_ic,
-                             int32_t arg2_srid,
-                             // TODO: add transform args
-                             int* result_type,
-                             int8_t** result_coords,
-                             int64_t* result_coords_size,
-                             int32_t** result_meta1,
-                             int64_t* result_meta1_size,
-                             int32_t** result_meta2,
-                             int64_t* result_meta2_size) {
+extern "C" RUNTIME_EXPORT bool Geos_Wkb_Wkb(
+    int op,
+    int arg1_type,
+    int8_t* arg1_coords,
+    int64_t arg1_coords_size,
+    int32_t* arg1_meta1,
+    int64_t arg1_meta1_size,
+    int32_t* arg1_meta2,
+    int64_t arg1_meta2_size,
+    // TODO: add meta3 args to support generic geometries
+    int32_t arg1_ic,
+    int32_t arg1_srid,
+    int arg2_type,
+    int8_t* arg2_coords,
+    int64_t arg2_coords_size,
+    int32_t* arg2_meta1,
+    int64_t arg2_meta1_size,
+    int32_t* arg2_meta2,
+    int64_t arg2_meta2_size,
+    // TODO: add meta3 args to support generic geometries
+    int32_t arg2_ic,
+    int32_t arg2_srid,
+    // TODO: add transform args
+    int* result_type,
+    int8_t** result_coords,
+    int64_t* result_coords_size,
+    int32_t** result_meta1,
+    int64_t* result_meta1_size,
+    int32_t** result_meta2,
+    int64_t* result_meta2_size) {
 #ifndef __CUDACC__
   // Get the result geo
   // What if intersection is not a POLYGON? POINT? LINESTRING, MULTIPOLYGON?
@@ -376,26 +377,27 @@
 #endif
 }
 
-extern "C" bool Geos_Wkb_double(int op,
-                                int arg1_type,
-                                int8_t* arg1_coords,
-                                int64_t arg1_coords_size,
-                                int32_t* arg1_meta1,
-                                int64_t arg1_meta1_size,
-                                int32_t* arg1_meta2,
-                                int64_t arg1_meta2_size,
-                                // TODO: add meta3 args to support generic geometries
-                                int32_t arg1_ic,
-                                int32_t arg1_srid,
-                                double arg2,
-                                // TODO: add transform args
-                                int* result_type,
-                                int8_t** result_coords,
-                                int64_t* result_coords_size,
-                                int32_t** result_meta1,
-                                int64_t* result_meta1_size,
-                                int32_t** result_meta2,
-                                int64_t* result_meta2_size) {
+extern "C" RUNTIME_EXPORT bool Geos_Wkb_double(
+    int op,
+    int arg1_type,
+    int8_t* arg1_coords,
+    int64_t arg1_coords_size,
+    int32_t* arg1_meta1,
+    int64_t arg1_meta1_size,
+    int32_t* arg1_meta2,
+    int64_t arg1_meta2_size,
+    // TODO: add meta3 args to support generic geometries
+    int32_t arg1_ic,
+    int32_t arg1_srid,
+    double arg2,
+    // TODO: add transform args
+    int* result_type,
+    int8_t** result_coords,
+    int64_t* result_coords_size,
+    int32_t** result_meta1,
+    int64_t* result_meta1_size,
+    int32_t** result_meta2,
+    int64_t* result_meta2_size) {
 #ifndef __CUDACC__
   int32_t best_planar_srid;
   int32_t* best_planar_srid_ptr = nullptr;
@@ -460,18 +462,19 @@
 #endif
 }
 
-extern "C" bool Geos_Wkb(int op,
-                         int arg_type,
-                         int8_t* arg_coords,
-                         int64_t arg_coords_size,
-                         int32_t* arg_meta1,
-                         int64_t arg_meta1_size,
-                         int32_t* arg_meta2,
-                         int64_t arg_meta2_size,
-                         // TODO: add meta3 args to support generic geometries
-                         int32_t arg_ic,
-                         int32_t arg_srid,
-                         bool* result) {
+extern "C" RUNTIME_EXPORT bool Geos_Wkb(
+    int op,
+    int arg_type,
+    int8_t* arg_coords,
+    int64_t arg_coords_size,
+    int32_t* arg_meta1,
+    int64_t arg_meta1_size,
+    int32_t* arg_meta2,
+    int64_t arg_meta2_size,
+    // TODO: add meta3 args to support generic geometries
+    int32_t arg_ic,
+    int32_t arg_srid,
+    bool* result) {
 #ifndef __CUDACC__
   WKB wkb1{};
   if (!result || !toWkb(wkb1,
diff -Naur ./QueryEngine/GeosRuntime.h ../omniscidb-master/QueryEngine/GeosRuntime.h
--- ./QueryEngine/GeosRuntime.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/GeosRuntime.h	2021-04-21 00:02:57.000000000 +0300
@@ -17,62 +17,62 @@
 #ifndef QUERYENGINE_RUNTIMEFUNCTIONSGEOS_H
 #define QUERYENGINE_RUNTIMEFUNCTIONSGEOS_H
 
-extern "C" bool Geos_Wkb_Wkb(int op,
-                             int arg1_type,
-                             int8_t* arg1_coords,
-                             int64_t arg1_coords_size,
-                             int32_t* arg1_meta1,
-                             int64_t arg1_meta1_size,
-                             int32_t* arg1_meta2,
-                             int64_t arg1_meta2_size,
-                             int32_t arg1_ic,
-                             int32_t arg1_srid,
-                             int arg2_type,
-                             int8_t* arg2_coords,
-                             int64_t arg2_coords_size,
-                             int32_t* arg2_meta1,
-                             int64_t arg2_meta1_size,
-                             int32_t* arg2_meta2,
-                             int64_t arg2_meta2_size,
-                             int32_t arg2_ic,
-                             int32_t arg2_srid,
-                             int* result_type,
-                             int8_t** result_coords,
-                             int64_t* result_coords_size,
-                             int32_t** result_meta1,
-                             int64_t* result_meta1_size,
-                             int32_t** result_meta2,
-                             int64_t* result_meta2_size);
+extern "C" RUNTIME_EXPORT bool Geos_Wkb_Wkb(int op,
+                                            int arg1_type,
+                                            int8_t* arg1_coords,
+                                            int64_t arg1_coords_size,
+                                            int32_t* arg1_meta1,
+                                            int64_t arg1_meta1_size,
+                                            int32_t* arg1_meta2,
+                                            int64_t arg1_meta2_size,
+                                            int32_t arg1_ic,
+                                            int32_t arg1_srid,
+                                            int arg2_type,
+                                            int8_t* arg2_coords,
+                                            int64_t arg2_coords_size,
+                                            int32_t* arg2_meta1,
+                                            int64_t arg2_meta1_size,
+                                            int32_t* arg2_meta2,
+                                            int64_t arg2_meta2_size,
+                                            int32_t arg2_ic,
+                                            int32_t arg2_srid,
+                                            int* result_type,
+                                            int8_t** result_coords,
+                                            int64_t* result_coords_size,
+                                            int32_t** result_meta1,
+                                            int64_t* result_meta1_size,
+                                            int32_t** result_meta2,
+                                            int64_t* result_meta2_size);
 
-extern "C" bool Geos_Wkb_double(int op,
-                                int arg1_type,
-                                int8_t* arg1_coords,
-                                int64_t arg1_coords_size,
-                                int32_t* arg1_meta1,
-                                int64_t arg1_meta1_size,
-                                int32_t* arg1_meta2,
-                                int64_t arg1_meta2_size,
-                                int32_t arg1_ic,
-                                int32_t arg1_srid,
-                                double arg2,
-                                int* result_type,
-                                int8_t** result_coords,
-                                int64_t* result_coords_size,
-                                int32_t** result_meta1,
-                                int64_t* result_meta1_size,
-                                int32_t** result_meta2,
-                                int64_t* result_meta2_size);
+extern "C" RUNTIME_EXPORT bool Geos_Wkb_double(int op,
+                                               int arg1_type,
+                                               int8_t* arg1_coords,
+                                               int64_t arg1_coords_size,
+                                               int32_t* arg1_meta1,
+                                               int64_t arg1_meta1_size,
+                                               int32_t* arg1_meta2,
+                                               int64_t arg1_meta2_size,
+                                               int32_t arg1_ic,
+                                               int32_t arg1_srid,
+                                               double arg2,
+                                               int* result_type,
+                                               int8_t** result_coords,
+                                               int64_t* result_coords_size,
+                                               int32_t** result_meta1,
+                                               int64_t* result_meta1_size,
+                                               int32_t** result_meta2,
+                                               int64_t* result_meta2_size);
 
-extern "C" bool Geos_Wkb(int op,
-                         int arg_type,
-                         int8_t* arg_coords,
-                         int64_t arg_coords_size,
-                         int32_t* arg_meta1,
-                         int64_t arg_meta1_size,
-                         int32_t* arg_meta2,
-                         int64_t arg_meta2_size,
-                         int32_t arg_ic,
-                         int32_t arg_srid,
-                         bool* result);
+extern "C" RUNTIME_EXPORT bool Geos_Wkb(int op,
+                                        int arg_type,
+                                        int8_t* arg_coords,
+                                        int64_t arg_coords_size,
+                                        int32_t* arg_meta1,
+                                        int64_t arg_meta1_size,
+                                        int32_t* arg_meta2,
+                                        int64_t arg_meta2_size,
+                                        int32_t arg_ic,
+                                        int32_t arg_srid,
+                                        bool* result);
 
 #endif  // QUERYENGINE_RUNTIMEFUNCTIONSGEOS_H
diff -Naur ./QueryEngine/GroupByAndAggregate.cpp ../omniscidb-master/QueryEngine/GroupByAndAggregate.cpp
--- ./QueryEngine/GroupByAndAggregate.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/GroupByAndAggregate.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -31,6 +31,7 @@
 
 #include "../CudaMgr/CudaMgr.h"
 #include "../Shared/checked_alloc.h"
+#include "../Shared/funcannotations.h"
 #include "../Utils/ChunkIter.h"
 #include "DataMgr/BufferMgr/BufferMgr.h"
 #include "Execute.h"
@@ -414,7 +415,7 @@
     if (query_mem_desc->sortOnGpu() &&
         (query_mem_desc->getBufferSizeBytes(device_type_) +
          align_to_int64(query_mem_desc->getEntryCount() * sizeof(int32_t))) >
-            2 * 1024 * 1024 * 1024L) {
+            2 * 1024 * 1024 * 1024LL) {
       must_use_baseline_sort = true;
       sort_on_gpu_hint = false;
     } else {
@@ -656,7 +657,7 @@
         count_distinct_impl_type = CountDistinctImplType::Bitmap;
         if (agg_info.agg_kind == kCOUNT) {
           bitmap_sz_bits = arg_range_info.max - arg_range_info.min + 1;
-          const int64_t MAX_BITMAP_BITS{8 * 1000 * 1000 * 1000L};
+          const int64_t MAX_BITMAP_BITS{8 * 1000 * 1000 * 1000LL};
           if (bitmap_sz_bits <= 0 || bitmap_sz_bits > MAX_BITMAP_BITS) {
             count_distinct_impl_type = CountDistinctImplType::StdSet;
           }
@@ -1705,18 +1706,24 @@
            {bitmap, &*bitmap_size_lv, key_bytes, &*estimator_comp_bytes_lv});
 }
 
-extern "C" void agg_count_distinct(int64_t* agg, const int64_t val) {
+extern "C" RUNTIME_EXPORT void agg_count_distinct(int64_t* agg, const int64_t val) {
   reinterpret_cast<std::set<int64_t>*>(*agg)->insert(val);
 }
 
-extern "C" void agg_count_distinct_skip_val(int64_t* agg,
-                                            const int64_t val,
-                                            const int64_t skip_val) {
+extern "C" RUNTIME_EXPORT void agg_count_distinct_skip_val(int64_t* agg,
+                                                           const int64_t val,
+                                                           const int64_t skip_val) {
   if (val != skip_val) {
     agg_count_distinct(agg, val);
   }
 }
 
+extern "C" RUNTIME_EXPORT void agg_approx_median(int64_t* agg, const double val) {
+  auto* t_digest = reinterpret_cast<quantile::TDigest*>(*agg);
+  t_digest->allocate();
+  t_digest->add(val);
+}
+
 void GroupByAndAggregate::codegenCountDistinct(
     const size_t target_idx,
     const Analyzer::Expr* target_expr,
@@ -1817,7 +1824,8 @@
     auto const agg_info = get_target_info(target_expr, g_bigint_count);
     agg_args.back() = executor_->castToFP(agg_args.back(), arg_ti, agg_info.sql_type);
   }
-  emitCall("agg_approx_median", agg_args);
+  cs->emitExternalCall(
+      "agg_approx_median", llvm::Type::getVoidTy(cs->context_), agg_args);
   if (nullable) {
     irb.CreateBr(skip);
     cs->current_func_->getBasicBlockList().push_back(skip);
diff -Naur ./QueryEngine/GroupByRuntime.cpp ../omniscidb-master/QueryEngine/GroupByRuntime.cpp
--- ./QueryEngine/GroupByRuntime.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/GroupByRuntime.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -17,13 +17,12 @@
 #include "JoinHashTable/Runtime/JoinHashImpl.h"
 #include "MurmurHash.h"
 
-extern "C" ALWAYS_INLINE DEVICE uint32_t key_hash(const int64_t* key,
-                                                  const uint32_t key_count,
-                                                  const uint32_t key_byte_width) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE uint32_t
+key_hash(const int64_t* key, const uint32_t key_count, const uint32_t key_byte_width) {
   return MurmurHash1(key, key_byte_width * key_count, 0);
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t* get_group_value(
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t* get_group_value(
     int64_t* groups_buffer,
     const uint32_t groups_buffer_entry_count,
     const int64_t* key,
@@ -48,9 +47,9 @@
   return NULL;
 }
 
-extern "C" NEVER_INLINE DEVICE bool dynamic_watchdog();
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE bool dynamic_watchdog();
 
-extern "C" NEVER_INLINE DEVICE int64_t* get_group_value_with_watchdog(
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t* get_group_value_with_watchdog(
     int64_t* groups_buffer,
     const uint32_t groups_buffer_entry_count,
     const int64_t* key,
@@ -82,7 +81,7 @@
   return NULL;
 }
 
-extern "C" NEVER_INLINE DEVICE int32_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int32_t
 get_group_value_columnar_slot(int64_t* groups_buffer,
                               const uint32_t groups_buffer_entry_count,
                               const int64_t* key,
@@ -106,7 +105,7 @@
   return -1;
 }
 
-extern "C" NEVER_INLINE DEVICE int32_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int32_t
 get_group_value_columnar_slot_with_watchdog(int64_t* groups_buffer,
                                             const uint32_t groups_buffer_entry_count,
                                             const int64_t* key,
@@ -137,7 +136,7 @@
   return -1;
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t* get_group_value_columnar(
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t* get_group_value_columnar(
     int64_t* groups_buffer,
     const uint32_t groups_buffer_entry_count,
     const int64_t* key,
@@ -160,11 +159,11 @@
   return NULL;
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t* get_group_value_columnar_with_watchdog(
-    int64_t* groups_buffer,
-    const uint32_t groups_buffer_entry_count,
-    const int64_t* key,
-    const uint32_t key_qw_count) {
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t*
+get_group_value_columnar_with_watchdog(int64_t* groups_buffer,
+                                       const uint32_t groups_buffer_entry_count,
+                                       const int64_t* key,
+                                       const uint32_t key_qw_count) {
   uint32_t h = key_hash(key, key_qw_count, sizeof(int64_t)) % groups_buffer_entry_count;
   int64_t* matching_group = get_matching_group_value_columnar(
       groups_buffer, h, key, key_qw_count, groups_buffer_entry_count);
@@ -190,7 +189,7 @@
   return NULL;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t* get_group_value_fast(
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t* get_group_value_fast(
     int64_t* groups_buffer,
     const int64_t key,
     const int64_t min_key,
@@ -207,13 +206,13 @@
   return groups_buffer + off + 1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t* get_group_value_fast_with_original_key(
-    int64_t* groups_buffer,
-    const int64_t key,
-    const int64_t orig_key,
-    const int64_t min_key,
-    const int64_t bucket,
-    const uint32_t row_size_quad) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t*
+get_group_value_fast_with_original_key(int64_t* groups_buffer,
+                                       const int64_t key,
+                                       const int64_t orig_key,
+                                       const int64_t min_key,
+                                       const int64_t bucket,
+                                       const uint32_t row_size_quad) {
   int64_t key_diff = key - min_key;
   if (bucket) {
     key_diff /= bucket;
@@ -225,7 +224,7 @@
   return groups_buffer + off + 1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE uint32_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE uint32_t
 get_columnar_group_bin_offset(int64_t* key_base_ptr,
                               const int64_t key,
                               const int64_t min_key,
@@ -240,7 +239,7 @@
   return off;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t* get_scan_output_slot(
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t* get_scan_output_slot(
     int64_t* output_buffer,
     const uint32_t output_buffer_entry_count,
     const uint32_t pos,
@@ -254,7 +253,7 @@
   return NULL;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int32_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int32_t
 get_columnar_scan_output_offset(int64_t* output_buffer,
                                 const uint32_t output_buffer_entry_count,
                                 const uint32_t pos,
@@ -266,7 +265,7 @@
   return -1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 bucketized_hash_join_idx(int64_t hash_buff,
                          int64_t const key,
                          int64_t const min_key,
@@ -279,17 +278,18 @@
   return -1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t hash_join_idx(int64_t hash_buff,
-                                                      const int64_t key,
-                                                      const int64_t min_key,
-                                                      const int64_t max_key) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+hash_join_idx(int64_t hash_buff,
+              const int64_t key,
+              const int64_t min_key,
+              const int64_t max_key) {
   if (key >= min_key && key <= max_key) {
     return *SUFFIX(get_hash_slot)(reinterpret_cast<int32_t*>(hash_buff), key, min_key);
   }
   return -1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 bucketized_hash_join_idx_nullable(int64_t hash_buff,
                                   const int64_t key,
                                   const int64_t min_key,
@@ -301,15 +301,16 @@
                          : -1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t hash_join_idx_nullable(int64_t hash_buff,
-                                                               const int64_t key,
-                                                               const int64_t min_key,
-                                                               const int64_t max_key,
-                                                               const int64_t null_val) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+hash_join_idx_nullable(int64_t hash_buff,
+                       const int64_t key,
+                       const int64_t min_key,
+                       const int64_t max_key,
+                       const int64_t null_val) {
   return key != null_val ? hash_join_idx(hash_buff, key, min_key, max_key) : -1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 bucketized_hash_join_idx_bitwise(int64_t hash_buff,
                                  const int64_t key,
                                  const int64_t min_key,
@@ -326,7 +327,7 @@
                                                     bucket_normalization);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 hash_join_idx_bitwise(int64_t hash_buff,
                       const int64_t key,
                       const int64_t min_key,
@@ -338,7 +339,7 @@
              : hash_join_idx(hash_buff, translated_val, min_key, translated_val);
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 hash_join_idx_sharded(int64_t hash_buff,
                       const int64_t key,
                       const int64_t min_key,
@@ -357,7 +358,7 @@
   return -1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 hash_join_idx_sharded_nullable(int64_t hash_buff,
                                const int64_t key,
                                const int64_t min_key,
@@ -376,7 +377,7 @@
                          : -1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
 hash_join_idx_bitwise_sharded(int64_t hash_buff,
                               const int64_t key,
                               const int64_t min_key,
@@ -402,13 +403,13 @@
                                                  device_count);
 }
 
-#define DEF_TRANSLATE_NULL_KEY(key_type)                                           \
-  extern "C" NEVER_INLINE DEVICE int64_t translate_null_key_##key_type(            \
-      const key_type key, const key_type null_val, const int64_t translated_val) { \
-    if (key == null_val) {                                                         \
-      return translated_val;                                                       \
-    }                                                                              \
-    return key;                                                                    \
+#define DEF_TRANSLATE_NULL_KEY(key_type)                                               \
+  extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t translate_null_key_##key_type( \
+      const key_type key, const key_type null_val, const int64_t translated_val) {     \
+    if (key == null_val) {                                                             \
+      return translated_val;                                                           \
+    }                                                                                  \
+    return key;                                                                        \
   }
 
 DEF_TRANSLATE_NULL_KEY(int8_t)
diff -Naur ./QueryEngine/HyperLogLogRank.h ../omniscidb-master/QueryEngine/HyperLogLogRank.h
--- ./QueryEngine/HyperLogLogRank.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/HyperLogLogRank.h	2021-04-21 00:02:57.000000000 +0300
@@ -18,6 +18,9 @@
 #define QUERYENGINE_HYPERLOGLOGRT_H
 
 #include "../Shared/funcannotations.h"
+#ifdef _MSC_VER
+#include <intrin.h>
+#endif
 
 #ifdef __CUDACC__
 inline __device__ int32_t get_rank(uint64_t x, uint32_t b) {
@@ -25,7 +28,11 @@
 }
 #else
 FORCE_INLINE uint8_t get_rank(uint64_t x, uint32_t b) {
+#ifdef _MSC_VER
+  return std::min(b, static_cast<uint32_t>(x ? __lzcnt64(x) : 64)) + 1;
+#else
   return std::min(b, static_cast<uint32_t>(x ? __builtin_clzl(x) : 64)) + 1;
+#endif
 }
 #endif
 
diff -Naur ./QueryEngine/InValuesBitmap.cpp ../omniscidb-master/QueryEngine/InValuesBitmap.cpp
--- ./QueryEngine/InValuesBitmap.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/InValuesBitmap.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -75,7 +75,7 @@
     CHECK(rhs_has_null_);
     return;
   }
-  const int64_t MAX_BITMAP_BITS{8 * 1000 * 1000 * 1000L};
+  const int64_t MAX_BITMAP_BITS{8 * 1000 * 1000 * 1000LL};
   const auto bitmap_sz_bits =
       static_cast<int64_t>(checked_int64_t(max_val_) - min_val_ + 1);
   if (bitmap_sz_bits > MAX_BITMAP_BITS) {
diff -Naur ./QueryEngine/InputMetadata.cpp ../omniscidb-master/QueryEngine/InputMetadata.cpp
--- ./QueryEngine/InputMetadata.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/InputMetadata.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -133,6 +133,7 @@
 }  // namespace
 
 ChunkMetadataMap synthesize_metadata(const ResultSet* rows) {
+  auto timer = DEBUG_TIMER(__func__);
   rows->moveToBegin();
   std::vector<std::vector<std::unique_ptr<Encoder>>> dummy_encoders;
   const size_t worker_count =
diff -Naur ./QueryEngine/JoinHashTable/HashJoin.cpp ../omniscidb-master/QueryEngine/JoinHashTable/HashJoin.cpp
--- ./QueryEngine/JoinHashTable/HashJoin.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/JoinHashTable/HashJoin.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -670,10 +670,11 @@
       throw HashJoinFail(
           "Overlaps join only supported for 4-element double fixed length arrays");
     }
-    if (!(outer_col_ti.get_type() == kPOINT || is_bounds_array(outer_col_ti))) {
+    if (!(outer_col_ti.get_type() == kPOINT || is_bounds_array(outer_col_ti) ||
+          is_constructed_point(outer_expr))) {
       throw HashJoinFail(
-          "Overlaps join only supported for geometry outer columns of type point or "
-          "geometry columns with bounds");
+          "Overlaps join only supported for geometry outer columns of type point, "
+          "geometry columns with bounds or constructed points");
     }
   } else {
     if (!(inner_col_real_ti.is_integer() || inner_col_real_ti.is_time() ||
diff -Naur ./QueryEngine/JoinHashTable/OverlapsJoinHashTable.cpp ../omniscidb-master/QueryEngine/JoinHashTable/OverlapsJoinHashTable.cpp
--- ./QueryEngine/JoinHashTable/OverlapsJoinHashTable.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/JoinHashTable/OverlapsJoinHashTable.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -31,11 +31,11 @@
         OverlapsHashTableCache<OverlapsHashTableCacheKey,
                                OverlapsJoinHashTable::HashTableCacheValue>>();
 
-std::unique_ptr<HashTableCache<HashTableCacheKey,
+std::unique_ptr<HashTableCache<OverlapsHashTableCacheKey,
                                std::pair<OverlapsJoinHashTable::BucketThreshold,
                                          OverlapsJoinHashTable::BucketSizes>>>
     OverlapsJoinHashTable::auto_tuner_cache_ =
-        std::make_unique<HashTableCache<HashTableCacheKey,
+        std::make_unique<HashTableCache<OverlapsHashTableCacheKey,
                                         std::pair<OverlapsJoinHashTable::BucketThreshold,
                                                   OverlapsJoinHashTable::BucketSizes>>>();
 
@@ -59,7 +59,9 @@
     if (condition->is_overlaps_oper()) {
       CHECK_EQ(inner_outer_pairs.size(), size_t(1));
       if (inner_outer_pairs[0].first->get_type_info().is_array() &&
-          inner_outer_pairs[0].second->get_type_info().is_array()) {
+          inner_outer_pairs[0].second->get_type_info().is_array() &&
+          // Bounds vs constructed points, former should yield ManyToMany
+          inner_outer_pairs[0].second->get_type_info().get_size() == 32) {
         layout = HashType::ManyToMany;
       }
     }
@@ -521,7 +523,9 @@
 
   auto overlaps_max_table_size_bytes = g_overlaps_max_table_size_bytes;
   std::optional<double> overlaps_threshold_override;
+  double overlaps_target_entries_per_bin = g_overlaps_target_entries_per_bin;
   auto query_hint = getRegisteredQueryHint();
+  auto skip_hashtable_caching = false;
   if (query_hint.isHintRegistered("overlaps_bucket_threshold")) {
     VLOG(1) << "Setting overlaps bucket threshold "
                "\'overlaps_hashjoin_bucket_threshold\' via "
@@ -532,12 +536,10 @@
   if (query_hint.isHintRegistered("overlaps_max_size")) {
     std::ostringstream oss;
     oss << "User requests to change a threshold \'overlaps_max_table_size_bytes\' via "
-           "query hint: "
-        << overlaps_max_table_size_bytes << " -> " << query_hint.overlaps_max_size;
+           "query hint";
     if (!overlaps_threshold_override.has_value()) {
-      oss << "Enable user-given threshold \'overlaps_max_table_size_bytes\' via "
-             "query hint: "
-          << overlaps_max_table_size_bytes << " -> " << query_hint.overlaps_max_size;
+      oss << ": " << overlaps_max_table_size_bytes << " -> "
+          << query_hint.overlaps_max_size;
       overlaps_max_table_size_bytes = query_hint.overlaps_max_size;
     } else {
       oss << ", but is skipped since the query hint also changes the threshold "
@@ -545,6 +547,18 @@
     }
     VLOG(1) << oss.str();
   }
+  if (query_hint.isHintRegistered("overlaps_no_cache")) {
+    VLOG(1) << "User requests to skip caching overlaps join hashtable and its tuned "
+               "parameters for this query";
+    skip_hashtable_caching = true;
+  }
+  if (query_hint.isHintRegistered("overlaps_keys_per_bin")) {
+    VLOG(1) << "User requests to change a threshold \'overlaps_keys_per_bin\' via query "
+               "hint: "
+            << overlaps_target_entries_per_bin << " -> "
+            << query_hint.overlaps_keys_per_bin;
+    overlaps_target_entries_per_bin = query_hint.overlaps_keys_per_bin;
+  }
 
   std::vector<ColumnsForDevice> columns_per_device;
   const auto catalog = executor_->getCatalog();
@@ -596,7 +610,7 @@
 
   if (overlaps_threshold_override) {
     // compute bucket sizes based on the user provided threshold
-    BucketSizeTuner tuner(*overlaps_threshold_override,
+    BucketSizeTuner tuner(/*initial_threshold=*/*overlaps_threshold_override,
                           /*step=*/1.0,
                           /*min_threshold=*/0.0,
                           getEffectiveMemoryLevel(inner_outer_pairs_),
@@ -607,7 +621,11 @@
     const auto inverse_bucket_sizes = tuner.getInverseBucketSizes();
 
     auto [entry_count, emitted_keys_count] =
-        computeHashTableCounts(shard_count, inverse_bucket_sizes, columns_per_device);
+        computeHashTableCounts(shard_count,
+                               inverse_bucket_sizes,
+                               columns_per_device,
+                               overlaps_max_table_size_bytes,
+                               *overlaps_threshold_override);
     setInverseBucketSizeInfo(inverse_bucket_sizes, columns_per_device, device_count_);
     // reifyImpl will check the hash table cache for an appropriate hash table w/ those
     // bucket sizes (or within tolerances) if a hash table exists use it, otherwise build
@@ -617,20 +635,27 @@
               layout,
               shard_count,
               entry_count,
-              emitted_keys_count);
+              emitted_keys_count,
+              skip_hashtable_caching,
+              overlaps_max_table_size_bytes,
+              *overlaps_threshold_override);
   } else {
-    HashTableCacheKey cache_key{columns_per_device.front().join_columns.front().num_elems,
-                                composite_key_info.cache_key_chunks,
-                                condition_->get_optype()};
     double overlaps_bucket_threshold = std::numeric_limits<double>::max();
+    OverlapsHashTableCacheKey cache_key{
+        columns_per_device.front().join_columns.front().num_elems,
+        composite_key_info.cache_key_chunks,
+        condition_->get_optype(),
+        overlaps_max_table_size_bytes,
+        overlaps_bucket_threshold};
     auto cached_bucket_threshold_opt = auto_tuner_cache_->get(cache_key);
     if (cached_bucket_threshold_opt) {
       overlaps_bucket_threshold = cached_bucket_threshold_opt->first;
-      VLOG(1) << "Auto tuner using cached overlaps hash table size of: "
-              << overlaps_bucket_threshold;
       auto inverse_bucket_sizes = cached_bucket_threshold_opt->second;
 
-      OverlapsHashTableCacheKey hash_table_cache_key(cache_key, inverse_bucket_sizes);
+      OverlapsHashTableCacheKey hash_table_cache_key(cache_key,
+                                                     overlaps_max_table_size_bytes,
+                                                     overlaps_bucket_threshold,
+                                                     inverse_bucket_sizes);
       if (auto hash_table_cache_opt =
               hash_table_cache_->getWithKey(hash_table_cache_key)) {
         // if we already have a built hash table, we can skip the scans required for
@@ -649,11 +674,14 @@
                   layout,
                   shard_count,
                   hash_table->getEntryCount(),
-                  hash_table->getEmittedKeysCount());
+                  hash_table->getEmittedKeysCount(),
+                  skip_hashtable_caching,
+                  overlaps_max_table_size_bytes,
+                  overlaps_bucket_threshold);
       } else {
         VLOG(1) << "Computing bucket size for cached bucket threshold";
         // compute bucket size using our cached tuner value
-        BucketSizeTuner tuner(overlaps_bucket_threshold,
+        BucketSizeTuner tuner(/*initial_threshold=*/overlaps_bucket_threshold,
                               /*step=*/1.0,
                               /*min_threshold=*/0.0,
                               getEffectiveMemoryLevel(inner_outer_pairs_),
@@ -665,7 +693,11 @@
         const auto inverse_bucket_sizes = tuner.getInverseBucketSizes();
 
         auto [entry_count, emitted_keys_count] =
-            computeHashTableCounts(shard_count, inverse_bucket_sizes, columns_per_device);
+            computeHashTableCounts(shard_count,
+                                   inverse_bucket_sizes,
+                                   columns_per_device,
+                                   overlaps_max_table_size_bytes,
+                                   overlaps_bucket_threshold);
         setInverseBucketSizeInfo(inverse_bucket_sizes, columns_per_device, device_count_);
 
         reifyImpl(columns_per_device,
@@ -673,12 +705,15 @@
                   layout,
                   shard_count,
                   entry_count,
-                  emitted_keys_count);
+                  emitted_keys_count,
+                  skip_hashtable_caching,
+                  overlaps_max_table_size_bytes,
+                  overlaps_bucket_threshold);
       }
     } else {
       // compute bucket size using the auto tuner
       BucketSizeTuner tuner(
-          /*initial_threshold=*/std::numeric_limits<double>::max(),
+          /*initial_threshold=*/overlaps_bucket_threshold,
           /*step=*/2.0,
           /*min_threshold=*/1e-7,
           getEffectiveMemoryLevel(inner_outer_pairs_),
@@ -691,12 +726,16 @@
 
       // manages the tuning state machine
       TuningState tuning_state(overlaps_max_table_size_bytes,
-                               g_overlaps_target_entries_per_bin);
+                               overlaps_target_entries_per_bin);
       while (tuner.tuneOneStep(tuning_state.tuning_direction)) {
         const auto inverse_bucket_sizes = tuner.getInverseBucketSizes();
 
         const auto [crt_entry_count, crt_emitted_keys_count] =
-            computeHashTableCounts(shard_count, inverse_bucket_sizes, columns_per_device);
+            computeHashTableCounts(shard_count,
+                                   inverse_bucket_sizes,
+                                   columns_per_device,
+                                   tuning_state.overlaps_max_table_size_bytes,
+                                   tuning_state.chosen_overlaps_threshold);
         const size_t hash_table_size = calculateHashTableSize(
             inverse_bucket_sizes.size(), crt_emitted_keys_count, crt_entry_count);
         HashTableProps crt_props(crt_entry_count,
@@ -739,17 +778,24 @@
       }
       CHECK_GE(tuning_state.chosen_overlaps_threshold, double(0));
       if (!cache_key_contains_intermediate_table(cache_key)) {
-        auto cache_value = std::make_pair(tuning_state.chosen_overlaps_threshold,
-                                          inverse_bucket_sizes_for_dimension_);
-        auto_tuner_cache_->insert(cache_key, cache_value);
+        if (skip_hashtable_caching) {
+          VLOG(1) << "Skip to add tuned parameters to auto tuner";
+        } else {
+          auto cache_value = std::make_pair(tuning_state.chosen_overlaps_threshold,
+                                            inverse_bucket_sizes_for_dimension_);
+          auto_tuner_cache_->insert(cache_key, cache_value);
+        }
       }
-
+      overlaps_bucket_threshold = tuning_state.chosen_overlaps_threshold;
       reifyImpl(columns_per_device,
                 query_info,
                 layout,
                 shard_count,
                 crt_props.entry_count,
-                crt_props.emitted_keys_count);
+                crt_props.emitted_keys_count,
+                skip_hashtable_caching,
+                overlaps_max_table_size_bytes,
+                overlaps_bucket_threshold);
     }
   }
 }
@@ -810,10 +856,15 @@
 std::pair<size_t, size_t> OverlapsJoinHashTable::computeHashTableCounts(
     const size_t shard_count,
     const std::vector<double>& inverse_bucket_sizes_for_dimension,
-    std::vector<ColumnsForDevice>& columns_per_device) {
+    std::vector<ColumnsForDevice>& columns_per_device,
+    const size_t chosen_max_hashtable_size,
+    const double chosen_bucket_threshold) {
   CHECK(!inverse_bucket_sizes_for_dimension.empty());
   const auto [tuple_count, emitted_keys_count] =
-      approximateTupleCount(inverse_bucket_sizes_for_dimension, columns_per_device);
+      approximateTupleCount(inverse_bucket_sizes_for_dimension,
+                            columns_per_device,
+                            chosen_max_hashtable_size,
+                            chosen_bucket_threshold);
   const auto entry_count = 2 * std::max(tuple_count, size_t(1));
 
   return std::make_pair(
@@ -823,7 +874,9 @@
 
 std::pair<size_t, size_t> OverlapsJoinHashTable::approximateTupleCount(
     const std::vector<double>& inverse_bucket_sizes_for_dimension,
-    std::vector<ColumnsForDevice>& columns_per_device) {
+    std::vector<ColumnsForDevice>& columns_per_device,
+    const size_t chosen_max_hashtable_size,
+    const double chosen_bucket_threshold) {
   const auto effective_memory_level = getEffectiveMemoryLevel(inner_outer_pairs_);
   CountDistinctDescriptor count_distinct_desc{
       CountDistinctImplType::Bitmap,
@@ -862,6 +915,8 @@
         columns_per_device.front().join_columns.front().num_elems,
         composite_key_info.cache_key_chunks,
         condition_->get_optype(),
+        chosen_max_hashtable_size,
+        chosen_bucket_threshold,
         inverse_bucket_sizes_for_dimension};
     const auto cached_count_info = getApproximateTupleCountFromCache(cache_key);
     if (cached_count_info) {
@@ -1024,7 +1079,9 @@
   CHECK(condition_->is_overlaps_oper());
   CHECK_EQ(inner_outer_pairs_.size(), size_t(1));
   HashType layout;
-  if (inner_outer_pairs_[0].second->get_type_info().is_array()) {
+  if (inner_outer_pairs_[0].second->get_type_info().is_fixlen_array() &&
+      inner_outer_pairs_[0].second->get_type_info().get_size() == 32) {
+    // bounds array
     layout = HashType::ManyToMany;
   } else {
     layout = HashType::OneToMany;
@@ -1044,7 +1101,10 @@
                                       const HashType layout,
                                       const size_t shard_count,
                                       const size_t entry_count,
-                                      const size_t emitted_keys_count) {
+                                      const size_t emitted_keys_count,
+                                      const bool skip_hashtable_caching,
+                                      const size_t chosen_max_hashtable_size,
+                                      const double chosen_bucket_threshold) {
   std::vector<std::future<void>> init_threads;
   for (int device_id = 0; device_id < device_count_; ++device_id) {
     const auto fragments =
@@ -1058,6 +1118,9 @@
                                       layout,
                                       entry_count,
                                       emitted_keys_count,
+                                      skip_hashtable_caching,
+                                      chosen_max_hashtable_size,
+                                      chosen_bucket_threshold,
                                       device_id,
                                       logger::thread_id()));
   }
@@ -1073,6 +1136,9 @@
                                            const HashType layout,
                                            const size_t entry_count,
                                            const size_t emitted_keys_count,
+                                           const bool skip_hashtable_caching,
+                                           const size_t chosen_max_hashtable_size,
+                                           const double chosen_bucket_threshold,
                                            const int device_id,
                                            const logger::ThreadId parent_thread_id) {
   DEBUG_TIMER_NEW_THREAD(parent_thread_id);
@@ -1087,7 +1153,10 @@
                                          columns_for_device.join_buckets,
                                          layout,
                                          entry_count,
-                                         emitted_keys_count);
+                                         emitted_keys_count,
+                                         skip_hashtable_caching,
+                                         chosen_max_hashtable_size,
+                                         chosen_bucket_threshold);
     CHECK(hash_table);
 
 #ifdef HAVE_CUDA
@@ -1128,7 +1197,10 @@
     const std::vector<JoinBucketInfo>& join_bucket_info,
     const HashType layout,
     const size_t entry_count,
-    const size_t emitted_keys_count) {
+    const size_t emitted_keys_count,
+    const bool skip_hashtable_caching,
+    const size_t chosen_max_hashtable_size,
+    const double chosen_bucket_threshold) {
   auto timer = DEBUG_TIMER(__func__);
   const auto composite_key_info =
       HashJoin::getCompositeKeyInfo(inner_outer_pairs_, executor_);
@@ -1137,6 +1209,8 @@
   OverlapsHashTableCacheKey cache_key{join_columns.front().num_elems,
                                       composite_key_info.cache_key_chunks,
                                       condition_->get_optype(),
+                                      chosen_max_hashtable_size,
+                                      chosen_bucket_threshold,
                                       inverse_bucket_sizes_for_dimension_};
 
   std::lock_guard<std::mutex> cpu_hash_table_buff_lock(cpu_hash_table_buff_mutex_);
@@ -1181,7 +1255,11 @@
   }
   std::shared_ptr<BaselineHashTable> hash_table = builder.getHashTable();
   if (HashJoin::getInnerTableId(inner_outer_pairs_) > 0) {
-    putHashTableOnCpuToCache(cache_key, hash_table);
+    if (skip_hashtable_caching) {
+      VLOG(1) << "Skip to cache overlaps join hashtable";
+    } else {
+      putHashTableOnCpuToCache(cache_key, hash_table);
+    }
   }
   return hash_table;
 }
@@ -1296,55 +1374,74 @@
   }
 
   const auto& inner_outer_pair = inner_outer_pairs_[0];
-  const auto outer_col = inner_outer_pair.second;
-  const auto outer_col_ti = outer_col->get_type_info();
+  const auto outer_geo = inner_outer_pair.second;
+  const auto outer_geo_ti = outer_geo->get_type_info();
 
-  if (outer_col_ti.is_geometry()) {
-    CodeGenerator code_generator(executor_);
+  llvm::Value* arr_ptr = nullptr;
+  CodeGenerator code_generator(executor_);
+  CHECK_EQ(inverse_bucket_sizes_for_dimension_.size(), static_cast<size_t>(2));
+
+  if (outer_geo_ti.is_geometry()) {
     // TODO(adb): for points we will use the coords array, but for other geometries we
     // will need to use the bounding box. For now only support points.
-    CHECK_EQ(outer_col_ti.get_type(), kPOINT);
-    CHECK_EQ(inverse_bucket_sizes_for_dimension_.size(), static_cast<size_t>(2));
-
-    const auto col_lvs = code_generator.codegen(outer_col, true, co);
-    CHECK_EQ(col_lvs.size(), size_t(1));
+    CHECK_EQ(outer_geo_ti.get_type(), kPOINT);
 
-    const auto outer_col_var = dynamic_cast<const Analyzer::ColumnVar*>(outer_col);
-    CHECK(outer_col_var);
-    const auto coords_cd = executor_->getCatalog()->getMetadataForColumn(
-        outer_col_var->get_table_id(), outer_col_var->get_column_id() + 1);
-    CHECK(coords_cd);
-
-    const auto array_ptr = executor_->cgen_state_->emitExternalCall(
-        "array_buff",
-        llvm::Type::getInt8PtrTy(executor_->cgen_state_->context_),
-        {col_lvs.front(), code_generator.posArg(outer_col)});
-    CHECK(coords_cd->columnType.get_elem_type().get_type() == kTINYINT)
-        << "Only TINYINT coordinates columns are supported in geo overlaps hash join.";
-    const auto arr_ptr =
-        code_generator.castArrayPointer(array_ptr, coords_cd->columnType.get_elem_type());
-
-    for (size_t i = 0; i < 2; i++) {
-      const auto key_comp_dest_lv = LL_BUILDER.CreateGEP(key_buff_lv, LL_INT(i));
-
-      // Note that get_bucket_key_for_range_compressed will need to be specialized for
-      // future compression schemes
-      auto bucket_key =
-          outer_col_ti.get_compression() == kENCODING_GEOINT
-              ? executor_->cgen_state_->emitExternalCall(
-                    "get_bucket_key_for_range_compressed",
-                    get_int_type(64, LL_CONTEXT),
-                    {arr_ptr, LL_INT(i), LL_FP(inverse_bucket_sizes_for_dimension_[i])})
-              : executor_->cgen_state_->emitExternalCall(
-                    "get_bucket_key_for_range_double",
-                    get_int_type(64, LL_CONTEXT),
-                    {arr_ptr, LL_INT(i), LL_FP(inverse_bucket_sizes_for_dimension_[i])});
-      const auto col_lv = LL_BUILDER.CreateSExt(
-          bucket_key, get_int_type(key_component_width * 8, LL_CONTEXT));
-      LL_BUILDER.CreateStore(col_lv, key_comp_dest_lv);
-    }
-  } else {
-    LOG(FATAL) << "Overlaps key currently only supported for geospatial types.";
+    if (const auto outer_geo_col = dynamic_cast<const Analyzer::ColumnVar*>(outer_geo)) {
+      const auto outer_geo_col_lvs = code_generator.codegen(outer_geo_col, true, co);
+      CHECK_EQ(outer_geo_col_lvs.size(), size_t(1));
+      const auto coords_cd = executor_->getCatalog()->getMetadataForColumn(
+          outer_geo_col->get_table_id(), outer_geo_col->get_column_id() + 1);
+      CHECK(coords_cd);
+
+      const auto array_ptr = executor_->cgen_state_->emitExternalCall(
+          "array_buff",
+          llvm::Type::getInt8PtrTy(executor_->cgen_state_->context_),
+          {outer_geo_col_lvs.front(), code_generator.posArg(outer_geo_col)});
+      CHECK(coords_cd->columnType.get_elem_type().get_type() == kTINYINT)
+          << "Only TINYINT coordinates columns are supported in geo overlaps hash join.";
+      arr_ptr = code_generator.castArrayPointer(array_ptr,
+                                                coords_cd->columnType.get_elem_type());
+    }
+  } else if (outer_geo_ti.is_fixlen_array()) {
+    // Process dynamically constructed points
+    const auto outer_geo_cast_coord_array =
+        dynamic_cast<const Analyzer::UOper*>(outer_geo);
+    CHECK(outer_geo_cast_coord_array->get_optype() == kCAST);
+    const auto outer_geo_coord_array = dynamic_cast<const Analyzer::ArrayExpr*>(
+        outer_geo_cast_coord_array->get_operand());
+    CHECK(outer_geo_coord_array);
+    CHECK(outer_geo_coord_array->isLocalAlloc());
+    CHECK(outer_geo_coord_array->getElementCount() == 2);
+    CHECK(outer_geo_ti.get_size() == 2 * sizeof(double));
+    const auto outer_geo_constructed_lvs = code_generator.codegen(outer_geo, true, co);
+    // CHECK_EQ(outer_geo_constructed_lvs.size(), size_t(2));     // Pointer and size
+    const auto array_ptr = outer_geo_constructed_lvs.front();  // Just need the pointer
+    arr_ptr = LL_BUILDER.CreateGEP(array_ptr, LL_INT(0));
+    arr_ptr = code_generator.castArrayPointer(array_ptr, SQLTypeInfo(kTINYINT, true));
+  }
+  if (!arr_ptr) {
+    LOG(FATAL) << "Overlaps key currently only supported for geospatial columns and "
+                  "constructed points.";
+  }
+
+  for (size_t i = 0; i < 2; i++) {
+    const auto key_comp_dest_lv = LL_BUILDER.CreateGEP(key_buff_lv, LL_INT(i));
+
+    // Note that get_bucket_key_for_range_compressed will need to be specialized for
+    // future compression schemes
+    auto bucket_key =
+        outer_geo_ti.get_compression() == kENCODING_GEOINT
+            ? executor_->cgen_state_->emitExternalCall(
+                  "get_bucket_key_for_range_compressed",
+                  get_int_type(64, LL_CONTEXT),
+                  {arr_ptr, LL_INT(i), LL_FP(inverse_bucket_sizes_for_dimension_[i])})
+            : executor_->cgen_state_->emitExternalCall(
+                  "get_bucket_key_for_range_double",
+                  get_int_type(64, LL_CONTEXT),
+                  {arr_ptr, LL_INT(i), LL_FP(inverse_bucket_sizes_for_dimension_[i])});
+    const auto col_lv = LL_BUILDER.CreateSExt(
+        bucket_key, get_int_type(key_component_width * 8, LL_CONTEXT));
+    LL_BUILDER.CreateStore(col_lv, key_comp_dest_lv);
   }
   return key_buff_lv;
 }
diff -Naur ./QueryEngine/JoinHashTable/OverlapsJoinHashTable.h ../omniscidb-master/QueryEngine/JoinHashTable/OverlapsJoinHashTable.h
--- ./QueryEngine/JoinHashTable/OverlapsJoinHashTable.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/JoinHashTable/OverlapsJoinHashTable.h	2021-04-21 00:02:57.000000000 +0300
@@ -25,6 +25,8 @@
   const size_t num_elements;
   const std::vector<ChunkKey> chunk_keys;
   const SQLOps optype;
+  const size_t max_hashtable_size;
+  const double bucket_threshold;
   const std::vector<double> inverse_bucket_sizes;
 
   bool operator==(const struct OverlapsHashTableCacheKey& that) const {
@@ -38,24 +40,33 @@
       }
     }
     return num_elements == that.num_elements && chunk_keys == that.chunk_keys &&
-           optype == that.optype;
+           optype == that.optype && max_hashtable_size == that.max_hashtable_size &&
+           bucket_threshold == that.bucket_threshold;
   }
 
   OverlapsHashTableCacheKey(const size_t num_elements,
                             const std::vector<ChunkKey>& chunk_keys,
                             const SQLOps& optype,
-                            const std::vector<double> inverse_bucket_sizes)
+                            const size_t max_hashtable_size,
+                            const double bucket_threshold,
+                            const std::vector<double> inverse_bucket_sizes = {})
       : num_elements(num_elements)
       , chunk_keys(chunk_keys)
       , optype(optype)
+      , max_hashtable_size(max_hashtable_size)
+      , bucket_threshold(bucket_threshold)
       , inverse_bucket_sizes(inverse_bucket_sizes) {}
 
   // "copy" constructor
-  OverlapsHashTableCacheKey(const HashTableCacheKey& that,
-                            const std::vector<double>& inverse_bucket_sizes)
+  OverlapsHashTableCacheKey(const OverlapsHashTableCacheKey& that,
+                            const size_t max_hashtable_size,
+                            const double bucket_threshold,
+                            const std::vector<double>& inverse_bucket_sizes = {})
       : num_elements(that.num_elements)
       , chunk_keys(that.chunk_keys)
       , optype(that.optype)
+      , max_hashtable_size(max_hashtable_size)
+      , bucket_threshold(bucket_threshold)
       , inverse_bucket_sizes(inverse_bucket_sizes) {}
 };
 
@@ -135,12 +146,18 @@
                          const HashType layout,
                          const size_t shard_count,
                          const size_t entry_count,
-                         const size_t emitted_keys_count);
+                         const size_t emitted_keys_count,
+                         const bool skip_hashtable_caching,
+                         const size_t chosen_max_hashtable_size,
+                         const double chosen_bucket_threshold);
 
   void reifyForDevice(const ColumnsForDevice& columns_for_device,
                       const HashType layout,
                       const size_t entry_count,
                       const size_t emitted_keys_count,
+                      const bool skip_hashtable_caching,
+                      const size_t chosen_max_hashtable_size,
+                      const double chosen_bucket_threshold,
                       const int device_id,
                       const logger::ThreadId parent_thread_id);
 
@@ -156,13 +173,17 @@
   // returns entry_count, emitted_keys_count
   virtual std::pair<size_t, size_t> approximateTupleCount(
       const std::vector<double>& inverse_bucket_sizes_for_dimension,
-      std::vector<ColumnsForDevice>&);
+      std::vector<ColumnsForDevice>&,
+      const size_t chosen_max_hashtable_size,
+      const double chosen_bucket_threshold);
 
   // returns entry_count, emitted_keys_count
   virtual std::pair<size_t, size_t> computeHashTableCounts(
       const size_t shard_count,
       const std::vector<double>& inverse_bucket_sizes_for_dimension,
-      std::vector<ColumnsForDevice>& columns_per_device);
+      std::vector<ColumnsForDevice>& columns_per_device,
+      const size_t chosen_max_hashtable_size,
+      const double chosen_bucket_threshold);
 
   void setInverseBucketSizeInfo(const std::vector<double>& inverse_bucket_sizes,
                                 std::vector<ColumnsForDevice>& columns_per_device,
@@ -193,7 +214,10 @@
       const std::vector<JoinBucketInfo>& join_bucket_info,
       const HashType layout,
       const size_t entry_count,
-      const size_t emitted_keys_count);
+      const size_t emitted_keys_count,
+      const bool skip_hashtable_caching,
+      const size_t chosen_max_hashtable_size,
+      const double chosen_bucket_threshold);
 
 #ifdef HAVE_CUDA
   std::shared_ptr<BaselineHashTable> initHashTableOnGpu(
@@ -340,7 +364,7 @@
   using BucketThreshold = double;
   using BucketSizes = std::vector<double>;
   static std::unique_ptr<
-      HashTableCache<HashTableCacheKey, std::pair<BucketThreshold, BucketSizes>>>
+      HashTableCache<OverlapsHashTableCacheKey, std::pair<BucketThreshold, BucketSizes>>>
       auto_tuner_cache_;
 
   QueryHint query_hint_;
diff -Naur ./QueryEngine/JoinHashTable/Runtime/HashJoinRuntime.cpp ../omniscidb-master/QueryEngine/JoinHashTable/Runtime/HashJoinRuntime.cpp
--- ./QueryEngine/JoinHashTable/Runtime/HashJoinRuntime.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/JoinHashTable/Runtime/HashJoinRuntime.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -1342,7 +1342,7 @@
 
   std::vector<int32_t> count_copy(hash_entry_count, 0);
   CHECK_GT(hash_entry_count, int64_t(0));
-  memcpy(&count_copy[1], count_buff, (hash_entry_count - 1) * sizeof(int32_t));
+  memcpy(count_copy.data() + 1, count_buff, (hash_entry_count - 1) * sizeof(int32_t));
 #if HAVE_CUDA
   thrust::inclusive_scan(count_copy.begin(), count_copy.end(), count_copy.begin());
 #else
diff -Naur ./QueryEngine/JoinHashTable/Runtime/JoinHashTableQueryRuntime.cpp ../omniscidb-master/QueryEngine/JoinHashTable/Runtime/JoinHashTableQueryRuntime.cpp
--- ./QueryEngine/JoinHashTable/Runtime/JoinHashTableQueryRuntime.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/JoinHashTable/Runtime/JoinHashTableQueryRuntime.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -80,7 +80,7 @@
   return kNoMatch;
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t
 baseline_hash_join_idx_32(const int8_t* hash_buff,
                           const int8_t* key,
                           const size_t key_bytes,
@@ -88,7 +88,7 @@
   return baseline_hash_join_idx_impl<int32_t>(hash_buff, key, key_bytes, entry_count);
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t
 baseline_hash_join_idx_64(const int8_t* hash_buff,
                           const int8_t* key,
                           const size_t key_bytes,
@@ -102,7 +102,7 @@
   return static_cast<int64_t>(floor(static_cast<double>(value) * bucket_size));
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t
 get_bucket_key_for_range_double(const int8_t* range_bytes,
                                 const size_t range_component_index,
                                 const double bucket_size) {
@@ -126,7 +126,7 @@
   }
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t
 get_bucket_key_for_range_compressed(const int8_t* range,
                                     const size_t range_component_index,
                                     const double bucket_size) {
@@ -158,7 +158,7 @@
   return -1;
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t
 get_composite_key_index_32(const int32_t* key,
                            const size_t key_component_count,
                            const int32_t* composite_key_dict,
@@ -167,7 +167,7 @@
       key, key_component_count, composite_key_dict, entry_count);
 }
 
-extern "C" NEVER_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t
 get_composite_key_index_64(const int64_t* key,
                            const size_t key_component_count,
                            const int64_t* composite_key_dict,
@@ -176,9 +176,9 @@
       key, key_component_count, composite_key_dict, entry_count);
 }
 
-extern "C" NEVER_INLINE DEVICE int32_t insert_sorted(int32_t* arr,
-                                                     size_t elem_count,
-                                                     int32_t elem) {
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int32_t insert_sorted(int32_t* arr,
+                                                                    size_t elem_count,
+                                                                    int32_t elem) {
   for (size_t i = 0; i < elem_count; i++) {
     if (elem == arr[i])
       return 0;
@@ -197,10 +197,11 @@
   return 1;
 }
 
-extern "C" ALWAYS_INLINE DEVICE int64_t overlaps_hash_join_idx(int64_t hash_buff,
-                                                               const int64_t key,
-                                                               const int64_t min_key,
-                                                               const int64_t max_key) {
+extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE int64_t
+overlaps_hash_join_idx(int64_t hash_buff,
+                       const int64_t key,
+                       const int64_t min_key,
+                       const int64_t max_key) {
   if (key >= min_key && key <= max_key) {
     return *(reinterpret_cast<int32_t*>(hash_buff) + (key - min_key));
   }
@@ -226,7 +227,7 @@
       get_composite_key_index_64(key, key_component_count, hash_table_ptr, entry_count);
 
   if (key_idx < -1) {
-    return BufferRange{.buffer = nullptr, .element_count = 0};
+    return BufferRange{nullptr, 0};
   }
 
   int8_t* one_to_many_ptr = reinterpret_cast<int8_t*>(hash_table_ptr);
@@ -236,7 +237,7 @@
   const auto slot = overlaps_hash_join_idx(
       reinterpret_cast<int64_t>(one_to_many_ptr), key_idx, min_key, max_key);
   if (slot < 0) {
-    return BufferRange{.buffer = nullptr, .element_count = 0};
+    return BufferRange{nullptr, 0};
   }
 
   // Offset into the row count section of buffer
@@ -249,7 +250,7 @@
   int32_t* rowid_buffer = (int32_t*)(one_to_many_ptr + 2 * sub_buff_size);
   const auto rowidoff_ptr = &rowid_buffer[slot];
 
-  return BufferRange{.buffer = rowidoff_ptr, .element_count = matched_row_count};
+  return BufferRange{rowidoff_ptr, matched_row_count};
 }
 
 struct Bounds {
@@ -283,7 +284,7 @@
 /// Unique Row IDs are placed on the fixed size stack array that is passed
 /// in as out_arr.
 /// The number of row ids in this array is returned.
-extern "C" NEVER_INLINE DEVICE int64_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t
 get_candidate_rows(int32_t* out_arr,
                    const uint32_t max_arr_size,
                    const int8_t* range_bytes,
@@ -300,8 +301,7 @@
 
   size_t elem_count = 0;
 
-  const auto bounds =
-      Bounds{.min_X = range[0], .min_Y = range[1], .max_X = range[2], .max_Y = range[3]};
+  const auto bounds = Bounds{range[0], range[1], range[2], range[3]};
 
   for (int64_t x = floor(bounds.min_X * bucket_size_x);
        x <= floor(bounds.max_X * bucket_size_x);
@@ -334,7 +334,7 @@
 // /// Given the bounding box and the bucket size,
 // /// return the number of buckets the bounding box
 // /// will be split into.
-extern "C" NEVER_INLINE DEVICE int32_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int32_t
 get_num_buckets_for_bounds(const int8_t* range_bytes,
                            const int32_t range_component_index,
                            const double bucket_size_x,
diff -Naur ./QueryEngine/LoopControlFlow/JoinLoopTest.cpp ../omniscidb-master/QueryEngine/LoopControlFlow/JoinLoopTest.cpp
--- ./QueryEngine/LoopControlFlow/JoinLoopTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/LoopControlFlow/JoinLoopTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -33,7 +33,9 @@
 #include <memory>
 #include <vector>
 
-extern "C" void print_iterators(const int64_t i, const int64_t j, const int64_t k) {
+extern "C" RUNTIME_EXPORT void print_iterators(const int64_t i,
+                                               const int64_t j,
+                                               const int64_t k) {
   printf("%ld, %ld, %ld\n", i, j, k);
 }
 
diff -Naur ./QueryEngine/MurmurHash.cpp ../omniscidb-master/QueryEngine/MurmurHash.cpp
--- ./QueryEngine/MurmurHash.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/MurmurHash.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -17,14 +17,14 @@
 #include "MurmurHash.h"
 #include "MurmurHash1Inl.h"
 
-extern "C" NEVER_INLINE DEVICE uint32_t MurmurHash1(const void* key,
-                                                    int len,
-                                                    const uint32_t seed) {
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE uint32_t MurmurHash1(const void* key,
+                                                                   int len,
+                                                                   const uint32_t seed) {
   return MurmurHash1Impl(key, len, seed);
 }
 
-extern "C" NEVER_INLINE DEVICE uint64_t MurmurHash64A(const void* key,
-                                                      int len,
-                                                      uint64_t seed) {
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE uint64_t MurmurHash64A(const void* key,
+                                                                     int len,
+                                                                     uint64_t seed) {
   return MurmurHash64AImpl(key, len, seed);
 }
diff -Naur ./QueryEngine/MurmurHash.h ../omniscidb-master/QueryEngine/MurmurHash.h
--- ./QueryEngine/MurmurHash.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/MurmurHash.h	2021-04-21 00:02:57.000000000 +0300
@@ -20,12 +20,10 @@
 #include <cstdint>
 #include "../Shared/funcannotations.h"
 
-extern "C" NEVER_INLINE DEVICE uint32_t MurmurHash1(const void* key,
-                                                    int len,
-                                                    const uint32_t seed);
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE RUNTIME_EXPORT uint32_t
+MurmurHash1(const void* key, int len, const uint32_t seed);
 
-extern "C" NEVER_INLINE DEVICE uint64_t MurmurHash64A(const void* key,
-                                                      int len,
-                                                      uint64_t seed);
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE RUNTIME_EXPORT uint64_t
+MurmurHash64A(const void* key, int len, uint64_t seed);
 
 #endif  // QUERYENGINE_MURMURHASH_H
diff -Naur ./QueryEngine/NativeCodegen.cpp ../omniscidb-master/QueryEngine/NativeCodegen.cpp
--- ./QueryEngine/NativeCodegen.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/NativeCodegen.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -215,7 +215,7 @@
         } else {
           if (defined.find(F2name) == defined.end()) {
             defined.emplace(F2name);
-            scan_function_calls(*F2, defined, undefined, ignored);
+            scan_function_calls<T>(*F2, defined, undefined, ignored);
           }
         }
       }
@@ -443,6 +443,13 @@
     eb.setOptLevel(llvm::CodeGenOpt::None);
   }
 
+#ifdef _WIN32
+  // TODO: workaround for data layout mismatch crash for now
+  auto target_machine = eb.selectTarget();
+  CHECK(target_machine);
+  module->setDataLayout(target_machine->createDataLayout());
+#endif
+
   ExecutionEngineWrapper execution_engine(eb.create(), co);
   CHECK(execution_engine.get());
   LOG(ASM) << assemblyForCPU(execution_engine, module);
@@ -787,7 +794,6 @@
 declare void @agg_count_distinct_bitmap_gpu(i64*, i64, i64, i64, i64, i64, i64);
 declare void @agg_count_distinct_bitmap_skip_val_gpu(i64*, i64, i64, i64, i64, i64, i64, i64);
 declare void @agg_approximate_count_distinct_gpu(i64*, i64, i32, i64, i64);
-declare void @agg_approx_median(i64*, double);
 declare void @record_error_code(i32, i32*);
 declare i32 @get_error_code(i32*);
 declare i1 @dynamic_watchdog();
@@ -1334,7 +1340,11 @@
          func->getName() == "fixed_width_double_decode" ||
          func->getName() == "fixed_width_float_decode" ||
          func->getName() == "fixed_width_small_date_decode" ||
-         func->getName() == "record_error_code" || func->getName() == "get_error_code";
+         func->getName() == "record_error_code" || func->getName() == "get_error_code" ||
+         func->getName() == "pos_start_impl" || func->getName() == "pos_step_impl" ||
+         func->getName() == "group_buff_idx_impl" ||
+         func->getName() == "init_shared_mem" ||
+         func->getName() == "init_shared_mem_nop" || func->getName() == "write_back_nop";
 }
 
 llvm::Module* read_template_module(llvm::LLVMContext& context) {
@@ -3053,13 +3063,15 @@
       cgen_state_->ir_builder_.CreateRet(cgen_state_->llInt<int32_t>(0));
     }
 
-    redeclareFilterFunction();
-
     cgen_state_->ir_builder_.SetInsertPoint(cgen_state_->row_func_bb_);
     cgen_state_->current_func_ = cgen_state_->row_func_;
     cgen_state_->filter_func_call_ =
         cgen_state_->ir_builder_.CreateCall(cgen_state_->filter_func_, {});
 
+    // Create real filter function declaration after placeholder call
+    // is emitted.
+    redeclareFilterFunction();
+
     if (cgen_state_->row_func_bb_->getName() == "loop_body") {
       auto loop_done_true = llvm::BasicBlock::Create(
           cgen_state_->context_, "loop_done_true", cgen_state_->row_func_);
diff -Naur ./QueryEngine/OmniSciTypes.h ../omniscidb-master/QueryEngine/OmniSciTypes.h
--- ./QueryEngine/OmniSciTypes.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/OmniSciTypes.h	2021-04-21 00:02:57.000000000 +0300
@@ -23,8 +23,8 @@
 #include "../Shared/InlineNullValues.h"
 #include "../Shared/funcannotations.h"
 
-#define EXTENSION_INLINE extern "C" ALWAYS_INLINE DEVICE
-#define EXTENSION_NOINLINE extern "C" NEVER_INLINE DEVICE
+#define EXTENSION_INLINE extern "C" RUNTIME_EXPORT ALWAYS_INLINE DEVICE
+#define EXTENSION_NOINLINE extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE
 
 EXTENSION_NOINLINE int8_t* allocate_varlen_buffer(int64_t element_count,
                                                   int64_t element_size);
diff -Naur ./QueryEngine/QueryExecutionContext.cpp ../omniscidb-master/QueryEngine/QueryExecutionContext.cpp
--- ./QueryEngine/QueryExecutionContext.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/QueryExecutionContext.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -601,7 +601,7 @@
 
   std::vector<const int8_t**> multifrag_col_buffers;
   for (auto& col_buffer : col_buffers) {
-    multifrag_col_buffers.push_back(&col_buffer[0]);
+    multifrag_col_buffers.push_back(col_buffer.empty() ? nullptr : col_buffer.data());
   }
   const int8_t*** multifrag_cols_ptr{
       multifrag_col_buffers.empty() ? nullptr : &multifrag_col_buffers[0]};
@@ -670,12 +670,12 @@
       reinterpret_cast<agg_query>(native_code->func())(
           multifrag_cols_ptr,
           &num_fragments,
-          &literal_buff[0],
+          literal_buff.data(),
           num_rows_ptr,
-          &flatened_frag_offsets[0],
+          flatened_frag_offsets.data(),
           &scan_limit,
           &total_matched_init,
-          &cmpt_val_buff[0],
+          cmpt_val_buff.data(),
           query_buffers_->getGroupByBuffersPtr(),
           error_code,
           &num_tables,
@@ -683,13 +683,13 @@
     } else {
       reinterpret_cast<agg_query>(native_code->func())(multifrag_cols_ptr,
                                                        &num_fragments,
-                                                       &literal_buff[0],
+                                                       literal_buff.data(),
                                                        num_rows_ptr,
-                                                       &flatened_frag_offsets[0],
+                                                       flatened_frag_offsets.data(),
                                                        &scan_limit,
                                                        &total_matched_init,
-                                                       &init_agg_vals[0],
-                                                       &out_vec[0],
+                                                       init_agg_vals.data(),
+                                                       out_vec.data(),
                                                        error_code,
                                                        &num_tables,
                                                        join_hash_tables_ptr);
@@ -711,10 +711,10 @@
           multifrag_cols_ptr,
           &num_fragments,
           num_rows_ptr,
-          &flatened_frag_offsets[0],
+          flatened_frag_offsets.data(),
           &scan_limit,
           &total_matched_init,
-          &cmpt_val_buff[0],
+          cmpt_val_buff.data(),
           query_buffers_->getGroupByBuffersPtr(),
           error_code,
           &num_tables,
@@ -723,11 +723,11 @@
       reinterpret_cast<agg_query>(native_code->func())(multifrag_cols_ptr,
                                                        &num_fragments,
                                                        num_rows_ptr,
-                                                       &flatened_frag_offsets[0],
+                                                       flatened_frag_offsets.data(),
                                                        &scan_limit,
                                                        &total_matched_init,
-                                                       &init_agg_vals[0],
-                                                       &out_vec[0],
+                                                       init_agg_vals.data(),
+                                                       out_vec.data(),
                                                        error_code,
                                                        &num_tables,
                                                        join_hash_tables_ptr);
diff -Naur ./QueryEngine/QueryHint.h ../omniscidb-master/QueryEngine/QueryHint.h
--- ./QueryEngine/QueryHint.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/QueryHint.h	2021-04-21 00:02:57.000000000 +0300
@@ -37,6 +37,8 @@
     overlaps_bucket_threshold = other.overlaps_bucket_threshold;
     overlaps_max_size = other.overlaps_max_size;
     overlaps_allow_gpu_build = other.overlaps_allow_gpu_build;
+    overlaps_no_cache = other.overlaps_no_cache;
+    overlaps_keys_per_bin = other.overlaps_keys_per_bin;
     registered_hint = other.registered_hint;
     return *this;
   }
@@ -46,6 +48,8 @@
     overlaps_bucket_threshold = other.overlaps_bucket_threshold;
     overlaps_max_size = other.overlaps_max_size;
     overlaps_allow_gpu_build = other.overlaps_allow_gpu_build;
+    overlaps_no_cache = other.overlaps_no_cache;
+    overlaps_keys_per_bin = other.overlaps_keys_per_bin;
     registered_hint = other.registered_hint;
   }
 
@@ -56,12 +60,16 @@
   double overlaps_bucket_threshold;  // defined in "OverlapsJoinHashTable.h"
   size_t overlaps_max_size;
   bool overlaps_allow_gpu_build;
+  bool overlaps_no_cache;
+  double overlaps_keys_per_bin;
 
   std::unordered_map<std::string, size_t> OMNISCI_SUPPORTED_HINT_CLASS = {
       {"cpu_mode", 0},
       {"overlaps_bucket_threshold", 1},
       {"overlaps_max_size", 2},
-      {"overlaps_allow_gpu_build", 3}};
+      {"overlaps_allow_gpu_build", 3},
+      {"overlaps_no_cache", 4},
+      {"overlaps_keys_per_bin", 5}};
 
   std::vector<bool> registered_hint;
 
diff -Naur ./QueryEngine/QueryMemoryInitializer.cpp ../omniscidb-master/QueryEngine/QueryMemoryInitializer.cpp
--- ./QueryEngine/QueryMemoryInitializer.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/QueryMemoryInitializer.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -27,7 +27,7 @@
 #include <Shared/checked_alloc.h>
 
 // 8 GB, the limit of perfect hash group by under normal conditions
-int64_t g_bitmap_memory_limit{8 * 1000 * 1000 * 1000L};
+int64_t g_bitmap_memory_limit{8LL * 1000 * 1000 * 1000};
 
 namespace {
 
diff -Naur ./QueryEngine/QueryRewrite.cpp ../omniscidb-master/QueryEngine/QueryRewrite.cpp
--- ./QueryEngine/QueryRewrite.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/QueryRewrite.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -276,8 +276,10 @@
         // Codegen expects a string value. The string will be
         // resolved to its ID during Constant codegen. Copy the string from the
         // original expr
-        Datum new_string_datum{.stringval = new std::string(
-                                   *original_constant_expr->get_constval().stringval)};
+        Datum datum;
+        datum.stringval =
+            new std::string(*original_constant_expr->get_constval().stringval);
+        Datum new_string_datum{datum};
 
         new_column_value =
             makeExpr<Analyzer::Constant>(column_to_update->get_type_info(),
@@ -393,7 +395,8 @@
     throw std::runtime_error("Delete via join not yet supported for temporary tables.");
   }
 
-  const auto true_datum = Datum{.boolval = true};
+  Datum true_datum;
+  true_datum.boolval = true;
   const auto deleted_constant =
       makeExpr<Analyzer::Constant>(delete_column->get_type_info(), false, true_datum);
 
diff -Naur ./QueryEngine/RelAlgDagBuilder.cpp ../omniscidb-master/QueryEngine/RelAlgDagBuilder.cpp
--- ./QueryEngine/RelAlgDagBuilder.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/RelAlgDagBuilder.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -1611,7 +1611,7 @@
 
   auto reset_state = [&crt_pattern, &crt_state]() {
     crt_state = CoalesceState::Initial;
-    decltype(crt_pattern)().swap(crt_pattern);
+    std::vector<size_t>().swap(crt_pattern);
   };
 
   for (RANodeIterator nodeIt(nodes); !nodeIt.allVisited();) {
diff -Naur ./QueryEngine/RelAlgDagBuilder.h ../omniscidb-master/QueryEngine/RelAlgDagBuilder.h
--- ./QueryEngine/RelAlgDagBuilder.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/RelAlgDagBuilder.h	2021-04-21 00:02:57.000000000 +0300
@@ -1023,8 +1023,10 @@
 
   void injectOffsetInFragmentExpr() const {
     RexFunctionOperator::ConstRexScalarPtrVector transient_vector;
-    scalar_exprs_.emplace_back(std::make_unique<RexFunctionOperator const>(
-        std::string("OFFSET_IN_FRAGMENT"), transient_vector, SQLTypeInfo(kINT, false)));
+    scalar_exprs_.emplace_back(
+        std::make_unique<RexFunctionOperator const>(std::string("OFFSET_IN_FRAGMENT"),
+                                                    transient_vector,
+                                                    SQLTypeInfo(kBIGINT, false)));
     fields_.emplace_back("EXPR$DELETE_OFFSET_IN_FRAGMENT");
   }
 
@@ -1900,6 +1902,26 @@
             VLOG(1) << "Allowing GPU hash table build for overlaps join.";
             break;
           }
+          case 4: {  // overlaps_no_cache
+            query_hint_.registerHint(kv.first);
+            query_hint_.overlaps_no_cache = true;
+            VLOG(1) << "Skip auto tuner and hashtable caching for overlaps join.";
+            break;
+          }
+          case 5: {  // overlaps_keys_per_bin
+            CHECK(target->second.getListOptions().size() == 1);
+            double overlaps_keys_per_bin = std::stod(target->second.getListOptions()[0]);
+            if (overlaps_keys_per_bin > 0.0 &&
+                overlaps_keys_per_bin < std::numeric_limits<double>::max()) {
+              query_hint_.registerHint(kv.first);
+              query_hint_.overlaps_keys_per_bin = overlaps_keys_per_bin;
+            } else {
+              VLOG(1) << "Skip the given query hint \"overlaps_keys_per_bin\" ("
+                      << overlaps_keys_per_bin
+                      << ") : the hint value should be larger than zero";
+            }
+            break;
+          }
           default:
             break;
         }
diff -Naur ./QueryEngine/RelAlgExecutor.cpp ../omniscidb-master/QueryEngine/RelAlgExecutor.cpp
--- ./QueryEngine/RelAlgExecutor.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/RelAlgExecutor.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -603,7 +603,23 @@
 
   time(&now_);
   CHECK(!seq.empty());
-  const auto exec_desc_count = eo.just_explain ? size_t(1) : seq.size();
+
+  auto get_descriptor_count = [&seq, &eo]() -> size_t {
+    if (eo.just_explain) {
+      if (dynamic_cast<const RelLogicalValues*>(seq.getDescriptor(0)->getBody())) {
+        // run the logical values descriptor to generate the result set, then the next
+        // descriptor to generate the explain
+        CHECK_GE(seq.size(), size_t(2));
+        return 2;
+      } else {
+        return 1;
+      }
+    } else {
+      return seq.size();
+    }
+  };
+
+  const auto exec_desc_count = get_descriptor_count();
 
   for (size_t i = 0; i < exec_desc_count; i++) {
     VLOG(1) << "Executing query step " << i;
@@ -2029,10 +2045,6 @@
     const RelLogicalValues* logical_values,
     const ExecutionOptions& eo) {
   auto timer = DEBUG_TIMER(__func__);
-  if (eo.just_explain) {
-    throw std::runtime_error("EXPLAIN not supported for LogicalValues");
-  }
-
   QueryMemoryDescriptor query_mem_desc(executor_,
                                        logical_values->getNumRows(),
                                        QueryDescriptionType::Projection,
@@ -3240,47 +3252,77 @@
     }
     return;
   }
-  if (error_code == Executor::ERR_INTERRUPTED) {
-    Executor::getExecutor(Executor::UNITARY_EXECUTOR_ID)->resetInterrupt();
-  }
   throw std::runtime_error(getErrorMessageFromCode(error_code));
 }
 
-std::string RelAlgExecutor::getErrorMessageFromCode(const int32_t error_code) {
-  if (error_code < 0) {
-    return "Ran out of slots in the query output buffer";
-  }
+namespace {
+struct ErrorInfo {
+  const char* code{nullptr};
+  const char* description{nullptr};
+};
+ErrorInfo getErrorDescription(const int32_t error_code) {
   switch (error_code) {
     case Executor::ERR_DIV_BY_ZERO:
-      return "Division by zero";
+      return {.code = "ERR_DIV_BY_ZERO", .description = "Division by zero"};
     case Executor::ERR_OUT_OF_GPU_MEM:
-      return "Query couldn't keep the entire working set of columns in GPU memory";
+      return {.code = "ERR_OUT_OF_GPU_MEM",
+              .description =
+                  "Query couldn't keep the entire working set of columns in GPU memory"};
     case Executor::ERR_UNSUPPORTED_SELF_JOIN:
-      return "Self joins not supported yet";
+      return {.code = "ERR_UNSUPPORTED_SELF_JOIN",
+              .description = "Self joins not supported yet"};
     case Executor::ERR_OUT_OF_CPU_MEM:
-      return "Not enough host memory to execute the query";
+      return {.code = "ERR_OUT_OF_CPU_MEM",
+              .description = "Not enough host memory to execute the query"};
     case Executor::ERR_OVERFLOW_OR_UNDERFLOW:
-      return "Overflow or underflow";
+      return {.code = "ERR_OVERFLOW_OR_UNDERFLOW",
+              .description = "Overflow or underflow"};
     case Executor::ERR_OUT_OF_TIME:
-      return "Query execution has exceeded the time limit";
+      return {.code = "ERR_OUT_OF_TIME",
+              .description = "Query execution has exceeded the time limit"};
     case Executor::ERR_INTERRUPTED:
-      return "Query execution has been interrupted";
+      return {.code = "ERR_INTERRUPTED",
+              .description = "Query execution has been interrupted"};
     case Executor::ERR_COLUMNAR_CONVERSION_NOT_SUPPORTED:
-      return "Columnar conversion not supported for variable length types";
+      return {
+          .code = "ERR_COLUMNAR_CONVERSION_NOT_SUPPORTED",
+          .description = "Columnar conversion not supported for variable length types"};
     case Executor::ERR_TOO_MANY_LITERALS:
-      return "Too many literals in the query";
+      return {.code = "ERR_TOO_MANY_LITERALS",
+              .description = "Too many literals in the query"};
     case Executor::ERR_STRING_CONST_IN_RESULTSET:
-      return "NONE ENCODED String types are not supported as input result set.";
+      return {.code = "ERR_STRING_CONST_IN_RESULTSET",
+              .description =
+                  "NONE ENCODED String types are not supported as input result set."};
     case Executor::ERR_OUT_OF_RENDER_MEM:
-      return "Not enough OpenGL memory to render the query results";
+      return {.code = "ERR_OUT_OF_RENDER_MEM",
+              .description = "Not enough OpenGL memory to render the query results"};
     case Executor::ERR_STREAMING_TOP_N_NOT_SUPPORTED_IN_RENDER_QUERY:
-      return "Streaming-Top-N not supported in Render Query";
+      return {.code = "ERR_STREAMING_TOP_N_NOT_SUPPORTED_IN_RENDER_QUERY",
+              .description = "Streaming-Top-N not supported in Render Query"};
     case Executor::ERR_SINGLE_VALUE_FOUND_MULTIPLE_VALUES:
-      return "Multiple distinct values encountered";
+      return {.code = "ERR_SINGLE_VALUE_FOUND_MULTIPLE_VALUES",
+              .description = "Multiple distinct values encountered"};
     case Executor::ERR_GEOS:
-      return "Geos call failure";
+      return {.code = "ERR_GEOS", .description = "ERR_GEOS"};
+    default:
+      return {.code = nullptr, .description = nullptr};
+  }
+}
+
+}  // namespace
+
+std::string RelAlgExecutor::getErrorMessageFromCode(const int32_t error_code) {
+  if (error_code < 0) {
+    return "Ran out of slots in the query output buffer";
+  }
+  const auto errorInfo = getErrorDescription(error_code);
+
+  if (errorInfo.code) {
+    return errorInfo.code + ": "s + errorInfo.description;
+  } else {
+    return "Other error: code "s + std::to_string(error_code);
   }
-  return "Other error: code " + std::to_string(error_code);
 }
 
 void RelAlgExecutor::executePostExecutionCallback() {
diff -Naur ./QueryEngine/ResultSet.h ../omniscidb-master/QueryEngine/ResultSet.h
--- ./QueryEngine/ResultSet.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ResultSet.h	2021-04-21 00:02:57.000000000 +0300
@@ -193,6 +193,11 @@
 
   ~ResultSet();
 
+  std::string toString() const {
+    return typeName(this) + "(targets=" + ::toString(targets_) +
+           ", query_mem_desc=" + ::toString(query_mem_desc_) + ")";
+  }
+
   inline ResultSetRowIterator rowIterator(size_t from_logical_index,
                                           bool translate_strings,
                                           bool decimal_to_double) const {
@@ -315,6 +320,13 @@
   void setValidationOnlyRes();
   bool isValidationOnlyRes() const;
 
+  std::string getExplanation() const {
+    if (just_explain_) {
+      return explanation_;
+    }
+    return {};
+  }
+
   bool isGeoColOnGpu(const size_t col_idx) const;
   int getDeviceId() const;
 
diff -Naur ./QueryEngine/ResultSetReduction.cpp ../omniscidb-master/QueryEngine/ResultSetReduction.cpp
--- ./QueryEngine/ResultSetReduction.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ResultSetReduction.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -156,14 +156,14 @@
     std::lock_guard<std::mutex> compilation_lock(Executor::compilation_mutex_);
     auto ret = ReductionInterpreter::run(
         reduction_code.ir_reduce_loop.get(),
-        {ReductionInterpreter::EvalValue{.ptr = this_buff},
-         ReductionInterpreter::EvalValue{.ptr = that_buff},
-         ReductionInterpreter::EvalValue{.int_val = start_entry_index},
-         ReductionInterpreter::EvalValue{.int_val = end_entry_index},
-         ReductionInterpreter::EvalValue{.int_val = that_entry_count},
-         ReductionInterpreter::EvalValue{.ptr = this_qmd},
-         ReductionInterpreter::EvalValue{.ptr = that_qmd},
-         ReductionInterpreter::EvalValue{.ptr = serialized_varlen_buffer}});
+        {ReductionInterpreter::MakeEvalValue(this_buff),
+         ReductionInterpreter::MakeEvalValue(that_buff),
+         ReductionInterpreter::MakeEvalValue(start_entry_index),
+         ReductionInterpreter::MakeEvalValue(end_entry_index),
+         ReductionInterpreter::MakeEvalValue(that_entry_count),
+         ReductionInterpreter::MakeEvalValue(this_qmd),
+         ReductionInterpreter::MakeEvalValue(that_qmd),
+         ReductionInterpreter::MakeEvalValue(serialized_varlen_buffer)});
     err = ret.int_val;
   }
   if (err) {
diff -Naur ./QueryEngine/ResultSetReductionInterpreter.cpp ../omniscidb-master/QueryEngine/ResultSetReductionInterpreter.cpp
--- ./QueryEngine/ResultSetReductionInterpreter.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ResultSetReductionInterpreter.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -70,7 +70,7 @@
     const auto index = interpreter->vars_[gep->index()->id()];
     auto result_ptr =
         reinterpret_cast<const int8_t*>(base.ptr) + index.int_val * element_size;
-    interpreter->setVar(gep, ReductionInterpreter::EvalValue{.ptr = result_ptr});
+    interpreter->setVar(gep, ReductionInterpreter::MakeEvalValue(result_ptr));
   }
 
   static void runLoad(const Instruction* instruction,
@@ -83,34 +83,32 @@
     switch (source_type) {
       case Type::Int8Ptr: {
         const auto int_val = *reinterpret_cast<const int8_t*>(source.ptr);
-        interpreter->setVar(load, ReductionInterpreter::EvalValue{.int_val = int_val});
+        interpreter->setVar(load, ReductionInterpreter::MakeEvalValue(int_val));
         break;
       }
       case Type::Int32Ptr: {
         const auto int_val = *reinterpret_cast<const int32_t*>(source.ptr);
-        interpreter->setVar(load, ReductionInterpreter::EvalValue{.int_val = int_val});
+        interpreter->setVar(load, ReductionInterpreter::MakeEvalValue(int_val));
         break;
       }
       case Type::Int64Ptr: {
         const auto int_val = *reinterpret_cast<const int64_t*>(source.ptr);
-        interpreter->setVar(load, ReductionInterpreter::EvalValue{.int_val = int_val});
+        interpreter->setVar(load, ReductionInterpreter::MakeEvalValue(int_val));
         break;
       }
       case Type::FloatPtr: {
         const auto float_val = *reinterpret_cast<const float*>(source.ptr);
-        interpreter->setVar(load,
-                            ReductionInterpreter::EvalValue{.float_val = float_val});
+        interpreter->setVar(load, ReductionInterpreter::MakeEvalValue(float_val));
         break;
       }
       case Type::DoublePtr: {
         const auto double_val = *reinterpret_cast<const double*>(source.ptr);
-        interpreter->setVar(load,
-                            ReductionInterpreter::EvalValue{.double_val = double_val});
+        interpreter->setVar(load, ReductionInterpreter::MakeEvalValue(double_val));
         break;
       }
       case Type::Int64PtrPtr: {
         const auto int_ptr_val = *reinterpret_cast<const int64_t* const*>(source.ptr);
-        interpreter->setVar(load, ReductionInterpreter::EvalValue{.ptr = int_ptr_val});
+        interpreter->setVar(load, ReductionInterpreter::MakeEvalValue(int_ptr_val));
         break;
       }
       default: {
@@ -142,7 +140,7 @@
         LOG(FATAL) << "Predicate not supported: " << static_cast<int>(icmp->predicate());
       }
     }
-    interpreter->setVar(icmp, ReductionInterpreter::EvalValue{.int_val = result});
+    interpreter->setVar(icmp, ReductionInterpreter::MakeEvalValue(result));
   }
 
   static void runBinaryOperator(const Instruction* instruction,
@@ -167,8 +165,7 @@
                    << static_cast<int>(binary_operator->op());
       }
     }
-    interpreter->setVar(binary_operator,
-                        ReductionInterpreter::EvalValue{.int_val = result});
+    interpreter->setVar(binary_operator, ReductionInterpreter::MakeEvalValue(result));
   }
 
   static void runCast(const Instruction* instruction,
@@ -182,13 +179,12 @@
       case Cast::CastOp::Trunc:
       case Cast::CastOp::SExt: {
         CHECK(is_integer_type(cast->source()->type()));
-        interpreter->setVar(cast,
-                            ReductionInterpreter::EvalValue{.int_val = source.int_val});
+        interpreter->setVar(cast, ReductionInterpreter::MakeEvalValue(source.int_val));
         break;
       }
       case Cast::CastOp::BitCast: {
         CHECK(is_pointer_type(cast->source()->type()));
-        interpreter->setVar(cast, ReductionInterpreter::EvalValue{.ptr = source.ptr});
+        interpreter->setVar(cast, ReductionInterpreter::MakeEvalValue(source.ptr));
         break;
       }
       default: {
@@ -257,9 +253,9 @@
     CHECK(is_integer_type(alloca->array_size()->type()));
     const auto array_size = interpreter->vars_[alloca->array_size()->id()];
     interpreter->alloca_buffers_.emplace_back(element_size * array_size.int_val);
-    interpreter->setVar(alloca,
-                        ReductionInterpreter::EvalValue{
-                            .mutable_ptr = interpreter->alloca_buffers_.back().data()});
+    ReductionInterpreter::EvalValue eval_value;
+    eval_value.mutable_ptr = interpreter->alloca_buffers_.back().data();
+    interpreter->setVar(alloca, eval_value);
   }
 
   static void runMemCpy(const Instruction* instruction,
@@ -286,7 +282,7 @@
 
     if (cond.int_val) {
       auto rc = interpreter->vars_[error_code->id()].int_val;
-      interpreter->ret_ = ReductionInterpreter::EvalValue{.int_val = rc};
+      interpreter->ret_ = ReductionInterpreter::MakeEvalValue(rc);
     }
   }
 
@@ -302,7 +298,7 @@
     for (int64_t i = start.int_val; i < end.int_val; ++i) {
       // The start and end indices are absolute, but the iteration happens from 0.
       // Subtract the start index before setting the iterator.
-      interpreter->vars_[for_loop->iter()->id()] = {.int_val = i - start.int_val};
+      interpreter->vars_[for_loop->iter()->id()].int_val = i - start.int_val;
       auto ret = ReductionInterpreter::run(for_loop->body(), interpreter->vars_);
       if (ret) {
         interpreter->ret_ = *ret;
@@ -411,14 +407,16 @@
     case Type::Int8:
     case Type::Int32:
     case Type::Int64: {
-      return {.int_val = static_cast<const ConstantInt*>(constant)->value()};
+      return ReductionInterpreter::MakeEvalValue(
+          static_cast<const ConstantInt*>(constant)->value());
     }
     case Type::Float: {
-      return {.float_val =
-                  static_cast<float>(static_cast<const ConstantFP*>(constant)->value())};
+      return ReductionInterpreter::MakeEvalValue(
+          static_cast<float>(static_cast<const ConstantFP*>(constant)->value()));
     }
     case Type::Double: {
-      return {.double_val = static_cast<const ConstantFP*>(constant)->value()};
+      return ReductionInterpreter::MakeEvalValue(
+          static_cast<const ConstantFP*>(constant)->value());
     }
     default: {
       LOG(FATAL) << "Constant type not supported: " << static_cast<int>(constant->type());
diff -Naur ./QueryEngine/ResultSetReductionInterpreter.h ../omniscidb-master/QueryEngine/ResultSetReductionInterpreter.h
--- ./QueryEngine/ResultSetReductionInterpreter.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ResultSetReductionInterpreter.h	2021-04-21 00:02:57.000000000 +0300
@@ -33,6 +33,21 @@
 
   static EvalValue run(const Function* function, const std::vector<EvalValue>& inputs);
 
+  template <typename T>
+  static EvalValue MakeEvalValue(const T& val) {
+    EvalValue ret;
+    if constexpr (std::is_integral<T>::value) {
+      ret.int_val = static_cast<int64_t>(val);
+    } else if constexpr (std::is_same<T, float>::value) {
+      ret.float_val = val;
+    } else if constexpr (std::is_same<T, double>::value) {
+      ret.double_val = val;
+    } else if constexpr (std::is_pointer<T>::value) {
+      ret.ptr = val;
+    }
+    return ret;
+  }
+
   static std::optional<EvalValue> run(
       const std::vector<std::unique_ptr<Instruction>>& body,
       const std::vector<EvalValue>& vars);
diff -Naur ./QueryEngine/ResultSetReductionInterpreterStubs.cpp ../omniscidb-master/QueryEngine/ResultSetReductionInterpreterStubs.cpp
--- ./QueryEngine/ResultSetReductionInterpreterStubs.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ResultSetReductionInterpreterStubs.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -18,6 +18,8 @@
 #include "CodeGenerator.h"
 #include "ResultSetReductionCodegen.h"
 
+#include "Shared/funcannotations.h"
+
 namespace {
 
 // Creates an empty stub function, with the fixed signature required by the interpreter.
@@ -115,50 +117,59 @@
 // The following read_stub_arg_* functions read the argument at the given position from
 // the list of wrapped inputs passed from the interpreter.
 
-extern "C" int64_t read_stub_arg_int(const void* inputs_handle, const int32_t i) {
+extern "C" RUNTIME_EXPORT int64_t read_stub_arg_int(const void* inputs_handle,
+                                                    const int32_t i) {
   const auto& inputs = *reinterpret_cast<const StubGenerator::InputsType*>(inputs_handle);
   CHECK_LT(static_cast<size_t>(i), inputs.size());
   return inputs[i].int_val;
 }
 
-extern "C" float read_stub_arg_float(const void* inputs_handle, const int32_t i) {
+extern "C" RUNTIME_EXPORT float read_stub_arg_float(const void* inputs_handle,
+                                                    const int32_t i) {
   const auto& inputs = *reinterpret_cast<const StubGenerator::InputsType*>(inputs_handle);
   CHECK_LT(static_cast<size_t>(i), inputs.size());
   return inputs[i].float_val;
 }
 
-extern "C" double read_stub_arg_double(const void* inputs_handle, const int32_t i) {
+extern "C" RUNTIME_EXPORT double read_stub_arg_double(const void* inputs_handle,
+                                                      const int32_t i) {
   const auto& inputs = *reinterpret_cast<const StubGenerator::InputsType*>(inputs_handle);
   CHECK_LT(static_cast<size_t>(i), inputs.size());
   return inputs[i].double_val;
 }
 
-extern "C" const void* read_stub_arg_pvoid(const void* inputs_handle, const int32_t i) {
+extern "C" RUNTIME_EXPORT const void* read_stub_arg_pvoid(const void* inputs_handle,
+                                                          const int32_t i) {
   const auto& inputs = *reinterpret_cast<const StubGenerator::InputsType*>(inputs_handle);
   CHECK_LT(static_cast<size_t>(i), inputs.size());
   return inputs[i].ptr;
 }
 
-extern "C" const int8_t* read_stub_arg_pi8(const void* inputs_handle, const int32_t i) {
+extern "C" RUNTIME_EXPORT const int8_t* read_stub_arg_pi8(const void* inputs_handle,
+                                                          const int32_t i) {
   return static_cast<const int8_t*>(read_stub_arg_pvoid(inputs_handle, i));
 }
 
-extern "C" const int32_t* read_stub_arg_pi32(const void* inputs_handle, const int32_t i) {
+extern "C" RUNTIME_EXPORT const int32_t* read_stub_arg_pi32(const void* inputs_handle,
+                                                            const int32_t i) {
   return static_cast<const int32_t*>(read_stub_arg_pvoid(inputs_handle, i));
 }
 
-extern "C" const int32_t* read_stub_arg_pi64(const void* inputs_handle, const int32_t i) {
+extern "C" RUNTIME_EXPORT const int32_t* read_stub_arg_pi64(const void* inputs_handle,
+                                                            const int32_t i) {
   return static_cast<const int32_t*>(read_stub_arg_pvoid(inputs_handle, i));
 }
 
-extern "C" const int64_t* const* read_stub_arg_ppi64(const void* inputs_handle,
-                                                     const int32_t i) {
+extern "C" RUNTIME_EXPORT const int64_t* const* read_stub_arg_ppi64(
+    const void* inputs_handle,
+    const int32_t i) {
   return static_cast<const int64_t* const*>(read_stub_arg_pvoid(inputs_handle, i));
 }
 
 // Writes back the value returned by the runtime function to the wrapped output value used
 // from the interpreter.
-extern "C" void write_stub_result_int(void* output_handle, const int64_t int_val) {
+extern "C" RUNTIME_EXPORT void write_stub_result_int(void* output_handle,
+                                                     const int64_t int_val) {
   auto output = reinterpret_cast<ReductionInterpreter::EvalValue*>(output_handle);
   output->int_val = int_val;
 }
diff -Naur ./QueryEngine/ResultSetReductionJIT.cpp ../omniscidb-master/QueryEngine/ResultSetReductionJIT.cpp
--- ./QueryEngine/ResultSetReductionJIT.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/ResultSetReductionJIT.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -411,7 +411,7 @@
 
 }  // namespace
 
-extern "C" void serialized_varlen_buffer_sample(
+extern "C" RUNTIME_EXPORT void serialized_varlen_buffer_sample(
     const void* serialized_varlen_buffer_handle,
     int8_t* this_ptr1,
     int8_t* this_ptr2,
@@ -441,11 +441,12 @@
 // Wrappers to be called from the generated code, sharing implementation with the rest of
 // the system.
 
-extern "C" void count_distinct_set_union_jit_rt(const int64_t new_set_handle,
-                                                const int64_t old_set_handle,
-                                                const void* that_qmd_handle,
-                                                const void* this_qmd_handle,
-                                                const int64_t target_logical_idx) {
+extern "C" RUNTIME_EXPORT void count_distinct_set_union_jit_rt(
+    const int64_t new_set_handle,
+    const int64_t old_set_handle,
+    const void* that_qmd_handle,
+    const void* this_qmd_handle,
+    const int64_t target_logical_idx) {
   const auto that_qmd = reinterpret_cast<const QueryMemoryDescriptor*>(that_qmd_handle);
   const auto this_qmd = reinterpret_cast<const QueryMemoryDescriptor*>(this_qmd_handle);
   const auto& new_count_distinct_desc =
@@ -458,11 +459,11 @@
       new_set_handle, old_set_handle, new_count_distinct_desc, old_count_distinct_desc);
 }
 
-extern "C" void approx_median_jit_rt(const int64_t new_set_handle,
-                                     const int64_t old_set_handle,
-                                     const void* that_qmd_handle,
-                                     const void* this_qmd_handle,
-                                     const int64_t target_logical_idx) {
+extern "C" RUNTIME_EXPORT void approx_median_jit_rt(const int64_t new_set_handle,
+                                                    const int64_t old_set_handle,
+                                                    const void* that_qmd_handle,
+                                                    const void* this_qmd_handle,
+                                                    const int64_t target_logical_idx) {
   auto* incoming = reinterpret_cast<quantile::TDigest*>(new_set_handle);
   if (incoming->centroids().capacity()) {
     auto* accumulator = reinterpret_cast<quantile::TDigest*>(old_set_handle);
@@ -471,16 +472,17 @@
   }
 }
 
-extern "C" void get_group_value_reduction_rt(int8_t* groups_buffer,
-                                             const int8_t* key,
-                                             const uint32_t key_count,
-                                             const void* this_qmd_handle,
-                                             const int8_t* that_buff,
-                                             const uint32_t that_entry_idx,
-                                             const uint32_t that_entry_count,
-                                             const uint32_t row_size_bytes,
-                                             int64_t** buff_out,
-                                             uint8_t* empty) {
+extern "C" RUNTIME_EXPORT void get_group_value_reduction_rt(
+    int8_t* groups_buffer,
+    const int8_t* key,
+    const uint32_t key_count,
+    const void* this_qmd_handle,
+    const int8_t* that_buff,
+    const uint32_t that_entry_idx,
+    const uint32_t that_entry_count,
+    const uint32_t row_size_bytes,
+    int64_t** buff_out,
+    uint8_t* empty) {
   const auto& this_qmd = *reinterpret_cast<const QueryMemoryDescriptor*>(this_qmd_handle);
   const auto gvi =
       result_set::get_group_value_reduction(reinterpret_cast<int64_t*>(groups_buffer),
@@ -497,7 +499,7 @@
   *empty = gvi.second;
 }
 
-extern "C" uint8_t check_watchdog_rt(const size_t sample_seed) {
+extern "C" RUNTIME_EXPORT uint8_t check_watchdog_rt(const size_t sample_seed) {
   if (UNLIKELY(g_enable_dynamic_watchdog && (sample_seed & 0x3F) == 0 &&
                dynamic_watchdog())) {
     return true;
diff -Naur ./QueryEngine/RuntimeFunctions.cpp ../omniscidb-master/QueryEngine/RuntimeFunctions.cpp
--- ./QueryEngine/RuntimeFunctions.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/RuntimeFunctions.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -336,16 +336,6 @@
                                                                const int64_t,
                                                                const int64_t) {}
 
-extern "C" NEVER_INLINE void agg_approx_median_impl(int64_t* agg, const double val) {
-  auto* t_digest = reinterpret_cast<quantile::TDigest*>(*agg);
-  t_digest->allocate();
-  t_digest->add(val);
-}
-
-extern "C" ALWAYS_INLINE void agg_approx_median(int64_t* agg, const double val) {
-  agg_approx_median_impl(agg, val);
-}
-
 extern "C" ALWAYS_INLINE int8_t bit_is_set(const int64_t bitset,
                                            const int64_t val,
                                            const int64_t min_val,
@@ -974,8 +964,10 @@
 extern "C" NEVER_INLINE void write_back_nop(int64_t* dest,
                                             int64_t* src,
                                             const int32_t sz) {
+#ifndef _WIN32
   // the body is not really needed, just make sure the call is not optimized away
   assert(dest);
+#endif
 }
 
 extern "C" int64_t* init_shared_mem(const int64_t* global_groups_buffer,
@@ -991,8 +983,10 @@
     const uint32_t agg_col_count,
     const bool keyless,
     const int8_t warp_size) {
+#ifndef _WIN32
   // the body is not really needed, just make sure the call is not optimized away
   assert(groups_buffer);
+#endif
 }
 
 extern "C" NEVER_INLINE void init_columnar_group_by_buffer_gpu(
@@ -1004,8 +998,10 @@
     const bool keyless,
     const bool blocks_share_memory,
     const int32_t frag_idx) {
+#ifndef _WIN32
   // the body is not really needed, just make sure the call is not optimized away
   assert(groups_buffer);
+#endif
 }
 
 extern "C" NEVER_INLINE void init_group_by_buffer_impl(
@@ -1016,8 +1012,10 @@
     const uint32_t agg_col_count,
     const bool keyless,
     const int8_t warp_size) {
+#ifndef _WIN32
   // the body is not really needed, just make sure the call is not optimized away
   assert(groups_buffer);
+#endif
 }
 
 template <typename T>
@@ -1330,9 +1328,11 @@
                                                          const int64_t* join_hash_tables,
                                                          int32_t* error_code,
                                                          int32_t* total_matched) {
+#ifndef _WIN32
   assert(col_buffers || literals || num_rows || frag_row_offsets || max_matched ||
          init_agg_value || out || frag_idx || error_code || join_hash_tables ||
          total_matched);
+#endif
 }
 
 extern "C" void multifrag_query_hoisted_literals(const int8_t*** col_buffers,
@@ -1372,8 +1372,10 @@
                                         const int64_t* join_hash_tables,
                                         int32_t* error_code,
                                         int32_t* total_matched) {
+#ifndef _WIN32
   assert(col_buffers || num_rows || frag_row_offsets || max_matched || init_agg_value ||
          out || frag_idx || error_code || join_hash_tables || total_matched);
+#endif
 }
 
 extern "C" void multifrag_query(const int8_t*** col_buffers,
diff -Naur ./QueryEngine/RuntimeFunctions.h ../omniscidb-master/QueryEngine/RuntimeFunctions.h
--- ./QueryEngine/RuntimeFunctions.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/RuntimeFunctions.h	2021-04-21 00:02:57.000000000 +0300
@@ -17,6 +17,8 @@
 #ifndef QUERYENGINE_RUNTIMEFUNCTIONS_H
 #define QUERYENGINE_RUNTIMEFUNCTIONS_H
 
+#include "Shared/funcannotations.h"
+
 #include <cassert>
 #include <cstdint>
 #include <ctime>
@@ -116,16 +118,17 @@
 #define EMPTY_KEY_16 std::numeric_limits<int16_t>::max()
 #define EMPTY_KEY_8 std::numeric_limits<int8_t>::max()
 
-extern "C" uint32_t key_hash(const int64_t* key,
-                             const uint32_t key_qw_count,
-                             const uint32_t key_byte_width);
-
-extern "C" int64_t* get_group_value(int64_t* groups_buffer,
-                                    const uint32_t groups_buffer_entry_count,
-                                    const int64_t* key,
-                                    const uint32_t key_count,
-                                    const uint32_t key_width,
-                                    const uint32_t row_size_quad);
+extern "C" RUNTIME_EXPORT uint32_t key_hash(const int64_t* key,
+                                            const uint32_t key_qw_count,
+                                            const uint32_t key_byte_width);
+
+extern "C" RUNTIME_EXPORT int64_t* get_group_value(
+    int64_t* groups_buffer,
+    const uint32_t groups_buffer_entry_count,
+    const int64_t* key,
+    const uint32_t key_count,
+    const uint32_t key_width,
+    const uint32_t row_size_quad);
 
 enum RuntimeInterruptFlags { INT_CHECK = 0, INT_ABORT = -1, INT_RESET = -2 };
 
@@ -133,7 +136,7 @@
 
 extern "C" bool check_interrupt_init(unsigned command);
 
-extern "C" int64_t* get_group_value_with_watchdog(
+extern "C" RUNTIME_EXPORT int64_t* get_group_value_with_watchdog(
     int64_t* groups_buffer,
     const uint32_t groups_buffer_entry_count,
     const int64_t* key,
@@ -141,34 +144,36 @@
     const uint32_t key_width,
     const uint32_t row_size_quad);
 
-extern "C" int64_t* get_group_value_columnar(int64_t* groups_buffer,
-                                             const uint32_t groups_buffer_entry_count,
-                                             const int64_t* key,
-                                             const uint32_t key_qw_count);
+extern "C" RUNTIME_EXPORT int64_t* get_group_value_columnar(
+    int64_t* groups_buffer,
+    const uint32_t groups_buffer_entry_count,
+    const int64_t* key,
+    const uint32_t key_qw_count);
 
-extern "C" int64_t* get_group_value_columnar_with_watchdog(
+extern "C" RUNTIME_EXPORT int64_t* get_group_value_columnar_with_watchdog(
     int64_t* groups_buffer,
     const uint32_t groups_buffer_entry_count,
     const int64_t* key,
     const uint32_t key_qw_count);
 
-extern "C" int64_t* get_group_value_fast(int64_t* groups_buffer,
-                                         const int64_t key,
-                                         const int64_t min_key,
-                                         const int64_t bucket,
-                                         const uint32_t row_size_quad);
-
-extern "C" int64_t* get_group_value_fast_with_original_key(int64_t* groups_buffer,
-                                                           const int64_t key,
-                                                           const int64_t orig_key,
-                                                           const int64_t min_key,
-                                                           const int64_t bucket,
-                                                           const uint32_t row_size_quad);
-
-extern "C" uint32_t get_columnar_group_bin_offset(int64_t* key_base_ptr,
-                                                  const int64_t key,
-                                                  const int64_t min_key,
-                                                  const int64_t bucket);
+extern "C" RUNTIME_EXPORT int64_t* get_group_value_fast(int64_t* groups_buffer,
+                                                        const int64_t key,
+                                                        const int64_t min_key,
+                                                        const int64_t bucket,
+                                                        const uint32_t row_size_quad);
+
+extern "C" RUNTIME_EXPORT int64_t* get_group_value_fast_with_original_key(
+    int64_t* groups_buffer,
+    const int64_t key,
+    const int64_t orig_key,
+    const int64_t min_key,
+    const int64_t bucket,
+    const uint32_t row_size_quad);
+
+extern "C" RUNTIME_EXPORT uint32_t get_columnar_group_bin_offset(int64_t* key_base_ptr,
+                                                                 const int64_t key,
+                                                                 const int64_t min_key,
+                                                                 const int64_t bucket);
 
 extern "C" int64_t* get_matching_group_value_perfect_hash(int64_t* groups_buffer,
                                                           const uint32_t h,
diff -Naur ./QueryEngine/StringFunctions.cpp ../omniscidb-master/QueryEngine/StringFunctions.cpp
--- ./QueryEngine/StringFunctions.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/StringFunctions.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -19,7 +19,7 @@
 
 #ifdef EXECUTE_INCLUDE
 
-extern "C" NEVER_INLINE DEVICE int32_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int32_t
 char_length_encoded(const char* str, const int32_t str_len) {  // assumes utf8
   int32_t i = 0, char_count = 0;
   while (i < str_len) {
@@ -32,7 +32,7 @@
   return char_count;
 }
 
-extern "C" NEVER_INLINE DEVICE int32_t
+extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int32_t
 char_length_encoded_nullable(const char* str,
                              const int32_t str_len,
                              const int32_t int_null) {  // assumes utf8
diff -Naur ./QueryEngine/StringOpsIR.cpp ../omniscidb-master/QueryEngine/StringOpsIR.cpp
--- ./QueryEngine/StringOpsIR.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/StringOpsIR.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -17,12 +17,13 @@
 #include "CodeGenerator.h"
 #include "Execute.h"
 
+#include "../Shared/funcannotations.h"
 #include "../Shared/sqldefs.h"
 #include "Parser/ParserNode.h"
 
 #include <boost/locale/conversion.hpp>
 
-extern "C" uint64_t string_decode(int8_t* chunk_iter_, int64_t pos) {
+extern "C" RUNTIME_EXPORT uint64_t string_decode(int8_t* chunk_iter_, int64_t pos) {
   auto chunk_iter = reinterpret_cast<ChunkIter*>(chunk_iter_);
   VarlenDatum vd;
   bool is_end;
@@ -33,8 +34,8 @@
                           (static_cast<uint64_t>(vd.length) << 48);
 }
 
-extern "C" uint64_t string_decompress(const int32_t string_id,
-                                      const int64_t string_dict_handle) {
+extern "C" RUNTIME_EXPORT uint64_t string_decompress(const int32_t string_id,
+                                                     const int64_t string_dict_handle) {
   if (string_id == NULL_INT) {
     return 0;
   }
@@ -46,8 +47,8 @@
          (static_cast<uint64_t>(string_bytes.second) << 48);
 }
 
-extern "C" int32_t string_compress(const int64_t ptr_and_len,
-                                   const int64_t string_dict_handle) {
+extern "C" RUNTIME_EXPORT int32_t string_compress(const int64_t ptr_and_len,
+                                                  const int64_t string_dict_handle) {
   std::string raw_str(reinterpret_cast<char*>(extract_str_ptr_noinline(ptr_and_len)),
                       extract_str_len_noinline(ptr_and_len));
   auto string_dict_proxy =
@@ -55,7 +56,8 @@
   return string_dict_proxy->getIdOfString(raw_str);
 }
 
-extern "C" int32_t lower_encoded(int32_t string_id, int64_t string_dict_proxy_address) {
+extern "C" RUNTIME_EXPORT int32_t lower_encoded(int32_t string_id,
+                                                int64_t string_dict_proxy_address) {
   StringDictionaryProxy* string_dict_proxy =
       reinterpret_cast<StringDictionaryProxy*>(string_dict_proxy_address);
   auto str = string_dict_proxy->getString(string_id);
diff -Naur ./QueryEngine/TableFunctions/MLFunctions.hpp ../omniscidb-master/QueryEngine/TableFunctions/MLFunctions.hpp
--- ./QueryEngine/TableFunctions/MLFunctions.hpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/QueryEngine/TableFunctions/MLFunctions.hpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2021 OmniSci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifdef HAVE_MLPACK
+
+#include <mlpack/methods/dbscan/dbscan.hpp>
+#include <mlpack/methods/kmeans/kmeans.hpp>
+
+// clang-format off
+/*
+  UDTF: dbscan__cpu_(Cursor<Column<int>, ColumnList<double>>, float, int, RowMultiplier) -> Column<int>, Column<int>
+*/
+// clang-format on
+EXTENSION_NOINLINE int32_t dbscan__cpu_(const Column<int>& input_ids,
+                                        const ColumnList<double>& cluster_features,
+                                        const float epsilon,
+                                        const int min_num_points,
+                                        const int output_size_multiplier,
+                                        Column<int>& output_ids,
+                                        Column<int>& output_clusters) {
+  if (epsilon <= 0.0) {
+    throw std::runtime_error("DBSCAN: epsilon must be positive");
+  }
+  if (min_num_points < 1) {
+    throw std::runtime_error("DBSCAN: min_num_points must be >= 1");
+  }
+  const int64_t num_rows = input_ids.getSize();
+#ifndef __CUDACC__
+  const int64_t num_cluster_features = cluster_features.getCols();
+  arma::Mat<double> cluster_features_matrix(num_rows, num_cluster_features);
+  for (int64_t c = 0; c < num_cluster_features; ++c) {
+    memcpy(cluster_features_matrix.colptr(c),
+           cluster_features(c).ptr,
+           sizeof(double) * num_rows);
+  }
+  arma::Mat<double> cluster_features_matrix_transposed = cluster_features_matrix.t();
+  mlpack::dbscan::DBSCAN<> dbscan(epsilon, min_num_points);
+  arma::Row<size_t> cluster_assignments;
+  dbscan.Cluster(cluster_features_matrix_transposed, cluster_assignments);
+
+  for (int64_t r = 0; r < num_rows; ++r) {
+    output_ids[r] = input_ids[r];
+    output_clusters[r] = cluster_assignments[r] == SIZE_MAX ? -1 : cluster_assignments[r];
+  }
+#endif
+  return num_rows;
+}
+
+// clang-format off
+/*
+  UDTF: kmeans__cpu_(Cursor<Column<int>, ColumnList<double>>, int, RowMultiplier) -> Column<int>, Column<int>
+*/
+// clang-format on
+EXTENSION_NOINLINE int32_t kmeans__cpu_(const Column<int>& input_ids,
+                                        const ColumnList<double>& cluster_features,
+                                        const int num_clusters,
+                                        const int output_size_multiplier,
+                                        Column<int>& output_ids,
+                                        Column<int>& output_clusters) {
+  if (num_clusters <= 0) {
+    throw std::runtime_error("KMEANS: num_clusters must be positive integer");
+  }
+  const int64_t num_rows = input_ids.getSize();
+#ifndef __CUDACC__
+  const int64_t num_cluster_features = cluster_features.getCols();
+  arma::Mat<double> cluster_features_matrix(num_rows, num_cluster_features);
+  for (int64_t c = 0; c < num_cluster_features; ++c) {
+    memcpy(cluster_features_matrix.colptr(c),
+           cluster_features(c).ptr,
+           sizeof(double) * num_rows);
+  }
+  arma::Mat<double> cluster_features_matrix_transposed = cluster_features_matrix.t();
+  mlpack::kmeans::KMeans<> kmeans;
+  arma::Row<size_t> cluster_assignments;
+  kmeans.Cluster(cluster_features_matrix_transposed,
+                 static_cast<size_t>(num_clusters),
+                 cluster_assignments);
+
+  for (int64_t r = 0; r < num_rows; ++r) {
+    output_ids[r] = input_ids[r];
+    output_clusters[r] = cluster_assignments[r] == SIZE_MAX ? -1 : cluster_assignments[r];
+  }
+#endif
+  return num_rows;
+}
+
+#endif
\ No newline at end of file
diff -Naur ./QueryEngine/TableFunctions/TableFunctionExecutionContext.cpp ../omniscidb-master/QueryEngine/TableFunctions/TableFunctionExecutionContext.cpp
--- ./QueryEngine/TableFunctions/TableFunctionExecutionContext.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/TableFunctions/TableFunctionExecutionContext.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -271,6 +271,7 @@
   }
 
   // execute
+  auto timer = DEBUG_TIMER(__func__);
   const auto err = compilation_context->getFuncPtr()(
       byte_stream_ptr, col_sizes.data(), output_col_buf_ptrs.data(), &output_row_count);
   if (err) {
diff -Naur ./QueryEngine/TableFunctions/TableFunctions.hpp ../omniscidb-master/QueryEngine/TableFunctions/TableFunctions.hpp
--- ./QueryEngine/TableFunctions/TableFunctions.hpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/TableFunctions/TableFunctions.hpp	2021-04-21 00:02:57.000000000 +0300
@@ -17,9 +17,6 @@
 #include "../../QueryEngine/OmniSciTypes.h"
 #include "../../Shared/funcannotations.h"
 
-#define EXTENSION_INLINE extern "C" ALWAYS_INLINE DEVICE
-#define EXTENSION_NOINLINE extern "C" NEVER_INLINE DEVICE
-
 /*
   UDTF: row_copier(Column<double>, RowMultiplier) -> Column<double>
 */
@@ -191,3 +188,5 @@
   col2 = col_list(col_list.getLength() - 1);
   return col1.getSize();
 }
+
+#include "MLFunctions.hpp"
diff -Naur ./QueryEngine/TopKRuntime.cpp ../omniscidb-master/QueryEngine/TopKRuntime.cpp
--- ./QueryEngine/TopKRuntime.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/TopKRuntime.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -235,26 +235,26 @@
   }
 }
 
-#define DEF_GET_BIN_FROM_K_HEAP(key_type)                                 \
-  extern "C" NEVER_INLINE DEVICE int64_t* get_bin_from_k_heap_##key_type( \
-      int64_t* heaps,                                                     \
-      const uint32_t k,                                                   \
-      const uint32_t row_size_quad,                                       \
-      const uint32_t key_offset,                                          \
-      const bool min_heap,                                                \
-      const bool has_null,                                                \
-      const bool nulls_first,                                             \
-      const key_type null_key,                                            \
-      const key_type curr_key) {                                          \
-    return get_bin_from_k_heap_impl(heaps,                                \
-                                    k,                                    \
-                                    row_size_quad,                        \
-                                    key_offset,                           \
-                                    min_heap,                             \
-                                    has_null,                             \
-                                    nulls_first,                          \
-                                    null_key,                             \
-                                    curr_key);                            \
+#define DEF_GET_BIN_FROM_K_HEAP(key_type)                                                \
+  extern "C" RUNTIME_EXPORT NEVER_INLINE DEVICE int64_t* get_bin_from_k_heap_##key_type( \
+      int64_t* heaps,                                                                    \
+      const uint32_t k,                                                                  \
+      const uint32_t row_size_quad,                                                      \
+      const uint32_t key_offset,                                                         \
+      const bool min_heap,                                                               \
+      const bool has_null,                                                               \
+      const bool nulls_first,                                                            \
+      const key_type null_key,                                                           \
+      const key_type curr_key) {                                                         \
+    return get_bin_from_k_heap_impl(heaps,                                               \
+                                    k,                                                   \
+                                    row_size_quad,                                       \
+                                    key_offset,                                          \
+                                    min_heap,                                            \
+                                    has_null,                                            \
+                                    nulls_first,                                         \
+                                    null_key,                                            \
+                                    curr_key);                                           \
   }
 
 DEF_GET_BIN_FROM_K_HEAP(int32_t)
diff -Naur ./QueryEngine/TypePunning.h ../omniscidb-master/QueryEngine/TypePunning.h
--- ./QueryEngine/TypePunning.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/TypePunning.h	2021-04-21 00:02:57.000000000 +0300
@@ -22,9 +22,16 @@
 // Mark ptr as safe for type-punning operations. We need it whenever we want to
 // interpret a sequence of bytes as float / double through a reinterpret_cast.
 
+#ifdef _MSC_VER
+template <class T>
+FORCE_INLINE T* may_alias_ptr(T* ptr) {
+  return ptr;
+}
+#else
 template <class T>
     FORCE_INLINE T __attribute__((__may_alias__)) * may_alias_ptr(T* ptr) {
   return ptr;
 }
+#endif
 
 #endif  // QUERYENGINE_TYPEPUNNING_H
diff -Naur ./QueryEngine/WindowContext.cpp ../omniscidb-master/QueryEngine/WindowContext.cpp
--- ./QueryEngine/WindowContext.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/WindowContext.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -25,6 +25,7 @@
 #include "QueryEngine/RuntimeFunctions.h"
 #include "QueryEngine/TypePunning.h"
 #include "Shared/checked_alloc.h"
+#include "Shared/funcannotations.h"
 
 WindowFunctionContext::WindowFunctionContext(
     const Analyzer::WindowFunction* window_func,
@@ -305,38 +306,38 @@
 
 }  // namespace
 
-extern "C" void apply_window_pending_outputs_int64(const int64_t handle,
-                                                   const int64_t value,
-                                                   const int64_t bitset,
-                                                   const int64_t pos) {
+extern "C" RUNTIME_EXPORT void apply_window_pending_outputs_int64(const int64_t handle,
+                                                                  const int64_t value,
+                                                                  const int64_t bitset,
+                                                                  const int64_t pos) {
   apply_window_pending_outputs_int<int64_t>(handle, value, bitset, pos);
 }
 
-extern "C" void apply_window_pending_outputs_int32(const int64_t handle,
-                                                   const int64_t value,
-                                                   const int64_t bitset,
-                                                   const int64_t pos) {
+extern "C" RUNTIME_EXPORT void apply_window_pending_outputs_int32(const int64_t handle,
+                                                                  const int64_t value,
+                                                                  const int64_t bitset,
+                                                                  const int64_t pos) {
   apply_window_pending_outputs_int<int32_t>(handle, value, bitset, pos);
 }
 
-extern "C" void apply_window_pending_outputs_int16(const int64_t handle,
-                                                   const int64_t value,
-                                                   const int64_t bitset,
-                                                   const int64_t pos) {
+extern "C" RUNTIME_EXPORT void apply_window_pending_outputs_int16(const int64_t handle,
+                                                                  const int64_t value,
+                                                                  const int64_t bitset,
+                                                                  const int64_t pos) {
   apply_window_pending_outputs_int<int16_t>(handle, value, bitset, pos);
 }
 
-extern "C" void apply_window_pending_outputs_int8(const int64_t handle,
-                                                  const int64_t value,
-                                                  const int64_t bitset,
-                                                  const int64_t pos) {
+extern "C" RUNTIME_EXPORT void apply_window_pending_outputs_int8(const int64_t handle,
+                                                                 const int64_t value,
+                                                                 const int64_t bitset,
+                                                                 const int64_t pos) {
   apply_window_pending_outputs_int<int8_t>(handle, value, bitset, pos);
 }
 
-extern "C" void apply_window_pending_outputs_double(const int64_t handle,
-                                                    const double value,
-                                                    const int64_t bitset,
-                                                    const int64_t pos) {
+extern "C" RUNTIME_EXPORT void apply_window_pending_outputs_double(const int64_t handle,
+                                                                   const double value,
+                                                                   const int64_t bitset,
+                                                                   const int64_t pos) {
   if (!pos_is_set(bitset, pos)) {
     return;
   }
@@ -347,10 +348,10 @@
   pending_output_slots.clear();
 }
 
-extern "C" void apply_window_pending_outputs_float(const int64_t handle,
-                                                   const float value,
-                                                   const int64_t bitset,
-                                                   const int64_t pos) {
+extern "C" RUNTIME_EXPORT void apply_window_pending_outputs_float(const int64_t handle,
+                                                                  const float value,
+                                                                  const int64_t bitset,
+                                                                  const int64_t pos) {
   if (!pos_is_set(bitset, pos)) {
     return;
   }
@@ -361,10 +362,11 @@
   pending_output_slots.clear();
 }
 
-extern "C" void apply_window_pending_outputs_float_columnar(const int64_t handle,
-                                                            const float value,
-                                                            const int64_t bitset,
-                                                            const int64_t pos) {
+extern "C" RUNTIME_EXPORT void apply_window_pending_outputs_float_columnar(
+    const int64_t handle,
+    const float value,
+    const int64_t bitset,
+    const int64_t pos) {
   if (!pos_is_set(bitset, pos)) {
     return;
   }
@@ -376,7 +378,8 @@
 }
 
 // Add a pending output slot to be written back at the end of a peer row group.
-extern "C" void add_window_pending_output(void* pending_output, const int64_t handle) {
+extern "C" RUNTIME_EXPORT void add_window_pending_output(void* pending_output,
+                                                         const int64_t handle) {
   reinterpret_cast<std::vector<void*>*>(handle)->push_back(pending_output);
 }
 
diff -Naur ./QueryEngine/invoke_example/sample.cpp ../omniscidb-master/QueryEngine/invoke_example/sample.cpp
--- ./QueryEngine/invoke_example/sample.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryEngine/invoke_example/sample.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -65,7 +65,7 @@
   // Get kernel function
   checkCudaErrors(cuModuleGetFunction(&function, cudaModule, "kernel"));
 
-  int64_t N = 1000000000L;
+  int64_t N = 1000000000LL;
   int8_t* byte_stream_col_0 = new int8_t[N];
   memset(byte_stream_col_0, 42, N);
 
diff -Naur ./QueryRunner/QueryRunner.cpp ../omniscidb-master/QueryRunner/QueryRunner.cpp
--- ./QueryRunner/QueryRunner.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryRunner/QueryRunner.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -34,8 +34,8 @@
 #include "Shared/SystemParameters.h"
 #include "Shared/import_helpers.h"
 #include "TestProcessSignalHandler.h"
-#include "bcrypt.h"
 #include "gen-cpp/CalciteServer.h"
+#include "include/bcrypt.h"
 
 #include <boost/filesystem/operations.hpp>
 #include <csignal>
@@ -78,6 +78,22 @@
 query_state::QueryStates QueryRunner::query_states_;
 
 QueryRunner* QueryRunner::init(const char* db_path,
+                               const std::string& udf_filename,
+                               const size_t max_gpu_mem,
+                               const int reserved_gpu_mem) {
+  return QueryRunner::init(db_path,
+                           std::string{OMNISCI_ROOT_USER},
+                           "HyperInteractive",
+                           std::string{OMNISCI_DEFAULT_DB},
+                           {},
+                           {},
+                           udf_filename,
+                           true,
+                           max_gpu_mem,
+                           reserved_gpu_mem);
+}
+
+QueryRunner* QueryRunner::init(const char* db_path,
                                const std::string& user,
                                const std::string& pass,
                                const std::string& db_name,
@@ -123,7 +139,6 @@
                          const bool create_db)
     : dispatch_queue_(std::make_unique<QueryDispatchQueue>(1)) {
   g_serialize_temp_tables = true;
-
   boost::filesystem::path base_path{db_path};
   CHECK(boost::filesystem::exists(base_path));
   auto system_db_file = base_path / "mapd_catalogs" / OMNISCI_DEFAULT_DB;
@@ -161,19 +176,19 @@
   mapd_params.gpu_buffer_mem_bytes = max_gpu_mem;
   mapd_params.aggregator = !leaf_servers.empty();
 
-  auto data_mgr = std::make_shared<Data_Namespace::DataMgr>(data_dir.string(),
-                                                            mapd_params,
-                                                            std::move(cuda_mgr),
-                                                            uses_gpus,
-                                                            reserved_gpu_mem,
-                                                            0,
-                                                            disk_cache_config);
+  data_mgr_.reset(new Data_Namespace::DataMgr(data_dir.string(),
+                                              mapd_params,
+                                              std::move(cuda_mgr),
+                                              uses_gpus,
+                                              reserved_gpu_mem,
+                                              0,
+                                              disk_cache_config));
 
   auto& sys_cat = Catalog_Namespace::SysCatalog::instance();
 
   g_base_path = base_path.string();
   sys_cat.init(g_base_path,
-               data_mgr,
+               data_mgr_,
                {},
                g_calcite,
                false,
@@ -323,7 +338,7 @@
   CHECK_EQ(parser.parse(query_str, parse_trees, last_parsed), 0) << query_str;
   CHECK_EQ(parse_trees.size(), size_t(1));
   auto stmt = parse_trees.front().get();
-  auto insert_values_stmt = dynamic_cast<InsertValuesStmt*>(stmt);
+  auto insert_values_stmt = dynamic_cast<Parser::InsertValuesStmt*>(stmt);
   CHECK(insert_values_stmt);
   insert_values_stmt->execute(*session_info_);
   return nullptr;
diff -Naur ./QueryRunner/QueryRunner.h ../omniscidb-master/QueryRunner/QueryRunner.h
--- ./QueryRunner/QueryRunner.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/QueryRunner/QueryRunner.h	2021-04-21 00:02:57.000000000 +0300
@@ -61,18 +61,7 @@
   static QueryRunner* init(const char* db_path,
                            const std::string& udf_filename = "",
                            const size_t max_gpu_mem = 0,  // use all available mem
-                           const int reserved_gpu_mem = 256 << 20) {
-    return QueryRunner::init(db_path,
-                             std::string{OMNISCI_ROOT_USER},
-                             "HyperInteractive",
-                             std::string{OMNISCI_DEFAULT_DB},
-                             {},
-                             {},
-                             udf_filename,
-                             true,
-                             max_gpu_mem,
-                             reserved_gpu_mem);
-  }
+                           const int reserved_gpu_mem = 256 << 20);
 
   static QueryRunner* init(const char* db_path,
                            const std::vector<LeafHostInfo>& string_servers,
@@ -218,6 +207,7 @@
 
   std::shared_ptr<Catalog_Namespace::SessionInfo> session_info_;
   std::unique_ptr<QueryDispatchQueue> dispatch_queue_;
+  std::shared_ptr<Data_Namespace::DataMgr> data_mgr_;
 };
 
 class ImportDriver : public QueryRunner {
diff -Naur ./SQLFrontend/CommandFunctors.h ../omniscidb-master/SQLFrontend/CommandFunctors.h
--- ./SQLFrontend/CommandFunctors.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/SQLFrontend/CommandFunctors.h	2021-04-21 00:02:57.000000000 +0300
@@ -190,7 +190,13 @@
 
 #define StandardCommand_2(CommandName, CommandOperations) \
   StandardCommand_3(CommandName, CommandOperations, CmdDeterminant)
+#if !BOOST_PP_VARIADICS_MSVC
 #define StandardCommand(...) BOOST_PP_OVERLOAD(StandardCommand_, __VA_ARGS__)(__VA_ARGS__)
+#else
+#define StandardCommand(...)                                                  \
+  BOOST_PP_CAT(BOOST_PP_OVERLOAD(StandardCommand_, __VA_ARGS__)(__VA_ARGS__), \
+               BOOST_PP_EMPTY())
+#endif
 
 //
 // Standard Command Definitions
diff -Naur ./SQLFrontend/CommandHistoryFile.h ../omniscidb-master/SQLFrontend/CommandHistoryFile.h
--- ./SQLFrontend/CommandHistoryFile.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/SQLFrontend/CommandHistoryFile.h	2021-04-21 00:02:57.000000000 +0300
@@ -21,9 +21,16 @@
 #include <string>
 #include <utility>
 
-#include <pwd.h>
 #include <sys/types.h>
+#ifdef _WIN32
+#include <folly/portability/unistd.h>
+#include <shlobj_core.h>
+#include "Shared/cleanup_global_namespace.h"
+using namespace folly::portability::unistd;
+#else
+#include <pwd.h>
 #include <unistd.h>
+#endif
 
 inline constexpr char const* const getDefaultHistoryFilename() {
   return ".omnisql_history";
@@ -32,17 +39,54 @@
 class DefaultEnvResolver {
  public:
   auto getuid() const { return ::getuid(); }
+#ifndef _WIN32
   auto const* getpwuid(decltype(::getuid()) uid) const { return ::getpwuid(uid); }
+#endif
+
+  const char* getpwdir(decltype(::getuid()) uid) const {
+#ifdef _WIN32
+    if (uid != getuid()) {
+      return nullptr;
+    }
+#ifdef _UNICODE
+    wchar_t home_dir_w[MAX_PATH];
+    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, home_dir_w))) {
+      wcstombs(home_dir_, home_dir_w, MAX_PATH);
+      return home_dir_;
+    }
+#else
+    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, home_dir))) {
+      return home_dir_;
+    }
+#endif
+#else
+    auto* p = getpwuid(uid);
+    if (p) {
+      return p->pw_dir;
+    }
+#endif
+    return nullptr;
+  }
 
-#ifdef __APPLE__
+#if defined(_APPLE__) || defined(_WIN32)
   auto const* getenv(char const* env_var_name) const { return ::getenv(env_var_name); }
 #else
   auto const* getenv(char const* env_var_name) const {
     return ::secure_getenv(env_var_name);
   }
 #endif
+
+ private:
+#ifdef _WIN32
+  mutable char home_dir_[MAX_PATH];
+#endif
 };
 
+std::string getHomeDirectory() {
+  DefaultEnvResolver r;
+  return r.getpwdir(r.getuid());
+}
+
 template <typename ENV_RESOLVER>
 class CommandHistoryFileImpl : private ENV_RESOLVER {
  public:
@@ -60,19 +104,16 @@
                                          CommandHistoryFileImpl<ER> const& cmd_file);
 
  private:
-  auto resolveHomeDirectory() const {
+  const char* resolveHomeDirectory() const {
     auto* home_env = this->getenv("HOME");
     if (home_env == nullptr) {
-      auto* passwd_entry = ENV_RESOLVER::getpwuid(ENV_RESOLVER::getuid());
-      if (passwd_entry != nullptr) {
-        home_env = passwd_entry->pw_dir;
-      }
+      return ENV_RESOLVER::getpwdir(ENV_RESOLVER::getuid());
     }
     return home_env;
   }
 
   std::string const resolveCommandFile() const {
-    auto* home_dir = resolveHomeDirectory();
+    auto home_dir = resolveHomeDirectory();
     if (home_dir == nullptr) {  // Just use default command history file name in current
                                 // dir in this scenario
       return std::string(getDefaultHistoryFilename());
diff -Naur ./SQLFrontend/ThriftWithRetry.h ../omniscidb-master/SQLFrontend/ThriftWithRetry.h
--- ./SQLFrontend/ThriftWithRetry.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/SQLFrontend/ThriftWithRetry.h	2021-04-21 00:02:57.000000000 +0300
@@ -3,6 +3,7 @@
 
 #include <cmath>
 #include <iostream>
+#include <thread>
 #include "gen-cpp/omnisci_types.h"
 
 template <typename SERVICE_ENUM, typename CLIENT_CONTEXT>
@@ -164,7 +165,8 @@
       if (which_service == kDISCONNECT) {
         return false;
       }
-      sleep(con_timeout_base * pow(2, try_count));
+      std::this_thread::sleep_for(
+          std::chrono::seconds(con_timeout_base * (1 << try_count)));
       if (which_service != kCONNECT) {
         if (!thrift_with_retry(kCONNECT, context, nullptr, try_count + 1)) {
           return false;
diff -Naur ./SQLFrontend/omnisql.cpp ../omniscidb-master/SQLFrontend/omnisql.cpp
--- ./SQLFrontend/omnisql.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/SQLFrontend/omnisql.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -22,7 +22,13 @@
  **/
 
 #include <rapidjson/document.h>
+#ifndef _WIN32
 #include <termios.h>
+#else
+#include <Shlobj.h>
+#include <windows.h>
+#include "Shared/cleanup_global_namespace.h"
+#endif
 #include <boost/algorithm/string.hpp>
 #include <boost/algorithm/string/join.hpp>
 #include <boost/algorithm/string/predicate.hpp>
@@ -58,7 +64,7 @@
 #include "Shared/misc.h"
 #include "gen-cpp/OmniSci.h"
 
-#include "linenoise.h"
+#include "include/linenoise.h"
 
 #include "ClientContext.h"
 #include "CommandFunctors.h"
@@ -529,19 +535,23 @@
 
 // based on http://www.gnu.org/software/libc/manual/html_node/getpass.html
 std::string mapd_getpass() {
+#ifndef _WIN32
   struct termios origterm, tmpterm;
 
   tcgetattr(STDIN_FILENO, &origterm);
   tmpterm = origterm;
   tmpterm.c_lflag &= ~ECHO;
   tcsetattr(STDIN_FILENO, TCSAFLUSH, &tmpterm);
+#endif
 
   std::cout << "Password: ";
   std::string password;
   std::getline(std::cin, password);
   std::cout << std::endl;
 
+#ifndef _WIN32
   tcsetattr(STDIN_FILENO, TCSAFLUSH, &origterm);
+#endif
 
   return password;
 }
@@ -631,7 +641,9 @@
 
 void register_signal_handler() {
   signal(SIGTERM, omnisql_signal_handler);
+#ifndef _WIN32
   signal(SIGKILL, omnisql_signal_handler);
+#endif
   signal(SIGINT, omnisql_signal_handler);
 }
 
@@ -670,12 +682,12 @@
       tss << "            MAX            USE      ALLOCATED           FREE" << std::endl;
     }
   }
-  u_int16_t gpu_num = 0;
+  uint16_t gpu_num = 0;
   for (auto& nodeIt : memory_info) {
     int MB = 1024 * 1024;
-    u_int64_t page_count = 0;
-    u_int64_t free_page_count = 0;
-    u_int64_t used_page_count = 0;
+    uint64_t page_count = 0;
+    uint64_t free_page_count = 0;
+    uint64_t used_page_count = 0;
     for (auto& segIt : nodeIt.node_memory_data) {
       page_count += segIt.num_pages;
       if (segIt.is_free) {
@@ -1263,7 +1275,7 @@
    * pointer with a custom free() deleter; no need to free this memory explicitly. */
 
   while (true) {
-    using LineType = std::remove_pointer<__decltype(linenoise(prompt.c_str()))>::type;
+    using LineType = std::remove_pointer<decltype(linenoise(prompt.c_str()))>::type;
     using LineTypePtr = LineType*;
 
     std::unique_ptr<LineType, std::function<void(LineTypePtr)>> smart_line(
diff -Naur ./SampleCode/CMakeLists.txt ../omniscidb-master/SampleCode/CMakeLists.txt
--- ./SampleCode/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/SampleCode/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -28,26 +28,18 @@
   DEPENDS ${CMAKE_SOURCE_DIR}/QueryEngine/extension_functions.thrift
     OUTPUT
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/OmniSci.cpp
-        ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/omnisci_constants.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/omnisci_types.cpp
-        ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_constants.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_types.cpp
-        ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/serialized_result_set_constants.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/serialized_result_set_types.cpp
-        ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/common_constants.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/common_types.cpp
         ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/extension_functions_types.cpp
     COMMAND ${Thrift_EXECUTABLE}
     ARGS -gen cpp -r -I ${CMAKE_SOURCE_DIR} -o ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_SOURCE_DIR}/omnisci.thrift)
 add_library(mapd_sample_thrift
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/OmniSci.cpp
-    ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/omnisci_constants.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/omnisci_types.cpp
-    ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_constants.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/completion_hints_types.cpp
-    ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/serialized_result_set_constants.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/serialized_result_set_types.cpp
-    ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/common_constants.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/common_types.cpp
     ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp/extension_functions_types.cpp)
 target_link_libraries(mapd_sample_thrift ${Thrift_LIBRARIES})
diff -Naur ./SampleCode/StreamInsert.cpp ../omniscidb-master/SampleCode/StreamInsert.cpp
--- ./SampleCode/StreamInsert.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/SampleCode/StreamInsert.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -137,7 +137,7 @@
   std::cout << "  Waiting  " << copy_params.retry_wait
             << " secs to retry Inserts , will try " << (copy_params.retry_count - tries)
             << " times more " << std::endl;
-  sleep(copy_params.retry_wait);
+  std::this_thread::sleep_for(std::chrono::seconds(copy_params.retry_wait));
 
   closeConnection();
   createConnection(conn_details);
@@ -196,8 +196,9 @@
   int nskipped = 0;
   bool backEscape = false;
 
-  const std::pair<std::unique_ptr<boost::regex>, std::unique_ptr<std::string>>*
-      xforms[row_desc.size()];
+  std::vector<
+      const std::pair<std::unique_ptr<boost::regex>, std::unique_ptr<std::string>>*>
+      xforms(row_desc.size());
   for (size_t i = 0; i < row_desc.size(); i++) {
     auto it = transformations.find(row_desc[i].col_name);
     if (it != transformations.end()) {
diff -Naur ./Shared/CMakeLists.txt ../omniscidb-master/Shared/CMakeLists.txt
--- ./Shared/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -15,7 +15,7 @@
 
 file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/funcannotations.h DESTINATION ${CMAKE_BINARY_DIR}/Shared/)
 
-add_library(Shared ${shared_source_files})
+add_library(Shared ${shared_source_files} "cleanup_global_namespace.h" "boost_stacktrace.hpp")
 target_link_libraries(Shared Logger ${BLOSC_LIBRARIES} ${Boost_LIBRARIES})
 if("${MAPD_EDITION_LOWER}" STREQUAL "ee")
   target_link_libraries(Shared ${OPENSSL_LIBRARIES})
@@ -23,5 +23,5 @@
 
 # Required by ThriftClient.cpp
 add_definitions("-DTHRIFT_PACKAGE_VERSION=\"${Thrift_VERSION}\"")
-add_library(ThriftClient ThriftClient.cpp)
+add_library(ThriftClient ThriftClient.cpp "cleanup_global_namespace.h" "boost_stacktrace.hpp")
 target_link_libraries(ThriftClient  ${Thrift_LIBRARIES} ${Boost_LIBRARIES})
diff -Naur ./Shared/DoubleSort.h ../omniscidb-master/Shared/DoubleSort.h
--- ./Shared/DoubleSort.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/DoubleSort.h	2021-04-21 00:02:57.000000000 +0300
@@ -53,10 +53,10 @@
   // thrust::sort() copies Values, std::sort() moves Values.
 #ifdef __CUDACC__
   DEVICE Value() : ref_(false) {}
-  DEVICE Value(Value const& b)
-      : v0_{.value_ = b.ref_ ? *b.v0_.ptr_ : b.v0_.value_}
-      , v1_{.value_ = b.ref_ ? *b.v1_.ptr_ : b.v1_.value_}
-      , ref_(false) {}
+  DEVICE Value(Value const& b) : ref_(false) {
+    v0_.value_ = b.ref_ ? *b.v0_.ptr_ : b.v0_.value_;
+    v1_.value_ = b.ref_ ? *b.v1_.ptr_ : b.v1_.value_;
+  }
   DEVICE Value& operator=(Value const& b) {
     // Both branches are used by thrust::sort().
     if (ref_) {
@@ -69,10 +69,10 @@
     return *this;
   }
 #else
-  Value(Value&& b)
-      : v0_{.value_ = b.ref_ ? std::move(*b.v0_.ptr_) : std::move(b.v0_.value_)}
-      , v1_{.value_ = b.ref_ ? std::move(*b.v1_.ptr_) : std::move(b.v1_.value_)}
-      , ref_(false) {}
+  Value(Value&& b) : ref_(false) {
+    v0_.value_ = b.ref_ ? std::move(*b.v0_.ptr_) : std::move(b.v0_.value_);
+    v1_.value_ = b.ref_ ? std::move(*b.v1_.ptr_) : std::move(b.v1_.value_);
+  }
   Value& operator=(Value&& b) {
     if (ref_) {
       *v0_.ptr_ = b.ref_ ? std::move(*b.v0_.ptr_) : std::move(b.v0_.value_);
@@ -113,7 +113,9 @@
     return *this;
   }
   // Returns a reference object by reference
-  DEVICE Value<T0, T1>& operator*() { return this_; }
+  DEVICE Value<T0, T1>& operator*() const {
+    return const_cast<Iterator<T0, T1>*>(this)->this_;
+  }
   // Required by thrust::sort().
   // Returns a reference object by value
   DEVICE Value<T0, T1> operator[](int i) const { return operator+(i).this_; }
diff -Naur ./Shared/File.cpp ../omniscidb-master/Shared/File.cpp
--- ./Shared/File.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/File.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -60,7 +60,6 @@
   if (f == nullptr) {
     LOG(FATAL) << "Error trying to create file '" << path
                << "', the error was: " << std::strerror(errno);
-    ;
   }
   fseek(f, static_cast<long>((pageSize * numPages) - 1), SEEK_SET);
   fputc(EOF, f);
@@ -228,6 +227,23 @@
                                              std::to_string(ms.count()) + "_DELETE_ME");
     boost::filesystem::rename(directoryPath, newDirectoryPath, ec);
 
+#ifdef _WIN32
+    // On Windows we sometimes fail to rename a directory with System: 5 error
+    // code (access denied). An attempt to stop in debugger and look for opened
+    // handles for some of directory content shows no opened handles and actually
+    // allows renaming to execute successfully. It's not clear why, but a short
+    // pause allows to rename directory successfully. Until reasons are known,
+    // use this retry loop as a workaround.
+    int tries = 10;
+    while (ec.value() != boost::system::errc::success && tries) {
+      LOG(ERROR) << "Failed to rename directory " << directoryPath << " error was " << ec
+                 << " (" << tries << " attempts left)";
+      std::this_thread::sleep_for(std::chrono::milliseconds(100 / tries));
+      tries--;
+      boost::filesystem::rename(directoryPath, newDirectoryPath, ec);
+    }
+#endif
+
     if (ec.value() == boost::system::errc::success) {
       std::thread th([newDirectoryPath]() {
         boost::system::error_code ec;
diff -Naur ./Shared/InlineNullValues.h ../omniscidb-master/Shared/InlineNullValues.h
--- ./Shared/InlineNullValues.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/InlineNullValues.h	2021-04-21 00:02:57.000000000 +0300
@@ -185,7 +185,7 @@
   CHECK_EQ(kENCODING_FIXED, ti.get_compression());
   CHECK(ti.is_integer() || ti.is_time() || ti.is_decimal());
   CHECK_EQ(0, ti.get_comp_param() % 8);
-  return -(1L << (ti.get_comp_param() - 1));
+  return -(1LL << (ti.get_comp_param() - 1));
 }
 
 template <typename SQL_TYPE_INFO>
@@ -292,9 +292,9 @@
   CHECK(ti.is_integer() || ti.is_time() || ti.is_decimal());
   CHECK_EQ(0, ti.get_comp_param() % 8);
   // The value of the NULL sentinel for fixed encoding is:
-  //   -(1L << (ti.get_comp_param() - 1))
+  //   -(1LL << (ti.get_comp_param() - 1))
   // NULL_ARRAY sentinel would have to be the value just above NULL:
-  return -(1L << (ti.get_comp_param() - 1)) + 1;
+  return -(1LL << (ti.get_comp_param() - 1)) + 1;
 }
 
 #endif  // NO_BOOST
diff -Naur ./Shared/SqlTypesLayout.h ../omniscidb-master/Shared/SqlTypesLayout.h
--- ./Shared/SqlTypesLayout.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/SqlTypesLayout.h	2021-04-21 00:02:57.000000000 +0300
@@ -140,7 +140,7 @@
   CHECK_EQ(kENCODING_FIXED, ti.get_compression());
   CHECK(ti.is_integer() || ti.is_time() || ti.is_decimal());
   CHECK_EQ(0, ti.get_comp_param() % 8);
-  return -(1L << (ti.get_comp_param() - 1));
+  return -(1LL << (ti.get_comp_param() - 1));
 }
 
 inline double inline_fp_null_val(const SQLTypeInfo& ti) {
diff -Naur ./Shared/StackTrace.cpp ../omniscidb-master/Shared/StackTrace.cpp
--- ./Shared/StackTrace.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/StackTrace.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -18,8 +18,9 @@
 
 #define BOOST_STACKTRACE_GNU_SOURCE_NOT_REQUIRED 1
 
+#include "Shared/boost_stacktrace.hpp"
+
 #include <boost/algorithm/string.hpp>
-#include <boost/stacktrace.hpp>
 
 std::string getCurrentStackTrace(uint32_t num_frames_to_skip,
                                  const char* stop_at_this_frame,
diff -Naur ./Shared/StringTransform.cpp ../omniscidb-master/Shared/StringTransform.cpp
--- ./Shared/StringTransform.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/StringTransform.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -232,3 +232,13 @@
   return ss.str();
 }
 #endif  // __CUDACC__
+
+#ifndef __CUDACC__
+std::string simple_sanitize(const std::string& str) {
+  auto sanitized_str{str};
+  for (auto& c : sanitized_str) {
+    c = (c < 32) ? ' ' : c;
+  }
+  return sanitized_str;
+}
+#endif  // __CUDACC__
diff -Naur ./Shared/StringTransform.h ../omniscidb-master/Shared/StringTransform.h
--- ./Shared/StringTransform.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/StringTransform.h	2021-04-21 00:02:57.000000000 +0300
@@ -115,6 +115,11 @@
 bool remove_unquoted_newlines_linefeeds_and_tabs_from_sql_string(
     std::string& str) noexcept;
 
+//! simple sanitize string (replace control characters with space)
+#ifndef __CUDACC__
+std::string simple_sanitize(const std::string& str);
+#endif  // __CUDACC__
+
 #ifndef __CUDACC__
 //! Quote a string while escaping any existing quotes in the string.
 std::string get_quoted_string(const std::string& filename,
diff -Naur ./Shared/boost_stacktrace.hpp ../omniscidb-master/Shared/boost_stacktrace.hpp
--- ./Shared/boost_stacktrace.hpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Shared/boost_stacktrace.hpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2020 OmniSci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef BOOST_STACKTRACE_H
+#define BOOST_STACKTRACE_H
+
+#ifdef _WIN32
+#include <windows.h>
+
+// boost includes dbgeng.h which uses IN and OUT macroses
+// in structure declaration. For some reason those macroses
+// can be undefined (not clear if it is SDK or our bug, rpcdce.h defines them only),
+// so we define these macroses here to fix the problem.
+#ifndef IN
+#define IN
+#define OUT
+#define UNDEF_IN_OUT
+#endif
+
+#endif  // _WIN32
+
+#include <boost/stacktrace.hpp>
+
+#ifdef _WIN32
+
+#ifdef UNDEF_IN_OUT
+#undef IN
+#undef OUT
+#endif  // UNDEF_IN_OUT
+
+#include "cleanup_global_namespace.h"
+#endif  // _WIN32
+
+#endif  // BOOST_STACKTRACE_H
diff -Naur ./Shared/checked_alloc.h ../omniscidb-master/Shared/checked_alloc.h
--- ./Shared/checked_alloc.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/checked_alloc.h	2021-04-21 00:02:57.000000000 +0300
@@ -19,7 +19,8 @@
 
 #define BOOST_STACKTRACE_GNU_SOURCE_NOT_REQUIRED 1
 
-#include <boost/stacktrace.hpp>
+#include "Shared/boost_stacktrace.hpp"
+
 #include <cstdlib>
 #include <ostream>
 #include <stdexcept>
diff -Naur ./Shared/cleanup_global_namespace.h ../omniscidb-master/Shared/cleanup_global_namespace.h
--- ./Shared/cleanup_global_namespace.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Shared/cleanup_global_namespace.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,11 @@
+#ifdef _WIN32
+
+#ifdef OPTIONAL
+#undef OPTIONAL
+#endif
+
+#ifdef GetObject
+#undef GetObject
+#endif
+
+#endif
diff -Naur ./Shared/funcannotations.h ../omniscidb-master/Shared/funcannotations.h
--- ./Shared/funcannotations.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/funcannotations.h	2021-04-21 00:02:57.000000000 +0300
@@ -50,8 +50,7 @@
     defined(WITH_JIT_DEBUG)
 #define ALWAYS_INLINE
 #elif defined(ENABLE_EMBEDDED_DATABASE)
-#define ALWAYS_INLINE \
-  __attribute__((always_inline)) __attribute__((__visibility__("hidden")))
+#define ALWAYS_INLINE __attribute__((inline)) __attribute__((__visibility__("protected")))
 #elif defined(_MSC_VER)
 #define ALWAYS_INLINE __inline
 #else
@@ -71,3 +70,9 @@
 #else
 #define SUFFIX(name) name
 #endif
+
+#ifdef _WIN32
+#define RUNTIME_EXPORT __declspec(dllexport)
+#else
+#define RUNTIME_EXPORT
+#endif
diff -Naur ./Shared/get_nvidia_compute_capability.h ../omniscidb-master/Shared/get_nvidia_compute_capability.h
--- ./Shared/get_nvidia_compute_capability.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Shared/get_nvidia_compute_capability.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,63 @@
+// Copyright (c) 2021 OmniSci, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <cassert>
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+#include <cuda_runtime.h>
+
+inline std::vector<size_t> get_nvidia_compute_capability() {
+  using namespace std::string_literals;
+  std::vector<size_t> ret;
+
+  int deviceCount = 0;
+  cudaError_t error_id = cudaGetDeviceCount(&deviceCount);
+
+  if (error_id != cudaSuccess) {
+    throw std::runtime_error("cudaGetDeviceCount failed: "s + std::to_string(error_id) +
+                             ": "s + cudaGetErrorString(error_id));
+  }
+
+  for (int dev = 0; dev < deviceCount; ++dev) {
+    cudaSetDevice(dev);
+    cudaDeviceProp deviceProp;
+    cudaGetDeviceProperties(&deviceProp, dev);
+
+    if (deviceProp.major <= 0) {
+      throw std::runtime_error("unexpected cuda compute capability: major "s +
+                               std::to_string(deviceProp.major));
+    }
+    if (deviceProp.minor < 0) {
+      throw std::runtime_error("unexpected cuda compute capability: minor "s +
+                               std::to_string(deviceProp.minor));
+    }
+
+    if (deviceProp.major >= 10) {
+      throw std::runtime_error("unexpected cuda compute capability: major "s +
+                               std::to_string(deviceProp.major));
+    }
+    if (deviceProp.minor >= 10) {
+      throw std::runtime_error("unexpected cuda compute capability: minor "s +
+                               std::to_string(deviceProp.minor));
+    }
+
+    ret.push_back((deviceProp.major * 10U) + deviceProp.minor);
+  }
+
+  return ret;
+}
diff -Naur ./Shared/mapd_shared_mutex.h ../omniscidb-master/Shared/mapd_shared_mutex.h
--- ./Shared/mapd_shared_mutex.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/mapd_shared_mutex.h	2021-04-21 00:02:57.000000000 +0300
@@ -22,6 +22,8 @@
 #ifdef HAVE_FOLLY
 #include <folly/SharedMutex.h>
 using mapd_shared_mutex = folly::SharedMutex;
+// Folly includes windows.h and pollutes global namespace with macroses
+#include "cleanup_global_namespace.h"
 #else
 using mapd_shared_mutex = std::shared_timed_mutex;
 #endif  // HAVE_FOLLY
diff -Naur ./Shared/toString.h ../omniscidb-master/Shared/toString.h
--- ./Shared/toString.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/toString.h	2021-04-21 00:02:57.000000000 +0300
@@ -35,11 +35,13 @@
 #pragma once
 
 #ifndef __CUDACC__
-#if __cplusplus >= 201703L
 
 #define HAVE_TOSTRING
 
+#ifndef _WIN32
 #include <cxxabi.h>
+#endif
+
 #include <chrono>
 #include <iostream>
 #include <set>
@@ -71,17 +73,22 @@
 #endif
 #endif
 
-#define PRINT(EXPR)                                                             \
-  std::cout << __FILE__ << ":" << __func__ << "#" << __LINE__ << ": " #EXPR "=" \
-            << ::toString(EXPR) << std::endl;
+#define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
+#define PRINT(EXPR)                                                      \
+  std::cout << "[" << __FILENAME__ << ":" << __func__ << "#" << __LINE__ \
+            << "]: " #EXPR "=" << ::toString(EXPR) << std::endl;
 
 template <typename T>
 std::string typeName(const T* v) {
   std::stringstream stream;
   int status;
+#ifdef _WIN32
+  stream << std::string(typeid(T).name());
+#else
   char* demangled = abi::__cxa_demangle(typeid(T).name(), 0, 0, &status);
   stream << std::string(demangled);
   free(demangled);
+#endif
   return stream.str();
 }
 
@@ -281,5 +288,4 @@
   return std::string("(") + toString(left) + ", " + toString(right) + ")";
 }
 
-#endif  //  __cplusplus >= 201703L
 #endif  // __CUDACC__
diff -Naur ./Shared/types.h ../omniscidb-master/Shared/types.h
--- ./Shared/types.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Shared/types.h	2021-04-21 00:02:57.000000000 +0300
@@ -54,6 +54,11 @@
   return ChunkKey{key[CHUNK_KEY_DB_IDX], key[CHUNK_KEY_TABLE_IDX]};
 }
 
+inline std::pair<int, int> get_table_prefix(const ChunkKey& key) {
+  CHECK(has_table_prefix(key));
+  return std::pair<int, int>{key[CHUNK_KEY_DB_IDX], key[CHUNK_KEY_TABLE_IDX]};
+}
+
 inline bool is_column_key(const ChunkKey& key) {
   return key.size() == 3;
 }
@@ -70,6 +75,13 @@
   return key.size() == 5 && key[4] == 2;
 }
 
+inline bool in_same_table(const ChunkKey& left_key, const ChunkKey& right_key) {
+  CHECK(has_table_prefix(left_key));
+  CHECK(has_table_prefix(right_key));
+  return (left_key[CHUNK_KEY_DB_IDX] == right_key[CHUNK_KEY_DB_IDX] &&
+          left_key[CHUNK_KEY_TABLE_IDX] == right_key[CHUNK_KEY_TABLE_IDX]);
+}
+
 inline std::string show_chunk(const ChunkKey& key) {
   std::ostringstream tss;
   for (auto vecIt = key.begin(); vecIt != key.end(); ++vecIt) {
diff -Naur ./Tests/ArrowCsvForeignStorageTest.cpp ../omniscidb-master/Tests/ArrowCsvForeignStorageTest.cpp
--- ./Tests/ArrowCsvForeignStorageTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/ArrowCsvForeignStorageTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -105,7 +105,7 @@
   }
 }
 
-const char* trips_table_ddl = R"( 
+const char* trips_table_ddl = R"(
 CREATE TEMPORARY TABLE trips (
 trip_id BIGINT,
 vendor_id TEXT ENCODING NONE,
@@ -568,7 +568,6 @@
   logger::init(log_options);
 
   QR::init(BASE_PATH);
-  registerArrowCsvForeignStorage();
   int err{0};
   try {
     err = RUN_ALL_TESTS();
diff -Naur ./Tests/CMakeLists.txt ../omniscidb-master/Tests/CMakeLists.txt
--- ./Tests/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -30,6 +30,7 @@
 add_executable(JSONTest JSONTest.cpp)
 
 if(ENABLE_CUDA)
+  message(DEBUG "Tests CUDA_COMPILATION_ARCH: ${CUDA_COMPILATION_ARCH}")
   set(MAPD_DEFINITIONS -DHAVE_CUDA)
   if (SUPPRESS_NULL_LOGGER_DEPRECATION_WARNINGS)
     list(APPEND MAPD_DEFINITIONS -DSUPPRESS_NULL_LOGGER_DEPRECATION_WARNINGS)
@@ -101,6 +102,8 @@
 endif()
 if(ENABLE_CUDA)
   add_executable(GpuSharedMemoryTest GpuSharedMemoryTest.cpp ResultSetTestUtils.cpp)
+elseif(ENABLE_DBE)
+  add_executable(EmbeddedDatabaseTest EmbeddedDatabaseTest.cpp)
 endif()
 if(("${MAPD_EDITION_LOWER}" STREQUAL "ee") AND ENABLE_AWS_S3)
   add_executable(UserMappingDdlTest ee/UserMappingDdlTest.cpp)
@@ -201,6 +204,8 @@
 target_link_libraries(TableUpdateDeleteBenchmark benchmark ${EXECUTE_TEST_LIBS})
 if(ENABLE_CUDA)
   target_link_libraries(GpuSharedMemoryTest ${EXECUTE_TEST_LIBS})
+elseif(ENABLE_DBE)
+  target_link_libraries(EmbeddedDatabaseTest gtest DBEngine)
 endif()
 
 if(("${MAPD_EDITION_LOWER}" STREQUAL "ee") AND ENABLE_AWS_S3)
@@ -275,6 +280,8 @@
 
 if(ENABLE_CUDA)
   add_test(GpuSharedMemoryTest GpuSharedMemoryTest ${TEST_ARGS})
+elseif(ENABLE_DBE)
+  add_test(EmbeddedDatabaseTest EmbeddedDatabaseTest ${TEST_ARGS})
 endif()
 
 if(NOT ${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
@@ -363,6 +370,8 @@
 
 if(ENABLE_CUDA)
   list(APPEND TEST_PROGRAMS GpuSharedMemoryTest)
+elseif(ENABLE_DBE)
+  list(APPEND TEST_PROGRAMS EmbeddedDatabaseTest)
 endif()
 
 if(NOT ${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
@@ -411,3 +420,18 @@
     COMMAND initdb -f ${TEST_BASE_PATH}
     COMMAND ${CMAKE_CTEST_COMMAND} --verbose --tests-regex "\"(TopKTest)\""
     DEPENDS TopKTest)
+
+if(ENABLE_DBE)
+  set(DBE_TEST_PROGRAMS EmbeddedDatabaseTest)
+  set_tests_properties(${DBE_TEST_PROGRAMS} PROPERTIES LABELS "embedded")
+  add_custom_target(dbe_all_tests
+    COMMAND mkdir -p ${TEST_BASE_PATH}
+    COMMAND env AWS_REGION=${AWS_REGION}
+                AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
+                AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
+                ${CMAKE_CTEST_COMMAND} --verbose --label-regex embedded
+    DEPENDS DBEngine ${DBE_TEST_PROGRAMS}
+    USES_TERMINAL)
+  add_dependencies(dbe_all_tests dbe4py-test)
+  add_dependencies(all_tests dbe4py-test)
+endif()
diff -Naur ./Tests/CreateAndDropTableDdlTest.cpp ../omniscidb-master/Tests/CreateAndDropTableDdlTest.cpp
--- ./Tests/CreateAndDropTableDdlTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/CreateAndDropTableDdlTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -177,8 +177,8 @@
     EXPECT_EQ(table_name, td->tableName);
     EXPECT_EQ(Fragmenter_Namespace::FragmenterType::INSERT_ORDER, td->fragType);
     EXPECT_EQ(max_fragment_size, td->maxFragRows);
-    EXPECT_EQ(DEFAULT_MAX_CHUNK_SIZE, td->maxChunkSize);
-    EXPECT_EQ(DEFAULT_PAGE_SIZE, td->fragPageSize);
+    EXPECT_EQ(size_t(DEFAULT_MAX_CHUNK_SIZE), size_t(td->maxChunkSize));
+    EXPECT_EQ(size_t(DEFAULT_PAGE_SIZE), size_t(td->fragPageSize));
     EXPECT_EQ(DEFAULT_MAX_ROWS, td->maxRows);
     EXPECT_EQ(user_id, td->userId);
     EXPECT_EQ(Data_Namespace::MemoryLevel::DISK_LEVEL, td->persistenceLevel);
diff -Naur ./Tests/CtasIntegrationTest.cpp ../omniscidb-master/Tests/CtasIntegrationTest.cpp
--- ./Tests/CtasIntegrationTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/CtasIntegrationTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -331,11 +331,17 @@
   }
 
   std::string getValueAsString(int row) {
-    std::tm tm_struct;
+    char buf[128];
     time_t t = offset + (scale * row);
+#ifdef _WIN32
+    // On Windows gmtime is thread safe.
+    auto* tm_struct = gmtime(&t);
+    strftime(buf, 128, format.c_str(), tm_struct);
+#else
+    std::tm tm_struct;
     gmtime_r(&t, &tm_struct);
-    char buf[128];
     strftime(buf, 128, format.c_str(), &tm_struct);
+#endif
     return std::string(buf);
   }
 };
@@ -760,7 +766,7 @@
   boost::filesystem::path temp =
       boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();
 
-  std::string export_file_name = temp.native() + ".csv";
+  std::string export_file_name = temp.make_preferred().string() + ".csv";
 
   // execute CTAS
   std::string export_sql = "COPY (SELECT * FROM EXPORT_SOURCE) TO '" + export_file_name +
diff -Naur ./Tests/CtasUpdateTest.cpp ../omniscidb-master/Tests/CtasUpdateTest.cpp
--- ./Tests/CtasUpdateTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/CtasUpdateTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -1743,7 +1743,7 @@
   boost::filesystem::path temp =
       boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();
 
-  std::string export_file_name = temp.native() + ".csv";
+  std::string export_file_name = temp.make_preferred().string() + std::string(".csv");
 
   // execute CTAS
   std::string export_sql = "COPY (SELECT * FROM EXPORT_SOURCE) TO '" + export_file_name +
diff -Naur ./Tests/DBHandlerTestHelpers.h ../omniscidb-master/Tests/DBHandlerTestHelpers.h
--- ./Tests/DBHandlerTestHelpers.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/DBHandlerTestHelpers.h	2021-04-21 00:02:57.000000000 +0300
@@ -243,7 +243,8 @@
 #ifdef ENABLE_GEOS
                                                 libgeos_so_filename_,
 #endif
-                                                disk_cache_config);
+                                                disk_cache_config,
+                                                false);
       loginAdmin();
 
       // Execute on CPU by default
diff -Naur ./Tests/DataMgrTestHelpers.h ../omniscidb-master/Tests/DataMgrTestHelpers.h
--- ./Tests/DataMgrTestHelpers.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/DataMgrTestHelpers.h	2021-04-21 00:02:57.000000000 +0300
@@ -89,11 +89,11 @@
   MemoryLevel getType() const override { return Data_Namespace::CPU_LEVEL; }
 
   bool compare(AbstractBuffer* buffer, size_t num_bytes) {
-    int8_t left_array[num_bytes];
-    int8_t right_array[num_bytes];
-    read(left_array, num_bytes);
-    buffer->read(right_array, num_bytes);
-    if ((std::memcmp(left_array, right_array, num_bytes) == 0) &&
+    std::vector<int8_t> left_array(num_bytes);
+    std::vector<int8_t> right_array(num_bytes);
+    read(left_array.data(), num_bytes);
+    buffer->read(right_array.data(), num_bytes);
+    if ((std::memcmp(left_array.data(), right_array.data(), num_bytes) == 0) &&
         (hasEncoder() == buffer->hasEncoder())) {
       return true;
     }
diff -Naur ./Tests/EmbeddedDatabaseTest.cpp ../omniscidb-master/Tests/EmbeddedDatabaseTest.cpp
--- ./Tests/EmbeddedDatabaseTest.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/Tests/EmbeddedDatabaseTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2020 OmniSci, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <boost/program_options.hpp>
+#include "Embedded/DBEngine.h"
+
+#ifndef BASE_PATH
+#define BASE_PATH "./tmp"
+#endif
+
+using namespace std;
+using namespace EmbeddedDatabase;
+
+std::shared_ptr<DBEngine> engine;
+
+class DBEngineSQLTest : public ::testing::Test {
+ protected:
+  DBEngineSQLTest() {}
+  virtual ~DBEngineSQLTest() {}
+
+  void SetUp(const std::string& table_spec) {
+    run_ddl("DROP TABLE IF EXISTS dbe_test;");
+    run_ddl("CREATE TABLE dbe_test " + table_spec + ";");
+  }
+
+  virtual void TearDown() { run_ddl("DROP TABLE IF EXISTS dbe_test;"); }
+
+  int select_int(const string& query_str) {
+    auto cursor = ::engine->executeDML(query_str);
+    auto row = cursor->getNextRow();
+    return row.getInt(0);
+  }
+
+  float select_float(const string& query_str) {
+    auto cursor = ::engine->executeDML(query_str);
+    auto row = cursor->getNextRow();
+    return row.getFloat(0);
+  }
+
+  double select_double(const string& query_str) {
+    auto cursor = ::engine->executeDML(query_str);
+    auto row = cursor->getNextRow();
+    return row.getDouble(0);
+  }
+
+  void run_ddl(const string& query_str) { ::engine->executeDDL(query_str); }
+
+  std::shared_ptr<arrow::RecordBatch> run_dml(const string& query_str) {
+    auto cursor = ::engine->executeDML(query_str);
+    return cursor ? cursor->getArrowRecordBatch() : nullptr;
+  }
+};
+
+TEST_F(DBEngineSQLTest, InsertDict) {
+  EXPECT_NO_THROW(SetUp("(col1 TEXT ENCODING DICT) WITH (partitions='replicated')"));
+  EXPECT_NO_THROW(run_dml("INSERT INTO dbe_test VALUES('t1');"));
+  ASSERT_EQ(1, select_int("SELECT count(*) FROM dbe_test;"));
+
+  EXPECT_NO_THROW(run_dml("INSERT INTO dbe_test VALUES('t2');"));
+  ASSERT_EQ(2, select_int("SELECT count(*) FROM dbe_test;"));
+
+  EXPECT_NO_THROW(run_dml("INSERT INTO dbe_test VALUES('t3');"));
+  ASSERT_EQ(3, select_int("SELECT count(*) FROM dbe_test;"));
+}
+
+TEST_F(DBEngineSQLTest, InsertDecimal) {
+  EXPECT_NO_THROW(
+      SetUp("(big_dec DECIMAL(17, 2), med_dec DECIMAL(9, 2), "
+            "small_dec DECIMAL(4, 2)) WITH (fragment_size=2)"));
+
+  EXPECT_NO_THROW(
+      run_dml("INSERT INTO dbe_test VALUES(999999999999999.99, 9999999.99, 99.99);"));
+  ASSERT_EQ(1, select_int("SELECT count(*) FROM dbe_test;"));
+
+  EXPECT_NO_THROW(
+      run_dml("INSERT INTO dbe_test VALUES(-999999999999999.99, -9999999.99, -99.99);"));
+  ASSERT_EQ(2, select_int("SELECT count(*) FROM dbe_test;"));
+
+  EXPECT_NO_THROW(run_dml("INSERT INTO dbe_test VALUES(12.2382, 12.2382 , 12.2382);"));
+  ASSERT_EQ(3, select_int("SELECT count(*) FROM dbe_test;"));
+}
+
+TEST_F(DBEngineSQLTest, InsertShardedTableWithGeo) {
+  EXPECT_NO_THROW(
+      SetUp("(x Int, poly POLYGON, b SMALLINT, SHARD KEY(b)) WITH (shard_count = 4)"));
+
+  EXPECT_NO_THROW(
+      run_dml("INSERT INTO dbe_test VALUES (1,'POLYGON((0 0, 1 1, 2 2, 3 3))', 0);"));
+  EXPECT_NO_THROW(
+      run_dml("INSERT INTO dbe_test (x, poly, b) VALUES (1, 'POLYGON((0 0, 1 1, 2 2, 3 "
+              "3))', 1);"));
+  EXPECT_NO_THROW(
+      run_dml("INSERT INTO dbe_test (b, poly, x) VALUES (2, 'POLYGON((0 0, 1 1, 2 2, 3 "
+              "3))', 1);"));
+  EXPECT_NO_THROW(
+      run_dml("INSERT INTO dbe_test (x, b, poly) VALUES (1, 3, 'POLYGON((0 0, 1 1, 2 2, "
+              "3 3))');"));
+  EXPECT_NO_THROW(
+      run_dml("INSERT INTO dbe_test (poly, x, b) VALUES ('POLYGON((0 0, 1 1, 2 2, 3 "
+              "3))', 1, 4);"));
+
+  ASSERT_EQ(5, select_int("SELECT count(*) FROM dbe_test;"));
+}
+
+TEST_F(DBEngineSQLTest, UpdateText) {
+  SetUp("(t text encoding none)");
+
+  run_dml("insert into dbe_test values ('do');");
+  run_dml("insert into dbe_test values ('you');");
+  run_dml("insert into dbe_test values ('know');");
+  run_dml("insert into dbe_test values ('the');");
+  run_dml("insert into dbe_test values ('muffin');");
+  run_dml("insert into dbe_test values ('man');");
+
+  EXPECT_NO_THROW(run_dml("update dbe_test set t='pizza' where char_length(t) <= 3;"));
+  ASSERT_EQ(4, select_int("select count(t) from dbe_test where t='pizza';"));
+}
+
+TEST_F(DBEngineSQLTest, FilterAndSimpleAggregation) {
+  const ssize_t num_rows{10};
+
+  EXPECT_NO_THROW(
+      SetUp("(x int not null, w tinyint, y int, z smallint, t bigint, "
+            "b boolean, f float, ff float, fn float, d double, dn double, "
+            "str varchar(10), null_str text, fixed_str text, fixed_null_str text, "
+            "real_str text, shared_dict text, m timestamp(0), m_3 timestamp(3), "
+            "m_6 timestamp(6), m_9 timestamp(9), n time(0), o date, o1 date, o2 date, "
+            "fx int, dd decimal(10, 2), dd_notnull decimal(10, 2) not null, ss text, "
+            "u int, ofd int, ufd int not null, ofq bigint, ufq bigint not null, "
+            "smallint_nulls smallint, bn boolean not null)"));
+
+  for (ssize_t i = 0; i < num_rows; ++i) {
+    EXPECT_NO_THROW(
+        run_dml("INSERT INTO dbe_test VALUES(7, -8, 42, 101, 1001, 't', 1.1, 1.1, null, "
+                "2.2, null, "
+                "'foo', null, 'foo', null, "
+                "'real_foo', 'foo',"
+                "'2014-12-13 22:23:15', '2014-12-13 22:23:15.323', '1999-07-11 "
+                "14:02:53.874533', "
+                "'2006-04-26 "
+                "03:49:04.607435125', "
+                "'15:13:14', '1999-09-09', '1999-09-09', '1999-09-09', 9, 111.1, 111.1, "
+                "'fish', "
+                "null, "
+                "2147483647, -2147483648, null, -1, 32767, 't');"));
+    EXPECT_NO_THROW(run_dml(
+        "INSERT INTO dbe_test VALUES(8, -7, 43, -78, 1002, 'f', 1.2, 101.2, -101.2, 2.4, "
+        "-2002.4, 'bar', null, 'bar', null, "
+        "'real_bar', NULL, '2014-12-13 22:23:15', '2014-12-13 22:23:15.323', "
+        "'2014-12-13 "
+        "22:23:15.874533', "
+        "'2014-12-13 22:23:15.607435763', '15:13:14', NULL, NULL, NULL, NULL, 222.2, "
+        "222.2, "
+        "null, null, null, "
+        "-2147483647, "
+        "9223372036854775807, -9223372036854775808, null, 'f');"));
+    EXPECT_NO_THROW(run_dml(
+        "INSERT INTO dbe_test VALUES(7, -7, 43, 102, 1002, null, 1.3, 1000.3, -1000.3, "
+        "2.6, "
+        "-220.6, 'baz', null, null, null, "
+        "'real_baz', 'baz', '2014-12-14 22:23:15', '2014-12-14 22:23:15.750', "
+        "'2014-12-14 22:23:15.437321', "
+        "'2014-12-14 22:23:15.934567401', '15:13:14', '1999-09-09', '1999-09-09', "
+        "'1999-09-09', 11, "
+        "333.3, 333.3, "
+        "'boat', null, 1, "
+        "-1, 1, -9223372036854775808, 1, 't');"));
+  }
+
+  ASSERT_EQ(30, select_int("SELECT COUNT(*) FROM dbe_test;"));
+  ASSERT_EQ(30, select_int("SELECT COUNT(f) FROM dbe_test;"));
+  ASSERT_EQ(7, select_int("SELECT MIN(x) FROM dbe_test;"));
+  ASSERT_EQ(8, select_int("SELECT MAX(x) FROM dbe_test;"));
+  ASSERT_EQ(-78, select_int("SELECT MIN(z) FROM dbe_test;"));
+  ASSERT_EQ(102, select_int("SELECT MAX(z) FROM dbe_test;"));
+  ASSERT_EQ(1001, select_int("SELECT MIN(t) FROM dbe_test;"));
+  ASSERT_EQ(1002, select_int("SELECT MAX(t) FROM dbe_test;"));
+  EXPECT_FLOAT_EQ(1.1, select_float("SELECT MIN(ff) FROM dbe_test;"));
+  EXPECT_FLOAT_EQ(-1000.3, select_float("SELECT MIN(fn) FROM dbe_test;"));
+  EXPECT_FLOAT_EQ(1000, select_float("SELECT FLOOR(MAX(ff)) FROM dbe_test;"));
+  EXPECT_FLOAT_EQ(-102, select_float("SELECT FLOOR(MAX(fn)) FROM dbe_test;"));
+  EXPECT_FLOAT_EQ(11026, select_float("SELECT SUM(ff) FROM dbe_test;"));
+  EXPECT_FLOAT_EQ(-11015, select_float("SELECT SUM(fn) FROM dbe_test;"));
+  ASSERT_EQ(1500, select_int("SELECT SUM(x + y) FROM dbe_test;"));
+  ASSERT_EQ(2750, select_int("SELECT SUM(x + y + z) FROM dbe_test;"));
+  ASSERT_EQ(32800, select_int("SELECT SUM(x + y + z + t) FROM dbe_test;"));
+  ASSERT_EQ(20, select_int("SELECT COUNT(*) FROM dbe_test WHERE x > 6 AND x < 8;"));
+  ASSERT_EQ(10,
+            select_int("SELECT COUNT(*) FROM dbe_test WHERE x > 6 AND x < 8 AND z > 100 "
+                       "AND z < 102;"));
+  ASSERT_EQ(20,
+            select_int("SELECT COUNT(*) FROM dbe_test WHERE x > 6 AND x < 8 OR (z > 100 "
+                       "AND z < 103);"));
+  ASSERT_EQ(10,
+            select_int("SELECT COUNT(*) FROM dbe_test WHERE x > 6 AND x < 8 AND z > 100 "
+                       "AND z < 102 AND t > 1000 AND t < 1002;"));
+}
+
+int main(int argc, char** argv) {
+  testing::InitGoogleTest(&argc, argv);
+
+  namespace po = boost::program_options;
+
+  po::options_description desc("Options");
+
+  // these two are here to allow passing correctly google testing parameters
+  desc.add_options()("gtest_list_tests", "list all tests");
+  desc.add_options()("gtest_filter", "filters tests, use --help for details");
+
+  desc.add_options()("test-help",
+                     "Print all EmbeddedDbTest specific options (for gtest "
+                     "options use `--help`).");
+
+  logger::LogOptions log_options(argv[0]);
+  log_options.max_files_ = 0;  // stderr only by default
+  desc.add(log_options.get_options());
+
+  po::variables_map vm;
+  po::store(po::command_line_parser(argc, argv).options(desc).run(), vm);
+  po::notify(vm);
+
+  if (vm.count("test-help")) {
+    std::cout << "Usage: EmbeddedDatabaseTest" << std::endl << std::endl;
+    std::cout << desc << std::endl;
+    return 0;
+  }
+
+  logger::init(log_options);
+
+  engine = DBEngine::create("--data " + std::string(BASE_PATH));
+
+  int err{0};
+
+  try {
+    err = RUN_ALL_TESTS();
+    engine.reset();
+  } catch (const std::exception& e) {
+    LOG(ERROR) << e.what();
+  }
+  return err;
+}
diff -Naur ./Tests/ExecuteTest.cpp ../omniscidb-master/Tests/ExecuteTest.cpp
--- ./Tests/ExecuteTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/ExecuteTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -367,7 +367,7 @@
                 int fs = 0;
                 if (*end_str == '.') {
                   end_str++;
-                  uint frac_num;
+                  unsigned int frac_num;
                   int ntotal;
                   sscanf(end_str, "%d%n", &frac_num, &ntotal);
                   fs = parse_fractional_seconds(frac_num, ntotal, omnisci_ti);
@@ -522,6 +522,12 @@
     return;                                                       \
   }
 
+#define SKIP_IF_SHARDED()                                       \
+  if (g_shard_count) {                                          \
+    LOG(ERROR) << "Tests not valid when using sharded tables."; \
+    return;                                                     \
+  }
+
 bool validate_statement_syntax(const std::string& stmt) {
   SQLParser parser;
   list<std::unique_ptr<Parser::Stmt>> parse_trees;
@@ -3618,19 +3624,19 @@
   for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
     SKIP_NO_GPU();
 
-    ASSERT_EQ(1325376000L,
+    ASSERT_EQ(1325376000LL,
               v<int64_t>(run_simple_agg("SELECT DATE_TRUNC(year, CAST('2012-05-08 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
-    ASSERT_EQ(1325376000L,
+    ASSERT_EQ(1325376000LL,
               v<int64_t>(run_simple_agg("SELECT DATE_TRUNC('year', CAST('2012-05-08 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
-    ASSERT_EQ(1325376000L,
+    ASSERT_EQ(1325376000LL,
               v<int64_t>(run_simple_agg("SELECT PG_DATE_TRUNC(year, CAST('2012-05-08 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
-    ASSERT_EQ(1325376000L,
+    ASSERT_EQ(1325376000LL,
               v<int64_t>(run_simple_agg("SELECT PG_DATE_TRUNC('year', CAST('2012-05-08 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
@@ -3820,10 +3826,10 @@
               v<int64_t>(run_simple_agg("SELECT COUNT(*) FROM test WHERE CAST(o AS "
                                         "TIMESTAMP) > timestamp(0) '1999-09-10T160000';",
                                         dt)));
-    ASSERT_EQ(14185957950L,
+    ASSERT_EQ(14185957950LL,
               v<int64_t>(run_simple_agg(
                   "SELECT MAX(EXTRACT(EPOCH FROM m) * 10) FROM test;", dt)));
-    ASSERT_EQ(14185152000L,
+    ASSERT_EQ(14185152000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT MAX(EXTRACT(DATEEPOCH FROM m) * 10) FROM test;", dt)));
     ASSERT_EQ(20140,
@@ -3873,77 +3879,77 @@
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM o) FROM test WHERE o IS NOT NULL;", dt)));
     ASSERT_EQ(
-        936835200L,
+        936835200LL,
         v<int64_t>(run_simple_agg("SELECT MAX(EXTRACT(EPOCH FROM o)) FROM test;", dt)));
-    ASSERT_EQ(936835200L,
+    ASSERT_EQ(936835200LL,
               v<int64_t>(run_simple_agg(
                   "SELECT MAX(EXTRACT(DATEEPOCH FROM o)) FROM test;", dt)));
-    ASSERT_EQ(52L,
+    ASSERT_EQ(52LL,
               v<int64_t>(run_simple_agg("SELECT MAX(EXTRACT(WEEK FROM CAST('2012-01-01 "
                                         "20:15:12' AS TIMESTAMP))) FROM test limit 1;",
                                         dt)));
     ASSERT_EQ(
-        1L,
+        1LL,
         v<int64_t>(run_simple_agg("SELECT MAX(EXTRACT(WEEK_SUNDAY FROM CAST('2012-01-01 "
                                   "20:15:12' AS TIMESTAMP))) FROM test limit 1;",
                                   dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(
                   run_simple_agg("SELECT MAX(EXTRACT(WEEK_SATURDAY FROM CAST('2012-01-01 "
                                  "20:15:12' AS TIMESTAMP))) FROM test limit 1;",
                                  dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(run_simple_agg("SELECT MAX(EXTRACT(WEEK FROM CAST('2008-03-03 "
                                         "20:15:12' AS TIMESTAMP))) FROM test limit 1;",
                                         dt)));
     ASSERT_EQ(
-        10L,
+        10LL,
         v<int64_t>(run_simple_agg("SELECT MAX(EXTRACT(WEEK_SUNDAY FROM CAST('2008-03-03 "
                                   "20:15:12' AS TIMESTAMP))) FROM test limit 1;",
                                   dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(
                   run_simple_agg("SELECT MAX(EXTRACT(WEEK_SATURDAY FROM CAST('2008-03-03 "
                                  "20:15:12' AS TIMESTAMP))) FROM test limit 1;",
                                  dt)));
     // Monday
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg("SELECT EXTRACT(DOW FROM CAST('2008-03-03 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
     // Monday
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg("SELECT EXTRACT(ISODOW FROM CAST('2008-03-03 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
     // Sunday
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg("SELECT EXTRACT(DOW FROM CAST('2008-03-02 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
     // Sunday
-    ASSERT_EQ(7L,
+    ASSERT_EQ(7LL,
               v<int64_t>(run_simple_agg("SELECT EXTRACT(ISODOW FROM CAST('2008-03-02 "
                                         "20:15:12' AS TIMESTAMP)) FROM test limit 1;",
                                         dt)));
-    ASSERT_EQ(15000000000L,
+    ASSERT_EQ(15000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(nanosecond from m) FROM test limit 1;", dt)));
-    ASSERT_EQ(15000000L,
+    ASSERT_EQ(15000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(microsecond from m) FROM test limit 1;", dt)));
-    ASSERT_EQ(15000L,
+    ASSERT_EQ(15000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(millisecond from m) FROM test limit 1;", dt)));
-    ASSERT_EQ(56000000000L,
+    ASSERT_EQ(56000000000LL,
               v<int64_t>(run_simple_agg("SELECT EXTRACT(nanosecond from TIMESTAMP(0) "
                                         "'1999-03-14 23:34:56') FROM test limit 1;",
                                         dt)));
-    ASSERT_EQ(56000000L,
+    ASSERT_EQ(56000000LL,
               v<int64_t>(run_simple_agg("SELECT EXTRACT(microsecond from TIMESTAMP(0) "
                                         "'1999-03-14 23:34:56') FROM test limit 1;",
                                         dt)));
-    ASSERT_EQ(56000L,
+    ASSERT_EQ(56000LL,
               v<int64_t>(run_simple_agg("SELECT EXTRACT(millisecond from TIMESTAMP(0) "
                                         "'1999-03-14 23:34:56') FROM test limit 1;",
                                         dt)));
@@ -3965,7 +3971,7 @@
                                         dt)));
 
     // test DATE format processing
-    ASSERT_EQ(1434844800L,
+    ASSERT_EQ(1434844800LL,
               v<int64_t>(run_simple_agg(
                   "select CAST('2015-06-21' AS DATE) FROM test limit 1;", dt)));
     ASSERT_EQ(
@@ -3987,7 +3993,7 @@
     // test different input formats
     // added new format for customer
     ASSERT_EQ(
-        1434896116L,
+        1434896116LL,
         v<int64_t>(run_simple_agg(
             "select CAST('2015-06-21 14:15:16' AS timestamp) FROM test limit 1;", dt)));
     ASSERT_EQ(static_cast<int64_t>(2 * g_num_rows),
@@ -4038,47 +4044,47 @@
                                         "CAST('2015-08-21T18:13:14' AS TIMESTAMP);",
                                         dt)));
     // add test for quarterday behaviour
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "select EXTRACT (QUARTERDAY FROM CAST('2015-08-21T04:23:11' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "select EXTRACT (QUARTERDAY FROM CAST('2015-08-21T00:00:00' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "select EXTRACT (QUARTERDAY FROM CAST('2015-08-21T08:23:11' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "select EXTRACT (QUARTERDAY FROM CAST('2015-08-21T14:23:11' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "select EXTRACT (QUARTERDAY FROM CAST('2015-08-21T23:23:11' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(1440115200L,
+    ASSERT_EQ(1440115200LL,
               v<int64_t>(run_simple_agg(
                   "select DATE_TRUNC (QUARTERDAY, CAST('2015-08-21T04:23:11' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(1440136800L,
+    ASSERT_EQ(1440136800LL,
               v<int64_t>(run_simple_agg(
                   "select DATE_TRUNC (QUARTERDAY, CAST('2015-08-21T08:23:11' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(1440158400L,
+    ASSERT_EQ(1440158400LL,
               v<int64_t>(run_simple_agg(
                   "select DATE_TRUNC (QUARTERDAY, CAST('2015-08-21T13:23:11' AS "
                   "timestamp)) FROM test limit 1;",
                   dt)));
-    ASSERT_EQ(1440180000L,
+    ASSERT_EQ(1440180000LL,
               v<int64_t>(run_simple_agg(
                   "select DATE_TRUNC (QUARTERDAY, CAST('2015-08-21T23:59:59' AS "
                   "timestamp)) FROM test limit 1;",
@@ -4767,9 +4773,9 @@
                                         dt)));
 
     ASSERT_EQ(
-        1418428800L,
+        1418428800LL,
         v<int64_t>(run_simple_agg("SELECT CAST(m AS date) FROM test LIMIT 1;", dt)));
-    ASSERT_EQ(1336435200L,
+    ASSERT_EQ(1336435200LL,
               v<int64_t>(run_simple_agg("SELECT CAST(CAST('2012-05-08 20:15:12' AS "
                                         "TIMESTAMP) AS DATE) FROM test LIMIT 1;",
                                         dt)));
@@ -4803,71 +4809,71 @@
 
     std::vector<std::tuple<std::string, int64_t, int64_t>> date_trunc_queries{
         /*TIMESTAMP(0) */
-        std::make_tuple("year, m", 1388534400L, 20),
-        std::make_tuple("month, m", 1417392000L, 20),
-        std::make_tuple("day, m", 1418428800L, 15),
-        std::make_tuple("hour, m", 1418508000L, 15),
-        std::make_tuple("minute, m", 1418509380L, 15),
-        std::make_tuple("second, m", 1418509395L, 15),
-        std::make_tuple("millennium, m", 978307200L, 20),
-        std::make_tuple("century, m", 978307200L, 20),
-        std::make_tuple("decade, m", 1262304000L, 20),
-        std::make_tuple("week, m", 1417996800L, 20),
-        std::make_tuple("week_sunday, m", 1417910400L, 15),
-        std::make_tuple("week_saturday, m", 1418428800L, 20),
-        std::make_tuple("nanosecond, m", 1418509395L, 15),
-        std::make_tuple("microsecond, m", 1418509395L, 15),
-        std::make_tuple("millisecond, m", 1418509395L, 15),
+        std::make_tuple("year, m", 1388534400LL, 20),
+        std::make_tuple("month, m", 1417392000LL, 20),
+        std::make_tuple("day, m", 1418428800LL, 15),
+        std::make_tuple("hour, m", 1418508000LL, 15),
+        std::make_tuple("minute, m", 1418509380LL, 15),
+        std::make_tuple("second, m", 1418509395LL, 15),
+        std::make_tuple("millennium, m", 978307200LL, 20),
+        std::make_tuple("century, m", 978307200LL, 20),
+        std::make_tuple("decade, m", 1262304000LL, 20),
+        std::make_tuple("week, m", 1417996800LL, 20),
+        std::make_tuple("week_sunday, m", 1417910400LL, 15),
+        std::make_tuple("week_saturday, m", 1418428800LL, 20),
+        std::make_tuple("nanosecond, m", 1418509395LL, 15),
+        std::make_tuple("microsecond, m", 1418509395LL, 15),
+        std::make_tuple("millisecond, m", 1418509395LL, 15),
         /* TIMESTAMP(3) */
-        std::make_tuple("year, m_3", 1388534400000L, 20),
-        std::make_tuple("month, m_3", 1417392000000L, 20),
-        std::make_tuple("day, m_3", 1418428800000L, 15),
-        std::make_tuple("hour, m_3", 1418508000000L, 15),
-        std::make_tuple("minute, m_3", 1418509380000L, 15),
-        std::make_tuple("second, m_3", 1418509395000L, 15),
-        std::make_tuple("millennium, m_3", 978307200000L, 20),
-        std::make_tuple("century, m_3", 978307200000L, 20),
-        std::make_tuple("decade, m_3", 1262304000000L, 20),
-        std::make_tuple("week, m_3", 1417996800000L, 20),
-        std::make_tuple("week_sunday, m_3", 1417910400000L, 15),
-        std::make_tuple("week_saturday, m_3", 1418428800000L, 20),
-        std::make_tuple("nanosecond, m_3", 1418509395323L, 15),
-        std::make_tuple("microsecond, m_3", 1418509395323L, 15),
-        std::make_tuple("millisecond, m_3", 1418509395323L, 15),
+        std::make_tuple("year, m_3", 1388534400000LL, 20),
+        std::make_tuple("month, m_3", 1417392000000LL, 20),
+        std::make_tuple("day, m_3", 1418428800000LL, 15),
+        std::make_tuple("hour, m_3", 1418508000000LL, 15),
+        std::make_tuple("minute, m_3", 1418509380000LL, 15),
+        std::make_tuple("second, m_3", 1418509395000LL, 15),
+        std::make_tuple("millennium, m_3", 978307200000LL, 20),
+        std::make_tuple("century, m_3", 978307200000LL, 20),
+        std::make_tuple("decade, m_3", 1262304000000LL, 20),
+        std::make_tuple("week, m_3", 1417996800000LL, 20),
+        std::make_tuple("week_sunday, m_3", 1417910400000LL, 15),
+        std::make_tuple("week_saturday, m_3", 1418428800000LL, 20),
+        std::make_tuple("nanosecond, m_3", 1418509395323LL, 15),
+        std::make_tuple("microsecond, m_3", 1418509395323LL, 15),
+        std::make_tuple("millisecond, m_3", 1418509395323LL, 15),
         /* TIMESTAMP(6) */
-        std::make_tuple("year, m_6", 915148800000000L, 10),
-        std::make_tuple("month, m_6", 930787200000000L, 10),
-        std::make_tuple("day, m_6", 931651200000000L, 10),
-        std::make_tuple("hour, m_6", 931701600000000L, 10),
-        /* std::make_tuple("minute, m_6", 931701720000000L, 10), // Exception with sort
+        std::make_tuple("year, m_6", 915148800000000LL, 10),
+        std::make_tuple("month, m_6", 930787200000000LL, 10),
+        std::make_tuple("day, m_6", 931651200000000LL, 10),
+        std::make_tuple("hour, m_6", 931701600000000LL, 10),
+        /* std::make_tuple("minute, m_6", 931701720000000LL, 10), // Exception with sort
            watchdog */
-        std::make_tuple("second, m_6", 931701773000000L, 10),
-        std::make_tuple("millennium, m_6", -30578688000000000L, 10),
-        std::make_tuple("century, m_6", -2177452800000000L, 10),
-        std::make_tuple("decade, m_6", 631152000000000L, 10),
-        std::make_tuple("week, m_6", 931132800000000L, 10),
-        std::make_tuple("week_sunday, m_6", 931651200000000L, 10),
-        std::make_tuple("week_saturday, m_6", 931564800000000L, 10),
-        std::make_tuple("nanosecond, m_6", 931701773874533L, 10),
-        std::make_tuple("microsecond, m_6", 931701773874533L, 10),
-        std::make_tuple("millisecond, m_6", 931701773874000L, 10),
+        std::make_tuple("second, m_6", 931701773000000LL, 10),
+        std::make_tuple("millennium, m_6", -30578688000000000LL, 10),
+        std::make_tuple("century, m_6", -2177452800000000LL, 10),
+        std::make_tuple("decade, m_6", 631152000000000LL, 10),
+        std::make_tuple("week, m_6", 931132800000000LL, 10),
+        std::make_tuple("week_sunday, m_6", 931651200000000LL, 10),
+        std::make_tuple("week_saturday, m_6", 931564800000000LL, 10),
+        std::make_tuple("nanosecond, m_6", 931701773874533LL, 10),
+        std::make_tuple("microsecond, m_6", 931701773874533LL, 10),
+        std::make_tuple("millisecond, m_6", 931701773874000LL, 10),
         /* TIMESTAMP(9) */
-        std::make_tuple("year, m_9", 1136073600000000000L, 10),
-        std::make_tuple("month, m_9", 1143849600000000000L, 10),
-        std::make_tuple("day, m_9", 1146009600000000000L, 10),
-        std::make_tuple("hour, m_9", 1146020400000000000L, 10),
-        /* std::make_tuple("minute, m_9", 1146023340000000000L, 10), // Exception with
+        std::make_tuple("year, m_9", 1136073600000000000LL, 10),
+        std::make_tuple("month, m_9", 1143849600000000000LL, 10),
+        std::make_tuple("day, m_9", 1146009600000000000LL, 10),
+        std::make_tuple("hour, m_9", 1146020400000000000LL, 10),
+        /* std::make_tuple("minute, m_9", 1146023340000000000LL, 10), // Exception with
            sort watchdog */
-        std::make_tuple("second, m_9", 1146023344000000000L, 10),
-        std::make_tuple("millennium, m_9", 978307200000000000L, 20),
-        std::make_tuple("century, m_9", 978307200000000000L, 20),
-        std::make_tuple("decade, m_9", 946684800000000000L, 10),
-        std::make_tuple("week, m_9", 1145836800000000000L, 10),
-        std::make_tuple("week_sunday, m_9", 1145750400000000000L, 10),
-        std::make_tuple("week_saturday, m_9", 1145664000000000000L, 10),
-        std::make_tuple("nanosecond, m_9", 1146023344607435125L, 10),
-        std::make_tuple("microsecond, m_9", 1146023344607435000L, 10),
-        std::make_tuple("millisecond, m_9", 1146023344607000000L, 10)};
+        std::make_tuple("second, m_9", 1146023344000000000LL, 10),
+        std::make_tuple("millennium, m_9", 978307200000000000LL, 20),
+        std::make_tuple("century, m_9", 978307200000000000LL, 20),
+        std::make_tuple("decade, m_9", 946684800000000000LL, 10),
+        std::make_tuple("week, m_9", 1145836800000000000LL, 10),
+        std::make_tuple("week_sunday, m_9", 1145750400000000000LL, 10),
+        std::make_tuple("week_saturday, m_9", 1145664000000000000LL, 10),
+        std::make_tuple("nanosecond, m_9", 1146023344607435125LL, 10),
+        std::make_tuple("microsecond, m_9", 1146023344607435000LL, 10),
+        std::make_tuple("millisecond, m_9", 1146023344607000000LL, 10)};
     for (auto& query : date_trunc_queries) {
       const auto one_row = run_multiple_agg(
           "SELECT date_trunc(" + std::get<0>(query) +
@@ -4878,10 +4884,10 @@
           *one_row, std::get<1>(query), std::get<2>(query));
     }
     // Compressed DATE - limits test
-    ASSERT_EQ(4708022400L,
+    ASSERT_EQ(4708022400LL,
               v<int64_t>(run_simple_agg(
                   "select CAST('2119-03-12' AS DATE) FROM test limit 1;", dt)));
-    ASSERT_EQ(7998912000L,
+    ASSERT_EQ(7998912000LL,
               v<int64_t>(run_simple_agg("select CAST(CAST('2223-06-24 23:13:57' AS "
                                         "TIMESTAMP) AS DATE) FROM test limit 1;",
                                         dt)));
@@ -4973,10 +4979,10 @@
                                         "as DATE)) from test limit 1;",
                                         dt)));
     // Compressed DATE - limits test
-    ASSERT_EQ(4708022400L,
+    ASSERT_EQ(4708022400LL,
               v<int64_t>(run_simple_agg(
                   "select CAST('2119-03-12' AS DATE) FROM test limit 1;", dt)));
-    ASSERT_EQ(7998912000L,
+    ASSERT_EQ(7998912000LL,
               v<int64_t>(run_simple_agg("select CAST(CAST('2223-06-24 23:13:57' AS "
                                         "TIMESTAMP) AS DATE) FROM test limit 1;",
                                         dt)));
@@ -5091,115 +5097,115 @@
   for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
     SKIP_NO_GPU();
 
-    ASSERT_EQ(1325376000L,
+    ASSERT_EQ(1325376000LL,
               v<int64_t>(run_simple_agg(
                   R"(SELECT DATE_TRUNC(year, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
                   dt)));
     ASSERT_EQ(
-        1335830400L,
+        1335830400LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(month, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        1336435200L,
+        1336435200LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(day, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)", dt)));
-    ASSERT_EQ(1336507200L,
+    ASSERT_EQ(1336507200LL,
               v<int64_t>(run_simple_agg(
                   R"(SELECT DATE_TRUNC(hour, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
                   dt)));
     ASSERT_EQ(
-        1336508112L,
+        1336508112LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(second, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        978307200L,
+        978307200LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(millennium, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        978307200L,
+        978307200LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(century, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        1262304000L,
+        1262304000LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(decade, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        1336508112L,
+        1336508112LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(millisecond, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        1336508112L,
+        1336508112LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(microsecond, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
-    ASSERT_EQ(1336348800L,
+    ASSERT_EQ(1336348800LL,
               v<int64_t>(run_simple_agg(
                   R"(SELECT DATE_TRUNC(week, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
                   dt)));
     ASSERT_EQ(
-        1336348800L - 24 * 3600,
+        1336348800LL - 24 * 3600,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(week_sunday, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        1336348800L - 48 * 3600,
+        1336348800LL - 48 * 3600,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(week_saturday, CAST('2012-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
-    ASSERT_EQ(-2114380800L,
+    ASSERT_EQ(-2114380800LL,
               v<int64_t>(run_simple_agg(
                   R"(SELECT DATE_TRUNC(year, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
                   dt)));
     ASSERT_EQ(
-        -2104012800L,
+        -2104012800LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(month, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        -2103408000L,
+        -2103408000LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(day, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)", dt)));
-    ASSERT_EQ(-2103336000L,
+    ASSERT_EQ(-2103336000LL,
               v<int64_t>(run_simple_agg(
                   R"(SELECT DATE_TRUNC(hour, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
                   dt)));
     ASSERT_EQ(
-        -2103335088L,
+        -2103335088LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(second, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        -30578688000L,
+        -30578688000LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(millennium, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        -2177452800L,
+        -2177452800LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(century, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        -2208988800L,
+        -2208988800LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(decade, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        -2103335088L,
+        -2103335088LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(millisecond, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        -2103335088L,
+        -2103335088LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(microsecond, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
-    ASSERT_EQ(-2103753600L,
+    ASSERT_EQ(-2103753600LL,
               v<int64_t>(run_simple_agg(
                   R"(SELECT DATE_TRUNC(week, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
                   dt)));
@@ -5214,12 +5220,12 @@
             R"(SELECT DATE_TRUNC(week_saturday, CAST('1903-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(decade, CAST('1972-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
     ASSERT_EQ(
-        946684800L,
+        946684800LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(decade, CAST('2000-05-08 20:15:12' AS TIMESTAMP));)",
             dt)));
@@ -5235,27 +5241,27 @@
             R"(SELECT EXTRACT(quarter FROM CAST('2008-03-21 12:12:12' AS timestamp));)",
             dt)));
     ASSERT_EQ(
-        1199145600L,
+        1199145600LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(quarter, CAST('2008-03-21 12:12:12' AS timestamp));)",
             dt)));
     ASSERT_EQ(
-        1230768000L,
+        1230768000LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(quarter, CAST('2009-03-21 12:12:12' AS timestamp));)",
             dt)));
     ASSERT_EQ(
-        1254355200L,
+        1254355200LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(quarter, CAST('2009-11-21 12:12:12' AS timestamp));)",
             dt)));
     ASSERT_EQ(
-        946684800L,
+        946684800LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(quarter, CAST('2000-03-21 12:12:12' AS timestamp));)",
             dt)));
     ASSERT_EQ(
-        -2208988800L,
+        -2208988800LL,
         v<int64_t>(run_simple_agg(
             R"(SELECT DATE_TRUNC(quarter, CAST('1900-03-21 12:12:12' AS timestamp));)",
             dt)));
@@ -6161,16 +6167,16 @@
   for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
     SKIP_NO_GPU();
     ASSERT_EQ(
-        60 * 60 * 1000L,
+        60 * 60 * 1000LL,
         v<int64_t>(run_simple_agg("SELECT INTERVAL '1' HOUR FROM test LIMIT 1;", dt)));
     ASSERT_EQ(
-        24 * 60 * 60 * 1000L,
+        24 * 60 * 60 * 1000LL,
         v<int64_t>(run_simple_agg("SELECT INTERVAL '1' DAY FROM test LIMIT 1;", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (INTERVAL '1' YEAR)/12 FROM test order by o LIMIT 1;", dt)));
     ASSERT_EQ(
-        1L,
+        1LL,
         v<int64_t>(run_simple_agg(
             "SELECT INTERVAL '1' MONTH FROM test group by m order by m LIMIT 1;", dt)));
     ASSERT_EQ(
@@ -6185,65 +6191,65 @@
     ASSERT_EQ(static_cast<int64_t>(2 * g_num_rows),
               v<int64_t>(run_simple_agg(
                   "SELECT COUNT(*) FROM test GROUP BY INTERVAL '1' DAY;", dt)));
-    ASSERT_EQ(3 * 60 * 60 * 1000L,
+    ASSERT_EQ(3 * 60 * 60 * 1000LL,
               v<int64_t>(
                   run_simple_agg("SELECT 3 * INTERVAL '1' HOUR FROM test LIMIT 1;", dt)));
-    ASSERT_EQ(3 * 60 * 60 * 1000L,
+    ASSERT_EQ(3 * 60 * 60 * 1000LL,
               v<int64_t>(
                   run_simple_agg("SELECT INTERVAL '1' HOUR * 3 FROM test LIMIT 1;", dt)));
-    ASSERT_EQ(7L,
+    ASSERT_EQ(7LL,
               v<int64_t>(run_simple_agg(
                   "SELECT INTERVAL '1' MONTH * x FROM test WHERE x <> 8 LIMIT 1;", dt)));
-    ASSERT_EQ(7L,
+    ASSERT_EQ(7LL,
               v<int64_t>(run_simple_agg(
                   "SELECT x * INTERVAL '1' MONTH FROM test WHERE x <> 8 LIMIT 1;", dt)));
-    ASSERT_EQ(42L,
+    ASSERT_EQ(42LL,
               v<int64_t>(run_simple_agg(
                   "SELECT INTERVAL '1' MONTH * y FROM test WHERE y <> 43 LIMIT 1;", dt)));
-    ASSERT_EQ(42L,
+    ASSERT_EQ(42LL,
               v<int64_t>(run_simple_agg(
                   "SELECT y * INTERVAL '1' MONTH FROM test WHERE y <> 43 LIMIT 1;", dt)));
     ASSERT_EQ(
-        1002L,
+        1002LL,
         v<int64_t>(run_simple_agg(
             "SELECT INTERVAL '1' MONTH * t FROM test WHERE t <> 1001 LIMIT 1;", dt)));
     ASSERT_EQ(
-        1002L,
+        1002LL,
         v<int64_t>(run_simple_agg(
             "SELECT t * INTERVAL '1' MONTH FROM test WHERE t <> 1001 LIMIT 1;", dt)));
     ASSERT_EQ(
-        3L,
+        3LL,
         v<int64_t>(run_simple_agg(
             "SELECT INTERVAL '1' MONTH + INTERVAL '2' MONTH FROM test LIMIT 1;", dt)));
     ASSERT_EQ(
-        1388534400L,
+        1388534400LL,
         v<int64_t>(run_simple_agg("SELECT CAST(m AS date) + CAST(TRUNCATE(-1 * "
                                   "(EXTRACT(DOY FROM m) - 1), 0) AS INTEGER) * INTERVAL "
                                   "'1' DAY AS g FROM test GROUP BY g;",
                                   dt)));
     ASSERT_EQ(
-        1417392000L,
+        1417392000LL,
         v<int64_t>(run_simple_agg("SELECT CAST(m AS date) + CAST(TRUNCATE(-1 * "
                                   "(EXTRACT(DAY FROM m) - 1), 0) AS INTEGER) * INTERVAL "
                                   "'1' DAY AS g FROM test GROUP BY g;",
                                   dt)));
-    ASSERT_EQ(1418508000L,
+    ASSERT_EQ(1418508000LL,
               v<int64_t>(run_simple_agg("SELECT CAST(m AS date) + EXTRACT(HOUR FROM m) * "
                                         "INTERVAL '1' HOUR AS g FROM test GROUP BY g;",
                                         dt)));
     ASSERT_EQ(
-        1388534400L,
+        1388534400LL,
         v<int64_t>(run_simple_agg("SELECT TIMESTAMPADD(SQL_TSI_DAY, CAST(TRUNCATE(-1 * "
                                   "(EXTRACT(DOY from m) - 1), 0) AS INTEGER), "
                                   "CAST(m AS DATE)) AS g FROM test GROUP BY g;",
                                   dt)));
     ASSERT_EQ(
-        1417392000L,
+        1417392000LL,
         v<int64_t>(run_simple_agg("SELECT TIMESTAMPADD(SQL_TSI_DAY, CAST(TRUNCATE(-1 * "
                                   "(EXTRACT(DAY from m) - 1), 0) AS INTEGER), "
                                   "CAST(m AS DATE)) AS g FROM test GROUP BY g;",
                                   dt)));
-    ASSERT_EQ(1418508000L,
+    ASSERT_EQ(1418508000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(SQL_TSI_HOUR, EXTRACT(HOUR from "
                   "m), CAST(m AS DATE)) AS g FROM test GROUP BY g order by g;",
@@ -6490,6 +6496,21 @@
     EXPECT_ANY_THROW(run_simple_agg("SELECT * FROM (VALUES(1, 'test'));", dt));
 
     EXPECT_ANY_THROW(run_simple_agg("SELECT (1,2);", dt));
+
+    SKIP_ON_AGGREGATOR({
+      const auto query_explain_result =
+          QR::get()->runSelectQuery("SELECT 1+2;",
+                                    dt,
+                                    /*hoist_literals=*/true,
+                                    /*allow_loop_joins=*/false,
+                                    /*just_explain=*/true);
+      const auto explain_result = query_explain_result->getRows();
+      EXPECT_EQ(size_t(1), explain_result->rowCount());
+      const auto crt_row = explain_result->getNextRow(true, true);
+      EXPECT_EQ(size_t(1), crt_row.size());
+      const auto explain_str = boost::get<std::string>(v<NullableString>(crt_row[0]));
+      EXPECT_TRUE(explain_str.find("IR for the ") == 0);
+    });
   }
 }
 
@@ -8361,6 +8382,127 @@
   }
 }
 
+TEST(Select, Joins_Fixed_Size_Array_Multi_Frag) {
+  run_ddl_statement("DROP TABLE IF EXISTS mf_f_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_d_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_i_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_bi_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_ti_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_si_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_t_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS sharded_mf_i_arr");
+
+  run_ddl_statement(
+      "CREATE TABLE mf_f_arr (c2 FLOAT[2], c3 FLOAT[3], c4 FLOAT[4]) WITH (fragment_size "
+      "= 2);");
+  run_ddl_statement(
+      "CREATE TABLE mf_d_arr (c2 DOUBLE[2], c3 DOUBLE[3], c4 DOUBLE[4]) WITH "
+      "(fragment_size = 2);");
+  run_ddl_statement(
+      "CREATE TABLE mf_i_arr (c2 INT[2], c3 INT[3], c4 INT[4]) WITH (fragment_size = "
+      "2);");
+  run_ddl_statement(
+      "CREATE TABLE mf_bi_arr (c2 BIGINT[2], c3 BIGINT[3], c4 BIGINT[4]) WITH "
+      "(fragment_size = 2);");
+  run_ddl_statement(
+      "CREATE TABLE mf_ti_arr (c2 TINYINT[2], c3 TINYINT[3], c4 TINYINT[4]) WITH "
+      "(fragment_size = 2);");
+  run_ddl_statement(
+      "CREATE TABLE mf_si_arr (c2 SMALLINT[2], c3 SMALLINT[3], c4 SMALLINT[4]) WITH "
+      "(fragment_size = 2);");
+  run_ddl_statement(
+      "CREATE TABLE mf_t_arr (t2 TEXT[2] ENCODING DICT(32)) with (fragment_size = 2);");
+  run_ddl_statement(
+      "CREATE TABLE sharded_mf_i_arr (x INT, c2 INT[2], c3 INT[3], c4 INT[4], SHARD KEY "
+      "(x)) WITH (shard_count = 2, fragment_size = 1);");
+
+  auto insert_values = [&](const std::string& table_name) {
+    for (int i = 1; i < 6; i++) {
+      std::ostringstream oss;
+      oss << "INSERT INTO " << table_name << " VALUES (";
+      if (table_name.compare("sharded_mf_i_arr") == 0) {
+        oss << i << ", ";
+      }
+      oss << "{" << i << ", " << i + 1 << "}, ";
+      oss << "{" << i << ", " << i + 1 << ", " << i + 2 << "}, ";
+      oss << "{" << i << ", " << i + 1 << ", " << i + 2 << ", " << i + 3 << "});";
+      run_multiple_agg(oss.str(), ExecutorDeviceType::CPU);
+    }
+  };
+
+  insert_values("mf_f_arr");
+  insert_values("mf_d_arr");
+  insert_values("mf_i_arr");
+  insert_values("mf_bi_arr");
+  insert_values("mf_ti_arr");
+  insert_values("mf_si_arr");
+  insert_values("sharded_mf_i_arr");
+
+  run_multiple_agg("INSERT INTO mf_t_arr VALUES ({'1', '22'});", ExecutorDeviceType::CPU);
+  run_multiple_agg("INSERT INTO mf_t_arr VALUES ({'2', '33'});", ExecutorDeviceType::CPU);
+  run_multiple_agg("INSERT INTO mf_t_arr VALUES ({'3', '44'});", ExecutorDeviceType::CPU);
+  run_multiple_agg("INSERT INTO mf_t_arr VALUES ({'4', '55'});", ExecutorDeviceType::CPU);
+  run_multiple_agg("INSERT INTO mf_t_arr VALUES ({'5', '66'});", ExecutorDeviceType::CPU);
+
+  auto test_query = [&](const std::string& table_name, ExecutorDeviceType dt) {
+    std::ostringstream oss;
+    oss << "SELECT COUNT(1) FROM " << table_name << " t1, " << table_name << " t2 WHERE ";
+    auto common_part = oss.str();
+    auto q1{common_part + "t1.c2[1] = t2.c2[1];"};
+    ASSERT_EQ(int64_t(5), v<int64_t>(run_simple_agg(q1, dt)));
+
+    auto q2{common_part + "t1.c3[1] = t2.c3[1];"};
+    ASSERT_EQ(int64_t(5), v<int64_t>(run_simple_agg(q2, dt)));
+
+    auto q3{common_part + "t1.c4[1] = t2.c4[1];"};
+    ASSERT_EQ(int64_t(5), v<int64_t>(run_simple_agg(q3, dt)));
+
+    auto q4{common_part + "t1.c2[2] = t2.c2[2] and t1.c2[1] = t1.c2[1];"};
+    ASSERT_EQ(int64_t(5), v<int64_t>(run_simple_agg(q4, dt)));
+
+    auto q5{common_part + "t1.c3[2] = t2.c3[2] and t1.c3[1] = t1.c3[1];"};
+    ASSERT_EQ(int64_t(5), v<int64_t>(run_simple_agg(q5, dt)));
+
+    auto q6{common_part + "t1.c4[2] = t2.c4[2] and t1.c4[1] = t1.c4[1];"};
+    ASSERT_EQ(int64_t(5), v<int64_t>(run_simple_agg(q6, dt)));
+  };
+
+  // If GPU exists, check whether we get an exception related to varlen columnarization
+  // when query is executed on GPU
+  if (!skip_tests(ExecutorDeviceType::GPU)) {
+    EXPECT_THROW(
+        run_simple_agg(
+            R"(SELECT COUNT(1) FROM mf_t_arr r1, mf_t_arr r2 WHERE r1.t2[1] = r2.t2[1];)",
+            ExecutorDeviceType::GPU),
+        std::runtime_error);
+  }
+
+  // skip to test GPU device until we fix the #5425 issue
+  for (auto dt : {ExecutorDeviceType::CPU}) {
+    test_query("mf_f_arr", dt);
+    test_query("mf_d_arr", dt);
+    test_query("mf_i_arr", dt);
+    test_query("mf_bi_arr", dt);
+    test_query("mf_ti_arr", dt);
+    test_query("mf_si_arr", dt);
+    test_query("sharded_mf_i_arr", dt);
+    ASSERT_EQ(
+        int64_t(5),
+        v<int64_t>(run_simple_agg(
+            "SELECT COUNT(1) FROM mf_t_arr r1, mf_t_arr r2 WHERE r1.t2[1] = r2.t2[1]",
+            dt)));
+  }
+
+  run_ddl_statement("DROP TABLE IF EXISTS mf_f_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_d_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_i_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_bi_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_ti_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_si_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS sharded_mf_i_arr");
+  run_ddl_statement("DROP TABLE IF EXISTS mf_t_arr");
+}
+
 TEST(Select, Joins_ShardedEmptyTable) {
   for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
     SKIP_NO_GPU();
@@ -11069,7 +11211,7 @@
   for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
     SKIP_NO_GPU();
     EXPECT_EQ(
-        999999997L,
+        999999997LL,
         datediff(
             "nanosecond", "1950-01-02 12:34:56.000000003", "1950-01-02 12:34:57", dt));
     EXPECT_EQ(
@@ -11081,7 +11223,7 @@
         datediff(
             "nanosecond", "1950-01-02 12:34:56.000000003", "1950-01-02 12:34:55", dt));
     EXPECT_EQ(
-        999999997L,
+        999999997LL,
         datediff(
             "nanosecond", "2000-01-02 12:34:56.000000003", "2000-01-02 12:34:57", dt));
     EXPECT_EQ(
@@ -11221,23 +11363,23 @@
     EXPECT_EQ(2556698 * 24,
               datediff("hour", "1900-02-15 12:00:00.003", "8900-02-15 12:00:00.003", dt));
     EXPECT_EQ(
-        2556698 * 24 * 60L - 1,
+        2556698 * 24 * 60LL - 1,
         datediff("minute", "1900-02-15 12:00:00.003", "8900-02-15 12:00:00.002", dt));
     EXPECT_EQ(
-        2556698 * 24 * 60L,
+        2556698 * 24 * 60LL,
         datediff("minute", "1900-02-15 12:00:00.003", "8900-02-15 12:00:00.003", dt));
     EXPECT_EQ(
-        2556698 * 24 * 60L * 60 - 1,
+        2556698 * 24 * 60LL * 60 - 1,
         datediff("second", "1900-02-15 12:00:00.003", "8900-02-15 12:00:00.002", dt));
     EXPECT_EQ(
-        2556698 * 24 * 60L * 60,
+        2556698 * 24 * 60LL * 60,
         datediff("second", "1900-02-15 12:00:00.003", "8900-02-15 12:00:00.003", dt));
     EXPECT_EQ(
-        2556698 * 24 * 60L * 60 * 1000 - 1,
+        2556698 * 24 * 60LL * 60 * 1000 - 1,
         datediff(
             "millisecond", "1900-02-15 12:00:00.003", "8900-02-15 12:00:00.002", dt));
     EXPECT_EQ(
-        2556698 * 24 * 60L * 60 * 1000,
+        2556698 * 24 * 60LL * 60 * 1000,
         datediff(
             "millisecond", "1900-02-15 12:00:00.003", "8900-02-15 12:00:00.003", dt));
   }
@@ -11247,22 +11389,22 @@
   for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
     SKIP_NO_GPU();
     /* ---DATE TRUNCATE--- */
-    ASSERT_EQ(978307200000L,
+    ASSERT_EQ(978307200000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(millennium, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(978307200000L,
+    ASSERT_EQ(978307200000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(century, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1262304000000L,
+    ASSERT_EQ(1262304000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(decade, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1388534400000L,
+    ASSERT_EQ(1388534400000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(year, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1417392000000L,
+    ASSERT_EQ(1417392000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(month, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1417996800000L,
+    ASSERT_EQ(1417996800000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(week, m_3) FROM test limit 1;", dt)));
     ASSERT_EQ(1417910400000L,
@@ -11272,42 +11414,42 @@
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(week_saturday, m_3) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        1418428800000L,
+        1418428800000LL,
         v<int64_t>(run_simple_agg("SELECT DATE_TRUNC(day, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418508000000L,
+    ASSERT_EQ(1418508000000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(hour, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509380000L,
+    ASSERT_EQ(1418509380000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(minute, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395000L,
+    ASSERT_EQ(1418509395000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(second, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(millisecond, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(microsecond, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(nanosecond, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(-30578688000000000L,
+    ASSERT_EQ(-30578688000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(millennium, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(-2177452800000000L,
+    ASSERT_EQ(-2177452800000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(century, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(631152000000000L,
+    ASSERT_EQ(631152000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(decade, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(915148800000000L,
+    ASSERT_EQ(915148800000000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(year, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(930787200000000L,
+    ASSERT_EQ(930787200000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(month, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931132800000000L,
+    ASSERT_EQ(931132800000000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(week, m_6) FROM test limit 1;", dt)));
     ASSERT_EQ(931651200000000L,
@@ -11317,42 +11459,42 @@
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(week_saturday, m_6) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        931651200000000L,
+        931651200000000LL,
         v<int64_t>(run_simple_agg("SELECT DATE_TRUNC(day, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701600000000L,
+    ASSERT_EQ(931701600000000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(hour, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701720000000L,
+    ASSERT_EQ(931701720000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(minute, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773000000L,
+    ASSERT_EQ(931701773000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(second, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874000L,
+    ASSERT_EQ(931701773874000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(millisecond, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874533L,
+    ASSERT_EQ(931701773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(microsecond, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874533L,
+    ASSERT_EQ(931701773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(nanosecond, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(978307200000000000L,
+    ASSERT_EQ(978307200000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(millennium, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(978307200000000000L,
+    ASSERT_EQ(978307200000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(century, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(946684800000000000L,
+    ASSERT_EQ(946684800000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(decade, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1136073600000000000L,
+    ASSERT_EQ(1136073600000000000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(year, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1143849600000000000L,
+    ASSERT_EQ(1143849600000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(month, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1145836800000000000L,
+    ASSERT_EQ(1145836800000000000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(week, m_9) FROM test limit 1;", dt)));
     ASSERT_EQ(1145750400000000000L,
@@ -11362,418 +11504,418 @@
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(week_saturday, m_9) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        1146009600000000000L,
+        1146009600000000000LL,
         v<int64_t>(run_simple_agg("SELECT DATE_TRUNC(day, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146020400000000000L,
+    ASSERT_EQ(1146020400000000000LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATE_TRUNC(hour, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023340000000000L,
+    ASSERT_EQ(1146023340000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(minute, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344000000000L,
+    ASSERT_EQ(1146023344000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(second, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607000000L,
+    ASSERT_EQ(1146023344607000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(millisecond, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607435000L,
+    ASSERT_EQ(1146023344607435000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(microsecond, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607435125L,
+    ASSERT_EQ(1146023344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATE_TRUNC(nanosecond, m_9) FROM test limit 1;", dt)));
     /* ---Extract --- */
-    ASSERT_EQ(1146023344L,
+    ASSERT_EQ(1146023344LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(epoch from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146009600L,
+    ASSERT_EQ(1146009600LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(dateepoch from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4607435125L,
+    ASSERT_EQ(4607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(nanosecond from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4607435L,
+    ASSERT_EQ(4607435LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(microsecond from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4607L,
+    ASSERT_EQ(4607LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(millisecond from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(second from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(49L,
+    ASSERT_EQ(49LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(minute from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(hour from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(dow from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(isodow from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(17L,
+    ASSERT_EQ(17LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(17L,
+    ASSERT_EQ(17LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week_sunday from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(17L,
+    ASSERT_EQ(17LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week_saturday from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(26L,
+    ASSERT_EQ(26LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(day from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(116L,
+    ASSERT_EQ(116LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(doy from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(month from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(quarter from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(quarterday from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(2006L,
+    ASSERT_EQ(2006LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(year from m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773L,
+    ASSERT_EQ(931701773LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(epoch from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931651200L,
+    ASSERT_EQ(931651200LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(dateepoch from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53874533000L,
+    ASSERT_EQ(53874533000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(nanosecond from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53874533L,
+    ASSERT_EQ(53874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(microsecond from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53874L,
+    ASSERT_EQ(53874LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(millisecond from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53L,
+    ASSERT_EQ(53LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(second from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(minute from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(14L,
+    ASSERT_EQ(14LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(hour from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(dow from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(7L,
+    ASSERT_EQ(7LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(isodow from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(27L,
+    ASSERT_EQ(27LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(28L,
+    ASSERT_EQ(28LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week_sunday from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(28L,
+    ASSERT_EQ(28LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week_saturday from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(day from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(192L,
+    ASSERT_EQ(192LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(doy from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(7L,
+    ASSERT_EQ(7LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(month from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(quarter from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(quarterday from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(1999L,
+    ASSERT_EQ(1999LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(year from m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395L,
+    ASSERT_EQ(1418509395LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(epoch from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418428800L,
+    ASSERT_EQ(1418428800LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(dateepoch from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15323000000L,
+    ASSERT_EQ(15323000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(nanosecond from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15323000L,
+    ASSERT_EQ(15323000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(microsecond from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15323L,
+    ASSERT_EQ(15323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(millisecond from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15L,
+    ASSERT_EQ(15LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(second from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(23L,
+    ASSERT_EQ(23LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(minute from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(22L,
+    ASSERT_EQ(22LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(hour from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(6L,
+    ASSERT_EQ(6LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(dow from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(6L,
+    ASSERT_EQ(6LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(isodow from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week_sunday from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(week_saturday from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(13L,
+    ASSERT_EQ(13LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(day from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(347L,
+    ASSERT_EQ(347LL,
               v<int64_t>(
                   run_simple_agg("SELECT EXTRACT(doy from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(month from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(quarter from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(quarterday from m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(2014L,
+    ASSERT_EQ(2014LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(year from m_3) FROM test limit 1;", dt)));
 
     /* ---DATE PART --- */
-    ASSERT_EQ(2014L,
+    ASSERT_EQ(2014LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATEPART('year', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('quarter', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('month', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(347L,
+    ASSERT_EQ(347LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('dayofyear', m_3) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        13L,
+        13LL,
         v<int64_t>(run_simple_agg("SELECT DATEPART('day', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(22L,
+    ASSERT_EQ(22LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATEPART('hour', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(23L,
+    ASSERT_EQ(23LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('minute', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15L,
+    ASSERT_EQ(15LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('second', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15323L,
+    ASSERT_EQ(15323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('millisecond', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15323000L,
+    ASSERT_EQ(15323000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('microsecond', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(15323000000L,
+    ASSERT_EQ(15323000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('nanosecond', m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1999L,
+    ASSERT_EQ(1999LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATEPART('year', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('quarter', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(7L,
+    ASSERT_EQ(7LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('month', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(192L,
+    ASSERT_EQ(192LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('dayofyear', m_6) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        11L,
+        11LL,
         v<int64_t>(run_simple_agg("SELECT DATEPART('day', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(14L,
+    ASSERT_EQ(14LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATEPART('hour', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('minute', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53L,
+    ASSERT_EQ(53LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('second', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53874L,
+    ASSERT_EQ(53874LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('millisecond', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53874533L,
+    ASSERT_EQ(53874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('microsecond', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(53874533000L,
+    ASSERT_EQ(53874533000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('nanosecond', m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(2006L,
+    ASSERT_EQ(2006LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATEPART('year', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('quarter', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('month', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(116L,
+    ASSERT_EQ(116LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('dayofyear', m_9) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        26L,
+        26LL,
         v<int64_t>(run_simple_agg("SELECT DATEPART('day', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATEPART('hour', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(49L,
+    ASSERT_EQ(49LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('minute', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('second', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4607L,
+    ASSERT_EQ(4607LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('millisecond', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4607435L,
+    ASSERT_EQ(4607435LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('microsecond', m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(4607435125L,
+    ASSERT_EQ(4607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEPART('nanosecond', m_9) FROM test limit 1;", dt)));
     EXPECT_ANY_THROW(run_simple_agg("SELECT DATEPART(NULL, m_9) FROM test limit 1;", dt));
     /* ---DATE ADD --- */
-    ASSERT_EQ(1177559344607435125L,
+    ASSERT_EQ(1177559344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('year',1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1153885744607435125L,
+    ASSERT_EQ(1153885744607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('quarter', 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1148615344607435125L,
+    ASSERT_EQ(1148615344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('month', 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146109744607435125L,
+    ASSERT_EQ(1146109744607435125LL,
               v<int64_t>(
                   run_simple_agg("SELECT DATEADD('day',1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146026944607435125L,
+    ASSERT_EQ(1146026944607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('hour', 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023404607435125L,
+    ASSERT_EQ(1146023404607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('minute', 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023403607435125L,
+    ASSERT_EQ(1146023403607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('second', 59, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344932435125L,
+    ASSERT_EQ(1146023344932435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('millisecond', 325 , m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607960125L,
+    ASSERT_EQ(1146023344607960125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('microsecond', 525, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607436000L,
+    ASSERT_EQ(1146023344607436000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('nanosecond', 875, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1026396173874533L,
+    ASSERT_EQ(1026396173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('year',3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(955461773874533L,
+    ASSERT_EQ(955461773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('quarter', 3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(947599373874533L,
+    ASSERT_EQ(947599373874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('month', 6, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(932824973874533L,
+    ASSERT_EQ(932824973874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('day',13, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931734173874533L,
+    ASSERT_EQ(931734173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('hour', 9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931704053874533L,
+    ASSERT_EQ(931704053874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('minute', 38, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701783874533L,
+    ASSERT_EQ(931701783874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('second', 10, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773885533L,
+    ASSERT_EQ(931701773885533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('millisecond', 11 , m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874678L,
+    ASSERT_EQ(931701773874678LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('microsecond', 145, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874533L,
+    ASSERT_EQ(931701773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('nanosecond', 875, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(1734128595323L,
+    ASSERT_EQ(1734128595323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('year',10, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1450045395323L,
+    ASSERT_EQ(1450045395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('quarter', 4, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1423866195323L,
+    ASSERT_EQ(1423866195323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('month', 2, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1419805395323L,
+    ASSERT_EQ(1419805395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('day',15, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418516595323L,
+    ASSERT_EQ(1418516595323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('hour', 2, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418510055323L,
+    ASSERT_EQ(1418510055323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('minute', 11, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509415323L,
+    ASSERT_EQ(1418509415323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('second', 20, m_3) FROM test limit 1;", dt)));
     ASSERT_EQ(1418509395553,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('millisecond', 230 , m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('microsecond', 145, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('nanosecond', 875, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('nanosecond', 145000, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395553L,
+    ASSERT_EQ(1418509395553LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('microsecond', 230000, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509396553L,
+    ASSERT_EQ(1418509396553LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('millisecond', 1230, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701774885533L,
+    ASSERT_EQ(931701774885533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('millisecond', 1011 , m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701774874678L,
+    ASSERT_EQ(931701774874678LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('microsecond', 1000145, m_6) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        931701774874533L,
+        931701774874533LL,
         v<int64_t>(run_simple_agg(
             "SELECT DATEADD('nanosecond', 1000000875, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023345932435125L,
+    ASSERT_EQ(1146023345932435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('millisecond', 1325 , m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023345607960125L,
+    ASSERT_EQ(1146023345607960125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEADD('microsecond', 1000525, m_9) FROM test limit 1;", dt)));
     ASSERT_EQ(
-        1146023345607436000L,
+        1146023345607436000LL,
         v<int64_t>(run_simple_agg(
             "SELECT DATEADD('nanosecond', 1000000875, m_9) FROM test limit 1;", dt)));
     EXPECT_ANY_THROW(
@@ -11781,112 +11923,112 @@
     EXPECT_ANY_THROW(run_simple_agg(
         "SELECT DATEADD('microsecond', NULL, m_9) FROM test LIMIT 1;", dt));
     /* ---DATE DIFF --- */
-    ASSERT_EQ(1146023344607435125L - 931701773874533000L,
+    ASSERT_EQ(1146023344607435125LL - 931701773874533000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_6, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874533000L - 1146023344607435125L,
+    ASSERT_EQ(931701773874533000LL - 1146023344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607435125L - 1418509395323000000L,
+    ASSERT_EQ(1146023344607435125LL - 1418509395323000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_3, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323000000L - 1146023344607435125L,
+    ASSERT_EQ(1418509395323000000LL - 1146023344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_9, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607435125L - 1418509395000000000L,
+    ASSERT_EQ(1146023344607435125LL - 1418509395000000000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395000000000L - 1146023344607435125L,
+    ASSERT_EQ(1418509395000000000LL - 1146023344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_9, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 931701773874533000L) / 1000L,
+    ASSERT_EQ((1146023344607435125LL - 931701773874533000LL) / 1000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_6, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533000L - 1146023344607435125L) / 1000L,
+    ASSERT_EQ((931701773874533000LL - 1146023344607435125LL) / 1000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 1418509395323000000L) / 1000L,
+    ASSERT_EQ((1146023344607435125LL - 1418509395323000000LL) / 1000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_3, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323000000L - 1146023344607435125L) / 1000L,
+    ASSERT_EQ((1418509395323000000LL - 1146023344607435125LL) / 1000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_9, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 1418509395000000000L) / 1000L,
+    ASSERT_EQ((1146023344607435125LL - 1418509395000000000LL) / 1000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000000000L - 1146023344607435125L) / 1000L,
+    ASSERT_EQ((1418509395000000000LL - 1146023344607435125LL) / 1000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_9, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 931701773874533000L) / (1000L * 1000L),
+    ASSERT_EQ((1146023344607435125LL - 931701773874533000LL) / (1000LL * 1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_6, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533000L - 1146023344607435125L) / (1000L * 1000L),
+    ASSERT_EQ((931701773874533000LL - 1146023344607435125LL) / (1000LL * 1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 1418509395323000000L) / (1000L * 1000L),
+    ASSERT_EQ((1146023344607435125LL - 1418509395323000000LL) / (1000LL * 1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_3, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323000000L - 1146023344607435125L) / (1000L * 1000L),
+    ASSERT_EQ((1418509395323000000LL - 1146023344607435125LL) / (1000LL * 1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_9, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 1418509395000000000L) / (1000L * 1000L),
+    ASSERT_EQ((1146023344607435125LL - 1418509395000000000LL) / (1000LL * 1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000000000L - 1146023344607435125L) / (1000L * 1000L),
+    ASSERT_EQ((1418509395000000000LL - 1146023344607435125LL) / (1000LL * 1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_9, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 931701773874533L * 1000) / 1000000000,
+    ASSERT_EQ((1146023344607435125LL - 931701773874533LL * 1000) / 1000000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_6, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L * 1000 - 1146023344607435125L) / 1000000000,
+    ASSERT_EQ((931701773874533LL * 1000 - 1146023344607435125LL) / 1000000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 1418509395323L * 1000000) / 1000000000,
+    ASSERT_EQ((1146023344607435125LL - 1418509395323LL * 1000000) / 1000000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_3, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L * 1000000 - 1146023344607435125L) / 1000000000,
+    ASSERT_EQ((1418509395323LL * 1000000 - 1146023344607435125LL) / 1000000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_9, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1146023344607435125L - 1418509395L * 1000000000) / 1000000000,
+    ASSERT_EQ((1146023344607435125LL - 1418509395LL * 1000000000) / 1000000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395L * 1000000000 - 1146023344607435125L) / 1000000000,
+    ASSERT_EQ((1418509395LL * 1000000000 - 1146023344607435125LL) / 1000000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_9, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((3572026L),
+    ASSERT_EQ((3572026LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_6, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((-3572026L),
+    ASSERT_EQ((-3572026LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(-4541434L,
+    ASSERT_EQ(-4541434LL,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_3, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((4541434L),
+    ASSERT_EQ((4541434LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_9, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((-4541434L),
+    ASSERT_EQ((-4541434LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((4541434L),
+    ASSERT_EQ((4541434LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_9, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((59533L),
+    ASSERT_EQ((59533LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_6, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((-59533L),
+    ASSERT_EQ((-59533LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((-75690L),
+    ASSERT_EQ((-75690LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_3, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((75690L),
+    ASSERT_EQ((75690LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_9, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((-75690L),
+    ASSERT_EQ((-75690LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ((75690L),
+    ASSERT_EQ((75690LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_9, m) FROM test limit 1;", dt)));
     ASSERT_EQ((2480),
@@ -11943,88 +12085,90 @@
     ASSERT_EQ((8),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('year', m_9, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395323000L) * 1000,
+    ASSERT_EQ((931701773874533LL - 1418509395323000LL) * 1000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323000L - 931701773874533L) * 1000,
+    ASSERT_EQ((1418509395323000LL - 931701773874533LL) * 1000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_6, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395000000L) * 1000,
+    ASSERT_EQ((931701773874533LL - 1418509395000000LL) * 1000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000000L - 931701773874533L) * 1000,
+    ASSERT_EQ((1418509395000000LL - 931701773874533LL) * 1000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_6, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395323000L),
+    ASSERT_EQ((931701773874533LL - 1418509395323000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323000L - 931701773874533L),
+    ASSERT_EQ((1418509395323000LL - 931701773874533LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_6, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395000000L),
+    ASSERT_EQ((931701773874533LL - 1418509395000000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000000L - 931701773874533L),
+    ASSERT_EQ((1418509395000000LL - 931701773874533LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_6, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395323000L) / (1000L),
+    ASSERT_EQ((931701773874533LL - 1418509395323000LL) / (1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323000L - 931701773874533L) / (1000L),
+    ASSERT_EQ((1418509395323000LL - 931701773874533LL) / (1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_6, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395000000L) / (1000L),
+    ASSERT_EQ((931701773874533LL - 1418509395000000LL) / (1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000000L - 931701773874533L) / (1000L),
+    ASSERT_EQ((1418509395000000LL - 931701773874533LL) / (1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_6, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395323L * 1000) / 1000000,
+    ASSERT_EQ((931701773874533LL - 1418509395323LL * 1000) / 1000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L * 1000 - 931701773874533L) / 1000000,
+    ASSERT_EQ((1418509395323LL * 1000 - 931701773874533LL) / 1000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_6, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L - 1418509395L * 1000000) / 1000000,
+    ASSERT_EQ((931701773874533LL - 1418509395LL * 1000000) / 1000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395L * 1000000 - 931701773874533L) / 1000000,
+    ASSERT_EQ((1418509395LL * 1000000 - 931701773874533LL) / 1000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_6, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L / 1000000 - 1418509395323 / 1000L) / (60),
+    ASSERT_EQ((931701773874533LL / 1000000 - 1418509395323 / 1000LL) / (60),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L / 1000 - 931701773874533L / 1000000) / (60L),
+    ASSERT_EQ((1418509395323LL / 1000 - 931701773874533LL / 1000000) / (60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_6, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L / 1000000 - 1418509395L) / (60),
+    ASSERT_EQ((931701773874533LL / 1000000 - 1418509395LL) / (60),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395L - 931701773874533L / 1000000) / (60),
+    ASSERT_EQ((1418509395LL - 931701773874533LL / 1000000) / (60),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_6, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L / 1000000 - 1418509395323L / 1000) / (60L * 60L),
+    ASSERT_EQ((931701773874533LL / 1000000 - 1418509395323LL / 1000) / (60LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L / 1000 - 931701773874533L / 1000000) / (60L * 60L),
+    ASSERT_EQ((1418509395323LL / 1000 - 931701773874533LL / 1000000) / (60LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_6, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L / 1000000 - 1418509395L) / (60L * 60L),
+    ASSERT_EQ((931701773874533LL / 1000000 - 1418509395LL) / (60LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395L - 931701773874533L / 1000000) / (60L * 60L),
+    ASSERT_EQ((1418509395LL - 931701773874533LL / 1000000) / (60LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_6, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L / 1000000 - 1418509395323L / 1000) / (60L * 60L * 24L),
-              v<int64_t>(run_simple_agg(
-                  "SELECT DATEDIFF('day', m_3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L / 1000 - 931701773874533L / 1000000) / (60L * 60L * 24L),
-              v<int64_t>(run_simple_agg(
-                  "SELECT DATEDIFF('day', m_6, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((931701773874533L / 1000000 - 1418509395L) / (60L * 60L * 24L),
+    ASSERT_EQ(
+        (931701773874533LL / 1000000 - 1418509395323LL / 1000) / (60LL * 60LL * 24LL),
+        v<int64_t>(
+            run_simple_agg("SELECT DATEDIFF('day', m_3, m_6) FROM test limit 1;", dt)));
+    ASSERT_EQ(
+        (1418509395323LL / 1000 - 931701773874533LL / 1000000) / (60LL * 60LL * 24LL),
+        v<int64_t>(
+            run_simple_agg("SELECT DATEDIFF('day', m_6, m_3) FROM test limit 1;", dt)));
+    ASSERT_EQ((931701773874533LL / 1000000 - 1418509395LL) / (60LL * 60LL * 24LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('day', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395L - 931701773874533L / 1000000) / (60L * 60L * 24L),
+    ASSERT_EQ((1418509395LL - 931701773874533LL / 1000000) / (60LL * 60LL * 24LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('day', m_6, m) FROM test limit 1;", dt)));
     ASSERT_EQ(185,
@@ -12051,48 +12195,50 @@
     ASSERT_EQ(-15,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('year', m, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000L - 1418509395323L) * 1000000,
+    ASSERT_EQ((1418509395000LL - 1418509395323LL) * 1000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m_3, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L - 1418509395000) * 1000000,
+    ASSERT_EQ((1418509395323LL - 1418509395000) * 1000000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('nanosecond', m, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000L - 1418509395323L) * 1000,
+    ASSERT_EQ((1418509395000LL - 1418509395323LL) * 1000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m_3, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L - 1418509395000L) * 1000,
+    ASSERT_EQ((1418509395323LL - 1418509395000LL) * 1000,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('microsecond', m, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000L - 1418509395323L),
+    ASSERT_EQ((1418509395000LL - 1418509395323LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m_3, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L - 1418509395000L),
+    ASSERT_EQ((1418509395323LL - 1418509395000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('millisecond', m, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000L - 1418509395323L) / (1000L),
+    ASSERT_EQ((1418509395000LL - 1418509395323LL) / (1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m_3, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L - 1418509395000L) / (1000L),
+    ASSERT_EQ((1418509395323LL - 1418509395000LL) / (1000LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('second', m, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000L - 1418509395323L) / (1000L * 60L),
+    ASSERT_EQ((1418509395000LL - 1418509395323LL) / (1000LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m_3, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L - 1418509395000L) / (1000L * 60L),
+    ASSERT_EQ((1418509395323LL - 1418509395000LL) / (1000LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('minute', m, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000L - 1418509395323L) / (1000L * 1000L * 60L * 60L),
+    ASSERT_EQ((1418509395000LL - 1418509395323LL) / (1000LL * 1000LL * 60LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m_3, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L - 1418509395000L) / (1000L * 1000L * 60L * 60L),
+    ASSERT_EQ((1418509395323LL - 1418509395000LL) / (1000LL * 1000LL * 60LL * 60LL),
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('hour', m, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395000L - 1418509395323L) / (1000L * 1000L * 60L * 60L * 24L),
-              v<int64_t>(run_simple_agg(
-                  "SELECT DATEDIFF('day', m_3, m) FROM test limit 1;", dt)));
-    ASSERT_EQ((1418509395323L - 1418509395000L) / (1000L * 1000L * 60L * 60L * 24L),
-              v<int64_t>(run_simple_agg(
-                  "SELECT DATEDIFF('day', m, m_3) FROM test limit 1;", dt)));
+    ASSERT_EQ(
+        (1418509395000LL - 1418509395323LL) / (1000LL * 1000LL * 60LL * 60LL * 24LL),
+        v<int64_t>(
+            run_simple_agg("SELECT DATEDIFF('day', m_3, m) FROM test limit 1;", dt)));
+    ASSERT_EQ(
+        (1418509395323LL - 1418509395000LL) / (1000LL * 1000LL * 60LL * 60LL * 24LL),
+        v<int64_t>(
+            run_simple_agg("SELECT DATEDIFF('day', m, m_3) FROM test limit 1;", dt)));
     ASSERT_EQ(0,
               v<int64_t>(run_simple_agg(
                   "SELECT DATEDIFF('month', m_3, m) FROM test limit 1;", dt)));
@@ -12108,188 +12254,188 @@
     EXPECT_ANY_THROW(
         run_simple_agg("SELECT DATEDIFF(NULL, m, m_3) FROM test limit 1;", dt));
     /* ---TIMESTAMPADD --- */
-    ASSERT_EQ(1177559344607435125L,
+    ASSERT_EQ(1177559344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(YEAR,1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1153885744607435125L,
+    ASSERT_EQ(1153885744607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(QUARTER, 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1148615344607435125L,
+    ASSERT_EQ(1148615344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MONTH, 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146109744607435125L,
+    ASSERT_EQ(1146109744607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(DAY,1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146026944607435125L,
+    ASSERT_EQ(1146026944607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(HOUR, 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023404607435125L,
+    ASSERT_EQ(1146023404607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MINUTE, 1, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023403607435125L,
+    ASSERT_EQ(1146023403607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(SECOND, 59, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1026396173874533L,
+    ASSERT_EQ(1026396173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(YEAR,3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(955461773874533L,
+    ASSERT_EQ(955461773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(QUARTER, 3, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(947599373874533L,
+    ASSERT_EQ(947599373874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MONTH, 6, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(932824973874533L,
+    ASSERT_EQ(932824973874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(DAY,13, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931734173874533L,
+    ASSERT_EQ(931734173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(HOUR, 9, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931704053874533L,
+    ASSERT_EQ(931704053874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MINUTE, 38, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701783874533L,
+    ASSERT_EQ(931701783874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(SECOND, 10, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(1734128595323L,
+    ASSERT_EQ(1734128595323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(YEAR,10, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1450045395323L,
+    ASSERT_EQ(1450045395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(QUARTER, 4, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1423866195323L,
+    ASSERT_EQ(1423866195323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MONTH, 2, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1419805395323L,
+    ASSERT_EQ(1419805395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(DAY,15, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418516595323L,
+    ASSERT_EQ(1418516595323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(HOUR, 2, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418510055323L,
+    ASSERT_EQ(1418510055323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MINUTE, 11, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509415323L,
+    ASSERT_EQ(1418509415323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(SECOND, 20, m_3) FROM test limit 1;", dt)));
 
     /* ---INTERVAL --- */
-    ASSERT_EQ(1177559344607435125L,
+    ASSERT_EQ(1177559344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 + INTERVAL '1' year) from test limit 1;", dt)));
-    ASSERT_EQ(1148615344607435125L,
+    ASSERT_EQ(1148615344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 + INTERVAL '1' month) from test limit 1;", dt)));
-    ASSERT_EQ(1146109744607435125L,
+    ASSERT_EQ(1146109744607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 + INTERVAL '1' day) from test limit 1;", dt)));
-    ASSERT_EQ(1146026944607435125L,
+    ASSERT_EQ(1146026944607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 + INTERVAL '1' hour) from test limit 1;", dt)));
-    ASSERT_EQ(1146023404607435125L,
+    ASSERT_EQ(1146023404607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 + INTERVAL '1' minute) from test limit 1;", dt)));
-    ASSERT_EQ(1146023345607435125L,
+    ASSERT_EQ(1146023345607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 + INTERVAL '1' second) from test limit 1;", dt)));
-    ASSERT_EQ(1114487344607435125L,
+    ASSERT_EQ(1114487344607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 - INTERVAL '1' year) from test limit 1;", dt)));
-    ASSERT_EQ(1143344944607435125L,
+    ASSERT_EQ(1143344944607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 - INTERVAL '1' month) from test limit 1;", dt)));
-    ASSERT_EQ(1145936944607435125L,
+    ASSERT_EQ(1145936944607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 - INTERVAL '1' day) from test limit 1;", dt)));
-    ASSERT_EQ(1146019744607435125L,
+    ASSERT_EQ(1146019744607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 - INTERVAL '1' hour) from test limit 1;", dt)));
-    ASSERT_EQ(1146023284607435125L,
+    ASSERT_EQ(1146023284607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 - INTERVAL '1' minute) from test limit 1;", dt)));
-    ASSERT_EQ(1146023343607435125L,
+    ASSERT_EQ(1146023343607435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_9 - INTERVAL '1' second) from test limit 1;", dt)));
-    ASSERT_EQ(963324173874533L,
+    ASSERT_EQ(963324173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 + INTERVAL '1' year) from test limit 1;", dt)));
-    ASSERT_EQ(934380173874533L,
+    ASSERT_EQ(934380173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 + INTERVAL '1' month) from test limit 1;", dt)));
-    ASSERT_EQ(931788173874533L,
+    ASSERT_EQ(931788173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 + INTERVAL '1' day) from test limit 1;", dt)));
-    ASSERT_EQ(931705373874533L,
+    ASSERT_EQ(931705373874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 + INTERVAL '1' hour) from test limit 1;", dt)));
-    ASSERT_EQ(931701833874533L,
+    ASSERT_EQ(931701833874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 + INTERVAL '1' minute) from test limit 1;", dt)));
-    ASSERT_EQ(931701774874533L,
+    ASSERT_EQ(931701774874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 + INTERVAL '1' second) from test limit 1;", dt)));
-    ASSERT_EQ(900165773874533L,
+    ASSERT_EQ(900165773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 - INTERVAL '1' year) from test limit 1;", dt)));
-    ASSERT_EQ(929109773874533L,
+    ASSERT_EQ(929109773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 - INTERVAL '1' month) from test limit 1;", dt)));
-    ASSERT_EQ(931615373874533L,
+    ASSERT_EQ(931615373874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 - INTERVAL '1' day) from test limit 1;", dt)));
-    ASSERT_EQ(931698173874533L,
+    ASSERT_EQ(931698173874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 - INTERVAL '1' hour) from test limit 1;", dt)));
-    ASSERT_EQ(931701713874533L,
+    ASSERT_EQ(931701713874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 - INTERVAL '1' minute) from test limit 1;", dt)));
-    ASSERT_EQ(931701772874533L,
+    ASSERT_EQ(931701772874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_6 - INTERVAL '1' second) from test limit 1;", dt)));
-    ASSERT_EQ(1450045395323L,
+    ASSERT_EQ(1450045395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 + INTERVAL '1' year) from test limit 1;", dt)));
-    ASSERT_EQ(1421187795323L,
+    ASSERT_EQ(1421187795323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 + INTERVAL '1' month) from test limit 1;", dt)));
-    ASSERT_EQ(1418595795323L,
+    ASSERT_EQ(1418595795323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 + INTERVAL '1' day) from test limit 1;", dt)));
-    ASSERT_EQ(1418512995323L,
+    ASSERT_EQ(1418512995323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 + INTERVAL '1' hour) from test limit 1;", dt)));
-    ASSERT_EQ(1418509455323L,
+    ASSERT_EQ(1418509455323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 + INTERVAL '1' minute) from test limit 1;", dt)));
-    ASSERT_EQ(1418509396323L,
+    ASSERT_EQ(1418509396323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 + INTERVAL '1' second) from test limit 1;", dt)));
-    ASSERT_EQ(1386973395323L,
+    ASSERT_EQ(1386973395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 - INTERVAL '1' year) from test limit 1;", dt)));
-    ASSERT_EQ(1415917395323L,
+    ASSERT_EQ(1415917395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 - INTERVAL '1' month) from test limit 1;", dt)));
-    ASSERT_EQ(1418422995323L,
+    ASSERT_EQ(1418422995323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 - INTERVAL '1' day) from test limit 1;", dt)));
-    ASSERT_EQ(1418505795323L,
+    ASSERT_EQ(1418505795323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 - INTERVAL '1' hour) from test limit 1;", dt)));
-    ASSERT_EQ(1418509335323L,
+    ASSERT_EQ(1418509335323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 - INTERVAL '1' minute) from test limit 1;", dt)));
-    ASSERT_EQ(1418509394323L,
+    ASSERT_EQ(1418509394323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT (m_3 - INTERVAL '1' second) from test limit 1;", dt)));
 
     /*--- High Precision Timestamps Casts with intervals---*/
     ASSERT_EQ(
-        1146023345L,
+        1146023345LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_9 as timestamp(0)) + INTERVAL '1' second) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        1146023343607L,
+        1146023343607LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_9 as timestamp(3)) - INTERVAL '1' second) from test limit 1;",
             dt)));
@@ -12299,47 +12445,47 @@
             "SELECT (cast(m_9 as timestamp(6)) + INTERVAL '1' minute) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        931705373L,
+        931705373LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_6 as timestamp(0)) + INTERVAL '1' hour) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        931698173874L,
+        931698173874LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_6 as timestamp(3)) - INTERVAL '1' hour) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        931701833874533000L,
+        931701833874533000LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_6 as timestamp(9)) + INTERVAL '1' minute) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        1450045395L,
+        1450045395LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_3 as timestamp(0)) + INTERVAL '1' year) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        1386973395323000L,
+        1386973395323000LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_3 as timestamp(6)) - INTERVAL '1' year) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        1450045395323000000L,
+        1450045395323000000LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m_3 as timestamp(9)) + INTERVAL '1' year) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        1418509335000L,
+        1418509335000LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m as timestamp(3)) - INTERVAL '1' minute) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        1418505795000000L,
+        1418505795000000LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m as timestamp(6)) - INTERVAL '1' hour) from test limit 1;",
             dt)));
     ASSERT_EQ(
-        1418509455000000000L,
+        1418509455000000000LL,
         v<int64_t>(run_simple_agg(
             "SELECT (cast(m as timestamp(9)) + INTERVAL '1' minute) from test limit 1;",
             dt)));
@@ -13262,31 +13408,31 @@
                                   "TIMESTAMP(9) '2017-05-31 1:12:11.123120000';",
                                   dt)));
 
-    ASSERT_EQ(1146023344932435125L,
+    ASSERT_EQ(1146023344932435125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MILLISECOND, 325 , m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607960125L,
+    ASSERT_EQ(1146023344607960125LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MICROSECOND, 525, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(1146023344607436000L,
+    ASSERT_EQ(1146023344607436000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(NANOSECOND, 875, m_9) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773885533L,
+    ASSERT_EQ(931701773885533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MILLISECOND, 11 , m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874678L,
+    ASSERT_EQ(931701773874678LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MICROSECOND, 145, m_6) FROM test limit 1;", dt)));
-    ASSERT_EQ(931701773874533L,
+    ASSERT_EQ(931701773874533LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(NANOSECOND, 875, m_6) FROM test limit 1;", dt)));
     ASSERT_EQ(1418509395553,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MILLISECOND, 230 , m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(MICROSECOND, 145, m_3) FROM test limit 1;", dt)));
-    ASSERT_EQ(1418509395323L,
+    ASSERT_EQ(1418509395323LL,
               v<int64_t>(run_simple_agg(
                   "SELECT TIMESTAMPADD(NANOSECOND, 875, m_3) FROM test limit 1;", dt)));
     ASSERT_EQ(5,
@@ -13466,64 +13612,64 @@
         "01:02:03.000003046777Z', '2012-05-22 01:02:03.000000003046777Z');",
         dt));
 
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg("SELECT count(ts_3) FROM ts_format where "
                                         "extract(epoch from ts_3) = 1337648523 "
                                         "AND extract('millisecond' from ts_3) = 3000;",
                                         dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg("SELECT count(ts_3) FROM ts_format where "
                                         "extract(epoch from ts_3) = 1337648523 "
                                         "AND extract('millisecond' from ts_3) = 3100;",
                                         dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg("SELECT count(ts_3) FROM ts_format where "
                                         "extract(epoch from ts_3) = 1337648523 "
                                         "AND extract('millisecond' from ts_3) = 3030;",
                                         dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg("SELECT count(ts_3) FROM ts_format where "
                                         "extract(epoch from ts_3) = 1337648523 "
                                         "AND extract('millisecond' from ts_3) = 3003;",
                                         dt)));
 
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_6) FROM ts_format where extract(epoch from ts_6) = "
                   "1337648523 AND extract('microsecond' from ts_6) = 3000000;",
                   dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_6) FROM ts_format where extract(epoch from ts_6) = "
                   "1337648523 AND extract('microsecond' from ts_6) = 3100000;",
                   dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_6) FROM ts_format where extract(epoch from ts_6) = "
                   "1337648523 AND extract('microsecond' from ts_6) = 3030000;",
                   dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_6) FROM ts_format where extract(epoch from ts_6) = "
                   "1337648523 AND extract('microsecond' from ts_6) = 3000003;",
                   dt)));
 
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_9) FROM ts_format where extract(epoch from ts_9) = "
                   "1337648523 AND extract('nanosecond' from ts_9) = 3000000000;",
                   dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_9) FROM ts_format where extract(epoch from ts_9) = "
                   "1337648523 AND extract('nanosecond' from ts_9) = 3100000000;",
                   dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_9) FROM ts_format where extract(epoch from ts_9) = "
                   "1337648523 AND extract('nanosecond' from ts_9) = 3030000000;",
                   dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT count(ts_9) FROM ts_format where extract(epoch from ts_9) = "
                   "1337648523 AND extract('nanosecond' from ts_9) = 3000000003;",
@@ -13823,680 +13969,680 @@
 TEST(Select, ExtractFromNegativeTimes) {
   for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
     SKIP_NO_GPU();
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(-1769003452L,
+    ASSERT_EQ(-1769003452LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        8000000L,
+        8000000LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        8000L,
+        8000LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(9L,
+    ASSERT_EQ(9LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(8L,
+    ASSERT_EQ(8LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        49L,
+        49LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(1913L,
+    ASSERT_EQ(1913LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '1913-12-11 10:09:08');", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(-1769003460L,
+    ASSERT_EQ(-1769003460LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(9L,
+    ASSERT_EQ(9LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        49L,
+        49LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(1913L,
+    ASSERT_EQ(1913LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '1913-12-11 10:09:00');", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(-1769004000L,
+    ASSERT_EQ(-1769004000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        49L,
+        49LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(1913L,
+    ASSERT_EQ(1913LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '1913-12-11 10:00:00');", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(-1769040000L,
+    ASSERT_EQ(-1769040000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        49L,
+        49LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(1913L,
+    ASSERT_EQ(1913LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '1913-12-11 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(335L,
+    ASSERT_EQ(335LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(-1769904000L,
+    ASSERT_EQ(-1769904000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(49L,
+    ASSERT_EQ(49LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        49L,
+        49LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        48L,
+        48LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(1913L,
+    ASSERT_EQ(1913LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '1913-12-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(-1798761600L,
+    ASSERT_EQ(-1798761600LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        1L,
+        1LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        53L,
+        53LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1913L,
+    ASSERT_EQ(1913LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '1913-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        53L,
+        53LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        52L,
+        52LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1970L,
+    ASSERT_EQ(1970LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '1970-01-01 00:00:00');", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(1386756548L,
+    ASSERT_EQ(1386756548LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        8000000L,
+        8000000LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        8000L,
+        8000LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(9L,
+    ASSERT_EQ(9LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(8L,
+    ASSERT_EQ(8LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(2013L,
+    ASSERT_EQ(2013LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '2013-12-11 10:09:08');", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(1386756540L,
+    ASSERT_EQ(1386756540LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(9L,
+    ASSERT_EQ(9LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(2013L,
+    ASSERT_EQ(2013LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '2013-12-11 10:09:00');", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(1386756000L,
+    ASSERT_EQ(1386756000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(10L,
+    ASSERT_EQ(10LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(2013L,
+    ASSERT_EQ(2013LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '2013-12-11 10:00:00');", dt)));
-    ASSERT_EQ(11L,
+    ASSERT_EQ(11LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(345L,
+    ASSERT_EQ(345LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(1386720000L,
+    ASSERT_EQ(1386720000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(3L,
+    ASSERT_EQ(3LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(50L,
+    ASSERT_EQ(50LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
     ASSERT_EQ(
-        50L,
+        50LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(2013L,
+    ASSERT_EQ(2013LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '2013-12-11 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(335L,
+    ASSERT_EQ(335LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(1385856000L,
+    ASSERT_EQ(1385856000LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(7L,
+    ASSERT_EQ(7LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(12L,
+    ASSERT_EQ(12LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(4L,
+    ASSERT_EQ(4LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(48L,
+    ASSERT_EQ(48LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        49L,
+        49LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
     ASSERT_EQ(
-        49L,
+        49LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(2013L,
+    ASSERT_EQ(2013LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '2013-12-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DAY FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOW FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(DOY FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1356998400L,
+    ASSERT_EQ(1356998400LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(HOUR FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(2L,
+    ASSERT_EQ(2LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(ISODOW FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MICROSECOND FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        0L,
+        0LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(MILLISECOND FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MINUTE FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(MONTH FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(QUARTER FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(0L,
+    ASSERT_EQ(0LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(SECOND FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(1L,
+    ASSERT_EQ(1LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(WEEK FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        1L,
+        1LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SUNDAY FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
     ASSERT_EQ(
-        1L,
+        1LL,
         v<int64_t>(run_simple_agg(
             "SELECT EXTRACT(WEEK_SATURDAY FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
-    ASSERT_EQ(2013L,
+    ASSERT_EQ(2013LL,
               v<int64_t>(run_simple_agg(
                   "SELECT EXTRACT(YEAR FROM TIMESTAMP '2013-01-01 00:00:00');", dt)));
   }
@@ -19173,6 +19319,49 @@
   }
 }
 
+TEST(Select, OffsetInFragment) {
+  // Skip test in sharded/distributed situations, as otherwise we have to replicate much
+  // of logic of how we shard strings to compute the number rows of test table that will
+  // be distributed to each shard
+  // TODO: consider creating simple integer sharded table specific for this test
+  SKIP_IF_SHARDED();
+  SKIP_ALL_ON_AGGREGATOR();
+
+  for (auto dt : {ExecutorDeviceType::CPU, ExecutorDeviceType::GPU}) {
+    SKIP_NO_GPU();
+    // With fragment_size of 2, we should have 10 frags
+    EXPECT_EQ(10,
+              v<int64_t>(run_simple_agg(
+                  "SELECT COUNT(*) FROM test WHERE offset_in_fragment() = 1;", dt)));
+    EXPECT_EQ(
+        10,
+        v<int64_t>(run_simple_agg(
+            "SELECT COUNT(*) FROM test WHERE offset_in_fragment() = CAST(1 AS INT);",
+            dt)));
+    EXPECT_EQ(10,
+              v<int64_t>(run_simple_agg(
+                  "SELECT COUNT(*) FROM test WHERE offset_in_fragment() < 1;", dt)));
+    EXPECT_EQ(20,
+              v<int64_t>(run_simple_agg(
+                  "SELECT COUNT(*) FROM test WHERE offset_in_fragment() <= 1;", dt)));
+    EXPECT_EQ(
+        10,
+        v<int64_t>(run_simple_agg("SELECT COUNT(*) FROM test WHERE offset_in_fragment() "
+                                  "<= 1 AND offset_in_fragment() != 0;",
+                                  dt)));
+    EXPECT_EQ(
+        1,
+        v<int64_t>(run_simple_agg("SELECT CAST(AVG(offset_in_fragment()) AS BIGINT) FROM "
+                                  "test WHERE offset_in_fragment() > 0;",
+                                  dt)));
+    const auto num_rows = v<int64_t>(run_simple_agg(
+        "SELECT COUNT(*) FROM (SELECT COUNT(*) FROM test WHERE offset_in_fragment() <= "
+        "10 GROUP BY MOD(offset_in_fragment(), 2));",
+        dt));
+    EXPECT_EQ(num_rows, 2);
+  }
+}
+
 // Additional integer parsing tests in ImportTestInt.ImportBadInt and ImportGoodInt.
 TEST(Select, ParseIntegerExceptions) {
   struct TestPair {
diff -Naur ./Tests/FileMgrTest.cpp ../omniscidb-master/Tests/FileMgrTest.cpp
--- ./Tests/FileMgrTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/FileMgrTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -85,11 +85,11 @@
   void compareBuffers(AbstractBuffer* left_buffer,
                       AbstractBuffer* right_buffer,
                       size_t num_bytes) {
-    int8_t left_array[num_bytes];
-    int8_t right_array[num_bytes];
-    left_buffer->read(left_array, num_bytes);
-    right_buffer->read(right_array, num_bytes);
-    ASSERT_EQ(std::memcmp(left_array, right_array, num_bytes), 0);
+    std::vector<int8_t> left_array(num_bytes);
+    std::vector<int8_t> right_array(num_bytes);
+    left_buffer->read(left_array.data(), num_bytes);
+    right_buffer->read(right_array.data(), num_bytes);
+    ASSERT_EQ(std::memcmp(left_array.data(), right_array.data(), num_bytes), 0);
     ASSERT_EQ(left_buffer->hasEncoder(), right_buffer->hasEncoder());
   }
 
diff -Naur ./Tests/FilePathWhitelistTest.cpp ../omniscidb-master/Tests/FilePathWhitelistTest.cpp
--- ./Tests/FilePathWhitelistTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/FilePathWhitelistTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -51,6 +51,7 @@
   static void TearDownTestSuite() {
     boost::filesystem::remove(temp_file_path_);
     boost::filesystem::remove(CONFIG_FILE_PATH);
+    boost::filesystem::remove("symlink_test.csv");
     boost::filesystem::remove_all(DEFAULT_IMPORT_PATH);
     boost::filesystem::remove_all(DEFAULT_EXPORT_PATH);
   }
@@ -107,17 +108,23 @@
     return file_path;
   }
 
-  std::string setAndGetFileAtDefaultImportAndExportPath() {
-    auto source_path = getTestFilePath();
-    boost::filesystem::path destination_path;
+  boost::filesystem::path initDefaultImportOrExportDirectory() {
+    boost::filesystem::path directory_path;
     if (GetParam() == "CopyTo") {
-      destination_path = DEFAULT_EXPORT_PATH;
+      directory_path = DEFAULT_EXPORT_PATH;
     } else {
-      destination_path = DEFAULT_IMPORT_PATH;
+      directory_path = DEFAULT_IMPORT_PATH;
     }
-    if (!boost::filesystem::exists(destination_path)) {
-      boost::filesystem::create_directory(destination_path);
+    if (!boost::filesystem::exists(directory_path)) {
+      boost::filesystem::create_directory(directory_path);
     }
+    return directory_path;
+  }
+
+  std::string setAndGetFileAtDefaultImportOrExportPath() {
+    auto source_path = getTestFilePath();
+    boost::filesystem::path destination_path = initDefaultImportOrExportDirectory();
+
     destination_path /= boost::filesystem::path(source_path).filename().string();
     boost::filesystem::copy_file(source_path,
                                  destination_path,
@@ -125,6 +132,23 @@
     return boost::filesystem::canonical(destination_path).string();
   }
 
+  std::string clearAndGetSymlinkFilePath(boost::filesystem::path destination_path) {
+    destination_path = boost::filesystem::canonical(destination_path);
+    destination_path /= "symlink_test.csv";
+    if (boost::filesystem::exists(destination_path)) {
+      boost::filesystem::remove(destination_path);
+    }
+    return destination_path.string();
+  }
+
+  std::string getWhitelistedSymlinkFilePath() {
+    return clearAndGetSymlinkFilePath(initDefaultImportOrExportDirectory());
+  }
+
+  std::string getUnlistedSymlinkFilePath() {
+    return clearAndGetSymlinkFilePath(boost::filesystem::path("."));
+  }
+
   std::string getMalformedConfigErrorMessage() {
     std::string config_key;
     if (GetParam() == "CopyTo") {
@@ -193,6 +217,48 @@
       "Exception: File or directory path \"" + file_path + "\" is not whitelisted.");
 }
 
+TEST_P(FilePathWhitelistTest, WhitelistedSymlinkToUnlistedPath) {
+  setServerConfig("test_config.conf");
+  initializeWhitelist();
+  const auto file_path =
+      boost::filesystem::canonical(
+          "../../Tests/Import/datafiles/with_quoted_fields_doublequotes.csv")
+          .string();
+  const auto symlink_path = getWhitelistedSymlinkFilePath();
+  boost::filesystem::create_symlink(file_path, symlink_path);
+
+  queryAndAssertException(getQuery(symlink_path),
+                          "Exception: File or directory path \"" + symlink_path +
+                              "\" (resolved to \"" + file_path +
+                              "\") is not whitelisted.");
+}
+
+TEST_P(FilePathWhitelistTest, UnlistedSymlinkToWhitelistedPath) {
+  setServerConfig("test_config.conf");
+  initializeWhitelist();
+  const auto file_path = getTestFilePath();
+  const auto symlink_path = getUnlistedSymlinkFilePath();
+  boost::filesystem::create_symlink(file_path, symlink_path);
+
+  EXPECT_NO_THROW(sql(getQuery(symlink_path)));
+}
+
+TEST_P(FilePathWhitelistTest, UnlistedSymlinkToUnlistedPath) {
+  setServerConfig("test_config.conf");
+  initializeWhitelist();
+  const auto file_path =
+      boost::filesystem::canonical(
+          "../../Tests/Import/datafiles/with_quoted_fields_doublequotes.csv")
+          .string();
+  const auto symlink_path = getUnlistedSymlinkFilePath();
+  boost::filesystem::create_symlink(file_path, symlink_path);
+
+  queryAndAssertException(getQuery(symlink_path),
+                          "Exception: File or directory path \"" + symlink_path +
+                              "\" (resolved to \"" + file_path +
+                              "\") is not whitelisted.");
+}
+
 TEST_P(FilePathWhitelistTest, InvalidConfigValue) {
   std::string config_path;
   if (GetParam() == "CopyTo") {
@@ -237,6 +303,18 @@
                               "\" is not allowed.");
 }
 
+TEST_P(FilePathWhitelistTest, UnlistedSymlinkToBlacklistedPath) {
+  setServerConfig("test_config.conf");
+  const auto file_path = getTestFilePath();
+  const auto symlink_path = getUnlistedSymlinkFilePath();
+  ddl_utils::FilePathBlacklist::addToBlacklist(file_path);
+  boost::filesystem::create_symlink(file_path, symlink_path);
+  queryAndAssertException(getQuery(symlink_path),
+                          "Exception: Access to file or directory path \"" +
+                              symlink_path + "\" (resolved to \"" + file_path +
+                              "\") is not allowed.");
+}
+
 TEST_P(FilePathWhitelistTest, RootPathWhitelisted) {
   whitelistRootPath();
   std::string file_path = getTestFilePath();
@@ -253,7 +331,7 @@
 
 TEST_P(FilePathWhitelistTest, DefaultImportAndExportPaths) {
   ddl_utils::FilePathWhitelist::initialize(BASE_PATH, "", "");
-  auto file_path = setAndGetFileAtDefaultImportAndExportPath();
+  auto file_path = setAndGetFileAtDefaultImportOrExportPath();
   EXPECT_NO_THROW(sql(getQuery(file_path)));
 }
 
diff -Naur ./Tests/ForeignStorageCacheTest.cpp ../omniscidb-master/Tests/ForeignStorageCacheTest.cpp
--- ./Tests/ForeignStorageCacheTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/ForeignStorageCacheTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -15,6 +15,7 @@
  */
 
 #include "DataMgr/ForeignStorage/ForeignStorageCache.h"
+#include "DataMgr/ForeignStorage/ForeignStorageInterface.h"
 #include "DataMgr/ForeignStorage/ForeignStorageMgr.h"
 #include "DataMgr/PersistentStorageMgr/PersistentStorageMgr.h"
 #include "DataMgrTestHelpers.h"
@@ -25,6 +26,7 @@
 #include "Catalog/Catalog.h"
 
 extern bool g_enable_fsi;
+std::shared_ptr<ForeignStorageInterface> fsi;
 
 using namespace foreign_storage;
 using namespace File_Namespace;
@@ -47,7 +49,6 @@
 
 class ForeignStorageCacheUnitTest : public testing::Test {
  protected:
-  inline static GlobalFileMgr* gfm_;
   inline static std::unique_ptr<ForeignStorageCache> cache_;
   inline static std::string cache_path_;
 
@@ -126,23 +127,20 @@
   }
 
   static void reinitializeCache(std::unique_ptr<ForeignStorageCache>& cache,
-                                GlobalFileMgr*& gfm,
                                 const DiskCacheConfig& config) {
     cache = std::make_unique<ForeignStorageCache>(config);
-    gfm = cache->getGlobalFileMgr();
   }
 
   static void SetUpTestSuite() {
     cache_path_ = "./tmp/mapd_data/test_foreign_data_cache";
     boost::filesystem::remove_all(cache_path_);
-    reinitializeCache(cache_, gfm_, {cache_path_, DiskCacheLevel::fsi});
+    reinitializeCache(cache_, {cache_path_, DiskCacheLevel::fsi});
   }
 
   static void TearDownTestSuite() { boost::filesystem::remove_all(cache_path_); }
 
   void SetUp() override {
     cache_->clear();
-    ASSERT_EQ(gfm_->getNumChunks(), 0U);
     ASSERT_EQ(cache_->getNumCachedChunks(), 0U);
     ASSERT_EQ(cache_->getNumCachedMetadata(), 0U);
   }
@@ -284,9 +282,6 @@
   cache_->clearForTablePrefix(table_prefix1);
   ASSERT_EQ(cache_->getNumCachedChunks(), 1U);
   ASSERT_EQ(cache_->getNumCachedMetadata(), 1U);
-  ASSERT_FALSE(gfm_->isBufferOnDevice(chunk_key1));
-  ASSERT_FALSE(gfm_->isBufferOnDevice(chunk_key2));
-  ASSERT_TRUE(gfm_->isBufferOnDevice(chunk_key_table2));
 }
 
 TEST_F(ForeignStorageCacheUnitTest, Clear) {
@@ -301,9 +296,6 @@
   cache_->clear();
   ASSERT_EQ(cache_->getNumCachedChunks(), 0U);
   ASSERT_EQ(cache_->getNumCachedMetadata(), 0U);
-  ASSERT_FALSE(gfm_->isBufferOnDevice(chunk_key1));
-  ASSERT_FALSE(gfm_->isBufferOnDevice(chunk_key2));
-  ASSERT_FALSE(gfm_->isBufferOnDevice(chunk_key_table2));
 }
 
 class CacheDiskStorageTest : public ForeignStorageCacheUnitTest {
@@ -314,35 +306,28 @@
   static void TearDownTestSuite() {}
   void SetUp() override {
     boost::filesystem::remove_all(cache_path_);
-    reinitializeCache(cache_, gfm_, {cache_path_, DiskCacheLevel::fsi});
+    reinitializeCache(cache_, {cache_path_, DiskCacheLevel::fsi});
   }
   void TearDown() override { boost::filesystem::remove_all(cache_path_); }
 };
 
-TEST_F(CacheDiskStorageTest, CachePath_CreateBaseDir) {
-  ASSERT_FALSE(boost::filesystem::exists(cache_path_ + "/table_1_1"));
-  ChunkWrapper<int32_t> chunk_wrapper1{kINT, {1, 2, 3, 4}};
-  chunk_wrapper1.cacheMetadata(chunk_key1);
-  ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/table_1_1"));
-}
-
 TEST_F(CacheDiskStorageTest, CacheMetadata_VerifyMetadataFileCreated) {
   ChunkWrapper<int32_t> chunk_wrapper1{kINT, {1, 2, 3, 4}};
   chunk_wrapper1.cacheMetadata(chunk_key1);
-  ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/table_1_1/0.4096.mapd"));
+  ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/0.4096.mapd"));
 }
 
 TEST_F(CacheDiskStorageTest, CacheChunk_VerifyChunkFileCreated) {
   ChunkWrapper<int32_t> chunk_wrapper1{kINT, {1, 2, 3, 4}};
   chunk_wrapper1.cacheMetadataThenChunk(chunk_key1);
-  ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/table_1_1/1." +
-                                        to_string(gfm_->getDefaultPageSize()) + ".mapd"));
+  ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/1." +
+                                        to_string(DEFAULT_PAGE_SIZE) + ".mapd"));
 }
 
 TEST_F(CacheDiskStorageTest, RecoverCache_Metadata) {
   ChunkWrapper<int32_t> chunk_wrapper1{kINT, {1, 2, 3, 4}};
   chunk_wrapper1.cacheMetadata(chunk_key1);
-  reinitializeCache(cache_, gfm_, {cache_path_, DiskCacheLevel::fsi});
+  reinitializeCache(cache_, {cache_path_, DiskCacheLevel::fsi});
   ASSERT_EQ(cache_->getNumCachedMetadata(), 0U);
   ChunkMetadataVector metadata_vec_cached{};
   cache_->recoverCacheForTable(metadata_vec_cached, table_prefix1);
@@ -356,7 +341,7 @@
   chunk_wrapper1.cacheMetadata(chunk_key1);
   ChunkWrapper<int32_t> chunk_wrapper2{kINT, {5, 6}};
   chunk_wrapper2.cacheMetadata(chunk_key1);
-  reinitializeCache(cache_, gfm_, {cache_path_, DiskCacheLevel::fsi});
+  reinitializeCache(cache_, {cache_path_, DiskCacheLevel::fsi});
   ChunkMetadataVector metadata_vec_cached{};
   cache_->recoverCacheForTable(metadata_vec_cached, table_prefix1);
   ASSERT_EQ(cache_->getNumCachedMetadata(), 1U);
@@ -366,7 +351,7 @@
 TEST_F(CacheDiskStorageTest, RecoverCache_SingleChunk) {
   ChunkWrapper<int32_t> chunk_wrapper1{kINT, {1, 2, 3, 4}};
   chunk_wrapper1.cacheMetadataThenChunk(chunk_key1);
-  reinitializeCache(cache_, gfm_, {cache_path_, DiskCacheLevel::fsi});
+  reinitializeCache(cache_, {cache_path_, DiskCacheLevel::fsi});
   ASSERT_EQ(cache_->getNumCachedChunks(), 0U);
   ChunkMetadataVector metadata_vec_cached{};
   cache_->recoverCacheForTable(metadata_vec_cached, table_prefix1);
@@ -387,11 +372,8 @@
   boost::filesystem::remove_all(cache_path_);
   {
     ForeignStorageCache cache{{cache_path_, DiskCacheLevel::fsi}};
-    GlobalFileMgr* gfm = cache.getGlobalFileMgr();
     ASSERT_TRUE(boost::filesystem::exists(cache_path_));
-    ASSERT_FALSE(boost::filesystem::exists(cache_path_ + "/table_1_1"));
     ASSERT_EQ(cache.getCachedChunkIfExists(chunk_key1), nullptr);
-    ASSERT_FALSE(gfm->isBufferOnDevice(chunk_key1));
     TestBuffer source_buffer{std::vector<int8_t>{1, 2, 3, 4}};
     source_buffer.initEncoder(kINT);
     std::shared_ptr<ChunkMetadata> cached_meta = std::make_shared<ChunkMetadata>();
@@ -400,10 +382,9 @@
     auto buffer_map = cache.getChunkBuffersForCaching({chunk_key1});
     buffer_map[chunk_key1]->write(source_buffer.getMemoryPtr(), source_buffer.size());
     cache.cacheTableChunks({chunk_key1});
-    ASSERT_TRUE(gfm->isBufferOnDevice(chunk_key1));
-    ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/table_1_1/0.4096.mapd"));
-    ASSERT_TRUE(boost::filesystem::exists(
-        cache_path_ + "/table_1_1/1." + to_string(gfm->getDefaultPageSize()) + ".mapd"));
+    ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/0.4096.mapd"));
+    ASSERT_TRUE(boost::filesystem::exists(cache_path_ + "/1." +
+                                          to_string(DEFAULT_PAGE_SIZE) + ".mapd"));
   }
   // Cache files should persist after cache is destroyed.
   ASSERT_TRUE(boost::filesystem::exists(cache_path_));
@@ -412,7 +393,7 @@
 TEST_F(ForeignStorageCacheFileTest, CustomPath) {
   cache_path_ = "./test_foreign_data_cache";
   PersistentStorageMgr psm(data_path, 0, {cache_path_, DiskCacheLevel::fsi});
-  ASSERT_EQ(psm.getDiskCache()->getGlobalFileMgr()->getBasePath(), cache_path_ + "/");
+  ASSERT_EQ(psm.getDiskCache()->getCacheDirectory(), cache_path_);
 }
 
 TEST_F(ForeignStorageCacheFileTest, InitializeSansCache) {
@@ -456,6 +437,7 @@
   TestHelpers::init_logger_stderr_only(argc, argv);
   testing::InitGoogleTest(&argc, argv);
   g_enable_fsi = true;
+  fsi.reset(new ForeignStorageInterface());
 
   int err{0};
   try {
@@ -464,6 +446,7 @@
     LOG(ERROR) << e.what();
   }
 
+  fsi.reset();
   g_enable_fsi = false;
   return err;
 }
diff -Naur ./Tests/ForeignTableDmlTest.cpp ../omniscidb-master/Tests/ForeignTableDmlTest.cpp
--- ./Tests/ForeignTableDmlTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/ForeignTableDmlTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -124,7 +124,7 @@
   static ChunkKey getChunkKeyFromTable(const Catalog_Namespace::Catalog& cat,
                                        const std::string& table_name,
                                        const ChunkKey& key_suffix) {
-    const TableDescriptor* fd = cat.getMetadataForTable(table_name);
+    const TableDescriptor* fd = cat.getMetadataForTable(table_name, false);
     ChunkKey key{cat.getCurrentDB().dbId, fd->tableId};
     for (auto i : key_suffix) {
       key.push_back(i);
@@ -193,7 +193,7 @@
       bool has_nulls,
       const std::string& table_name) {
     auto& cat = getCatalog();
-    auto foreign_table = cat.getMetadataForTable(table_name);
+    auto foreign_table = cat.getMetadataForTable(table_name, false);
     auto column_descriptor = cat.getMetadataForColumn(foreign_table->tableId, column_id);
     auto chunk_metadata = std::make_unique<ChunkMetadata>();
     chunk_metadata->sqlType = column_descriptor->columnType;
@@ -225,7 +225,7 @@
           expected_metadata,
       const std::string& table_name) const {
     auto& cat = getCatalog();
-    auto foreign_table = cat.getMetadataForTable(table_name);
+    auto foreign_table = cat.getMetadataForTable(table_name, false);
     if (!foreign_table) {
       throw std::runtime_error("Could not find foreign table: " + table_name);
     }
@@ -279,7 +279,7 @@
     : public SelectQueryTest,
       public ::testing::WithParamInterface<DiskCacheLevel> {
  public:
-  inline static std::string cache_path_ = to_string(BASE_PATH) + "/omnisci_disk_cache/";
+  inline static std::string cache_path_ = to_string(BASE_PATH) + "/omnisci_disk_cache";
   DiskCacheLevel starting_cache_level_;
 
  protected:
@@ -343,7 +343,7 @@
 
 class RecoverCacheQueryTest : public ForeignTableTest {
  public:
-  inline static std::string cache_path_ = to_string(BASE_PATH) + "/omnisci_disk_cache/";
+  inline static std::string cache_path_ = to_string(BASE_PATH) + "/omnisci_disk_cache";
   Catalog_Namespace::Catalog* cat_;
   PersistentStorageMgr* psm_;
   foreign_storage::ForeignStorageCache* cache_;
@@ -360,7 +360,7 @@
   }
 
   bool isTableDatawrapperRestored(const std::string& name) {
-    auto td = getCatalog().getMetadataForTable(name);
+    auto td = getCatalog().getMetadataForTable(name, false);
     ChunkKey table_key{getCatalog().getCurrentDB().dbId, td->tableId};
     return getCatalog()
         .getDataMgr()
@@ -370,26 +370,28 @@
   }
 
   bool isTableDatawrapperDataOnDisk(const std::string& name) {
-    auto td = getCatalog().getMetadataForTable(name);
-    ChunkKey table_key{getCatalog().getCurrentDB().dbId, td->tableId};
+    auto td = getCatalog().getMetadataForTable(name, false);
+    auto db_id = getCatalog().getCurrentDB().dbId;
+    ChunkKey table_key{db_id, td->tableId};
     return bf::exists(getCatalog()
                           .getDataMgr()
                           .getPersistentStorageMgr()
                           ->getDiskCache()
-                          ->getCacheDirectoryForTablePrefix(table_key) +
-                      "/wrapper_metadata.json");
+                          ->getCacheDirectoryForTable(db_id, td->tableId) +
+                      "/" + foreign_storage::wrapper_file_name);
   }
 
   bool compareTableDatawrapperMetadataToFile(const std::string& name,
                                              const std::string& filepath) {
-    auto td = getCatalog().getMetadataForTable(name);
-    ChunkKey table_key{getCatalog().getCurrentDB().dbId, td->tableId};
+    auto td = getCatalog().getMetadataForTable(name, false);
+    auto db_id = getCatalog().getCurrentDB().dbId;
+    ChunkKey table_key{db_id, td->tableId};
     return compare_json_files(getCatalog()
                                       .getDataMgr()
                                       .getPersistentStorageMgr()
                                       ->getDiskCache()
-                                      ->getCacheDirectoryForTablePrefix(table_key) +
-                                  "/wrapper_metadata.json",
+                                      ->getCacheDirectoryForTable(db_id, td->tableId) +
+                                  foreign_storage::wrapper_file_name,
                               filepath,
                               getDataFilesPath());
   }
@@ -1565,7 +1567,7 @@
                                const std::string& table_name,
                                const std::vector<std::vector<int>> subkeys) {
   // subkey is chunkey without db, table ids
-  auto td = cat->getMetadataForTable(table_name);
+  auto td = cat->getMetadataForTable(table_name, false);
   ChunkKey table_key{cat->getCurrentDB().dbId, td->tableId};
   auto cache = cat->getDataMgr().getPersistentStorageMgr()->getDiskCache();
 
@@ -3416,7 +3418,6 @@
   inline static const std::string col_name3 = "col3";
   inline static Catalog_Namespace::Catalog* cat;
   inline static ForeignStorageCache* cache;
-  inline static File_Namespace::GlobalFileMgr* gfm;
   inline static const TableDescriptor* td;
   inline static const ColumnDescriptor *cd1, *cd2, *cd3;
   inline static ChunkKey query_chunk_key1, query_chunk_key2, query_chunk_key3,
@@ -3426,7 +3427,6 @@
     DBHandlerTestFixture::SetUpTestSuite();
     cat = &getCatalog();
     cache = cat->getDataMgr().getPersistentStorageMgr()->getDiskCache();
-    gfm = cache->getGlobalFileMgr();
     sqlDropForeignTable();
   }
 
@@ -3437,7 +3437,7 @@
         "(" + col_name1 + " TEXT, " + col_name2 + " INTEGER, " + col_name3 + " DOUBLE)",
         table_2_filename,
         "csv");
-    td = cat->getMetadataForTable(default_table_name);
+    td = cat->getMetadataForTable(default_table_name, false);
     cd1 = cat->getMetadataForColumn(td->tableId, col_name1);
     cd2 = cat->getMetadataForColumn(td->tableId, col_name2);
     cd3 = cat->getMetadataForColumn(td->tableId, col_name3);
@@ -3490,7 +3490,7 @@
   }
 };
 
-TEST_F(ForeignStorageCacheQueryTest, CreatePopulateMetadata) {
+TEST_F(ForeignStorageCacheQueryTest, CreateDoesNotPopulateMetadata) {
   sqlDropForeignTable();
   ASSERT_FALSE(cache->isMetadataCached(query_chunk_key1));
   ASSERT_FALSE(cache->isMetadataCached(query_chunk_key2));
@@ -3498,11 +3498,11 @@
   ASSERT_FALSE(cache->hasCachedMetadataForKeyPrefix(query_chunk_key1));
   ASSERT_FALSE(cache->hasCachedMetadataForKeyPrefix(query_table_prefix));
   createTestTable();
-  ASSERT_TRUE(cache->isMetadataCached(query_chunk_key1));
-  ASSERT_TRUE(cache->isMetadataCached(query_chunk_key2));
-  ASSERT_TRUE(cache->isMetadataCached(query_chunk_key3));
-  ASSERT_TRUE(cache->hasCachedMetadataForKeyPrefix(query_chunk_key1));
-  ASSERT_TRUE(cache->hasCachedMetadataForKeyPrefix(query_table_prefix));
+  ASSERT_FALSE(cache->isMetadataCached(query_chunk_key1));
+  ASSERT_FALSE(cache->isMetadataCached(query_chunk_key2));
+  ASSERT_FALSE(cache->isMetadataCached(query_chunk_key3));
+  ASSERT_FALSE(cache->hasCachedMetadataForKeyPrefix(query_chunk_key1));
+  ASSERT_FALSE(cache->hasCachedMetadataForKeyPrefix(query_table_prefix));
 }
 
 TEST_F(ForeignStorageCacheQueryTest, CacheEvictAfterDrop) {
@@ -3555,7 +3555,7 @@
   sql(query);
   sql("SELECT COUNT(*) FROM " + default_table_name + ";");
 
-  auto td = cat->getMetadataForTable(default_table_name);
+  auto td = cat->getMetadataForTable(default_table_name, false);
   ChunkMetadataVector metadata_vec{};
   cache->getCachedMetadataVecForKeyPrefix(metadata_vec,
                                           {cat->getCurrentDB().dbId, td->tableId});
@@ -3611,8 +3611,7 @@
 TEST_F(CacheDefaultTest, Path) {
   auto cat = &getCatalog();
   auto cache = cat->getDataMgr().getPersistentStorageMgr()->getDiskCache();
-  ASSERT_EQ(cache->getGlobalFileMgr()->getBasePath(),
-            to_string(BASE_PATH) + "/omnisci_disk_cache/");
+  ASSERT_EQ(cache->getCacheDirectory(), to_string(BASE_PATH) + "/omnisci_disk_cache");
 }
 
 TEST_F(RecoverCacheQueryTest, RecoverWithoutWrappers) {
@@ -3622,7 +3621,7 @@
                       "SERVER omnisci_local_csv WITH (file_path = '" +
                       getDataFilesPath() + "/" + "example_1_dir_archives/');";
   sql(query);
-  auto td = cat_->getMetadataForTable(default_table_name);
+  auto td = cat_->getMetadataForTable(default_table_name, false);
   ChunkKey key{cat_->getCurrentDB().dbId, td->tableId, 1, 0};
   ChunkKey table_key{cat_->getCurrentDB().dbId, td->tableId};
 
@@ -3652,14 +3651,14 @@
   sqlDropForeignTable();
 }
 
-TEST_F(RecoverCacheQueryTest, RecoverThenPopulateDataWrappersOnDemandVarLen) {
+TEST_F(RecoverCacheQueryTest, RecoverThenPopulateDataWrappersOnDemandVarLenCsv) {
   sqlDropForeignTable();
   std::string query = "CREATE FOREIGN TABLE " + default_table_name +
                       " (t TEXT, i BIGINT[]) "s +
                       "SERVER omnisci_local_csv WITH (file_path = '" +
                       getDataFilesPath() + "/" + "example_1_dir_archives/');";
   sql(query);
-  auto td = cat_->getMetadataForTable(default_table_name);
+  auto td = cat_->getMetadataForTable(default_table_name, false);
   ChunkKey key{cat_->getCurrentDB().dbId, td->tableId, 1, 0};
   ChunkKey table_key{cat_->getCurrentDB().dbId, td->tableId};
 
@@ -3689,6 +3688,43 @@
   sqlDropForeignTable();
 }
 
+TEST_F(RecoverCacheQueryTest, RecoverThenPopulateDataWrappersOnDemandVarLenParquet) {
+  sqlDropForeignTable();
+  std::string query = "CREATE FOREIGN TABLE " + default_table_name +
+                      " (t TEXT, i INTEGER[]) "s +
+                      "SERVER omnisci_local_parquet WITH (file_path = '" +
+                      getDataFilesPath() + "/" + "example_1.parquet');";
+  sql(query);
+  auto td = cat_->getMetadataForTable(default_table_name, false);
+  ChunkKey key{cat_->getCurrentDB().dbId, td->tableId, 1, 0};
+  ChunkKey table_key{cat_->getCurrentDB().dbId, td->tableId};
+
+  sqlAndCompareResult("SELECT COUNT(*) FROM " + default_table_name + ";", {{i(3)}});
+  ASSERT_FALSE(isTableDatawrapperRestored(default_table_name));
+
+  // Reset cache and clear memory representations.
+  resetStorageManagerAndClearTableMemory(table_key);
+
+  // Cache should be empty until query prompts recovery from disk
+  ASSERT_EQ(cache_->getNumCachedMetadata(), 0U);
+  ASSERT_EQ(cache_->getNumCachedChunks(), 0U);
+
+  ASSERT_TRUE(isTableDatawrapperDataOnDisk(default_table_name));
+
+  sqlAndCompareResult("SELECT * FROM " + default_table_name + "  ORDER BY t;",
+                      {{"a", array({i(1), i(1), i(1)})},
+                       {"aa", array({i(NULL_INT), i(2), i(2)})},
+                       {"aaa", array({i(3), i(NULL_INT), i(3)})}});
+
+  // 2 data + 1 index chunk
+  ASSERT_EQ(cache_->getNumCachedChunks(), 3U);
+  // Only 2 metadata
+  ASSERT_EQ(cache_->getNumCachedMetadata(), 2U);
+
+  ASSERT_TRUE(isTableDatawrapperRestored(default_table_name));
+  sqlDropForeignTable();
+}
+
 // Check that csv datawrapper metadata is generated and restored correctly for CSV
 // Archives
 TEST_F(RecoverCacheQueryTest, RecoverThenPopulateDataWrappersOnDemandFromCsvArchive) {
@@ -3698,7 +3734,7 @@
                       "SERVER omnisci_local_csv WITH (file_path = '" +
                       getDataFilesPath() + "/" + "example_1_multilevel.zip');";
   sql(query);
-  auto td = cat_->getMetadataForTable(default_table_name);
+  auto td = cat_->getMetadataForTable(default_table_name, false);
   ChunkKey key{cat_->getCurrentDB().dbId, td->tableId, 1, 0};
   ChunkKey table_key{cat_->getCurrentDB().dbId, td->tableId};
 
@@ -3738,7 +3774,7 @@
   sqlDropForeignTable();
   sqlCreateForeignTable("(col1 BIGINT)", "1", wrapper);
 
-  auto td = cat_->getMetadataForTable(default_table_name);
+  auto td = cat_->getMetadataForTable(default_table_name, false);
   ChunkKey key{cat_->getCurrentDB().dbId, td->tableId, 1, 0};
   ChunkKey table_key{cat_->getCurrentDB().dbId, td->tableId};
 
@@ -3797,7 +3833,7 @@
                       "', REFRESH_UPDATE_TYPE = 'APPEND');";
   sql(query);
 
-  auto td = cat_->getMetadataForTable(default_table_name);
+  auto td = cat_->getMetadataForTable(default_table_name, false);
   ChunkKey key{cat_->getCurrentDB().dbId, td->tableId, 1, 0};
   ChunkKey table_key{cat_->getCurrentDB().dbId, td->tableId};
 
diff -Naur ./Tests/GeospatialTest.cpp ../omniscidb-master/Tests/GeospatialTest.cpp
--- ./Tests/GeospatialTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/GeospatialTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -287,6 +287,31 @@
   }
 }
 
+void import_geospatial_multi_frag_test(const bool use_temporary_tables) {
+  const std::string geospatial_multi_frag_test(
+      "DROP TABLE IF EXISTS geospatial_multi_frag_test;");
+  run_ddl_statement(geospatial_multi_frag_test);
+  const auto create_ddl = build_create_table_statement(
+      "pt geometry(point, 4326), pt_none geometry(point, 4326) encoding none, pt_comp "
+      "geometry(point, 4326) encoding compressed(32)",
+      "geospatial_multi_frag_test",
+      {"", 0},
+      {},
+      2,
+      /*use_temporary_tables=*/use_temporary_tables,
+      /*deleted_support=*/true,
+      /*is_replicated=*/false);
+  run_ddl_statement(create_ddl);
+  TestHelpers::ValuesGenerator gen("geospatial_multi_frag_test");
+  for (size_t i = 0; i < 11; ++i) {
+    const std::string point{"'POINT(" + std::to_string(i) + " " + std::to_string(i) +
+                            ")'"};
+    run_multiple_agg(gen(point, point, point), ExecutorDeviceType::CPU);
+  }
+  run_multiple_agg("insert into geospatial_multi_frag_test values ('', '', '')",
+                   ExecutorDeviceType::CPU);
+}
+
 }  // namespace
 
 class GeoSpatialTestTablesFixture : public ::testing::TestWithParam<bool> {
@@ -2081,6 +2106,125 @@
                          GeoSpatialJoinTablesFixture,
                          ::testing::Values(true, false));
 
+class GeoSpatialMultiFragTestTablesFixture : public ::testing::TestWithParam<bool> {
+ protected:
+  void SetUp() override {
+    import_geospatial_multi_frag_test(/*with_temporary_tables=*/GetParam());
+  }
+
+  void TearDown() override {
+    if (!GetParam() && !g_keep_data) {
+      run_ddl_statement("DROP TABLE IF EXISTS geospatial_multi_frag_test;");
+    }
+  }
+};
+
+TEST_P(GeoSpatialMultiFragTestTablesFixture, LoopJoin) {
+  const auto enable_overlaps_hashjoin_state = g_enable_overlaps_hashjoin;
+  g_enable_overlaps_hashjoin = false;
+  ScopeGuard reset_overlaps_state = [&enable_overlaps_hashjoin_state] {
+    g_enable_overlaps_hashjoin = enable_overlaps_hashjoin_state;
+  };
+
+  // If GPU exists, check whether we get an exception related to varlen columnarization
+  // when query is executed on GPU
+  if (!skip_tests(ExecutorDeviceType::GPU)) {
+    EXPECT_THROW(
+        run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt, t2.pt) < 10;)",
+            ExecutorDeviceType::GPU),
+        std::runtime_error);
+  }
+
+  // skip to test GPU device until we fix the #5425 issue
+  for (auto dt : {ExecutorDeviceType::CPU}) {
+    ASSERT_EQ(
+        static_cast<int64_t>(109),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt, t2.pt) < 10;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(109),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_none, t2.pt_none) < 10;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(109),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_comp, t2.pt_comp) < 10;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(65),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt, t2.pt) < 5;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(65),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_none, t2.pt_none) < 5;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(65),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_comp, t2.pt_comp) < 5;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(11),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt, t2.pt) < 1;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(11),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_none, t2.pt_none) < 1;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(11),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_comp, t2.pt_comp) < 1;)",
+            dt)));
+
+    // valid rows: { pt(1 1), pt(2 2), ..., pt(10 10) }
+    // invalid rows: { pt(0 0), pt(null null) }
+    // expected rows in the resultset:
+    // row 1 ~ 10:  zero          | 10 valid rows
+    // row 11 ~ 20: 10 valid rows | zero
+    // row 21:      zero          | null
+    // row 22:      null          | zero
+    // row 23:      null          | null
+    // total 23 rows
+    ASSERT_EQ(
+        static_cast<int64_t>(23),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt, t2.pt) is null;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(23),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_none, t2.pt_none) is null;)",
+            dt)));
+
+    ASSERT_EQ(
+        static_cast<int64_t>(23),
+        v<int64_t>(run_simple_agg(
+            R"(SELECT count(*) FROM geospatial_multi_frag_test t1, geospatial_multi_frag_test t2 WHERE ST_DISTANCE(t1.pt_comp, t2.pt_comp) is null;)",
+            dt)));
+  }
+}
+
+INSTANTIATE_TEST_SUITE_P(GeospatialMultiFragExecutionTests,
+                         GeoSpatialMultiFragTestTablesFixture,
+                         ::testing::Values(true, false));
+
 int main(int argc, char** argv) {
   g_is_test_env = true;
 
diff -Naur ./Tests/OmniSQLCommandTest.cpp ../omniscidb-master/Tests/OmniSQLCommandTest.cpp
--- ./Tests/OmniSQLCommandTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/OmniSQLCommandTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -864,7 +864,11 @@
   static const char* test_filename = "export_unlikely_file_to_over_be_opened_1234.txt";
   std::string fake_input = std::string("\\export_dashboard simpledash ") + test_filename;
 
+#ifdef _WIN32
+  auto result = mkdir(test_filename);
+#else
   auto result = mkdir(test_filename, 0700);
+#endif
   EXPECT_EQ(result, 0);
 
   std::ostringstream test_capture_stream;
@@ -878,7 +882,7 @@
                                test_capture_stream)
           .is_resolved();
 
-  result = rmdir(test_filename);
+  result = ::rmdir(test_filename);
   EXPECT_EQ(result, 0);
 
   EXPECT_TRUE(resolution);
diff -Naur ./Tests/OmniSQLUtilitiesTest.cpp ../omniscidb-master/Tests/OmniSQLUtilitiesTest.cpp
--- ./Tests/OmniSQLUtilitiesTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/OmniSQLUtilitiesTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -25,7 +25,9 @@
 // Mocks
 
 using GetEnvRetType = decltype(DefaultEnvResolver().getenv(""));
+#ifndef _WIN32
 using GetPWUIDRetType = decltype(DefaultEnvResolver().getpwuid(0));
+#endif
 
 class DefaultUnitTestResolver {
  public:
@@ -33,20 +35,26 @@
   GetEnvRetType getenv(ARGS&&...) const {
     return nullptr;
   }
+#ifndef _WIN32
   template <typename... ARGS>
   GetPWUIDRetType getpwuid(ARGS&&...) const {
     return nullptr;
   }
+#endif
+  template <typename... ARGS>
+  const char* getpwdir(ARGS&&...) const {
+    return nullptr;
+  }
   auto getuid() const { return ::getuid(); }
 };
 
 class NoHomeNoPWEntResolver : public DefaultUnitTestResolver {};
 
-class NoHomePWEntResolver : public DefaultUnitTestResolver {
+class NoHomePWEntResolver : public DefaultEnvResolver {
  public:
   template <typename... ARGS>
-  GetPWUIDRetType getpwuid(ARGS&&... args) const {
-    return ::getpwuid(std::forward<ARGS>(args)...);
+  GetEnvRetType getenv(ARGS&&...) const {
+    return nullptr;
   }
 };
 
@@ -56,10 +64,16 @@
   GetEnvRetType getenv(ARGS&&... args) const {
     return DefaultEnvResolver::getenv(std::forward<ARGS>(args)...);
   }
+#ifndef _WIN32
   template <typename... ARGS>
   GetPWUIDRetType getpwuid(ARGS&&...) const {
     throw std::runtime_error("Unexpected getpwuid() invocation.");
   }
+#endif
+  template <typename... ARGS>
+  const char* getpwdir(ARGS&&...) const {
+    throw std::runtime_error("Unexpected getpwdir() invocation.");
+  }
 };
 
 // Mock-base class equivalents of CommandHistoryFile
@@ -73,22 +87,19 @@
   ASSERT_EQ(std::string(getDefaultHistoryFilename()), std::string(cmd_file));
 
   CommandHistoryFile_NoHomePWEnt cmd_file2;
-  ASSERT_EQ(std::string(getpwuid(getuid())->pw_dir) + '/' +
-                std::string(getDefaultHistoryFilename()),
+  ASSERT_EQ(getHomeDirectory() + '/' + std::string(getDefaultHistoryFilename()),
             std::string(cmd_file2));
 }
 
 TEST(CommandHistoryFile, HomeEnv) {
   CommandHistoryFile_Home cmd_file;
-  ASSERT_EQ(std::string(getpwuid(getuid())->pw_dir) + '/' +
-                std::string(getDefaultHistoryFilename()),
+  ASSERT_EQ(getHomeDirectory() + '/' + std::string(getDefaultHistoryFilename()),
             std::string(cmd_file));
 }
 
 TEST(CommandHistoryFile, Basic) {
   CommandHistoryFile cmd_file;
-  ASSERT_EQ(std::string(getpwuid(getuid())->pw_dir) + '/' +
-                std::string(getDefaultHistoryFilename()),
+  ASSERT_EQ(getHomeDirectory() + '/' + std::string(getDefaultHistoryFilename()),
             std::string(cmd_file));
 }
 
@@ -111,8 +122,7 @@
   po::store(po::command_line_parser(fake_argc, fake_argv).options(desc).run(), vm);
   po::notify(vm);
 
-  ASSERT_EQ(std::string(getpwuid(getuid())->pw_dir) + '/' +
-                std::string(getDefaultHistoryFilename()),
+  ASSERT_EQ(getHomeDirectory() + '/' + std::string(getDefaultHistoryFilename()),
             std::string(cmd_file));
 }
 
diff -Naur ./Tests/OverlapsJoinTest.cpp ../omniscidb-master/Tests/OverlapsJoinTest.cpp
--- ./Tests/OverlapsJoinTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/OverlapsJoinTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -91,7 +91,9 @@
     R"(create table does_intersect_b (id int,
                                       poly geometry(polygon, 4326),
                                       mpoly geometry(multipolygon, 4326),
-                                      pt geometry(point, 4326));
+                                      pt geometry(point, 4326),
+                                      x DOUBLE,
+                                      y DOUBLE);
     )",
     R"(create table does_not_intersect_a (id int,
                                         poly geometry(polygon, 4326),
@@ -133,13 +135,15 @@
        values (0,
               'polygon((0 0,30 0,30 0,30 30,0 0))',
               'multipolygon(((0 0,30 0,30 0,30 30,0 0)))',
-              'point(8 8)');
+              'point(8 8)',
+              8, 8);
     )",
     R"(insert into does_intersect_b
        values (1,
               'polygon((25 25,30 25,30 30,25 30,25 25))',
               'multipolygon(((25 25,30 25,30 30,25 30,25 25)))',
-              'point(28 28)');
+              'point(28 28)',
+              28, 28);
     )",
     R"(insert into does_not_intersect_a
        values (1,
@@ -226,6 +230,19 @@
         "SELECT count(*) from does_intersect_b as b JOIN "
         "does_intersect_a as a ON ST_Intersects(a.poly, b.pt);";
     ASSERT_EQ(static_cast<int64_t>(3), v<int64_t>(execSQL(sql, dt)));
+
+    sql =
+        "SELECT "
+        "count(*) from "
+        "does_intersect_b as b JOIN does_intersect_a as a ON ST_Intersects(a.poly, "
+        "ST_SetSRID(ST_Point(b.x, b.y), 4326));";
+    ASSERT_EQ(static_cast<int64_t>(3), v<int64_t>(execSQL(sql, dt)));
+
+    sql =
+        "SELECT count(*) from does_intersect_b as b JOIN "
+        "does_intersect_a as a ON ST_Intersects(a.poly, "
+        "ST_SetSRID(ST_Point(b.x, b.y), 4326));";
+    ASSERT_EQ(static_cast<int64_t>(3), v<int64_t>(execSQL(sql, dt)));
   });
 }
 
@@ -398,6 +415,13 @@
         "does_intersect_b as b JOIN does_intersect_a as a ON ST_Contains(a.poly, b.pt);";
     ASSERT_EQ(static_cast<int64_t>(3), v<int64_t>(execSQL(sql, dt)));
 
+    sql =
+        "SELECT "
+        "count(*) from "
+        "does_intersect_b as b JOIN does_intersect_a as a ON "
+        "ST_Contains(a.poly, ST_SetSRID(ST_Point(b.x, b.y), 4326));";
+    ASSERT_EQ(static_cast<int64_t>(3), v<int64_t>(execSQL(sql, dt)));
+
     // sql =
     //     "SELECT "
     //     "count(*) from "
@@ -427,6 +451,167 @@
   });
 }
 
+TEST_F(OverlapsTest, SkipHashtableCaching) {
+  const auto enable_overlaps_hashjoin_state = g_enable_overlaps_hashjoin;
+  const auto enable_hashjoin_many_to_many_state = g_enable_hashjoin_many_to_many;
+
+  g_enable_overlaps_hashjoin = true;
+  g_enable_hashjoin_many_to_many = true;
+  g_trivial_loop_join_threshold = 1;
+
+  ScopeGuard reset_overlaps_state = [&enable_overlaps_hashjoin_state,
+                                     &enable_hashjoin_many_to_many_state] {
+    g_enable_overlaps_hashjoin = enable_overlaps_hashjoin_state;
+    g_enable_overlaps_hashjoin = enable_hashjoin_many_to_many_state;
+    g_trivial_loop_join_threshold = 1000;
+  };
+
+  QR::get()->clearCpuMemory();
+  // check whether overlaps hashtable caching works properly
+  const auto q1 =
+      "SELECT count(*) FROM does_not_intersect_b as b JOIN does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q1, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)2);
+
+  const auto q2 =
+      "SELECT /*+ overlaps_bucket_threshold(0.2), overlaps_no_cache */ count(*) FROM "
+      "does_not_intersect_b as b JOIN does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q2, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)2);
+
+  QR::get()->clearCpuMemory();
+  execSQL(q2, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)0);
+
+  const auto q3 =
+      "SELECT /*+ overlaps_no_cache */ count(*) FROM does_not_intersect_b as b JOIN "
+      "does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q3, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)0);
+
+  const auto q4 =
+      "SELECT /*+ overlaps_max_size(1000), overlaps_no_cache */ count(*) FROM "
+      "does_not_intersect_b as b JOIN does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q4, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)0);
+
+  const auto q5 =
+      "SELECT /*+ overlaps_bucket_threshold(0.2), overlaps_max_size(1000), "
+      "overlaps_no_cache */ count(*) FROM does_not_intersect_b as b JOIN "
+      "does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q5, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)0);
+}
+
+TEST_F(OverlapsTest, CacheBehaviorUnderQueryHint) {
+  // consider the following symbols:
+  // T_E: bucket_threshold_hint_enabled
+  // T_D: bucket_threshold_hint_disabled (use default value)
+  // T_C: use calculated bucket_threshold value
+  //      by performing auto tuner with an initial value of T_D
+  // M_E: hashtable_max_size_hint_enabled
+  // M_D: hashtable_max_size_hint_disabled (use default value)
+
+  // here, we only add param setting to auto_tuner iff the initial setting is <T_D, *>
+  // but we try to keep a hashtable for every param setting
+
+  // let say a hashtable is built from the setting C as C ----> T
+  // then we reuse hashtable iff we have a cached hashtable which is mapped to C
+  // all combinations of <chosen bucket_threshold, max_hashtable_size> combination:
+  // <T_E, M_E> --> impossible, we use <T_E, M_D> instead since we skip M_E and set M_D
+  // <T_E, M_D> --> possible, but do not add the pair to auto_tuner_cache
+  //                and map <T_E, M_D> ----> T to hashtable cache
+  // <T_D, M_E> --> possible, and it is reintepreted as <T_C, M_E> by auto tuner
+  //                add map <T_D, M_D> ----> <T_C, M_E> to auto_tuner_cache
+  //                add map <T_C, M_E> ----> T to hashtable cache
+  // <T_D, M_D> --> possible, and it is reinterpreted as <T_C, M_D> by auto tuner
+  //                add map <T_D, M_D> ----> <T_C, M_D> to auto_tuner_cache
+  //                add map <T_C, M_D> ----> T to hashtable cache
+  // <T_C, M_E> --> possible, and comes from the initial setting of <T_D, M_E>
+  // <T_C, M_D> --> possible, and comes from the initial setting of <T_D, M_D>
+
+  QR::get()->clearCpuMemory();
+  const auto enable_overlaps_hashjoin_state = g_enable_overlaps_hashjoin;
+  const auto enable_hashjoin_many_to_many_state = g_enable_hashjoin_many_to_many;
+
+  g_enable_overlaps_hashjoin = true;
+  g_enable_hashjoin_many_to_many = true;
+  g_trivial_loop_join_threshold = 1;
+
+  ScopeGuard reset_overlaps_state = [&enable_overlaps_hashjoin_state,
+                                     &enable_hashjoin_many_to_many_state] {
+    g_enable_overlaps_hashjoin = enable_overlaps_hashjoin_state;
+    g_enable_overlaps_hashjoin = enable_hashjoin_many_to_many_state;
+    g_trivial_loop_join_threshold = 1000;
+  };
+
+  // <T_D, M_D> case, add both <T_C, M_D> to auto tuner and its hashtable to cache
+  const auto q1 =
+      "SELECT count(*) FROM does_not_intersect_b as b JOIN does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q1, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)2);
+
+  // <T_E, M_D> case, only add hashtable to cache with <T_E: 0.1, M_D>
+  const auto q2 =
+      "SELECT /*+ overlaps_bucket_threshold(0.1) */ count(*) FROM does_not_intersect_b "
+      "as b JOIN does_not_intersect_a as a ON ST_Intersects(a.poly, b.poly);";
+  execSQL(q2, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)3);
+
+  // <T_E, M_D> case... only add hashtable to cache with <T_E: 0.2, M_D>
+  const auto q3 =
+      "SELECT /*+ overlaps_bucket_threshold(0.2) */ count(*) FROM does_not_intersect_b "
+      "as b JOIN does_not_intersect_a as a ON ST_Intersects(a.poly, b.poly);";
+  execSQL(q3, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)4);
+
+  // only reuse cached hashtable for <T_E: 0.1, M_D>
+  const auto q4 =
+      "SELECT /*+ overlaps_bucket_threshold(0.1) */ count(*) FROM does_not_intersect_b "
+      "as b JOIN does_not_intersect_a as a ON ST_Intersects(a.poly, b.poly);";
+  execSQL(q4, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)4);
+
+  // skip max_size hint, so <T_E, M_D> case and only reuse <T_E: 0.1, M_D> hashtable
+  const auto q5 =
+      "SELECT /*+ overlaps_bucket_threshold(0.1), overlaps_max_size(1000) */ count(*) "
+      "FROM does_not_intersect_b as b JOIN does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q5, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)4);
+
+  // <T_D, M_E> case, so it now becomes <T_C, M_E>
+  // add <T_D, M_E> --> <T_C, M_E: 1000> mapping to auto_tuner
+  // add <T_C, M_E: 1000> hashtable to cache
+  const auto q6 =
+      "SELECT /*+ overlaps_max_size(1000) */ count(*) FROM does_not_intersect_b as b "
+      "JOIN does_not_intersect_a as a ON ST_Intersects(a.poly, b.poly);";
+  execSQL(q6, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)6);
+
+  // <T_E, M_D> case, only reuse cached hashtable of <T_E: 0.2, M_D>
+  const auto q7 =
+      "SELECT /*+ overlaps_max_size(1000), overlaps_bucket_threshold(0.2) */ count(*) "
+      "FROM does_not_intersect_b as b JOIN does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q7, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)6);
+
+  // <T_E, M_D> case... only add hashtable to cache with <T_E: 0.3, M_D>
+  const auto q8 =
+      "SELECT /*+ overlaps_max_size(1000), overlaps_bucket_threshold(0.3) */ count(*) "
+      "FROM does_not_intersect_b as b JOIN does_not_intersect_a as a ON "
+      "ST_Intersects(a.poly, b.poly);";
+  execSQL(q8, ExecutorDeviceType::CPU);
+  ASSERT_EQ(QR::get()->getNumberOfCachedOverlapsHashTables(), (size_t)7);
+}
+
 class OverlapsJoinHashTableMock : public OverlapsJoinHashTable {
  public:
   struct ExpectedValues {
@@ -479,7 +664,10 @@
                  const HashType layout,
                  const size_t shard_count,
                  const size_t entry_count,
-                 const size_t emitted_keys_count) final {
+                 const size_t emitted_keys_count,
+                 const bool skip_hashtable_caching,
+                 const size_t chosen_max_hashtable_size,
+                 const double chosen_bucket_threshold) final {
     EXPECT_LE(step_, expected_values_per_step_.size());
     auto& expected_values = expected_values_per_step_.back();
     EXPECT_EQ(entry_count, expected_values.entry_count);
@@ -490,9 +678,14 @@
   // returns entry_count, emitted_keys_count
   std::pair<size_t, size_t> approximateTupleCount(
       const std::vector<double>& bucket_sizes_for_dimension,
-      std::vector<ColumnsForDevice>& columns_per_device) final {
-    auto [entry_count, emitted_keys_count] = OverlapsJoinHashTable::approximateTupleCount(
-        bucket_sizes_for_dimension, columns_per_device);
+      std::vector<ColumnsForDevice>& columns_per_device,
+      const size_t chosen_max_hashtable_size,
+      const double chosen_bucket_threshold) final {
+    auto [entry_count, emitted_keys_count] =
+        OverlapsJoinHashTable::approximateTupleCount(bucket_sizes_for_dimension,
+                                                     columns_per_device,
+                                                     chosen_max_hashtable_size,
+                                                     chosen_bucket_threshold);
     return std::make_pair(entry_count, emitted_keys_count);
   }
 
@@ -500,10 +693,15 @@
   std::pair<size_t, size_t> computeHashTableCounts(
       const size_t shard_count,
       const std::vector<double>& bucket_sizes_for_dimension,
-      std::vector<ColumnsForDevice>& columns_per_device) final {
+      std::vector<ColumnsForDevice>& columns_per_device,
+      const size_t chosen_max_hashtable_size,
+      const double chosen_bucket_threshold) final {
     auto [entry_count, emitted_keys_count] =
-        OverlapsJoinHashTable::computeHashTableCounts(
-            shard_count, bucket_sizes_for_dimension, columns_per_device);
+        OverlapsJoinHashTable::computeHashTableCounts(shard_count,
+                                                      bucket_sizes_for_dimension,
+                                                      columns_per_device,
+                                                      chosen_max_hashtable_size,
+                                                      chosen_bucket_threshold);
     EXPECT_LT(step_, expected_values_per_step_.size());
     auto& expected_values = expected_values_per_step_[step_];
     EXPECT_EQ(entry_count, expected_values.entry_count);
diff -Naur ./Tests/PersistentStorageTest.cpp ../omniscidb-master/Tests/PersistentStorageTest.cpp
--- ./Tests/PersistentStorageTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/PersistentStorageTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -38,7 +38,7 @@
 
 TEST_F(PersistentStorageMgrTest, DiskCache_CustomPath) {
   PersistentStorageMgr psm(data_path, 0, {cache_path_, DiskCacheLevel::fsi});
-  ASSERT_EQ(psm.getDiskCache()->getGlobalFileMgr()->getBasePath(), cache_path_ + "/");
+  ASSERT_EQ(psm.getDiskCache()->getCacheDirectory(), cache_path_);
 }
 
 TEST_F(PersistentStorageMgrTest, DiskCache_InitializeWithoutCache) {
@@ -48,15 +48,15 @@
 
 TEST_F(PersistentStorageMgrTest, MutableDiskCache_CustomPath) {
   MutableCachePersistentStorageMgr psm(data_path, 0, {cache_path_, DiskCacheLevel::all});
-  ASSERT_EQ(psm.getDiskCache()->getGlobalFileMgr()->getBasePath(), cache_path_ + "/");
+  ASSERT_EQ(psm.getDiskCache()->getCacheDirectory(), cache_path_);
 }
 
 int main(int argc, char** argv) {
   TestHelpers::init_logger_stderr_only(argc, argv);
   testing::InitGoogleTest(&argc, argv);
   g_enable_fsi = true;
-
   int err{0};
+
   try {
     err = RUN_ALL_TESTS();
   } catch (const std::exception& e) {
diff -Naur ./Tests/PopulateTableRandom.cpp ../omniscidb-master/Tests/PopulateTableRandom.cpp
--- ./Tests/PopulateTableRandom.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/PopulateTableRandom.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -138,14 +138,14 @@
                              int max_len,
                              size_t& data_volumn) {
   std::default_random_engine gen;
-  std::uniform_int_distribution<int8_t> dist(INT8_MIN, INT8_MAX);
+  std::uniform_int_distribution<short> dist(INT8_MIN, INT8_MAX);
   std::uniform_int_distribution<> len_dist(0, max_len);
   size_t hash = 0;
   for (size_t n = 0; n < num_elems; n++) {
     int len = len_dist(gen);
     std::vector<int8_t> s(len);
     for (int i = 0; i < len; i++) {
-      s[i] = dist(gen);
+      s[i] = static_cast<int8_t>(dist(gen));
       boost::hash_combine(hash, s[i]);
     }
     stringVec[n] = s;
diff -Naur ./Tests/SQLHintTest.cpp ../omniscidb-master/Tests/SQLHintTest.cpp
--- ./Tests/SQLHintTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/SQLHintTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -151,9 +151,27 @@
         "SELECT /*+ overlaps_bucket_threshold(0.1) */ a.id FROM geospatial_test a "
         "INNER "
         "JOIN geospatial_inner_join_test b ON ST_Contains(b.poly, a.p);";
-    auto q1_hints = QR::get()->getParsedQueryHint(q4);
-    EXPECT_TRUE(q1_hints.isHintRegistered("overlaps_bucket_threshold") &&
-                approx_eq(q1_hints.overlaps_bucket_threshold, 0.1));
+    auto q4_hints = QR::get()->getParsedQueryHint(q4);
+    EXPECT_TRUE(q4_hints.isHintRegistered("overlaps_bucket_threshold") &&
+                approx_eq(q4_hints.overlaps_bucket_threshold, 0.1));
+  }
+  {
+    const auto q5 =
+        "SELECT /*+ overlaps_keys_per_bin(0.1) */ a.id FROM geospatial_test a "
+        "INNER "
+        "JOIN geospatial_inner_join_test b ON ST_Contains(b.poly, a.p);";
+    auto q5_hints = QR::get()->getParsedQueryHint(q5);
+    EXPECT_TRUE(q5_hints.isHintRegistered("overlaps_keys_per_bin") &&
+                approx_eq(q5_hints.overlaps_keys_per_bin, 0.1));
+  }
+  {
+    const auto q6 =
+        "SELECT /*+ overlaps_keys_per_bin(19980909.01) */ a.id FROM geospatial_test a "
+        "INNER "
+        "JOIN geospatial_inner_join_test b ON ST_Contains(b.poly, a.p);";
+    auto q6_hints = QR::get()->getParsedQueryHint(q6);
+    EXPECT_TRUE(q6_hints.isHintRegistered("overlaps_keys_per_bin") &&
+                approx_eq(q6_hints.overlaps_keys_per_bin, 19980909.01));
   }
 
   {
@@ -189,6 +207,24 @@
     auto wrong_q3_hints = QR::get()->getParsedQueryHint(wrong_q3);
     EXPECT_TRUE(!wrong_q3_hints.isHintRegistered("overlaps_max_size"));
   }
+  {
+    const auto wrong_q4 =
+        "SELECT /*+ overlaps_keys_per_bin(-0.1) */ a.id FROM geospatial_test a INNER "
+        "JOIN geospatial_inner_join_test b ON ST_Contains(b.poly, a.p);";
+    auto wrong_q4_hints = QR::get()->getParsedQueryHint(wrong_q4);
+    EXPECT_TRUE(!wrong_q4_hints.isHintRegistered("overlaps_keys_per_bin"));
+  }
+  {
+    // overlaps_keys_per_bin needs to below then DOUBLE_MAX
+    auto double_max = std::to_string(std::numeric_limits<double>::max());
+    const auto wrong_q5 =
+        "SELECT /*+ overlaps_keys_per_bin(" + double_max +
+        ") */ a.id "
+        "FROM geospatial_test a INNER JOIN geospatial_inner_join_test b "
+        "ON ST_Contains(b.poly, a.p);";
+    auto wrong_q5_hints = QR::get()->getParsedQueryHint(wrong_q5);
+    EXPECT_TRUE(!wrong_q5_hints.isHintRegistered("overlaps_keys_per_bin"));
+  }
 }
 
 int main(int argc, char** argv) {
diff -Naur ./Tests/ShowCommandsDdlTest.cpp ../omniscidb-master/Tests/ShowCommandsDdlTest.cpp
--- ./Tests/ShowCommandsDdlTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/ShowCommandsDdlTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -20,10 +20,10 @@
  */
 
 #include <gtest/gtest.h>
-
 #include "DBHandlerTestHelpers.h"
 #include "Shared/File.h"
 #include "TestHelpers.h"
+#include "boost/filesystem.hpp"
 
 #ifndef BASE_PATH
 #define BASE_PATH "./tmp"
@@ -1023,11 +1023,10 @@
  public:
   static inline constexpr int64_t epoch_file_size{2 * sizeof(int64_t)};
   static inline constexpr int64_t empty_mgr_size{0};
-  static inline const int64_t meta_only_size{epoch_file_size +
-                                             DEFAULT_METADATA_FILE_SIZE};
-  static inline const int64_t minimum_total_size{DEFAULT_DATA_FILE_SIZE + meta_only_size};
+  static inline constexpr int64_t meta_only_size{METADATA_PAGE_SIZE};
+  static inline constexpr int64_t minimum_total_size{DEFAULT_PAGE_SIZE + meta_only_size};
   // TODO(Misiu): These can be made constexpr once c++20 is supported.
-  static inline std::string cache_path_ = to_string(BASE_PATH) + "/omnisci_disk_cache/";
+  static inline std::string cache_path_ = to_string(BASE_PATH) + "/omnisci_disk_cache";
   static inline std::string foreign_table1{"foreign_table1"};
   static inline std::string foreign_table2{"foreign_table2"};
   static inline std::string foreign_table3{"foreign_table3"};
@@ -1039,6 +1038,7 @@
     sql("DROP DATABASE IF EXISTS test_db;");
     sql("CREATE DATABASE test_db;");
     login("admin", "HyperInteractive", "test_db");
+    getCatalog().getDataMgr().getPersistentStorageMgr()->getDiskCache()->clear();
   }
 
   static void TearDownTestSuite() {
@@ -1074,6 +1074,28 @@
         boost::filesystem::canonical("../../Tests/FsiDataFiles/0.parquet").string() +
         "');");
   }
+
+  uint64_t getWrapperSizeForTable(std::string& table_name) {
+    uint64_t space_used = 0;
+    auto& cat = getCatalog();
+    auto td = cat.getMetadataForTable(table_name, false);
+    std::string table_dir =
+        cache_path_ + "/" +
+        File_Namespace::get_dir_name_for_table(cat.getDatabaseId(), td->tableId);
+    if (boost::filesystem::exists(table_dir)) {
+      for (const auto& file :
+           boost::filesystem::recursive_directory_iterator(table_dir)) {
+        if (boost::filesystem::is_regular_file(file.path())) {
+          space_used += boost::filesystem::file_size(file.path());
+        }
+      }
+    }
+    return space_used;
+  }
+
+  uint64_t getMinSizeForTable(std::string& table_name) {
+    return minimum_total_size + getWrapperSizeForTable(table_name);
+  }
 };
 
 TEST_F(ShowDiskCacheUsageTest, SingleTable) {
@@ -1086,7 +1108,8 @@
   sqlCreateBasicForeignTable(foreign_table1);
 
   sql("SELECT * FROM " + foreign_table1 + ";");
-  sqlAndCompareResult("SHOW DISK CACHE USAGE;", {{foreign_table1, minimum_total_size}});
+  sqlAndCompareResult("SHOW DISK CACHE USAGE;",
+                      {{foreign_table1, i(getMinSizeForTable(foreign_table1))}});
 }
 
 TEST_F(ShowDiskCacheUsageTest, MultipleTables) {
@@ -1098,8 +1121,8 @@
   sql("SELECT * FROM " + foreign_table2 + ";");
 
   sqlAndCompareResult("SHOW DISK CACHE USAGE;",
-                      {{foreign_table1, minimum_total_size},
-                       {foreign_table2, minimum_total_size},
+                      {{foreign_table1, i(getMinSizeForTable(foreign_table1))},
+                       {foreign_table2, i(getMinSizeForTable(foreign_table2))},
                        {foreign_table3, empty_mgr_size}});
 }
 
@@ -1123,7 +1146,8 @@
 
   sqlAndCompareResult(
       "SHOW DISK CACHE USAGE " + foreign_table1 + ", " + foreign_table3 + ";",
-      {{foreign_table1, minimum_total_size}, {foreign_table3, empty_mgr_size}});
+      {{foreign_table1, i(getMinSizeForTable(foreign_table1))},
+       {foreign_table3, empty_mgr_size}});
 }
 
 TEST_F(ShowDiskCacheUsageTest, SingleTableDropped) {
@@ -1150,7 +1174,8 @@
   sql("SELECT * FROM " + foreign_table1 + ";");
   sql("REFRESH FOREIGN TABLES " + foreign_table1 + ";");
 
-  sqlAndCompareResult("SHOW DISK CACHE USAGE;", {{foreign_table1, minimum_total_size}});
+  sqlAndCompareResult("SHOW DISK CACHE USAGE;",
+                      {{foreign_table1, i(getMinSizeForTable(foreign_table1))}});
 }
 
 TEST_F(ShowDiskCacheUsageTest, SingleTableMetadataOnly) {
@@ -1158,7 +1183,9 @@
 
   sql("SELECT COUNT(*) FROM " + foreign_table1 + ";");
 
-  sqlAndCompareResult("SHOW DISK CACHE USAGE;", {{foreign_table1, meta_only_size}});
+  sqlAndCompareResult(
+      "SHOW DISK CACHE USAGE;",
+      {{foreign_table1, i(meta_only_size + getWrapperSizeForTable(foreign_table1))}});
 }
 
 TEST_F(ShowDiskCacheUsageTest, ForeignAndNormalTable) {
@@ -1168,8 +1195,23 @@
   sql("SELECT * FROM " + foreign_table1 + ";");
   sql("SELECT * FROM " + table1 + ";");
 
+  sqlAndCompareResult(
+      "SHOW DISK CACHE USAGE;",
+      {{foreign_table1, i(getMinSizeForTable(foreign_table1))}, {table1, i(0)}});
+}
+
+TEST_F(ShowDiskCacheUsageTest, MultipleChunks) {
+  sql("CREATE FOREIGN TABLE " + foreign_table1 +
+      " (t TEXT, i INTEGER[]) SERVER omnisci_local_parquet WITH "
+      "(file_path = '" +
+      boost::filesystem::canonical("../../Tests/FsiDataFiles/example_1.parquet")
+          .string() +
+      "');");
+  sql("SELECT * FROM " + foreign_table1 + ";");
   sqlAndCompareResult("SHOW DISK CACHE USAGE;",
-                      {{foreign_table1, minimum_total_size}, {table1, i(0)}});
+                      {{foreign_table1,
+                        i(getMinSizeForTable(foreign_table1) +
+                          (2 * (METADATA_PAGE_SIZE + DEFAULT_PAGE_SIZE)))}});
 }
 
 class ShowDiskCacheUsageForNormalTableTest : public ShowDiskCacheUsageTest {
@@ -1200,7 +1242,8 @@
   sql("SELECT * FROM " + foreign_table1 + ";");
 
   sqlAndCompareResult("SHOW DISK CACHE USAGE;",
-                      {{foreign_table1, minimum_total_size}, {table1, empty_mgr_size}});
+                      {{foreign_table1, i(getMinSizeForTable(foreign_table1))},
+                       {table1, empty_mgr_size}});
 }
 
 // If a table is initialized, but empty (it has a fileMgr, but no content), it will have
@@ -1214,7 +1257,8 @@
   sql("SELECT * FROM " + table1 + ";");
 
   sqlAndCompareResult("SHOW DISK CACHE USAGE;",
-                      {{foreign_table1, minimum_total_size}, {table1, epoch_file_size}});
+                      {{foreign_table1, i(getMinSizeForTable(foreign_table1))},
+                       {table1, empty_mgr_size}});
 }
 
 TEST_F(ShowDiskCacheUsageForNormalTableTest, NormalTableMinimum) {
@@ -1224,9 +1268,9 @@
   sql("SELECT * FROM " + foreign_table1 + ";");
   sql("INSERT INTO " + table1 + " VALUES('1');");
 
-  sqlAndCompareResult(
-      "SHOW DISK CACHE USAGE;",
-      {{foreign_table1, minimum_total_size}, {table1, minimum_total_size}});
+  sqlAndCompareResult("SHOW DISK CACHE USAGE;",
+                      {{foreign_table1, i(getMinSizeForTable(foreign_table1))},
+                       {table1, i(minimum_total_size * 2)}});
 }
 
 class ShowTableDetailsTest : public ShowTest,
@@ -1802,7 +1846,6 @@
   } catch (const std::exception& e) {
     LOG(ERROR) << e.what();
   }
-
   g_enable_fsi = false;
   return err;
 }
diff -Naur ./Tests/UtilTest.cpp ../omniscidb-master/Tests/UtilTest.cpp
--- ./Tests/UtilTest.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Tests/UtilTest.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -89,7 +89,7 @@
                                    static_cast<Unsigned>(interval.end - interval.begin));
       threads.push_back(std::async(
           std::launch::async,
-          [&array](Interval<Integer> interval) {
+          [&array, offset](Interval<Integer> interval) {
             for (Integer i = interval.begin; i < interval.end; ++i) {
               ++array.at(offset + i);
             }
diff -Naur ./ThirdParty/VulkanMemoryAllocator/LICENSE.txt ../omniscidb-master/ThirdParty/VulkanMemoryAllocator/LICENSE.txt
--- ./ThirdParty/VulkanMemoryAllocator/LICENSE.txt	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/VulkanMemoryAllocator/LICENSE.txt	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,19 @@
+Copyright (c) 2017-2020 Advanced Micro Devices, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff -Naur ./ThirdParty/VulkanMemoryAllocator/OmniSci_README.md ../omniscidb-master/ThirdParty/VulkanMemoryAllocator/OmniSci_README.md
--- ./ThirdParty/VulkanMemoryAllocator/OmniSci_README.md	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/VulkanMemoryAllocator/OmniSci_README.md	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,17 @@
+# Vulkan Memory Allocator
+
+Easy to integrate Vulkan memory allocation library.
+
+Upstream: https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator
+
+> Last Edited: Matt Torok, Feb 24th 2021
+
+## About this fork
+
+Fork repo (public): https://github.com/omnisci/VulkanMemoryAllocator
+ 
+This is an OmniSci fork of Vulkan Memory Allocator, branching from the official repo at hash `7eee5e3d262637400fe3b133f19025f980e20cad`.
+ 
+The main change is to add support for exportable memory. This is surfaced by adding the `VMA_POOL_CREATE_EXPORTABLE_BIT` flag to the `VmaPoolCreateFlagBits` enum used when creating memory pools. When this flag is set during pool creation, the VkDeviceMemory block allocated for that pool will have the `VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO` struct passed during Vulkan allocation calls made by VMA. It is still the caller's responsibility to choose the correct memory type and other options to support memory export; all the flag does is cause the Vulkan exportable struct to be added to the Vulkan allocation options.
+ 
+Due to the fact that VMA uses a slab allocator by default (a desirable property for us), the exportable option only works at the pool level. It makes all allocations in that pool exportable. You must then pass this pool to VMA allocation functions to allocate exportable memory. You can not make individual allocation exportable or un-exportable; only the pool.
\ No newline at end of file
diff -Naur ./ThirdParty/VulkanMemoryAllocator/vk_mem_alloc.h ../omniscidb-master/ThirdParty/VulkanMemoryAllocator/vk_mem_alloc.h
--- ./ThirdParty/VulkanMemoryAllocator/vk_mem_alloc.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/VulkanMemoryAllocator/vk_mem_alloc.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,19243 @@
+//
+// Copyright (c) 2017-2020 Advanced Micro Devices, Inc. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+//
+
+#ifndef AMD_VULKAN_MEMORY_ALLOCATOR_H
+#define AMD_VULKAN_MEMORY_ALLOCATOR_H
+
+/** \mainpage Vulkan Memory Allocator
+
+<b>Version 3.0.0-development</b> (2020-11-03)
+
+Copyright (c) 2017-2020 Advanced Micro Devices, Inc. All rights reserved. \n
+License: MIT
+
+Documentation of all members: vk_mem_alloc.h
+
+\section main_table_of_contents Table of contents
+
+- <b>User guide</b>
+  - \subpage quick_start
+    - [Project setup](@ref quick_start_project_setup)
+    - [Initialization](@ref quick_start_initialization)
+    - [Resource allocation](@ref quick_start_resource_allocation)
+  - \subpage choosing_memory_type
+    - [Usage](@ref choosing_memory_type_usage)
+    - [Required and preferred flags](@ref choosing_memory_type_required_preferred_flags)
+    - [Explicit memory types](@ref choosing_memory_type_explicit_memory_types)
+    - [Custom memory pools](@ref choosing_memory_type_custom_memory_pools)
+    - [Dedicated allocations](@ref choosing_memory_type_dedicated_allocations)
+  - \subpage memory_mapping
+    - [Mapping functions](@ref memory_mapping_mapping_functions)
+    - [Persistently mapped memory](@ref memory_mapping_persistently_mapped_memory)
+    - [Cache flush and invalidate](@ref memory_mapping_cache_control)
+    - [Finding out if memory is mappable](@ref memory_mapping_finding_if_memory_mappable)
+  - \subpage staying_within_budget
+    - [Querying for budget](@ref staying_within_budget_querying_for_budget)
+    - [Controlling memory usage](@ref staying_within_budget_controlling_memory_usage)
+  - \subpage resource_aliasing
+  - \subpage custom_memory_pools
+    - [Choosing memory type index](@ref custom_memory_pools_MemTypeIndex)
+    - [Linear allocation algorithm](@ref linear_algorithm)
+      - [Free-at-once](@ref linear_algorithm_free_at_once)
+      - [Stack](@ref linear_algorithm_stack)
+      - [Double stack](@ref linear_algorithm_double_stack)
+      - [Ring buffer](@ref linear_algorithm_ring_buffer)
+    - [Buddy allocation algorithm](@ref buddy_algorithm)
+  - \subpage defragmentation
+      - [Defragmenting CPU memory](@ref defragmentation_cpu)
+      - [Defragmenting GPU memory](@ref defragmentation_gpu)
+      - [Additional notes](@ref defragmentation_additional_notes)
+      - [Writing custom allocation algorithm](@ref defragmentation_custom_algorithm)
+  - \subpage lost_allocations
+  - \subpage statistics
+    - [Numeric statistics](@ref statistics_numeric_statistics)
+    - [JSON dump](@ref statistics_json_dump)
+  - \subpage allocation_annotation
+    - [Allocation user data](@ref allocation_user_data)
+    - [Allocation names](@ref allocation_names)
+  - \subpage debugging_memory_usage
+    - [Memory initialization](@ref debugging_memory_usage_initialization)
+    - [Margins](@ref debugging_memory_usage_margins)
+    - [Corruption detection](@ref debugging_memory_usage_corruption_detection)
+  - \subpage record_and_replay
+- \subpage usage_patterns
+  - [Common mistakes](@ref usage_patterns_common_mistakes)
+  - [Simple patterns](@ref usage_patterns_simple)
+  - [Advanced patterns](@ref usage_patterns_advanced)
+- \subpage configuration
+  - [Pointers to Vulkan functions](@ref config_Vulkan_functions)
+  - [Custom host memory allocator](@ref custom_memory_allocator)
+  - [Device memory allocation callbacks](@ref allocation_callbacks)
+  - [Device heap memory limit](@ref heap_memory_limit)
+  - \subpage vk_khr_dedicated_allocation
+  - \subpage enabling_buffer_device_address
+  - \subpage vk_amd_device_coherent_memory
+- \subpage general_considerations
+  - [Thread safety](@ref general_considerations_thread_safety)
+  - [Validation layer warnings](@ref general_considerations_validation_layer_warnings)
+  - [Allocation algorithm](@ref general_considerations_allocation_algorithm)
+  - [Features not supported](@ref general_considerations_features_not_supported)
+
+\section main_see_also See also
+
+- [Product page on GPUOpen](https://gpuopen.com/gaming-product/vulkan-memory-allocator/)
+- [Source repository on GitHub](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator)
+
+
+
+
+\page quick_start Quick start
+
+\section quick_start_project_setup Project setup
+
+Vulkan Memory Allocator comes in form of a "stb-style" single header file.
+You don't need to build it as a separate library project.
+You can add this file directly to your project and submit it to code repository next to your other source files.
+
+"Single header" doesn't mean that everything is contained in C/C++ declarations,
+like it tends to be in case of inline functions or C++ templates.
+It means that implementation is bundled with interface in a single file and needs to be extracted using preprocessor macro.
+If you don't do it properly, you will get linker errors.
+
+To do it properly:
+
+-# Include "vk_mem_alloc.h" file in each CPP file where you want to use the library.
+   This includes declarations of all members of the library.
+-# In exacly one CPP file define following macro before this include.
+   It enables also internal definitions.
+
+\code
+#define VMA_IMPLEMENTATION
+#include "vk_mem_alloc.h"
+\endcode
+
+It may be a good idea to create dedicated CPP file just for this purpose.
+
+Note on language: This library is written in C++, but has C-compatible interface.
+Thus you can include and use vk_mem_alloc.h in C or C++ code, but full
+implementation with `VMA_IMPLEMENTATION` macro must be compiled as C++, NOT as C.
+
+Please note that this library includes header `<vulkan/vulkan.h>`, which in turn
+includes `<windows.h>` on Windows. If you need some specific macros defined
+before including these headers (like `WIN32_LEAN_AND_MEAN` or
+`WINVER` for Windows, `VK_USE_PLATFORM_WIN32_KHR` for Vulkan), you must define
+them before every `#include` of this library.
+
+You may need to configure the way you import Vulkan functions.
+
+- By default, VMA assumes you you link statically with Vulkan API. If this is not the case,
+  `#define VMA_STATIC_VULKAN_FUNCTIONS 0` before `#include` of the VMA implementation and use another way.
+- You can `#define VMA_DYNAMIC_VULKAN_FUNCTIONS 1` and make sure `vkGetInstanceProcAddr` and `vkGetDeviceProcAddr` globals are defined.
+  All the remaining Vulkan functions will be fetched automatically.
+- Finally, you can provide your own pointers to all Vulkan functions needed by VMA using structure member
+  VmaAllocatorCreateInfo::pVulkanFunctions, if you fetched them in some custom way e.g. using some loader like [Volk](https://github.com/zeux/volk).
+
+
+\section quick_start_initialization Initialization
+
+At program startup:
+
+-# Initialize Vulkan to have `VkPhysicalDevice`, `VkDevice` and `VkInstance` object.
+-# Fill VmaAllocatorCreateInfo structure and create #VmaAllocator object by
+   calling vmaCreateAllocator().
+
+\code
+VmaAllocatorCreateInfo allocatorInfo = {};
+allocatorInfo.vulkanApiVersion = VK_API_VERSION_1_2;
+allocatorInfo.physicalDevice = physicalDevice;
+allocatorInfo.device = device;
+allocatorInfo.instance = instance;
+
+VmaAllocator allocator;
+vmaCreateAllocator(&allocatorInfo, &allocator);
+\endcode
+
+Only members `physicalDevice`, `device`, `instance` are required.
+However, you should inform the library which Vulkan version do you use by setting
+VmaAllocatorCreateInfo::vulkanApiVersion and which extensions did you enable
+by setting VmaAllocatorCreateInfo::flags (like #VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT for VK_KHR_buffer_device_address).
+Otherwise, VMA would use only features of Vulkan 1.0 core with no extensions.
+
+
+\section quick_start_resource_allocation Resource allocation
+
+When you want to create a buffer or image:
+
+-# Fill `VkBufferCreateInfo` / `VkImageCreateInfo` structure.
+-# Fill VmaAllocationCreateInfo structure.
+-# Call vmaCreateBuffer() / vmaCreateImage() to get `VkBuffer`/`VkImage` with memory
+   already allocated and bound to it.
+
+\code
+VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+bufferInfo.size = 65536;
+bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+
+VmaAllocationCreateInfo allocInfo = {};
+allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+
+VkBuffer buffer;
+VmaAllocation allocation;
+vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
+\endcode
+
+Don't forget to destroy your objects when no longer needed:
+
+\code
+vmaDestroyBuffer(allocator, buffer, allocation);
+vmaDestroyAllocator(allocator);
+\endcode
+
+
+\page choosing_memory_type Choosing memory type
+
+Physical devices in Vulkan support various combinations of memory heaps and
+types. Help with choosing correct and optimal memory type for your specific
+resource is one of the key features of this library. You can use it by filling
+appropriate members of VmaAllocationCreateInfo structure, as described below.
+You can also combine multiple methods.
+
+-# If you just want to find memory type index that meets your requirements, you
+   can use function: vmaFindMemoryTypeIndex(), vmaFindMemoryTypeIndexForBufferInfo(),
+   vmaFindMemoryTypeIndexForImageInfo().
+-# If you want to allocate a region of device memory without association with any
+   specific image or buffer, you can use function vmaAllocateMemory(). Usage of
+   this function is not recommended and usually not needed.
+   vmaAllocateMemoryPages() function is also provided for creating multiple allocations at once,
+   which may be useful for sparse binding.
+-# If you already have a buffer or an image created, you want to allocate memory
+   for it and then you will bind it yourself, you can use function
+   vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage().
+   For binding you should use functions: vmaBindBufferMemory(), vmaBindImageMemory()
+   or their extended versions: vmaBindBufferMemory2(), vmaBindImageMemory2().
+-# If you want to create a buffer or an image, allocate memory for it and bind
+   them together, all in one call, you can use function vmaCreateBuffer(),
+   vmaCreateImage(). This is the easiest and recommended way to use this library.
+
+When using 3. or 4., the library internally queries Vulkan for memory types
+supported for that buffer or image (function `vkGetBufferMemoryRequirements()`)
+and uses only one of these types.
+
+If no memory type can be found that meets all the requirements, these functions
+return `VK_ERROR_FEATURE_NOT_PRESENT`.
+
+You can leave VmaAllocationCreateInfo structure completely filled with zeros.
+It means no requirements are specified for memory type.
+It is valid, although not very useful.
+
+\section choosing_memory_type_usage Usage
+
+The easiest way to specify memory requirements is to fill member
+VmaAllocationCreateInfo::usage using one of the values of enum #VmaMemoryUsage.
+It defines high level, common usage types.
+For more details, see description of this enum.
+
+For example, if you want to create a uniform buffer that will be filled using
+transfer only once or infrequently and used for rendering every frame, you can
+do it using following code:
+
+\code
+VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+bufferInfo.size = 65536;
+bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+
+VmaAllocationCreateInfo allocInfo = {};
+allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+
+VkBuffer buffer;
+VmaAllocation allocation;
+vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
+\endcode
+
+\section choosing_memory_type_required_preferred_flags Required and preferred flags
+
+You can specify more detailed requirements by filling members
+VmaAllocationCreateInfo::requiredFlags and VmaAllocationCreateInfo::preferredFlags
+with a combination of bits from enum `VkMemoryPropertyFlags`. For example,
+if you want to create a buffer that will be persistently mapped on host (so it
+must be `HOST_VISIBLE`) and preferably will also be `HOST_COHERENT` and `HOST_CACHED`,
+use following code:
+
+\code
+VmaAllocationCreateInfo allocInfo = {};
+allocInfo.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
+allocInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
+allocInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;
+
+VkBuffer buffer;
+VmaAllocation allocation;
+vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
+\endcode
+
+A memory type is chosen that has all the required flags and as many preferred
+flags set as possible.
+
+If you use VmaAllocationCreateInfo::usage, it is just internally converted to
+a set of required and preferred flags.
+
+\section choosing_memory_type_explicit_memory_types Explicit memory types
+
+If you inspected memory types available on the physical device and you have
+a preference for memory types that you want to use, you can fill member
+VmaAllocationCreateInfo::memoryTypeBits. It is a bit mask, where each bit set
+means that a memory type with that index is allowed to be used for the
+allocation. Special value 0, just like `UINT32_MAX`, means there are no
+restrictions to memory type index.
+
+Please note that this member is NOT just a memory type index.
+Still you can use it to choose just one, specific memory type.
+For example, if you already determined that your buffer should be created in
+memory type 2, use following code:
+
+\code
+uint32_t memoryTypeIndex = 2;
+
+VmaAllocationCreateInfo allocInfo = {};
+allocInfo.memoryTypeBits = 1u << memoryTypeIndex;
+
+VkBuffer buffer;
+VmaAllocation allocation;
+vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
+\endcode
+
+
+\section choosing_memory_type_custom_memory_pools Custom memory pools
+
+If you allocate from custom memory pool, all the ways of specifying memory
+requirements described above are not applicable and the aforementioned members
+of VmaAllocationCreateInfo structure are ignored. Memory type is selected
+explicitly when creating the pool and then used to make all the allocations from
+that pool. For further details, see \ref custom_memory_pools.
+
+\section choosing_memory_type_dedicated_allocations Dedicated allocations
+
+Memory for allocations is reserved out of larger block of `VkDeviceMemory`
+allocated from Vulkan internally. That's the main feature of this whole library.
+You can still request a separate memory block to be created for an allocation,
+just like you would do in a trivial solution without using any allocator.
+In that case, a buffer or image is always bound to that memory at offset 0.
+This is called a "dedicated allocation".
+You can explicitly request it by using flag #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
+The library can also internally decide to use dedicated allocation in some cases, e.g.:
+
+- When the size of the allocation is large.
+- When [VK_KHR_dedicated_allocation](@ref vk_khr_dedicated_allocation) extension is enabled
+  and it reports that dedicated allocation is required or recommended for the resource.
+- When allocation of next big memory block fails due to not enough device memory,
+  but allocation with the exact requested size succeeds.
+
+
+\page memory_mapping Memory mapping
+
+To "map memory" in Vulkan means to obtain a CPU pointer to `VkDeviceMemory`,
+to be able to read from it or write to it in CPU code.
+Mapping is possible only of memory allocated from a memory type that has
+`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.
+Functions `vkMapMemory()`, `vkUnmapMemory()` are designed for this purpose.
+You can use them directly with memory allocated by this library,
+but it is not recommended because of following issue:
+Mapping the same `VkDeviceMemory` block multiple times is illegal - only one mapping at a time is allowed.
+This includes mapping disjoint regions. Mapping is not reference-counted internally by Vulkan.
+Because of this, Vulkan Memory Allocator provides following facilities:
+
+\section memory_mapping_mapping_functions Mapping functions
+
+The library provides following functions for mapping of a specific #VmaAllocation: vmaMapMemory(), vmaUnmapMemory().
+They are safer and more convenient to use than standard Vulkan functions.
+You can map an allocation multiple times simultaneously - mapping is reference-counted internally.
+You can also map different allocations simultaneously regardless of whether they use the same `VkDeviceMemory` block.
+The way it's implemented is that the library always maps entire memory block, not just region of the allocation.
+For further details, see description of vmaMapMemory() function.
+Example:
+
+\code
+// Having these objects initialized:
+
+struct ConstantBuffer
+{
+    ...
+};
+ConstantBuffer constantBufferData;
+
+VmaAllocator allocator;
+VkBuffer constantBuffer;
+VmaAllocation constantBufferAllocation;
+
+// You can map and fill your buffer using following code:
+
+void* mappedData;
+vmaMapMemory(allocator, constantBufferAllocation, &mappedData);
+memcpy(mappedData, &constantBufferData, sizeof(constantBufferData));
+vmaUnmapMemory(allocator, constantBufferAllocation);
+\endcode
+
+When mapping, you may see a warning from Vulkan validation layer similar to this one:
+
+<i>Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.</i>
+
+It happens because the library maps entire `VkDeviceMemory` block, where different
+types of images and buffers may end up together, especially on GPUs with unified memory like Intel.
+You can safely ignore it if you are sure you access only memory of the intended
+object that you wanted to map.
+
+
+\section memory_mapping_persistently_mapped_memory Persistently mapped memory
+
+Kepping your memory persistently mapped is generally OK in Vulkan.
+You don't need to unmap it before using its data on the GPU.
+The library provides a special feature designed for that:
+Allocations made with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag set in
+VmaAllocationCreateInfo::flags stay mapped all the time,
+so you can just access CPU pointer to it any time
+without a need to call any "map" or "unmap" function.
+Example:
+
+\code
+VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+bufCreateInfo.size = sizeof(ConstantBuffer);
+bufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.usage = VMA_MEMORY_USAGE_CPU_ONLY;
+allocCreateInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;
+
+VkBuffer buf;
+VmaAllocation alloc;
+VmaAllocationInfo allocInfo;
+vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);
+
+// Buffer is already mapped. You can access its memory.
+memcpy(allocInfo.pMappedData, &constantBufferData, sizeof(constantBufferData));
+\endcode
+
+There are some exceptions though, when you should consider mapping memory only for a short period of time:
+
+- When operating system is Windows 7 or 8.x (Windows 10 is not affected because it uses WDDM2),
+  device is discrete AMD GPU,
+  and memory type is the special 256 MiB pool of `DEVICE_LOCAL + HOST_VISIBLE` memory
+  (selected when you use #VMA_MEMORY_USAGE_CPU_TO_GPU),
+  then whenever a memory block allocated from this memory type stays mapped
+  for the time of any call to `vkQueueSubmit()` or `vkQueuePresentKHR()`, this
+  block is migrated by WDDM to system RAM, which degrades performance. It doesn't
+  matter if that particular memory block is actually used by the command buffer
+  being submitted.
+- On Mac/MoltenVK there is a known bug - [Issue #175](https://github.com/KhronosGroup/MoltenVK/issues/175)
+  which requires unmapping before GPU can see updated texture.
+- Keeping many large memory blocks mapped may impact performance or stability of some debugging tools.
+
+\section memory_mapping_cache_control Cache flush and invalidate
+
+Memory in Vulkan doesn't need to be unmapped before using it on GPU,
+but unless a memory types has `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` flag set,
+you need to manually **invalidate** cache before reading of mapped pointer
+and **flush** cache after writing to mapped pointer.
+Map/unmap operations don't do that automatically.
+Vulkan provides following functions for this purpose `vkFlushMappedMemoryRanges()`,
+`vkInvalidateMappedMemoryRanges()`, but this library provides more convenient
+functions that refer to given allocation object: vmaFlushAllocation(),
+vmaInvalidateAllocation(),
+or multiple objects at once: vmaFlushAllocations(), vmaInvalidateAllocations().
+
+Regions of memory specified for flush/invalidate must be aligned to
+`VkPhysicalDeviceLimits::nonCoherentAtomSize`. This is automatically ensured by the library.
+In any memory type that is `HOST_VISIBLE` but not `HOST_COHERENT`, all allocations
+within blocks are aligned to this value, so their offsets are always multiply of
+`nonCoherentAtomSize` and two different allocations never share same "line" of this size.
+
+Please note that memory allocated with #VMA_MEMORY_USAGE_CPU_ONLY is guaranteed to be `HOST_COHERENT`.
+
+Also, Windows drivers from all 3 **PC** GPU vendors (AMD, Intel, NVIDIA)
+currently provide `HOST_COHERENT` flag on all memory types that are
+`HOST_VISIBLE`, so on this platform you may not need to bother.
+
+\section memory_mapping_finding_if_memory_mappable Finding out if memory is mappable
+
+It may happen that your allocation ends up in memory that is `HOST_VISIBLE` (available for mapping)
+despite it wasn't explicitly requested.
+For example, application may work on integrated graphics with unified memory (like Intel) or
+allocation from video memory might have failed, so the library chose system memory as fallback.
+
+You can detect this case and map such allocation to access its memory on CPU directly,
+instead of launching a transfer operation.
+In order to do that: inspect `allocInfo.memoryType`, call vmaGetMemoryTypeProperties(),
+and look for `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag in properties of that memory type.
+
+\code
+VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+bufCreateInfo.size = sizeof(ConstantBuffer);
+bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+allocCreateInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
+
+VkBuffer buf;
+VmaAllocation alloc;
+VmaAllocationInfo allocInfo;
+vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);
+
+VkMemoryPropertyFlags memFlags;
+vmaGetMemoryTypeProperties(allocator, allocInfo.memoryType, &memFlags);
+if((memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0)
+{
+    // Allocation ended up in mappable memory. You can map it and access it directly.
+    void* mappedData;
+    vmaMapMemory(allocator, alloc, &mappedData);
+    memcpy(mappedData, &constantBufferData, sizeof(constantBufferData));
+    vmaUnmapMemory(allocator, alloc);
+}
+else
+{
+    // Allocation ended up in non-mappable memory.
+    // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
+}
+\endcode
+
+You can even use #VMA_ALLOCATION_CREATE_MAPPED_BIT flag while creating allocations
+that are not necessarily `HOST_VISIBLE` (e.g. using #VMA_MEMORY_USAGE_GPU_ONLY).
+If the allocation ends up in memory type that is `HOST_VISIBLE`, it will be persistently mapped and you can use it directly.
+If not, the flag is just ignored.
+Example:
+
+\code
+VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+bufCreateInfo.size = sizeof(ConstantBuffer);
+bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+allocCreateInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;
+
+VkBuffer buf;
+VmaAllocation alloc;
+VmaAllocationInfo allocInfo;
+vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);
+
+if(allocInfo.pMappedData != nullptr)
+{
+    // Allocation ended up in mappable memory.
+    // It's persistently mapped. You can access it directly.
+    memcpy(allocInfo.pMappedData, &constantBufferData, sizeof(constantBufferData));
+}
+else
+{
+    // Allocation ended up in non-mappable memory.
+    // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
+}
+\endcode
+
+
+\page staying_within_budget Staying within budget
+
+When developing a graphics-intensive game or program, it is important to avoid allocating
+more GPU memory than it's physically available. When the memory is over-committed,
+various bad things can happen, depending on the specific GPU, graphics driver, and
+operating system:
+
+- It may just work without any problems.
+- The application may slow down because some memory blocks are moved to system RAM
+  and the GPU has to access them through PCI Express bus.
+- A new allocation may take very long time to complete, even few seconds, and possibly
+  freeze entire system.
+- The new allocation may fail with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
+- It may even result in GPU crash (TDR), observed as `VK_ERROR_DEVICE_LOST`
+  returned somewhere later.
+
+\section staying_within_budget_querying_for_budget Querying for budget
+
+To query for current memory usage and available budget, use function vmaGetBudget().
+Returned structure #VmaBudget contains quantities expressed in bytes, per Vulkan memory heap.
+
+Please note that this function returns different information and works faster than
+vmaCalculateStats(). vmaGetBudget() can be called every frame or even before every
+allocation, while vmaCalculateStats() is intended to be used rarely,
+only to obtain statistical information, e.g. for debugging purposes.
+
+It is recommended to use <b>VK_EXT_memory_budget</b> device extension to obtain information
+about the budget from Vulkan device. VMA is able to use this extension automatically.
+When not enabled, the allocator behaves same way, but then it estimates current usage
+and available budget based on its internal information and Vulkan memory heap sizes,
+which may be less precise. In order to use this extension:
+
+1. Make sure extensions VK_EXT_memory_budget and VK_KHR_get_physical_device_properties2
+   required by it are available and enable them. Please note that the first is a device
+   extension and the second is instance extension!
+2. Use flag #VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT when creating #VmaAllocator object.
+3. Make sure to call vmaSetCurrentFrameIndex() every frame. Budget is queried from
+   Vulkan inside of it to avoid overhead of querying it with every allocation.
+
+\section staying_within_budget_controlling_memory_usage Controlling memory usage
+
+There are many ways in which you can try to stay within the budget.
+
+First, when making new allocation requires allocating a new memory block, the library
+tries not to exceed the budget automatically. If a block with default recommended size
+(e.g. 256 MB) would go over budget, a smaller block is allocated, possibly even
+dedicated memory for just this resource.
+
+If the size of the requested resource plus current memory usage is more than the
+budget, by default the library still tries to create it, leaving it to the Vulkan
+implementation whether the allocation succeeds or fails. You can change this behavior
+by using #VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT flag. With it, the allocation is
+not made if it would exceed the budget or if the budget is already exceeded.
+Some other allocations become lost instead to make room for it, if the mechanism of
+[lost allocations](@ref lost_allocations) is used.
+If that is not possible, the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
+Example usage pattern may be to pass the #VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT flag
+when creating resources that are not essential for the application (e.g. the texture
+of a specific object) and not to pass it when creating critically important resources
+(e.g. render targets).
+
+Finally, you can also use #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT flag to make sure
+a new allocation is created only when it fits inside one of the existing memory blocks.
+If it would require to allocate a new block, if fails instead with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
+This also ensures that the function call is very fast because it never goes to Vulkan
+to obtain a new block.
+
+Please note that creating \ref custom_memory_pools with VmaPoolCreateInfo::minBlockCount
+set to more than 0 will try to allocate memory blocks without checking whether they
+fit within budget.
+
+
+\page resource_aliasing Resource aliasing (overlap)
+
+New explicit graphics APIs (Vulkan and Direct3D 12), thanks to manual memory
+management, give an opportunity to alias (overlap) multiple resources in the
+same region of memory - a feature not available in the old APIs (Direct3D 11, OpenGL).
+It can be useful to save video memory, but it must be used with caution.
+
+For example, if you know the flow of your whole render frame in advance, you
+are going to use some intermediate textures or buffers only during a small range of render passes,
+and you know these ranges don't overlap in time, you can bind these resources to
+the same place in memory, even if they have completely different parameters (width, height, format etc.).
+
+![Resource aliasing (overlap)](../gfx/Aliasing.png)
+
+Such scenario is possible using VMA, but you need to create your images manually.
+Then you need to calculate parameters of an allocation to be made using formula:
+
+- allocation size = max(size of each image)
+- allocation alignment = max(alignment of each image)
+- allocation memoryTypeBits = bitwise AND(memoryTypeBits of each image)
+
+Following example shows two different images bound to the same place in memory,
+allocated to fit largest of them.
+
+\code
+// A 512x512 texture to be sampled.
+VkImageCreateInfo img1CreateInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
+img1CreateInfo.imageType = VK_IMAGE_TYPE_2D;
+img1CreateInfo.extent.width = 512;
+img1CreateInfo.extent.height = 512;
+img1CreateInfo.extent.depth = 1;
+img1CreateInfo.mipLevels = 10;
+img1CreateInfo.arrayLayers = 1;
+img1CreateInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
+img1CreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
+img1CreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+img1CreateInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
+img1CreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+
+// A full screen texture to be used as color attachment.
+VkImageCreateInfo img2CreateInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
+img2CreateInfo.imageType = VK_IMAGE_TYPE_2D;
+img2CreateInfo.extent.width = 1920;
+img2CreateInfo.extent.height = 1080;
+img2CreateInfo.extent.depth = 1;
+img2CreateInfo.mipLevels = 1;
+img2CreateInfo.arrayLayers = 1;
+img2CreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
+img2CreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
+img2CreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+img2CreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
+img2CreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+
+VkImage img1;
+res = vkCreateImage(device, &img1CreateInfo, nullptr, &img1);
+VkImage img2;
+res = vkCreateImage(device, &img2CreateInfo, nullptr, &img2);
+
+VkMemoryRequirements img1MemReq;
+vkGetImageMemoryRequirements(device, img1, &img1MemReq);
+VkMemoryRequirements img2MemReq;
+vkGetImageMemoryRequirements(device, img2, &img2MemReq);
+
+VkMemoryRequirements finalMemReq = {};
+finalMemReq.size = std::max(img1MemReq.size, img2MemReq.size);
+finalMemReq.alignment = std::max(img1MemReq.alignment, img2MemReq.alignment);
+finalMemReq.memoryTypeBits = img1MemReq.memoryTypeBits & img2MemReq.memoryTypeBits;
+// Validate if(finalMemReq.memoryTypeBits != 0)
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+
+VmaAllocation alloc;
+res = vmaAllocateMemory(allocator, &finalMemReq, &allocCreateInfo, &alloc, nullptr);
+
+res = vmaBindImageMemory(allocator, alloc, img1);
+res = vmaBindImageMemory(allocator, alloc, img2);
+
+// You can use img1, img2 here, but not at the same time!
+
+vmaFreeMemory(allocator, alloc);
+vkDestroyImage(allocator, img2, nullptr);
+vkDestroyImage(allocator, img1, nullptr);
+\endcode
+
+Remember that using resouces that alias in memory requires proper synchronization.
+You need to issue a memory barrier to make sure commands that use `img1` and `img2`
+don't overlap on GPU timeline.
+You also need to treat a resource after aliasing as uninitialized - containing garbage data.
+For example, if you use `img1` and then want to use `img2`, you need to issue
+an image memory barrier for `img2` with `oldLayout` = `VK_IMAGE_LAYOUT_UNDEFINED`.
+
+Additional considerations:
+
+- Vulkan also allows to interpret contents of memory between aliasing resources consistently in some cases.
+See chapter 11.8. "Memory Aliasing" of Vulkan specification or `VK_IMAGE_CREATE_ALIAS_BIT` flag.
+- You can create more complex layout where different images and buffers are bound
+at different offsets inside one large allocation. For example, one can imagine
+a big texture used in some render passes, aliasing with a set of many small buffers
+used between in some further passes. To bind a resource at non-zero offset of an allocation,
+use vmaBindBufferMemory2() / vmaBindImageMemory2().
+- Before allocating memory for the resources you want to alias, check `memoryTypeBits`
+returned in memory requirements of each resource to make sure the bits overlap.
+Some GPUs may expose multiple memory types suitable e.g. only for buffers or
+images with `COLOR_ATTACHMENT` usage, so the sets of memory types supported by your
+resources may be disjoint. Aliasing them is not possible in that case.
+
+
+\page custom_memory_pools Custom memory pools
+
+A memory pool contains a number of `VkDeviceMemory` blocks.
+The library automatically creates and manages default pool for each memory type available on the device.
+Default memory pool automatically grows in size.
+Size of allocated blocks is also variable and managed automatically.
+
+You can create custom pool and allocate memory out of it.
+It can be useful if you want to:
+
+- Keep certain kind of allocations separate from others.
+- Enforce particular, fixed size of Vulkan memory blocks.
+- Limit maximum amount of Vulkan memory allocated for that pool.
+- Reserve minimum or fixed amount of Vulkan memory always preallocated for that pool.
+
+To use custom memory pools:
+
+-# Fill VmaPoolCreateInfo structure.
+-# Call vmaCreatePool() to obtain #VmaPool handle.
+-# When making an allocation, set VmaAllocationCreateInfo::pool to this handle.
+   You don't need to specify any other parameters of this structure, like `usage`.
+
+Example:
+
+\code
+// Create a pool that can have at most 2 blocks, 128 MiB each.
+VmaPoolCreateInfo poolCreateInfo = {};
+poolCreateInfo.memoryTypeIndex = ...
+poolCreateInfo.blockSize = 128ull * 1024 * 1024;
+poolCreateInfo.maxBlockCount = 2;
+
+VmaPool pool;
+vmaCreatePool(allocator, &poolCreateInfo, &pool);
+
+// Allocate a buffer out of it.
+VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+bufCreateInfo.size = 1024;
+bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.pool = pool;
+
+VkBuffer buf;
+VmaAllocation alloc;
+VmaAllocationInfo allocInfo;
+vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);
+\endcode
+
+You have to free all allocations made from this pool before destroying it.
+
+\code
+vmaDestroyBuffer(allocator, buf, alloc);
+vmaDestroyPool(allocator, pool);
+\endcode
+
+\section custom_memory_pools_MemTypeIndex Choosing memory type index
+
+When creating a pool, you must explicitly specify memory type index.
+To find the one suitable for your buffers or images, you can use helper functions
+vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo().
+You need to provide structures with example parameters of buffers or images
+that you are going to create in that pool.
+
+\code
+VkBufferCreateInfo exampleBufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+exampleBufCreateInfo.size = 1024; // Whatever.
+exampleBufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT; // Change if needed.
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY; // Change if needed.
+
+uint32_t memTypeIndex;
+vmaFindMemoryTypeIndexForBufferInfo(allocator, &exampleBufCreateInfo, &allocCreateInfo, &memTypeIndex);
+
+VmaPoolCreateInfo poolCreateInfo = {};
+poolCreateInfo.memoryTypeIndex = memTypeIndex;
+// ...
+\endcode
+
+When creating buffers/images allocated in that pool, provide following parameters:
+
+- `VkBufferCreateInfo`: Prefer to pass same parameters as above.
+  Otherwise you risk creating resources in a memory type that is not suitable for them, which may result in undefined behavior.
+  Using different `VK_BUFFER_USAGE_` flags may work, but you shouldn't create images in a pool intended for buffers
+  or the other way around.
+- VmaAllocationCreateInfo: You don't need to pass same parameters. Fill only `pool` member.
+  Other members are ignored anyway.
+
+\section linear_algorithm Linear allocation algorithm
+
+Each Vulkan memory block managed by this library has accompanying metadata that
+keeps track of used and unused regions. By default, the metadata structure and
+algorithm tries to find best place for new allocations among free regions to
+optimize memory usage. This way you can allocate and free objects in any order.
+
+![Default allocation algorithm](../gfx/Linear_allocator_1_algo_default.png)
+
+Sometimes there is a need to use simpler, linear allocation algorithm. You can
+create custom pool that uses such algorithm by adding flag
+#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT to VmaPoolCreateInfo::flags while creating
+#VmaPool object. Then an alternative metadata management is used. It always
+creates new allocations after last one and doesn't reuse free regions after
+allocations freed in the middle. It results in better allocation performance and
+less memory consumed by metadata.
+
+![Linear allocation algorithm](../gfx/Linear_allocator_2_algo_linear.png)
+
+With this one flag, you can create a custom pool that can be used in many ways:
+free-at-once, stack, double stack, and ring buffer. See below for details.
+
+\subsection linear_algorithm_free_at_once Free-at-once
+
+In a pool that uses linear algorithm, you still need to free all the allocations
+individually, e.g. by using vmaFreeMemory() or vmaDestroyBuffer(). You can free
+them in any order. New allocations are always made after last one - free space
+in the middle is not reused. However, when you release all the allocation and
+the pool becomes empty, allocation starts from the beginning again. This way you
+can use linear algorithm to speed up creation of allocations that you are going
+to release all at once.
+
+![Free-at-once](../gfx/Linear_allocator_3_free_at_once.png)
+
+This mode is also available for pools created with VmaPoolCreateInfo::maxBlockCount
+value that allows multiple memory blocks.
+
+\subsection linear_algorithm_stack Stack
+
+When you free an allocation that was created last, its space can be reused.
+Thanks to this, if you always release allocations in the order opposite to their
+creation (LIFO - Last In First Out), you can achieve behavior of a stack.
+
+![Stack](../gfx/Linear_allocator_4_stack.png)
+
+This mode is also available for pools created with VmaPoolCreateInfo::maxBlockCount
+value that allows multiple memory blocks.
+
+\subsection linear_algorithm_double_stack Double stack
+
+The space reserved by a custom pool with linear algorithm may be used by two
+stacks:
+
+- First, default one, growing up from offset 0.
+- Second, "upper" one, growing down from the end towards lower offsets.
+
+To make allocation from upper stack, add flag #VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT
+to VmaAllocationCreateInfo::flags.
+
+![Double stack](../gfx/Linear_allocator_7_double_stack.png)
+
+Double stack is available only in pools with one memory block -
+VmaPoolCreateInfo::maxBlockCount must be 1. Otherwise behavior is undefined.
+
+When the two stacks' ends meet so there is not enough space between them for a
+new allocation, such allocation fails with usual
+`VK_ERROR_OUT_OF_DEVICE_MEMORY` error.
+
+\subsection linear_algorithm_ring_buffer Ring buffer
+
+When you free some allocations from the beginning and there is not enough free space
+for a new one at the end of a pool, allocator's "cursor" wraps around to the
+beginning and starts allocation there. Thanks to this, if you always release
+allocations in the same order as you created them (FIFO - First In First Out),
+you can achieve behavior of a ring buffer / queue.
+
+![Ring buffer](../gfx/Linear_allocator_5_ring_buffer.png)
+
+Pools with linear algorithm support [lost allocations](@ref lost_allocations) when used as ring buffer.
+If there is not enough free space for a new allocation, but existing allocations
+from the front of the queue can become lost, they become lost and the allocation
+succeeds.
+
+![Ring buffer with lost allocations](../gfx/Linear_allocator_6_ring_buffer_lost.png)
+
+Ring buffer is available only in pools with one memory block -
+VmaPoolCreateInfo::maxBlockCount must be 1. Otherwise behavior is undefined.
+
+\section buddy_algorithm Buddy allocation algorithm
+
+There is another allocation algorithm that can be used with custom pools, called
+"buddy". Its internal data structure is based on a tree of blocks, each having
+size that is a power of two and a half of its parent's size. When you want to
+allocate memory of certain size, a free node in the tree is located. If it's too
+large, it is recursively split into two halves (called "buddies"). However, if
+requested allocation size is not a power of two, the size of a tree node is
+aligned up to the nearest power of two and the remaining space is wasted. When
+two buddy nodes become free, they are merged back into one larger node.
+
+![Buddy allocator](../gfx/Buddy_allocator.png)
+
+The advantage of buddy allocation algorithm over default algorithm is faster
+allocation and deallocation, as well as smaller external fragmentation. The
+disadvantage is more wasted space (internal fragmentation).
+
+For more information, please read ["Buddy memory allocation" on Wikipedia](https://en.wikipedia.org/wiki/Buddy_memory_allocation)
+or other sources that describe this concept in general.
+
+To use buddy allocation algorithm with a custom pool, add flag
+#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT to VmaPoolCreateInfo::flags while creating
+#VmaPool object.
+
+Several limitations apply to pools that use buddy algorithm:
+
+- It is recommended to use VmaPoolCreateInfo::blockSize that is a power of two.
+  Otherwise, only largest power of two smaller than the size is used for
+  allocations. The remaining space always stays unused.
+- [Margins](@ref debugging_memory_usage_margins) and
+  [corruption detection](@ref debugging_memory_usage_corruption_detection)
+  don't work in such pools.
+- [Lost allocations](@ref lost_allocations) don't work in such pools. You can
+  use them, but they never become lost. Support may be added in the future.
+- [Defragmentation](@ref defragmentation) doesn't work with allocations made from
+  such pool.
+
+\page defragmentation Defragmentation
+
+Interleaved allocations and deallocations of many objects of varying size can
+cause fragmentation over time, which can lead to a situation where the library is unable
+to find a continuous range of free memory for a new allocation despite there is
+enough free space, just scattered across many small free ranges between existing
+allocations.
+
+To mitigate this problem, you can use defragmentation feature:
+structure #VmaDefragmentationInfo2, function vmaDefragmentationBegin(), vmaDefragmentationEnd().
+Given set of allocations,
+this function can move them to compact used memory, ensure more continuous free
+space and possibly also free some `VkDeviceMemory` blocks.
+
+What the defragmentation does is:
+
+- Updates #VmaAllocation objects to point to new `VkDeviceMemory` and offset.
+  After allocation has been moved, its VmaAllocationInfo::deviceMemory and/or
+  VmaAllocationInfo::offset changes. You must query them again using
+  vmaGetAllocationInfo() if you need them.
+- Moves actual data in memory.
+
+What it doesn't do, so you need to do it yourself:
+
+- Recreate buffers and images that were bound to allocations that were defragmented and
+  bind them with their new places in memory.
+  You must use `vkDestroyBuffer()`, `vkDestroyImage()`,
+  `vkCreateBuffer()`, `vkCreateImage()`, vmaBindBufferMemory(), vmaBindImageMemory()
+  for that purpose and NOT vmaDestroyBuffer(),
+  vmaDestroyImage(), vmaCreateBuffer(), vmaCreateImage(), because you don't need to
+  destroy or create allocation objects!
+- Recreate views and update descriptors that point to these buffers and images.
+
+\section defragmentation_cpu Defragmenting CPU memory
+
+Following example demonstrates how you can run defragmentation on CPU.
+Only allocations created in memory types that are `HOST_VISIBLE` can be defragmented.
+Others are ignored.
+
+The way it works is:
+
+- It temporarily maps entire memory blocks when necessary.
+- It moves data using `memmove()` function.
+
+\code
+// Given following variables already initialized:
+VkDevice device;
+VmaAllocator allocator;
+std::vector<VkBuffer> buffers;
+std::vector<VmaAllocation> allocations;
+
+
+const uint32_t allocCount = (uint32_t)allocations.size();
+std::vector<VkBool32> allocationsChanged(allocCount);
+
+VmaDefragmentationInfo2 defragInfo = {};
+defragInfo.allocationCount = allocCount;
+defragInfo.pAllocations = allocations.data();
+defragInfo.pAllocationsChanged = allocationsChanged.data();
+defragInfo.maxCpuBytesToMove = VK_WHOLE_SIZE; // No limit.
+defragInfo.maxCpuAllocationsToMove = UINT32_MAX; // No limit.
+
+VmaDefragmentationContext defragCtx;
+vmaDefragmentationBegin(allocator, &defragInfo, nullptr, &defragCtx);
+vmaDefragmentationEnd(allocator, defragCtx);
+
+for(uint32_t i = 0; i < allocCount; ++i)
+{
+    if(allocationsChanged[i])
+    {
+        // Destroy buffer that is immutably bound to memory region which is no longer valid.
+        vkDestroyBuffer(device, buffers[i], nullptr);
+
+        // Create new buffer with same parameters.
+        VkBufferCreateInfo bufferInfo = ...;
+        vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);
+
+        // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.
+
+        // Bind new buffer to new memory region. Data contained in it is already moved.
+        VmaAllocationInfo allocInfo;
+        vmaGetAllocationInfo(allocator, allocations[i], &allocInfo);
+        vmaBindBufferMemory(allocator, allocations[i], buffers[i]);
+    }
+}
+\endcode
+
+Setting VmaDefragmentationInfo2::pAllocationsChanged is optional.
+This output array tells whether particular allocation in VmaDefragmentationInfo2::pAllocations at the same index
+has been modified during defragmentation.
+You can pass null, but you then need to query every allocation passed to defragmentation
+for new parameters using vmaGetAllocationInfo() if you might need to recreate and rebind a buffer or image associated with it.
+
+If you use [Custom memory pools](@ref choosing_memory_type_custom_memory_pools),
+you can fill VmaDefragmentationInfo2::poolCount and VmaDefragmentationInfo2::pPools
+instead of VmaDefragmentationInfo2::allocationCount and VmaDefragmentationInfo2::pAllocations
+to defragment all allocations in given pools.
+You cannot use VmaDefragmentationInfo2::pAllocationsChanged in that case.
+You can also combine both methods.
+
+\section defragmentation_gpu Defragmenting GPU memory
+
+It is also possible to defragment allocations created in memory types that are not `HOST_VISIBLE`.
+To do that, you need to pass a command buffer that meets requirements as described in
+VmaDefragmentationInfo2::commandBuffer. The way it works is:
+
+- It creates temporary buffers and binds them to entire memory blocks when necessary.
+- It issues `vkCmdCopyBuffer()` to passed command buffer.
+
+Example:
+
+\code
+// Given following variables already initialized:
+VkDevice device;
+VmaAllocator allocator;
+VkCommandBuffer commandBuffer;
+std::vector<VkBuffer> buffers;
+std::vector<VmaAllocation> allocations;
+
+
+const uint32_t allocCount = (uint32_t)allocations.size();
+std::vector<VkBool32> allocationsChanged(allocCount);
+
+VkCommandBufferBeginInfo cmdBufBeginInfo = ...;
+vkBeginCommandBuffer(commandBuffer, &cmdBufBeginInfo);
+
+VmaDefragmentationInfo2 defragInfo = {};
+defragInfo.allocationCount = allocCount;
+defragInfo.pAllocations = allocations.data();
+defragInfo.pAllocationsChanged = allocationsChanged.data();
+defragInfo.maxGpuBytesToMove = VK_WHOLE_SIZE; // Notice it's "GPU" this time.
+defragInfo.maxGpuAllocationsToMove = UINT32_MAX; // Notice it's "GPU" this time.
+defragInfo.commandBuffer = commandBuffer;
+
+VmaDefragmentationContext defragCtx;
+vmaDefragmentationBegin(allocator, &defragInfo, nullptr, &defragCtx);
+
+vkEndCommandBuffer(commandBuffer);
+
+// Submit commandBuffer.
+// Wait for a fence that ensures commandBuffer execution finished.
+
+vmaDefragmentationEnd(allocator, defragCtx);
+
+for(uint32_t i = 0; i < allocCount; ++i)
+{
+    if(allocationsChanged[i])
+    {
+        // Destroy buffer that is immutably bound to memory region which is no longer valid.
+        vkDestroyBuffer(device, buffers[i], nullptr);
+
+        // Create new buffer with same parameters.
+        VkBufferCreateInfo bufferInfo = ...;
+        vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);
+
+        // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.
+
+        // Bind new buffer to new memory region. Data contained in it is already moved.
+        VmaAllocationInfo allocInfo;
+        vmaGetAllocationInfo(allocator, allocations[i], &allocInfo);
+        vmaBindBufferMemory(allocator, allocations[i], buffers[i]);
+    }
+}
+\endcode
+
+You can combine these two methods by specifying non-zero `maxGpu*` as well as `maxCpu*` parameters.
+The library automatically chooses best method to defragment each memory pool.
+
+You may try not to block your entire program to wait until defragmentation finishes,
+but do it in the background, as long as you carefully fullfill requirements described
+in function vmaDefragmentationBegin().
+
+\section defragmentation_additional_notes Additional notes
+
+It is only legal to defragment allocations bound to:
+
+- buffers
+- images created with `VK_IMAGE_CREATE_ALIAS_BIT`, `VK_IMAGE_TILING_LINEAR`, and
+  being currently in `VK_IMAGE_LAYOUT_GENERAL` or `VK_IMAGE_LAYOUT_PREINITIALIZED`.
+
+Defragmentation of images created with `VK_IMAGE_TILING_OPTIMAL` or in any other
+layout may give undefined results.
+
+If you defragment allocations bound to images, new images to be bound to new
+memory region after defragmentation should be created with `VK_IMAGE_LAYOUT_PREINITIALIZED`
+and then transitioned to their original layout from before defragmentation if
+needed using an image memory barrier.
+
+While using defragmentation, you may experience validation layer warnings, which you just need to ignore.
+See [Validation layer warnings](@ref general_considerations_validation_layer_warnings).
+
+Please don't expect memory to be fully compacted after defragmentation.
+Algorithms inside are based on some heuristics that try to maximize number of Vulkan
+memory blocks to make totally empty to release them, as well as to maximimze continuous
+empty space inside remaining blocks, while minimizing the number and size of allocations that
+need to be moved. Some fragmentation may still remain - this is normal.
+
+\section defragmentation_custom_algorithm Writing custom defragmentation algorithm
+
+If you want to implement your own, custom defragmentation algorithm,
+there is infrastructure prepared for that,
+but it is not exposed through the library API - you need to hack its source code.
+Here are steps needed to do this:
+
+-# Main thing you need to do is to define your own class derived from base abstract
+   class `VmaDefragmentationAlgorithm` and implement your version of its pure virtual methods.
+   See definition and comments of this class for details.
+-# Your code needs to interact with device memory block metadata.
+   If you need more access to its data than it's provided by its public interface,
+   declare your new class as a friend class e.g. in class `VmaBlockMetadata_Generic`.
+-# If you want to create a flag that would enable your algorithm or pass some additional
+   flags to configure it, add them to `VmaDefragmentationFlagBits` and use them in
+   VmaDefragmentationInfo2::flags.
+-# Modify function `VmaBlockVectorDefragmentationContext::Begin` to create object
+   of your new class whenever needed.
+
+
+\page lost_allocations Lost allocations
+
+If your game oversubscribes video memory, if may work OK in previous-generation
+graphics APIs (DirectX 9, 10, 11, OpenGL) because resources are automatically
+paged to system RAM. In Vulkan you can't do it because when you run out of
+memory, an allocation just fails. If you have more data (e.g. textures) that can
+fit into VRAM and you don't need it all at once, you may want to upload them to
+GPU on demand and "push out" ones that are not used for a long time to make room
+for the new ones, effectively using VRAM (or a cartain memory pool) as a form of
+cache. Vulkan Memory Allocator can help you with that by supporting a concept of
+"lost allocations".
+
+To create an allocation that can become lost, include #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT
+flag in VmaAllocationCreateInfo::flags. Before using a buffer or image bound to
+such allocation in every new frame, you need to query it if it's not lost.
+To check it, call vmaTouchAllocation().
+If the allocation is lost, you should not use it or buffer/image bound to it.
+You mustn't forget to destroy this allocation and this buffer/image.
+vmaGetAllocationInfo() can also be used for checking status of the allocation.
+Allocation is lost when returned VmaAllocationInfo::deviceMemory == `VK_NULL_HANDLE`.
+
+To create an allocation that can make some other allocations lost to make room
+for it, use #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag. You will
+usually use both flags #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT and
+#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT at the same time.
+
+Warning! Current implementation uses quite naive, brute force algorithm,
+which can make allocation calls that use #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT
+flag quite slow. A new, more optimal algorithm and data structure to speed this
+up is planned for the future.
+
+<b>Q: When interleaving creation of new allocations with usage of existing ones,
+how do you make sure that an allocation won't become lost while it's used in the
+current frame?</b>
+
+It is ensured because vmaTouchAllocation() / vmaGetAllocationInfo() not only returns allocation
+status/parameters and checks whether it's not lost, but when it's not, it also
+atomically marks it as used in the current frame, which makes it impossible to
+become lost in that frame. It uses lockless algorithm, so it works fast and
+doesn't involve locking any internal mutex.
+
+<b>Q: What if my allocation may still be in use by the GPU when it's rendering a
+previous frame while I already submit new frame on the CPU?</b>
+
+You can make sure that allocations "touched" by vmaTouchAllocation() / vmaGetAllocationInfo() will not
+become lost for a number of additional frames back from the current one by
+specifying this number as VmaAllocatorCreateInfo::frameInUseCount (for default
+memory pool) and VmaPoolCreateInfo::frameInUseCount (for custom pool).
+
+<b>Q: How do you inform the library when new frame starts?</b>
+
+You need to call function vmaSetCurrentFrameIndex().
+
+Example code:
+
+\code
+struct MyBuffer
+{
+    VkBuffer m_Buf = nullptr;
+    VmaAllocation m_Alloc = nullptr;
+
+    // Called when the buffer is really needed in the current frame.
+    void EnsureBuffer();
+};
+
+void MyBuffer::EnsureBuffer()
+{
+    // Buffer has been created.
+    if(m_Buf != VK_NULL_HANDLE)
+    {
+        // Check if its allocation is not lost + mark it as used in current frame.
+        if(vmaTouchAllocation(allocator, m_Alloc))
+        {
+            // It's all OK - safe to use m_Buf.
+            return;
+        }
+    }
+
+    // Buffer not yet exists or lost - destroy and recreate it.
+
+    vmaDestroyBuffer(allocator, m_Buf, m_Alloc);
+
+    VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+    bufCreateInfo.size = 1024;
+    bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+
+    VmaAllocationCreateInfo allocCreateInfo = {};
+    allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+    allocCreateInfo.flags = VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT |
+        VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT;
+
+    vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &m_Buf, &m_Alloc, nullptr);
+}
+\endcode
+
+When using lost allocations, you may see some Vulkan validation layer warnings
+about overlapping regions of memory bound to different kinds of buffers and
+images. This is still valid as long as you implement proper handling of lost
+allocations (like in the example above) and don't use them.
+
+You can create an allocation that is already in lost state from the beginning using function
+vmaCreateLostAllocation(). It may be useful if you need a "dummy" allocation that is not null.
+
+You can call function vmaMakePoolAllocationsLost() to set all eligible allocations
+in a specified custom pool to lost state.
+Allocations that have been "touched" in current frame or VmaPoolCreateInfo::frameInUseCount frames back
+cannot become lost.
+
+<b>Q: Can I touch allocation that cannot become lost?</b>
+
+Yes, although it has no visible effect.
+Calls to vmaGetAllocationInfo() and vmaTouchAllocation() update last use frame index
+also for allocations that cannot become lost, but the only way to observe it is to dump
+internal allocator state using vmaBuildStatsString().
+You can use this feature for debugging purposes to explicitly mark allocations that you use
+in current frame and then analyze JSON dump to see for how long each allocation stays unused.
+
+
+\page statistics Statistics
+
+This library contains functions that return information about its internal state,
+especially the amount of memory allocated from Vulkan.
+Please keep in mind that these functions need to traverse all internal data structures
+to gather these information, so they may be quite time-consuming.
+Don't call them too often.
+
+\section statistics_numeric_statistics Numeric statistics
+
+You can query for overall statistics of the allocator using function vmaCalculateStats().
+Information are returned using structure #VmaStats.
+It contains #VmaStatInfo - number of allocated blocks, number of allocations
+(occupied ranges in these blocks), number of unused (free) ranges in these blocks,
+number of bytes used and unused (but still allocated from Vulkan) and other information.
+They are summed across memory heaps, memory types and total for whole allocator.
+
+You can query for statistics of a custom pool using function vmaGetPoolStats().
+Information are returned using structure #VmaPoolStats.
+
+You can query for information about specific allocation using function vmaGetAllocationInfo().
+It fill structure #VmaAllocationInfo.
+
+\section statistics_json_dump JSON dump
+
+You can dump internal state of the allocator to a string in JSON format using function vmaBuildStatsString().
+The result is guaranteed to be correct JSON.
+It uses ANSI encoding.
+Any strings provided by user (see [Allocation names](@ref allocation_names))
+are copied as-is and properly escaped for JSON, so if they use UTF-8, ISO-8859-2 or any other encoding,
+this JSON string can be treated as using this encoding.
+It must be freed using function vmaFreeStatsString().
+
+The format of this JSON string is not part of official documentation of the library,
+but it will not change in backward-incompatible way without increasing library major version number
+and appropriate mention in changelog.
+
+The JSON string contains all the data that can be obtained using vmaCalculateStats().
+It can also contain detailed map of allocated memory blocks and their regions -
+free and occupied by allocations.
+This allows e.g. to visualize the memory or assess fragmentation.
+
+
+\page allocation_annotation Allocation names and user data
+
+\section allocation_user_data Allocation user data
+
+You can annotate allocations with your own information, e.g. for debugging purposes.
+To do that, fill VmaAllocationCreateInfo::pUserData field when creating
+an allocation. It's an opaque `void*` pointer. You can use it e.g. as a pointer,
+some handle, index, key, ordinal number or any other value that would associate
+the allocation with your custom metadata.
+
+\code
+VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
+// Fill bufferInfo...
+
+MyBufferMetadata* pMetadata = CreateBufferMetadata();
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+allocCreateInfo.pUserData = pMetadata;
+
+VkBuffer buffer;
+VmaAllocation allocation;
+vmaCreateBuffer(allocator, &bufferInfo, &allocCreateInfo, &buffer, &allocation, nullptr);
+\endcode
+
+The pointer may be later retrieved as VmaAllocationInfo::pUserData:
+
+\code
+VmaAllocationInfo allocInfo;
+vmaGetAllocationInfo(allocator, allocation, &allocInfo);
+MyBufferMetadata* pMetadata = (MyBufferMetadata*)allocInfo.pUserData;
+\endcode
+
+It can also be changed using function vmaSetAllocationUserData().
+
+Values of (non-zero) allocations' `pUserData` are printed in JSON report created by
+vmaBuildStatsString(), in hexadecimal form.
+
+\section allocation_names Allocation names
+
+There is alternative mode available where `pUserData` pointer is used to point to
+a null-terminated string, giving a name to the allocation. To use this mode,
+set #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT flag in VmaAllocationCreateInfo::flags.
+Then `pUserData` passed as VmaAllocationCreateInfo::pUserData or argument to
+vmaSetAllocationUserData() must be either null or pointer to a null-terminated string.
+The library creates internal copy of the string, so the pointer you pass doesn't need
+to be valid for whole lifetime of the allocation. You can free it after the call.
+
+\code
+VkImageCreateInfo imageInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
+// Fill imageInfo...
+
+std::string imageName = "Texture: ";
+imageName += fileName;
+
+VmaAllocationCreateInfo allocCreateInfo = {};
+allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+allocCreateInfo.flags = VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT;
+allocCreateInfo.pUserData = imageName.c_str();
+
+VkImage image;
+VmaAllocation allocation;
+vmaCreateImage(allocator, &imageInfo, &allocCreateInfo, &image, &allocation, nullptr);
+\endcode
+
+The value of `pUserData` pointer of the allocation will be different than the one
+you passed when setting allocation's name - pointing to a buffer managed
+internally that holds copy of the string.
+
+\code
+VmaAllocationInfo allocInfo;
+vmaGetAllocationInfo(allocator, allocation, &allocInfo);
+const char* imageName = (const char*)allocInfo.pUserData;
+printf("Image name: %s\n", imageName);
+\endcode
+
+That string is also printed in JSON report created by vmaBuildStatsString().
+
+\note Passing string name to VMA allocation doesn't automatically set it to the Vulkan buffer or image created with it.
+You must do it manually using an extension like VK_EXT_debug_utils, which is independent of this library.
+
+
+\page debugging_memory_usage Debugging incorrect memory usage
+
+If you suspect a bug with memory usage, like usage of uninitialized memory or
+memory being overwritten out of bounds of an allocation,
+you can use debug features of this library to verify this.
+
+\section debugging_memory_usage_initialization Memory initialization
+
+If you experience a bug with incorrect and nondeterministic data in your program and you suspect uninitialized memory to be used,
+you can enable automatic memory initialization to verify this.
+To do it, define macro `VMA_DEBUG_INITIALIZE_ALLOCATIONS` to 1.
+
+\code
+#define VMA_DEBUG_INITIALIZE_ALLOCATIONS 1
+#include "vk_mem_alloc.h"
+\endcode
+
+It makes memory of all new allocations initialized to bit pattern `0xDCDCDCDC`.
+Before an allocation is destroyed, its memory is filled with bit pattern `0xEFEFEFEF`.
+Memory is automatically mapped and unmapped if necessary.
+
+If you find these values while debugging your program, good chances are that you incorrectly
+read Vulkan memory that is allocated but not initialized, or already freed, respectively.
+
+Memory initialization works only with memory types that are `HOST_VISIBLE`.
+It works also with dedicated allocations.
+It doesn't work with allocations created with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
+as they cannot be mapped.
+
+\section debugging_memory_usage_margins Margins
+
+By default, allocations are laid out in memory blocks next to each other if possible
+(considering required alignment, `bufferImageGranularity`, and `nonCoherentAtomSize`).
+
+![Allocations without margin](../gfx/Margins_1.png)
+
+Define macro `VMA_DEBUG_MARGIN` to some non-zero value (e.g. 16) to enforce specified
+number of bytes as a margin before and after every allocation.
+
+\code
+#define VMA_DEBUG_MARGIN 16
+#include "vk_mem_alloc.h"
+\endcode
+
+![Allocations with margin](../gfx/Margins_2.png)
+
+If your bug goes away after enabling margins, it means it may be caused by memory
+being overwritten outside of allocation boundaries. It is not 100% certain though.
+Change in application behavior may also be caused by different order and distribution
+of allocations across memory blocks after margins are applied.
+
+The margin is applied also before first and after last allocation in a block.
+It may occur only once between two adjacent allocations.
+
+Margins work with all types of memory.
+
+Margin is applied only to allocations made out of memory blocks and not to dedicated
+allocations, which have their own memory block of specific size.
+It is thus not applied to allocations made using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT flag
+or those automatically decided to put into dedicated allocations, e.g. due to its
+large size or recommended by VK_KHR_dedicated_allocation extension.
+Margins are also not active in custom pools created with #VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT flag.
+
+Margins appear in [JSON dump](@ref statistics_json_dump) as part of free space.
+
+Note that enabling margins increases memory usage and fragmentation.
+
+\section debugging_memory_usage_corruption_detection Corruption detection
+
+You can additionally define macro `VMA_DEBUG_DETECT_CORRUPTION` to 1 to enable validation
+of contents of the margins.
+
+\code
+#define VMA_DEBUG_MARGIN 16
+#define VMA_DEBUG_DETECT_CORRUPTION 1
+#include "vk_mem_alloc.h"
+\endcode
+
+When this feature is enabled, number of bytes specified as `VMA_DEBUG_MARGIN`
+(it must be multiply of 4) before and after every allocation is filled with a magic number.
+This idea is also know as "canary".
+Memory is automatically mapped and unmapped if necessary.
+
+This number is validated automatically when the allocation is destroyed.
+If it's not equal to the expected value, `VMA_ASSERT()` is executed.
+It clearly means that either CPU or GPU overwritten the memory outside of boundaries of the allocation,
+which indicates a serious bug.
+
+You can also explicitly request checking margins of all allocations in all memory blocks
+that belong to specified memory types by using function vmaCheckCorruption(),
+or in memory blocks that belong to specified custom pool, by using function
+vmaCheckPoolCorruption().
+
+Margin validation (corruption detection) works only for memory types that are
+`HOST_VISIBLE` and `HOST_COHERENT`.
+
+
+\page record_and_replay Record and replay
+
+\section record_and_replay_introduction Introduction
+
+While using the library, sequence of calls to its functions together with their
+parameters can be recorded to a file and later replayed using standalone player
+application. It can be useful to:
+
+- Test correctness - check if same sequence of calls will not cause crash or
+  failures on a target platform.
+- Gather statistics - see number of allocations, peak memory usage, number of
+  calls etc.
+- Benchmark performance - see how much time it takes to replay the whole
+  sequence.
+
+\section record_and_replay_usage Usage
+
+Recording functionality is disabled by default.
+To enable it, define following macro before every include of this library:
+
+\code
+#define VMA_RECORDING_ENABLED 1
+\endcode
+
+<b>To record sequence of calls to a file:</b> Fill in
+VmaAllocatorCreateInfo::pRecordSettings member while creating #VmaAllocator
+object. File is opened and written during whole lifetime of the allocator.
+
+<b>To replay file:</b> Use VmaReplay - standalone command-line program.
+Precompiled binary can be found in "bin" directory.
+Its source can be found in "src/VmaReplay" directory.
+Its project is generated by Premake.
+Command line syntax is printed when the program is launched without parameters.
+Basic usage:
+
+    VmaReplay.exe MyRecording.csv
+
+<b>Documentation of file format</b> can be found in file: "docs/Recording file format.md".
+It's a human-readable, text file in CSV format (Comma Separated Values).
+
+\section record_and_replay_additional_considerations Additional considerations
+
+- Replaying file that was recorded on a different GPU (with different parameters
+  like `bufferImageGranularity`, `nonCoherentAtomSize`, and especially different
+  set of memory heaps and types) may give different performance and memory usage
+  results, as well as issue some warnings and errors.
+- Current implementation of recording in VMA, as well as VmaReplay application, is
+  coded and tested only on Windows. Inclusion of recording code is driven by
+  `VMA_RECORDING_ENABLED` macro. Support for other platforms should be easy to
+  add. Contributions are welcomed.
+
+
+\page usage_patterns Recommended usage patterns
+
+See also slides from talk:
+[Sawicki, Adam. Advanced Graphics Techniques Tutorial: Memory management in Vulkan and DX12. Game Developers Conference, 2018](https://www.gdcvault.com/play/1025458/Advanced-Graphics-Techniques-Tutorial-New)
+
+
+\section usage_patterns_common_mistakes Common mistakes
+
+<b>Use of CPU_TO_GPU instead of CPU_ONLY memory</b>
+
+#VMA_MEMORY_USAGE_CPU_TO_GPU is recommended only for resources that will be
+mapped and written by the CPU, as well as read directly by the GPU - like some
+buffers or textures updated every frame (dynamic). If you create a staging copy
+of a resource to be written by CPU and then used as a source of transfer to
+another resource placed in the GPU memory, that staging resource should be
+created with #VMA_MEMORY_USAGE_CPU_ONLY. Please read the descriptions of these
+enums carefully for details.
+
+<b>Unnecessary use of custom pools</b>
+
+\ref custom_memory_pools may be useful for special purposes - when you want to
+keep certain type of resources separate e.g. to reserve minimum amount of memory
+for them, limit maximum amount of memory they can occupy, or make some of them
+push out the other through the mechanism of \ref lost_allocations. For most
+resources this is not needed and so it is not recommended to create #VmaPool
+objects and allocations out of them. Allocating from the default pool is sufficient.
+
+\section usage_patterns_simple Simple patterns
+
+\subsection usage_patterns_simple_render_targets Render targets
+
+<b>When:</b>
+Any resources that you frequently write and read on GPU,
+e.g. images used as color attachments (aka "render targets"), depth-stencil attachments,
+images/buffers used as storage image/buffer (aka "Unordered Access View (UAV)").
+
+<b>What to do:</b>
+Create them in video memory that is fastest to access from GPU using
+#VMA_MEMORY_USAGE_GPU_ONLY.
+
+Consider using [VK_KHR_dedicated_allocation](@ref vk_khr_dedicated_allocation) extension
+and/or manually creating them as dedicated allocations using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT,
+especially if they are large or if you plan to destroy and recreate them e.g. when
+display resolution changes.
+Prefer to create such resources first and all other GPU resources (like textures and vertex buffers) later.
+
+\subsection usage_patterns_simple_immutable_resources Immutable resources
+
+<b>When:</b>
+Any resources that you fill on CPU only once (aka "immutable") or infrequently
+and then read frequently on GPU,
+e.g. textures, vertex and index buffers, constant buffers that don't change often.
+
+<b>What to do:</b>
+Create them in video memory that is fastest to access from GPU using
+#VMA_MEMORY_USAGE_GPU_ONLY.
+
+To initialize content of such resource, create a CPU-side (aka "staging") copy of it
+in system memory - #VMA_MEMORY_USAGE_CPU_ONLY, map it, fill it,
+and submit a transfer from it to the GPU resource.
+You can keep the staging copy if you need it for another upload transfer in the future.
+If you don't, you can destroy it or reuse this buffer for uploading different resource
+after the transfer finishes.
+
+Prefer to create just buffers in system memory rather than images, even for uploading textures.
+Use `vkCmdCopyBufferToImage()`.
+Dont use images with `VK_IMAGE_TILING_LINEAR`.
+
+\subsection usage_patterns_dynamic_resources Dynamic resources
+
+<b>When:</b>
+Any resources that change frequently (aka "dynamic"), e.g. every frame or every draw call,
+written on CPU, read on GPU.
+
+<b>What to do:</b>
+Create them using #VMA_MEMORY_USAGE_CPU_TO_GPU.
+You can map it and write to it directly on CPU, as well as read from it on GPU.
+
+This is a more complex situation. Different solutions are possible,
+and the best one depends on specific GPU type, but you can use this simple approach for the start.
+Prefer to write to such resource sequentially (e.g. using `memcpy`).
+Don't perform random access or any reads from it on CPU, as it may be very slow.
+Also note that textures written directly from the host through a mapped pointer need to be in LINEAR not OPTIMAL layout.
+
+\subsection usage_patterns_readback Readback
+
+<b>When:</b>
+Resources that contain data written by GPU that you want to read back on CPU,
+e.g. results of some computations.
+
+<b>What to do:</b>
+Create them using #VMA_MEMORY_USAGE_GPU_TO_CPU.
+You can write to them directly on GPU, as well as map and read them on CPU.
+
+\section usage_patterns_advanced Advanced patterns
+
+\subsection usage_patterns_integrated_graphics Detecting integrated graphics
+
+You can support integrated graphics (like Intel HD Graphics, AMD APU) better
+by detecting it in Vulkan.
+To do it, call `vkGetPhysicalDeviceProperties()`, inspect
+`VkPhysicalDeviceProperties::deviceType` and look for `VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU`.
+When you find it, you can assume that memory is unified and all memory types are comparably fast
+to access from GPU, regardless of `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`.
+
+You can then sum up sizes of all available memory heaps and treat them as useful for
+your GPU resources, instead of only `DEVICE_LOCAL` ones.
+You can also prefer to create your resources in memory types that are `HOST_VISIBLE` to map them
+directly instead of submitting explicit transfer (see below).
+
+\subsection usage_patterns_direct_vs_transfer Direct access versus transfer
+
+For resources that you frequently write on CPU and read on GPU, many solutions are possible:
+
+-# Create one copy in video memory using #VMA_MEMORY_USAGE_GPU_ONLY,
+   second copy in system memory using #VMA_MEMORY_USAGE_CPU_ONLY and submit explicit transfer each time.
+-# Create just a single copy using #VMA_MEMORY_USAGE_CPU_TO_GPU, map it and fill it on CPU,
+   read it directly on GPU.
+-# Create just a single copy using #VMA_MEMORY_USAGE_CPU_ONLY, map it and fill it on CPU,
+   read it directly on GPU.
+
+Which solution is the most efficient depends on your resource and especially on the GPU.
+It is best to measure it and then make the decision.
+Some general recommendations:
+
+- On integrated graphics use (2) or (3) to avoid unnecesary time and memory overhead
+  related to using a second copy and making transfer.
+- For small resources (e.g. constant buffers) use (2).
+  Discrete AMD cards have special 256 MiB pool of video memory that is directly mappable.
+  Even if the resource ends up in system memory, its data may be cached on GPU after first
+  fetch over PCIe bus.
+- For larger resources (e.g. textures), decide between (1) and (2).
+  You may want to differentiate NVIDIA and AMD, e.g. by looking for memory type that is
+  both `DEVICE_LOCAL` and `HOST_VISIBLE`. When you find it, use (2), otherwise use (1).
+
+Similarly, for resources that you frequently write on GPU and read on CPU, multiple
+solutions are possible:
+
+-# Create one copy in video memory using #VMA_MEMORY_USAGE_GPU_ONLY,
+   second copy in system memory using #VMA_MEMORY_USAGE_GPU_TO_CPU and submit explicit tranfer each time.
+-# Create just single copy using #VMA_MEMORY_USAGE_GPU_TO_CPU, write to it directly on GPU,
+   map it and read it on CPU.
+
+You should take some measurements to decide which option is faster in case of your specific
+resource.
+
+Note that textures accessed directly from the host through a mapped pointer need to be in LINEAR layout,
+which may slow down their usage on the device.
+Textures accessed only by the device and transfer operations can use OPTIMAL layout.
+
+If you don't want to specialize your code for specific types of GPUs, you can still make
+an simple optimization for cases when your resource ends up in mappable memory to use it
+directly in this case instead of creating CPU-side staging copy.
+For details see [Finding out if memory is mappable](@ref memory_mapping_finding_if_memory_mappable).
+
+
+\page configuration Configuration
+
+Please check "CONFIGURATION SECTION" in the code to find macros that you can define
+before each include of this file or change directly in this file to provide
+your own implementation of basic facilities like assert, `min()` and `max()` functions,
+mutex, atomic etc.
+The library uses its own implementation of containers by default, but you can switch to using
+STL containers instead.
+
+For example, define `VMA_ASSERT(expr)` before including the library to provide
+custom implementation of the assertion, compatible with your project.
+By default it is defined to standard C `assert(expr)` in `_DEBUG` configuration
+and empty otherwise.
+
+\section config_Vulkan_functions Pointers to Vulkan functions
+
+There are multiple ways to import pointers to Vulkan functions in the library.
+In the simplest case you don't need to do anything.
+If the compilation or linking of your program or the initialization of the #VmaAllocator
+doesn't work for you, you can try to reconfigure it.
+
+First, the allocator tries to fetch pointers to Vulkan functions linked statically,
+like this:
+
+\code
+m_VulkanFunctions.vkAllocateMemory = (PFN_vkAllocateMemory)vkAllocateMemory;
+\endcode
+
+If you want to disable this feature, set configuration macro: `#define VMA_STATIC_VULKAN_FUNCTIONS 0`.
+
+Second, you can provide the pointers yourself by setting member VmaAllocatorCreateInfo::pVulkanFunctions.
+You can fetch them e.g. using functions `vkGetInstanceProcAddr` and `vkGetDeviceProcAddr` or
+by using a helper library like [volk](https://github.com/zeux/volk).
+
+Third, VMA tries to fetch remaining pointers that are still null by calling
+`vkGetInstanceProcAddr` and `vkGetDeviceProcAddr` on its own.
+If you want to disable this feature, set configuration macro: `#define VMA_DYNAMIC_VULKAN_FUNCTIONS 0`.
+
+Finally, all the function pointers required by the library (considering selected
+Vulkan version and enabled extensions) are checked with `VMA_ASSERT` if they are not null.
+
+
+\section custom_memory_allocator Custom host memory allocator
+
+If you use custom allocator for CPU memory rather than default operator `new`
+and `delete` from C++, you can make this library using your allocator as well
+by filling optional member VmaAllocatorCreateInfo::pAllocationCallbacks. These
+functions will be passed to Vulkan, as well as used by the library itself to
+make any CPU-side allocations.
+
+\section allocation_callbacks Device memory allocation callbacks
+
+The library makes calls to `vkAllocateMemory()` and `vkFreeMemory()` internally.
+You can setup callbacks to be informed about these calls, e.g. for the purpose
+of gathering some statistics. To do it, fill optional member
+VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.
+
+\section heap_memory_limit Device heap memory limit
+
+When device memory of certain heap runs out of free space, new allocations may
+fail (returning error code) or they may succeed, silently pushing some existing
+memory blocks from GPU VRAM to system RAM (which degrades performance). This
+behavior is implementation-dependent - it depends on GPU vendor and graphics
+driver.
+
+On AMD cards it can be controlled while creating Vulkan device object by using
+VK_AMD_memory_overallocation_behavior extension, if available.
+
+Alternatively, if you want to test how your program behaves with limited amount of Vulkan device
+memory available without switching your graphics card to one that really has
+smaller VRAM, you can use a feature of this library intended for this purpose.
+To do it, fill optional member VmaAllocatorCreateInfo::pHeapSizeLimit.
+
+
+
+\page vk_khr_dedicated_allocation VK_KHR_dedicated_allocation
+
+VK_KHR_dedicated_allocation is a Vulkan extension which can be used to improve
+performance on some GPUs. It augments Vulkan API with possibility to query
+driver whether it prefers particular buffer or image to have its own, dedicated
+allocation (separate `VkDeviceMemory` block) for better efficiency - to be able
+to do some internal optimizations.
+
+The extension is supported by this library. It will be used automatically when
+enabled. To enable it:
+
+1 . When creating Vulkan device, check if following 2 device extensions are
+supported (call `vkEnumerateDeviceExtensionProperties()`).
+If yes, enable them (fill `VkDeviceCreateInfo::ppEnabledExtensionNames`).
+
+- VK_KHR_get_memory_requirements2
+- VK_KHR_dedicated_allocation
+
+If you enabled these extensions:
+
+2 . Use #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag when creating
+your #VmaAllocator`to inform the library that you enabled required extensions
+and you want the library to use them.
+
+\code
+allocatorInfo.flags |= VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;
+
+vmaCreateAllocator(&allocatorInfo, &allocator);
+\endcode
+
+That's all. The extension will be automatically used whenever you create a
+buffer using vmaCreateBuffer() or image using vmaCreateImage().
+
+When using the extension together with Vulkan Validation Layer, you will receive
+warnings like this:
+
+    vkBindBufferMemory(): Binding memory to buffer 0x33 but vkGetBufferMemoryRequirements() has not been called on that buffer.
+
+It is OK, you should just ignore it. It happens because you use function
+`vkGetBufferMemoryRequirements2KHR()` instead of standard
+`vkGetBufferMemoryRequirements()`, while the validation layer seems to be
+unaware of it.
+
+To learn more about this extension, see:
+
+- [VK_KHR_dedicated_allocation in Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/chap44.html#VK_KHR_dedicated_allocation)
+- [VK_KHR_dedicated_allocation unofficial manual](http://asawicki.info/articles/VK_KHR_dedicated_allocation.php5)
+
+
+
+\page vk_amd_device_coherent_memory VK_AMD_device_coherent_memory
+
+VK_AMD_device_coherent_memory is a device extension that enables access to
+additional memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and
+`VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flag. It is useful mostly for
+allocation of buffers intended for writing "breadcrumb markers" in between passes
+or draw calls, which in turn are useful for debugging GPU crash/hang/TDR cases.
+
+When the extension is available but has not been enabled, Vulkan physical device
+still exposes those memory types, but their usage is forbidden. VMA automatically
+takes care of that - it returns `VK_ERROR_FEATURE_NOT_PRESENT` when an attempt
+to allocate memory of such type is made.
+
+If you want to use this extension in connection with VMA, follow these steps:
+
+\section vk_amd_device_coherent_memory_initialization Initialization
+
+1) Call `vkEnumerateDeviceExtensionProperties` for the physical device.
+Check if the extension is supported - if returned array of `VkExtensionProperties` contains "VK_AMD_device_coherent_memory".
+
+2) Call `vkGetPhysicalDeviceFeatures2` for the physical device instead of old `vkGetPhysicalDeviceFeatures`.
+Attach additional structure `VkPhysicalDeviceCoherentMemoryFeaturesAMD` to `VkPhysicalDeviceFeatures2::pNext` to be returned.
+Check if the device feature is really supported - check if `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true.
+
+3) While creating device with `vkCreateDevice`, enable this extension - add "VK_AMD_device_coherent_memory"
+to the list passed as `VkDeviceCreateInfo::ppEnabledExtensionNames`.
+
+4) While creating the device, also don't set `VkDeviceCreateInfo::pEnabledFeatures`.
+Fill in `VkPhysicalDeviceFeatures2` structure instead and pass it as `VkDeviceCreateInfo::pNext`.
+Enable this device feature - attach additional structure `VkPhysicalDeviceCoherentMemoryFeaturesAMD` to
+`VkPhysicalDeviceFeatures2::pNext` and set its member `deviceCoherentMemory` to `VK_TRUE`.
+
+5) While creating #VmaAllocator with vmaCreateAllocator() inform VMA that you
+have enabled this extension and feature - add #VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT
+to VmaAllocatorCreateInfo::flags.
+
+\section vk_amd_device_coherent_memory_usage Usage
+
+After following steps described above, you can create VMA allocations and custom pools
+out of the special `DEVICE_COHERENT` and `DEVICE_UNCACHED` memory types on eligible
+devices. There are multiple ways to do it, for example:
+
+- You can request or prefer to allocate out of such memory types by adding
+  `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` to VmaAllocationCreateInfo::requiredFlags
+  or VmaAllocationCreateInfo::preferredFlags. Those flags can be freely mixed with
+  other ways of \ref choosing_memory_type, like setting VmaAllocationCreateInfo::usage.
+- If you manually found memory type index to use for this purpose, force allocation
+  from this specific index by setting VmaAllocationCreateInfo::memoryTypeBits `= 1u << index`.
+
+\section vk_amd_device_coherent_memory_more_information More information
+
+To learn more about this extension, see [VK_AMD_device_coherent_memory in Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/chap44.html#VK_AMD_device_coherent_memory)
+
+Example use of this extension can be found in the code of the sample and test suite
+accompanying this library.
+
+
+\page enabling_buffer_device_address Enabling buffer device address
+
+Device extension VK_KHR_buffer_device_address
+allow to fetch raw GPU pointer to a buffer and pass it for usage in a shader code.
+It is promoted to core Vulkan 1.2.
+
+If you want to use this feature in connection with VMA, follow these steps:
+
+\section enabling_buffer_device_address_initialization Initialization
+
+1) (For Vulkan version < 1.2) Call `vkEnumerateDeviceExtensionProperties` for the physical device.
+Check if the extension is supported - if returned array of `VkExtensionProperties` contains
+"VK_KHR_buffer_device_address".
+
+2) Call `vkGetPhysicalDeviceFeatures2` for the physical device instead of old `vkGetPhysicalDeviceFeatures`.
+Attach additional structure `VkPhysicalDeviceBufferDeviceAddressFeatures*` to `VkPhysicalDeviceFeatures2::pNext` to be returned.
+Check if the device feature is really supported - check if `VkPhysicalDeviceBufferDeviceAddressFeatures*::bufferDeviceAddress` is true.
+
+3) (For Vulkan version < 1.2) While creating device with `vkCreateDevice`, enable this extension - add
+"VK_KHR_buffer_device_address" to the list passed as `VkDeviceCreateInfo::ppEnabledExtensionNames`.
+
+4) While creating the device, also don't set `VkDeviceCreateInfo::pEnabledFeatures`.
+Fill in `VkPhysicalDeviceFeatures2` structure instead and pass it as `VkDeviceCreateInfo::pNext`.
+Enable this device feature - attach additional structure `VkPhysicalDeviceBufferDeviceAddressFeatures*` to
+`VkPhysicalDeviceFeatures2::pNext` and set its member `bufferDeviceAddress` to `VK_TRUE`.
+
+5) While creating #VmaAllocator with vmaCreateAllocator() inform VMA that you
+have enabled this feature - add #VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT
+to VmaAllocatorCreateInfo::flags.
+
+\section enabling_buffer_device_address_usage Usage
+
+After following steps described above, you can create buffers with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT*` using VMA.
+The library automatically adds `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT*` to
+allocated memory blocks wherever it might be needed.
+
+Please note that the library supports only `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT*`.
+The second part of this functionality related to "capture and replay" is not supported,
+as it is intended for usage in debugging tools like RenderDoc, not in everyday Vulkan usage.
+
+\section enabling_buffer_device_address_more_information More information
+
+To learn more about this extension, see [VK_KHR_buffer_device_address in Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/chap46.html#VK_KHR_buffer_device_address)
+
+Example use of this extension can be found in the code of the sample and test suite
+accompanying this library.
+
+\page general_considerations General considerations
+
+\section general_considerations_thread_safety Thread safety
+
+- The library has no global state, so separate #VmaAllocator objects can be used
+  independently.
+  There should be no need to create multiple such objects though - one per `VkDevice` is enough.
+- By default, all calls to functions that take #VmaAllocator as first parameter
+  are safe to call from multiple threads simultaneously because they are
+  synchronized internally when needed.
+- When the allocator is created with #VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
+  flag, calls to functions that take such #VmaAllocator object must be
+  synchronized externally.
+- Access to a #VmaAllocation object must be externally synchronized. For example,
+  you must not call vmaGetAllocationInfo() and vmaMapMemory() from different
+  threads at the same time if you pass the same #VmaAllocation object to these
+  functions.
+
+\section general_considerations_validation_layer_warnings Validation layer warnings
+
+When using this library, you can meet following types of warnings issued by
+Vulkan validation layer. They don't necessarily indicate a bug, so you may need
+to just ignore them.
+
+- *vkBindBufferMemory(): Binding memory to buffer 0xeb8e4 but vkGetBufferMemoryRequirements() has not been called on that buffer.*
+  - It happens when VK_KHR_dedicated_allocation extension is enabled.
+    `vkGetBufferMemoryRequirements2KHR` function is used instead, while validation layer seems to be unaware of it.
+- *Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.*
+  - It happens when you map a buffer or image, because the library maps entire
+    `VkDeviceMemory` block, where different types of images and buffers may end
+    up together, especially on GPUs with unified memory like Intel.
+- *Non-linear image 0xebc91 is aliased with linear buffer 0xeb8e4 which may indicate a bug.*
+  - It happens when you use lost allocations, and a new image or buffer is
+    created in place of an existing object that bacame lost.
+  - It may happen also when you use [defragmentation](@ref defragmentation).
+
+\section general_considerations_allocation_algorithm Allocation algorithm
+
+The library uses following algorithm for allocation, in order:
+
+-# Try to find free range of memory in existing blocks.
+-# If failed, try to create a new block of `VkDeviceMemory`, with preferred block size.
+-# If failed, try to create such block with size/2, size/4, size/8.
+-# If failed and #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag was
+   specified, try to find space in existing blocks, possilby making some other
+   allocations lost.
+-# If failed, try to allocate separate `VkDeviceMemory` for this allocation,
+   just like when you use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
+-# If failed, choose other memory type that meets the requirements specified in
+   VmaAllocationCreateInfo and go to point 1.
+-# If failed, return `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
+
+\section general_considerations_features_not_supported Features not supported
+
+Features deliberately excluded from the scope of this library:
+
+- Data transfer. Uploading (straming) and downloading data of buffers and images
+  between CPU and GPU memory and related synchronization is responsibility of the user.
+  Defining some "texture" object that would automatically stream its data from a
+  staging copy in CPU memory to GPU memory would rather be a feature of another,
+  higher-level library implemented on top of VMA.
+- Allocations for imported/exported external memory. They tend to require
+  explicit memory type index and dedicated allocation anyway, so they don't
+  interact with main features of this library. Such special purpose allocations
+  should be made manually, using `vkCreateBuffer()` and `vkAllocateMemory()`.
+- Sub-allocation of parts of one large buffer. Although recommended as a good practice,
+  it is the user's responsibility to implement such logic on top of VMA.
+- Recreation of buffers and images. Although the library has functions for
+  buffer and image creation (vmaCreateBuffer(), vmaCreateImage()), you need to
+  recreate these objects yourself after defragmentation. That's because the big
+  structures `VkBufferCreateInfo`, `VkImageCreateInfo` are not stored in
+  #VmaAllocation object.
+- Handling CPU memory allocation failures. When dynamically creating small C++
+  objects in CPU memory (not Vulkan memory), allocation failures are not checked
+  and handled gracefully, because that would complicate code significantly and
+  is usually not needed in desktop PC applications anyway.
+  Success of an allocation is just checked with an assert.
+- Code free of any compiler warnings. Maintaining the library to compile and
+  work correctly on so many different platforms is hard enough. Being free of
+  any warnings, on any version of any compiler, is simply not feasible.
+- This is a C++ library with C interface.
+  Bindings or ports to any other programming languages are welcomed as external projects and
+  are not going to be included into this repository.
+
+*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+Define this macro to 0/1 to disable/enable support for recording functionality,
+available through VmaAllocatorCreateInfo::pRecordSettings.
+*/
+#ifndef VMA_RECORDING_ENABLED
+    #define VMA_RECORDING_ENABLED 0
+#endif
+
+#if !defined(NOMINMAX) && defined(VMA_IMPLEMENTATION)
+    #define NOMINMAX // For windows.h
+#endif
+
+#if defined(__ANDROID__) && defined(VK_NO_PROTOTYPES) && VMA_STATIC_VULKAN_FUNCTIONS
+    extern PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
+    extern PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;
+    extern PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
+    extern PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
+    extern PFN_vkAllocateMemory vkAllocateMemory;
+    extern PFN_vkFreeMemory vkFreeMemory;
+    extern PFN_vkMapMemory vkMapMemory;
+    extern PFN_vkUnmapMemory vkUnmapMemory;
+    extern PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
+    extern PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
+    extern PFN_vkBindBufferMemory vkBindBufferMemory;
+    extern PFN_vkBindImageMemory vkBindImageMemory;
+    extern PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
+    extern PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
+    extern PFN_vkCreateBuffer vkCreateBuffer;
+    extern PFN_vkDestroyBuffer vkDestroyBuffer;
+    extern PFN_vkCreateImage vkCreateImage;
+    extern PFN_vkDestroyImage vkDestroyImage;
+    extern PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
+    #if VMA_VULKAN_VERSION >= 1001000
+        extern PFN_vkGetBufferMemoryRequirements2 vkGetBufferMemoryRequirements2;
+        extern PFN_vkGetImageMemoryRequirements2 vkGetImageMemoryRequirements2;
+        extern PFN_vkBindBufferMemory2 vkBindBufferMemory2;
+        extern PFN_vkBindImageMemory2 vkBindImageMemory2;
+        extern PFN_vkGetPhysicalDeviceMemoryProperties2 vkGetPhysicalDeviceMemoryProperties2;
+    #endif // #if VMA_VULKAN_VERSION >= 1001000
+#endif // #if defined(__ANDROID__) && VMA_STATIC_VULKAN_FUNCTIONS && VK_NO_PROTOTYPES
+
+#ifndef VULKAN_H_
+    #include <vulkan/vulkan.h>
+#endif
+
+// Define this macro to declare maximum supported Vulkan version in format AAABBBCCC,
+// where AAA = major, BBB = minor, CCC = patch.
+// If you want to use version > 1.0, it still needs to be enabled via VmaAllocatorCreateInfo::vulkanApiVersion.
+#if !defined(VMA_VULKAN_VERSION)
+    #if defined(VK_VERSION_1_2)
+        #define VMA_VULKAN_VERSION 1002000
+    #elif defined(VK_VERSION_1_1)
+        #define VMA_VULKAN_VERSION 1001000
+    #else
+        #define VMA_VULKAN_VERSION 1000000
+    #endif
+#endif
+
+#if !defined(VMA_DEDICATED_ALLOCATION)
+    #if VK_KHR_get_memory_requirements2 && VK_KHR_dedicated_allocation
+        #define VMA_DEDICATED_ALLOCATION 1
+    #else
+        #define VMA_DEDICATED_ALLOCATION 0
+    #endif
+#endif
+
+#if !defined(VMA_BIND_MEMORY2)
+    #if VK_KHR_bind_memory2
+        #define VMA_BIND_MEMORY2 1
+    #else
+        #define VMA_BIND_MEMORY2 0
+    #endif
+#endif
+
+#if !defined(VMA_MEMORY_BUDGET)
+    #if VK_EXT_memory_budget && (VK_KHR_get_physical_device_properties2 || VMA_VULKAN_VERSION >= 1001000)
+        #define VMA_MEMORY_BUDGET 1
+    #else
+        #define VMA_MEMORY_BUDGET 0
+    #endif
+#endif
+
+// Defined to 1 when VK_KHR_buffer_device_address device extension or equivalent core Vulkan 1.2 feature is defined in its headers.
+#if !defined(VMA_BUFFER_DEVICE_ADDRESS)
+    #if VK_KHR_buffer_device_address || VMA_VULKAN_VERSION >= 1002000
+        #define VMA_BUFFER_DEVICE_ADDRESS 1
+    #else
+        #define VMA_BUFFER_DEVICE_ADDRESS 0
+    #endif
+#endif
+
+// Define these macros to decorate all public functions with additional code,
+// before and after returned type, appropriately. This may be useful for
+// exporting the functions when compiling VMA as a separate library. Example:
+// #define VMA_CALL_PRE  __declspec(dllexport)
+// #define VMA_CALL_POST __cdecl
+#ifndef VMA_CALL_PRE
+    #define VMA_CALL_PRE
+#endif
+#ifndef VMA_CALL_POST
+    #define VMA_CALL_POST
+#endif
+
+// Define this macro to decorate pointers with an attribute specifying the
+// length of the array they point to if they are not null.
+//
+// The length may be one of
+// - The name of another parameter in the argument list where the pointer is declared
+// - The name of another member in the struct where the pointer is declared
+// - The name of a member of a struct type, meaning the value of that member in
+//   the context of the call. For example
+//   VMA_LEN_IF_NOT_NULL("VkPhysicalDeviceMemoryProperties::memoryHeapCount"),
+//   this means the number of memory heaps available in the device associated
+//   with the VmaAllocator being dealt with.
+#ifndef VMA_LEN_IF_NOT_NULL
+    #define VMA_LEN_IF_NOT_NULL(len)
+#endif
+
+// The VMA_NULLABLE macro is defined to be _Nullable when compiling with Clang.
+// see: https://clang.llvm.org/docs/AttributeReference.html#nullable
+#ifndef VMA_NULLABLE
+    #ifdef __clang__
+        #define VMA_NULLABLE _Nullable
+    #else
+        #define VMA_NULLABLE
+    #endif
+#endif
+
+// The VMA_NOT_NULL macro is defined to be _Nonnull when compiling with Clang.
+// see: https://clang.llvm.org/docs/AttributeReference.html#nonnull
+#ifndef VMA_NOT_NULL
+    #ifdef __clang__
+        #define VMA_NOT_NULL _Nonnull
+    #else
+        #define VMA_NOT_NULL
+    #endif
+#endif
+
+// If non-dispatchable handles are represented as pointers then we can give
+// then nullability annotations
+#ifndef VMA_NOT_NULL_NON_DISPATCHABLE
+    #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
+        #define VMA_NOT_NULL_NON_DISPATCHABLE VMA_NOT_NULL
+    #else
+        #define VMA_NOT_NULL_NON_DISPATCHABLE
+    #endif
+#endif
+
+#ifndef VMA_NULLABLE_NON_DISPATCHABLE
+    #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
+        #define VMA_NULLABLE_NON_DISPATCHABLE VMA_NULLABLE
+    #else
+        #define VMA_NULLABLE_NON_DISPATCHABLE
+    #endif
+#endif
+
+/** \struct VmaAllocator
+\brief Represents main object of this library initialized.
+
+Fill structure #VmaAllocatorCreateInfo and call function vmaCreateAllocator() to create it.
+Call function vmaDestroyAllocator() to destroy it.
+
+It is recommended to create just one object of this type per `VkDevice` object,
+right after Vulkan is initialized and keep it alive until before Vulkan device is destroyed.
+*/
+VK_DEFINE_HANDLE(VmaAllocator)
+
+/// Callback function called after successful vkAllocateMemory.
+typedef void (VKAPI_PTR *PFN_vmaAllocateDeviceMemoryFunction)(
+    VmaAllocator VMA_NOT_NULL                    allocator,
+    uint32_t                                     memoryType,
+    VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory,
+    VkDeviceSize                                 size,
+    void* VMA_NULLABLE                           pUserData);
+/// Callback function called before vkFreeMemory.
+typedef void (VKAPI_PTR *PFN_vmaFreeDeviceMemoryFunction)(
+    VmaAllocator VMA_NOT_NULL                    allocator,
+    uint32_t                                     memoryType,
+    VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory,
+    VkDeviceSize                                 size,
+    void* VMA_NULLABLE                           pUserData);
+
+/** \brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`.
+
+Provided for informative purpose, e.g. to gather statistics about number of
+allocations or total amount of memory allocated in Vulkan.
+
+Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.
+*/
+typedef struct VmaDeviceMemoryCallbacks {
+    /// Optional, can be null.
+    PFN_vmaAllocateDeviceMemoryFunction VMA_NULLABLE pfnAllocate;
+    /// Optional, can be null.
+    PFN_vmaFreeDeviceMemoryFunction VMA_NULLABLE pfnFree;
+    /// Optional, can be null.
+    void* VMA_NULLABLE pUserData;
+} VmaDeviceMemoryCallbacks;
+
+/// Flags for created #VmaAllocator.
+typedef enum VmaAllocatorCreateFlagBits {
+    /** \brief Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you.
+
+    Using this flag may increase performance because internal mutexes are not used.
+    */
+    VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
+    /** \brief Enables usage of VK_KHR_dedicated_allocation extension.
+
+    The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.
+    When it's `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.
+
+    Using this extenion will automatically allocate dedicated blocks of memory for
+    some buffers and images instead of suballocating place for them out of bigger
+    memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
+    flag) when it is recommended by the driver. It may improve performance on some
+    GPUs.
+
+    You may set this flag only if you found out that following device extensions are
+    supported, you enabled them while creating Vulkan device passed as
+    VmaAllocatorCreateInfo::device, and you want them to be used internally by this
+    library:
+
+    - VK_KHR_get_memory_requirements2 (device extension)
+    - VK_KHR_dedicated_allocation (device extension)
+
+    When this flag is set, you can experience following warnings reported by Vulkan
+    validation layer. You can ignore them.
+
+    > vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.
+    */
+    VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT = 0x00000002,
+    /**
+    Enables usage of VK_KHR_bind_memory2 extension.
+
+    The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.
+    When it's `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.
+
+    You may set this flag only if you found out that this device extension is supported,
+    you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,
+    and you want it to be used internally by this library.
+
+    The extension provides functions `vkBindBufferMemory2KHR` and `vkBindImageMemory2KHR`,
+    which allow to pass a chain of `pNext` structures while binding.
+    This flag is required if you use `pNext` parameter in vmaBindBufferMemory2() or vmaBindImageMemory2().
+    */
+    VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT = 0x00000004,
+    /**
+    Enables usage of VK_EXT_memory_budget extension.
+
+    You may set this flag only if you found out that this device extension is supported,
+    you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,
+    and you want it to be used internally by this library, along with another instance extension
+    VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).
+
+    The extension provides query for current memory usage and budget, which will probably
+    be more accurate than an estimation used by the library otherwise.
+    */
+    VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT = 0x00000008,
+    /**
+    Enables usage of VK_AMD_device_coherent_memory extension.
+
+    You may set this flag only if you:
+
+    - found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,
+    - checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,
+    - want it to be used internally by this library.
+
+    The extension and accompanying device feature provide access to memory types with
+    `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags.
+    They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.
+
+    When the extension is not enabled, such memory types are still enumerated, but their usage is illegal.
+    To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type,
+    returning `VK_ERROR_FEATURE_NOT_PRESENT`.
+    */
+    VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT = 0x00000010,
+    /**
+    Enables usage of "buffer device address" feature, which allows you to use function
+    `vkGetBufferDeviceAddress*` to get raw GPU pointer to a buffer and pass it for usage inside a shader.
+
+    You may set this flag only if you:
+
+    1. (For Vulkan version < 1.2) Found as available and enabled device extension
+    VK_KHR_buffer_device_address.
+    This extension is promoted to core Vulkan 1.2.
+    2. Found as available and enabled device feature `VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress`.
+
+    When this flag is set, you can create buffers with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT` using VMA.
+    The library automatically adds `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT` to
+    allocated memory blocks wherever it might be needed.
+
+    For more information, see documentation chapter \ref enabling_buffer_device_address.
+    */
+    VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT = 0x00000020,
+
+    VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VmaAllocatorCreateFlagBits;
+typedef VkFlags VmaAllocatorCreateFlags;
+
+/** \brief Pointers to some Vulkan functions - a subset used by the library.
+
+Used in VmaAllocatorCreateInfo::pVulkanFunctions.
+*/
+typedef struct VmaVulkanFunctions {
+    PFN_vkGetPhysicalDeviceProperties VMA_NULLABLE vkGetPhysicalDeviceProperties;
+    PFN_vkGetPhysicalDeviceMemoryProperties VMA_NULLABLE vkGetPhysicalDeviceMemoryProperties;
+    PFN_vkAllocateMemory VMA_NULLABLE vkAllocateMemory;
+    PFN_vkFreeMemory VMA_NULLABLE vkFreeMemory;
+    PFN_vkMapMemory VMA_NULLABLE vkMapMemory;
+    PFN_vkUnmapMemory VMA_NULLABLE vkUnmapMemory;
+    PFN_vkFlushMappedMemoryRanges VMA_NULLABLE vkFlushMappedMemoryRanges;
+    PFN_vkInvalidateMappedMemoryRanges VMA_NULLABLE vkInvalidateMappedMemoryRanges;
+    PFN_vkBindBufferMemory VMA_NULLABLE vkBindBufferMemory;
+    PFN_vkBindImageMemory VMA_NULLABLE vkBindImageMemory;
+    PFN_vkGetBufferMemoryRequirements VMA_NULLABLE vkGetBufferMemoryRequirements;
+    PFN_vkGetImageMemoryRequirements VMA_NULLABLE vkGetImageMemoryRequirements;
+    PFN_vkCreateBuffer VMA_NULLABLE vkCreateBuffer;
+    PFN_vkDestroyBuffer VMA_NULLABLE vkDestroyBuffer;
+    PFN_vkCreateImage VMA_NULLABLE vkCreateImage;
+    PFN_vkDestroyImage VMA_NULLABLE vkDestroyImage;
+    PFN_vkCmdCopyBuffer VMA_NULLABLE vkCmdCopyBuffer;
+#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    PFN_vkGetBufferMemoryRequirements2KHR VMA_NULLABLE vkGetBufferMemoryRequirements2KHR;
+    PFN_vkGetImageMemoryRequirements2KHR VMA_NULLABLE vkGetImageMemoryRequirements2KHR;
+#endif
+#if VMA_BIND_MEMORY2 || VMA_VULKAN_VERSION >= 1001000
+    PFN_vkBindBufferMemory2KHR VMA_NULLABLE vkBindBufferMemory2KHR;
+    PFN_vkBindImageMemory2KHR VMA_NULLABLE vkBindImageMemory2KHR;
+#endif
+#if VMA_MEMORY_BUDGET || VMA_VULKAN_VERSION >= 1001000
+    PFN_vkGetPhysicalDeviceMemoryProperties2KHR VMA_NULLABLE vkGetPhysicalDeviceMemoryProperties2KHR;
+#endif
+} VmaVulkanFunctions;
+
+/// Flags to be used in VmaRecordSettings::flags.
+typedef enum VmaRecordFlagBits {
+    /** \brief Enables flush after recording every function call.
+
+    Enable it if you expect your application to crash, which may leave recording file truncated.
+    It may degrade performance though.
+    */
+    VMA_RECORD_FLUSH_AFTER_CALL_BIT = 0x00000001,
+
+    VMA_RECORD_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VmaRecordFlagBits;
+typedef VkFlags VmaRecordFlags;
+
+/// Parameters for recording calls to VMA functions. To be used in VmaAllocatorCreateInfo::pRecordSettings.
+typedef struct VmaRecordSettings
+{
+    /// Flags for recording. Use #VmaRecordFlagBits enum.
+    VmaRecordFlags flags;
+    /** \brief Path to the file that should be written by the recording.
+
+    Suggested extension: "csv".
+    If the file already exists, it will be overwritten.
+    It will be opened for the whole time #VmaAllocator object is alive.
+    If opening this file fails, creation of the whole allocator object fails.
+    */
+    const char* VMA_NOT_NULL pFilePath;
+} VmaRecordSettings;
+
+/// Description of a Allocator to be created.
+typedef struct VmaAllocatorCreateInfo
+{
+    /// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.
+    VmaAllocatorCreateFlags flags;
+    /// Vulkan physical device.
+    /** It must be valid throughout whole lifetime of created allocator. */
+    VkPhysicalDevice VMA_NOT_NULL physicalDevice;
+    /// Vulkan device.
+    /** It must be valid throughout whole lifetime of created allocator. */
+    VkDevice VMA_NOT_NULL device;
+    /// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.
+    /** Set to 0 to use default, which is currently 256 MiB. */
+    VkDeviceSize preferredLargeHeapBlockSize;
+    /// Custom CPU memory allocation callbacks. Optional.
+    /** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */
+    const VkAllocationCallbacks* VMA_NULLABLE pAllocationCallbacks;
+    /// Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.
+    /** Optional, can be null. */
+    const VmaDeviceMemoryCallbacks* VMA_NULLABLE pDeviceMemoryCallbacks;
+    /** \brief Maximum number of additional frames that are in use at the same time as current frame.
+
+    This value is used only when you make allocations with
+    VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become
+    lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount.
+
+    For example, if you double-buffer your command buffers, so resources used for
+    rendering in previous frame may still be in use by the GPU at the moment you
+    allocate resources needed for the current frame, set this value to 1.
+
+    If you want to allow any allocations other than used in the current frame to
+    become lost, set this value to 0.
+    */
+    uint32_t frameInUseCount;
+    /** \brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap.
+
+    If not NULL, it must be a pointer to an array of
+    `VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on
+    maximum number of bytes that can be allocated out of particular Vulkan memory
+    heap.
+
+    Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that
+    heap. This is also the default in case of `pHeapSizeLimit` = NULL.
+
+    If there is a limit defined for a heap:
+
+    - If user tries to allocate more memory from that heap using this allocator,
+      the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
+    - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the
+      value of this limit will be reported instead when using vmaGetMemoryProperties().
+
+    Warning! Using this feature may not be equivalent to installing a GPU with
+    smaller amount of memory, because graphics driver doesn't necessary fail new
+    allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is
+    exceeded. It may return success and just silently migrate some device memory
+    blocks to system RAM. This driver behavior can also be controlled using
+    VK_AMD_memory_overallocation_behavior extension.
+    */
+    const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL("VkPhysicalDeviceMemoryProperties::memoryHeapCount") pHeapSizeLimit;
+
+    /** \brief Pointers to Vulkan functions. Can be null.
+
+    For details see [Pointers to Vulkan functions](@ref config_Vulkan_functions).
+    */
+    const VmaVulkanFunctions* VMA_NULLABLE pVulkanFunctions;
+    /** \brief Parameters for recording of VMA calls. Can be null.
+
+    If not null, it enables recording of calls to VMA functions to a file.
+    If support for recording is not enabled using `VMA_RECORDING_ENABLED` macro,
+    creation of the allocator object fails with `VK_ERROR_FEATURE_NOT_PRESENT`.
+    */
+    const VmaRecordSettings* VMA_NULLABLE pRecordSettings;
+    /** \brief Handle to Vulkan instance object.
+
+    Starting from version 3.0.0 this member is no longer optional, it must be set!
+    */
+    VkInstance VMA_NOT_NULL instance;
+    /** \brief Optional. The highest version of Vulkan that the application is designed to use.
+
+    It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.
+    The patch version number specified is ignored. Only the major and minor versions are considered.
+    It must be less or equal (preferably equal) to value as passed to `vkCreateInstance` as `VkApplicationInfo::apiVersion`.
+    Only versions 1.0, 1.1, 1.2 are supported by the current implementation.
+    Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.
+    */
+    uint32_t vulkanApiVersion;
+} VmaAllocatorCreateInfo;
+
+/// Creates Allocator object.
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAllocator(
+    const VmaAllocatorCreateInfo* VMA_NOT_NULL pCreateInfo,
+    VmaAllocator VMA_NULLABLE * VMA_NOT_NULL pAllocator);
+
+/// Destroys allocator object.
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyAllocator(
+    VmaAllocator VMA_NULLABLE allocator);
+
+/** \brief Information about existing #VmaAllocator object.
+*/
+typedef struct VmaAllocatorInfo
+{
+    /** \brief Handle to Vulkan instance object.
+
+    This is the same value as has been passed through VmaAllocatorCreateInfo::instance.
+    */
+    VkInstance VMA_NOT_NULL instance;
+    /** \brief Handle to Vulkan physical device object.
+
+    This is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice.
+    */
+    VkPhysicalDevice VMA_NOT_NULL physicalDevice;
+    /** \brief Handle to Vulkan device object.
+
+    This is the same value as has been passed through VmaAllocatorCreateInfo::device.
+    */
+    VkDevice VMA_NOT_NULL device;
+} VmaAllocatorInfo;
+
+/** \brief Returns information about existing #VmaAllocator object - handle to Vulkan device etc.
+
+It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to
+`VkPhysicalDevice`, `VkDevice` etc. every time using this function.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocatorInfo(VmaAllocator VMA_NOT_NULL allocator, VmaAllocatorInfo* VMA_NOT_NULL pAllocatorInfo);
+
+/**
+PhysicalDeviceProperties are fetched from physicalDevice by the allocator.
+You can access it here, without fetching it again on your own.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetPhysicalDeviceProperties(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkPhysicalDeviceProperties* VMA_NULLABLE * VMA_NOT_NULL ppPhysicalDeviceProperties);
+
+/**
+PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.
+You can access it here, without fetching it again on your own.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryProperties(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkPhysicalDeviceMemoryProperties* VMA_NULLABLE * VMA_NOT_NULL ppPhysicalDeviceMemoryProperties);
+
+/**
+\brief Given Memory Type Index, returns Property Flags of this memory type.
+
+This is just a convenience function. Same information can be obtained using
+vmaGetMemoryProperties().
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryTypeProperties(
+    VmaAllocator VMA_NOT_NULL allocator,
+    uint32_t memoryTypeIndex,
+    VkMemoryPropertyFlags* VMA_NOT_NULL pFlags);
+
+/** \brief Sets index of the current frame.
+
+This function must be used if you make allocations with
+#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT and
+#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flags to inform the allocator
+when a new frame begins. Allocations queried using vmaGetAllocationInfo() cannot
+become lost in the current frame.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaSetCurrentFrameIndex(
+    VmaAllocator VMA_NOT_NULL allocator,
+    uint32_t frameIndex);
+
+/** \brief Calculated statistics of memory usage in entire allocator.
+*/
+typedef struct VmaStatInfo
+{
+    /// Number of `VkDeviceMemory` Vulkan memory blocks allocated.
+    uint32_t blockCount;
+    /// Number of #VmaAllocation allocation objects allocated.
+    uint32_t allocationCount;
+    /// Number of free ranges of memory between allocations.
+    uint32_t unusedRangeCount;
+    /// Total number of bytes occupied by all allocations.
+    VkDeviceSize usedBytes;
+    /// Total number of bytes occupied by unused ranges.
+    VkDeviceSize unusedBytes;
+    VkDeviceSize allocationSizeMin, allocationSizeAvg, allocationSizeMax;
+    VkDeviceSize unusedRangeSizeMin, unusedRangeSizeAvg, unusedRangeSizeMax;
+} VmaStatInfo;
+
+/// General statistics from current state of Allocator.
+typedef struct VmaStats
+{
+    VmaStatInfo memoryType[VK_MAX_MEMORY_TYPES];
+    VmaStatInfo memoryHeap[VK_MAX_MEMORY_HEAPS];
+    VmaStatInfo total;
+} VmaStats;
+
+/** \brief Retrieves statistics from current state of the Allocator.
+
+This function is called "calculate" not "get" because it has to traverse all
+internal data structures, so it may be quite slow. For faster but more brief statistics
+suitable to be called every frame or every allocation, use vmaGetBudget().
+
+Note that when using allocator from multiple threads, returned information may immediately
+become outdated.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaCalculateStats(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaStats* VMA_NOT_NULL pStats);
+
+/** \brief Statistics of current memory usage and available budget, in bytes, for specific memory heap.
+*/
+typedef struct VmaBudget
+{
+    /** \brief Sum size of all `VkDeviceMemory` blocks allocated from particular heap, in bytes.
+    */
+    VkDeviceSize blockBytes;
+
+    /** \brief Sum size of all allocations created in particular heap, in bytes.
+
+    Usually less or equal than `blockBytes`.
+    Difference `blockBytes - allocationBytes` is the amount of memory allocated but unused -
+    available for new allocations or wasted due to fragmentation.
+
+    It might be greater than `blockBytes` if there are some allocations in lost state, as they account
+    to this value as well.
+    */
+    VkDeviceSize allocationBytes;
+
+    /** \brief Estimated current memory usage of the program, in bytes.
+
+    Fetched from system using `VK_EXT_memory_budget` extension if enabled.
+
+    It might be different than `blockBytes` (usually higher) due to additional implicit objects
+    also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or
+    `VkDeviceMemory` blocks allocated outside of this library, if any.
+    */
+    VkDeviceSize usage;
+
+    /** \brief Estimated amount of memory available to the program, in bytes.
+
+    Fetched from system using `VK_EXT_memory_budget` extension if enabled.
+
+    It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors
+    external to the program, like other programs also consuming system resources.
+    Difference `budget - usage` is the amount of additional memory that can probably
+    be allocated without problems. Exceeding the budget may result in various problems.
+    */
+    VkDeviceSize budget;
+} VmaBudget;
+
+/** \brief Retrieves information about current memory budget for all memory heaps.
+
+\param[out] pBudget Must point to array with number of elements at least equal to number of memory heaps in physical device used.
+
+This function is called "get" not "calculate" because it is very fast, suitable to be called
+every frame or every allocation. For more detailed statistics use vmaCalculateStats().
+
+Note that when using allocator from multiple threads, returned information may immediately
+become outdated.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetBudget(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaBudget* VMA_NOT_NULL pBudget);
+
+#ifndef VMA_STATS_STRING_ENABLED
+#define VMA_STATS_STRING_ENABLED 1
+#endif
+
+#if VMA_STATS_STRING_ENABLED
+
+/// Builds and returns statistics as string in JSON format.
+/** @param[out] ppStatsString Must be freed using vmaFreeStatsString() function.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaBuildStatsString(
+    VmaAllocator VMA_NOT_NULL allocator,
+    char* VMA_NULLABLE * VMA_NOT_NULL ppStatsString,
+    VkBool32 detailedMap);
+
+VMA_CALL_PRE void VMA_CALL_POST vmaFreeStatsString(
+    VmaAllocator VMA_NOT_NULL allocator,
+    char* VMA_NULLABLE pStatsString);
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+/** \struct VmaPool
+\brief Represents custom memory pool
+
+Fill structure VmaPoolCreateInfo and call function vmaCreatePool() to create it.
+Call function vmaDestroyPool() to destroy it.
+
+For more information see [Custom memory pools](@ref choosing_memory_type_custom_memory_pools).
+*/
+VK_DEFINE_HANDLE(VmaPool)
+
+typedef enum VmaMemoryUsage
+{
+    /** No intended memory usage specified.
+    Use other members of VmaAllocationCreateInfo to specify your requirements.
+    */
+    VMA_MEMORY_USAGE_UNKNOWN = 0,
+    /** Memory will be used on device only, so fast access from the device is preferred.
+    It usually means device-local GPU (video) memory.
+    No need to be mappable on host.
+    It is roughly equivalent of `D3D12_HEAP_TYPE_DEFAULT`.
+
+    Usage:
+
+    - Resources written and read by device, e.g. images used as attachments.
+    - Resources transferred from host once (immutable) or infrequently and read by
+      device multiple times, e.g. textures to be sampled, vertex buffers, uniform
+      (constant) buffers, and majority of other types of resources used on GPU.
+
+    Allocation may still end up in `HOST_VISIBLE` memory on some implementations.
+    In such case, you are free to map it.
+    You can use #VMA_ALLOCATION_CREATE_MAPPED_BIT with this usage type.
+    */
+    VMA_MEMORY_USAGE_GPU_ONLY = 1,
+    /** Memory will be mappable on host.
+    It usually means CPU (system) memory.
+    Guarantees to be `HOST_VISIBLE` and `HOST_COHERENT`.
+    CPU access is typically uncached. Writes may be write-combined.
+    Resources created in this pool may still be accessible to the device, but access to them can be slow.
+    It is roughly equivalent of `D3D12_HEAP_TYPE_UPLOAD`.
+
+    Usage: Staging copy of resources used as transfer source.
+    */
+    VMA_MEMORY_USAGE_CPU_ONLY = 2,
+    /**
+    Memory that is both mappable on host (guarantees to be `HOST_VISIBLE`) and preferably fast to access by GPU.
+    CPU access is typically uncached. Writes may be write-combined.
+
+    Usage: Resources written frequently by host (dynamic), read by device. E.g. textures (with LINEAR layout), vertex buffers, uniform buffers updated every frame or every draw call.
+    */
+    VMA_MEMORY_USAGE_CPU_TO_GPU = 3,
+    /** Memory mappable on host (guarantees to be `HOST_VISIBLE`) and cached.
+    It is roughly equivalent of `D3D12_HEAP_TYPE_READBACK`.
+
+    Usage:
+
+    - Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.
+    - Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection.
+    */
+    VMA_MEMORY_USAGE_GPU_TO_CPU = 4,
+    /** CPU memory - memory that is preferably not `DEVICE_LOCAL`, but also not guaranteed to be `HOST_VISIBLE`.
+
+    Usage: Staging copy of resources moved from GPU memory to CPU memory as part
+    of custom paging/residency mechanism, to be moved back to GPU memory when needed.
+    */
+    VMA_MEMORY_USAGE_CPU_COPY = 5,
+    /** Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`.
+    Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.
+
+    Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.
+
+    Allocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
+    */
+    VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED = 6,
+
+    VMA_MEMORY_USAGE_MAX_ENUM = 0x7FFFFFFF
+} VmaMemoryUsage;
+
+/// Flags to be passed as VmaAllocationCreateInfo::flags.
+typedef enum VmaAllocationCreateFlagBits {
+    /** \brief Set this flag if the allocation should have its own memory block.
+
+    Use it for special, big resources, like fullscreen images used as attachments.
+
+    You should not use this flag if VmaAllocationCreateInfo::pool is not null.
+    */
+    VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT = 0x00000001,
+
+    /** \brief Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block.
+
+    If new allocation cannot be placed in any of the existing blocks, allocation
+    fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.
+
+    You should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and
+    #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense.
+
+    If VmaAllocationCreateInfo::pool is not null, this flag is implied and ignored. */
+    VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT = 0x00000002,
+    /** \brief Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
+
+    Pointer to mapped memory will be returned through VmaAllocationInfo::pMappedData.
+
+    It is valid to use this flag for allocation made from memory type that is not
+    `HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is
+    useful if you need an allocation that is efficient to use on GPU
+    (`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that
+    support it (e.g. Intel GPU).
+
+    You should not use this flag together with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT.
+    */
+    VMA_ALLOCATION_CREATE_MAPPED_BIT = 0x00000004,
+    /** Allocation created with this flag can become lost as a result of another
+    allocation with #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag, so you
+    must check it before use.
+
+    To check if allocation is not lost, call vmaGetAllocationInfo() and check if
+    VmaAllocationInfo::deviceMemory is not `VK_NULL_HANDLE`.
+
+    For details about supporting lost allocations, see Lost Allocations
+    chapter of User Guide on Main Page.
+
+    You should not use this flag together with #VMA_ALLOCATION_CREATE_MAPPED_BIT.
+    */
+    VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT = 0x00000008,
+    /** While creating allocation using this flag, other allocations that were
+    created with flag #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT can become lost.
+
+    For details about supporting lost allocations, see Lost Allocations
+    chapter of User Guide on Main Page.
+    */
+    VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT = 0x00000010,
+    /** Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a
+    null-terminated string. Instead of copying pointer value, a local copy of the
+    string is made and stored in allocation's `pUserData`. The string is automatically
+    freed together with the allocation. It is also used in vmaBuildStatsString().
+    */
+    VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT = 0x00000020,
+    /** Allocation will be created from upper stack in a double stack pool.
+
+    This flag is only allowed for custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT flag.
+    */
+    VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT = 0x00000040,
+    /** Create both buffer/image and allocation, but don't bind them together.
+    It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions.
+    The flag is meaningful only with functions that bind by default: vmaCreateBuffer(), vmaCreateImage().
+    Otherwise it is ignored.
+    */
+    VMA_ALLOCATION_CREATE_DONT_BIND_BIT = 0x00000080,
+    /** Create allocation only if additional device memory required for it, if any, won't exceed
+    memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
+    */
+    VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT = 0x00000100,
+
+    /** Allocation strategy that chooses smallest possible free range for the
+    allocation.
+    */
+    VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT  = 0x00010000,
+    /** Allocation strategy that chooses biggest possible free range for the
+    allocation.
+    */
+    VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT = 0x00020000,
+    /** Allocation strategy that chooses first suitable free range for the
+    allocation.
+
+    "First" doesn't necessarily means the one with smallest offset in memory,
+    but rather the one that is easiest and fastest to find.
+    */
+    VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT = 0x00040000,
+
+    /** Allocation strategy that tries to minimize memory usage.
+    */
+    VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT = VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT,
+    /** Allocation strategy that tries to minimize allocation time.
+    */
+    VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT = VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT,
+    /** Allocation strategy that tries to minimize memory fragmentation.
+    */
+    VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT = VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT,
+
+    /** A bit mask to extract only `STRATEGY` bits from entire set of flags.
+    */
+    VMA_ALLOCATION_CREATE_STRATEGY_MASK =
+        VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT |
+        VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT |
+        VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT,
+
+    VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VmaAllocationCreateFlagBits;
+typedef VkFlags VmaAllocationCreateFlags;
+
+typedef struct VmaAllocationCreateInfo
+{
+    /// Use #VmaAllocationCreateFlagBits enum.
+    VmaAllocationCreateFlags flags;
+    /** \brief Intended usage of memory.
+
+    You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \n
+    If `pool` is not null, this member is ignored.
+    */
+    VmaMemoryUsage usage;
+    /** \brief Flags that must be set in a Memory Type chosen for an allocation.
+
+    Leave 0 if you specify memory requirements in other way. \n
+    If `pool` is not null, this member is ignored.*/
+    VkMemoryPropertyFlags requiredFlags;
+    /** \brief Flags that preferably should be set in a memory type chosen for an allocation.
+
+    Set to 0 if no additional flags are preferred. \n
+    If `pool` is not null, this member is ignored. */
+    VkMemoryPropertyFlags preferredFlags;
+    /** \brief Bitmask containing one bit set for every memory type acceptable for this allocation.
+
+    Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if
+    it meets other requirements specified by this structure, with no further
+    restrictions on memory type index. \n
+    If `pool` is not null, this member is ignored.
+    */
+    uint32_t memoryTypeBits;
+    /** \brief Pool that this allocation should be created in.
+
+    Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:
+    `usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.
+    */
+    VmaPool VMA_NULLABLE pool;
+    /** \brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData().
+
+    If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either
+    null or pointer to a null-terminated string. The string will be then copied to
+    internal buffer, so it doesn't need to be valid after allocation call.
+    */
+    void* VMA_NULLABLE pUserData;
+} VmaAllocationCreateInfo;
+
+/**
+\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo.
+
+This algorithm tries to find a memory type that:
+
+- Is allowed by memoryTypeBits.
+- Contains all the flags from pAllocationCreateInfo->requiredFlags.
+- Matches intended usage.
+- Has as many flags from pAllocationCreateInfo->preferredFlags as possible.
+
+\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result
+from this function or any other allocating function probably means that your
+device doesn't support any memory type with requested features for the specific
+type of resource you want to use it for. Please check parameters of your
+resource, like image layout (OPTIMAL versus LINEAR) or mip level count.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndex(
+    VmaAllocator VMA_NOT_NULL allocator,
+    uint32_t memoryTypeBits,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo,
+    uint32_t* VMA_NOT_NULL pMemoryTypeIndex);
+
+/**
+\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.
+
+It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
+It internally creates a temporary, dummy buffer that never has memory bound.
+It is just a convenience function, equivalent to calling:
+
+- `vkCreateBuffer`
+- `vkGetBufferMemoryRequirements`
+- `vmaFindMemoryTypeIndex`
+- `vkDestroyBuffer`
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForBufferInfo(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkBufferCreateInfo* VMA_NOT_NULL pBufferCreateInfo,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo,
+    uint32_t* VMA_NOT_NULL pMemoryTypeIndex);
+
+/**
+\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.
+
+It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
+It internally creates a temporary, dummy image that never has memory bound.
+It is just a convenience function, equivalent to calling:
+
+- `vkCreateImage`
+- `vkGetImageMemoryRequirements`
+- `vmaFindMemoryTypeIndex`
+- `vkDestroyImage`
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForImageInfo(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkImageCreateInfo* VMA_NOT_NULL pImageCreateInfo,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo,
+    uint32_t* VMA_NOT_NULL pMemoryTypeIndex);
+
+/// Flags to be passed as VmaPoolCreateInfo::flags.
+typedef enum VmaPoolCreateFlagBits {
+    /** \brief Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored.
+
+    This is an optional optimization flag.
+
+    If you always allocate using vmaCreateBuffer(), vmaCreateImage(),
+    vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator
+    knows exact type of your allocations so it can handle Buffer-Image Granularity
+    in the optimal way.
+
+    If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),
+    exact type of such allocations is not known, so allocator must be conservative
+    in handling Buffer-Image Granularity, which can lead to suboptimal allocation
+    (wasted memory). In that case, if you can make sure you always allocate only
+    buffers and linear images or only optimal images out of this pool, use this flag
+    to make allocator disregard Buffer-Image Granularity and so make allocations
+    faster and more optimal.
+    */
+    VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT = 0x00000002,
+
+    /** \brief Enables alternative, linear allocation algorithm in this pool.
+
+    Specify this flag to enable linear allocation algorithm, which always creates
+    new allocations after last one and doesn't reuse space from allocations freed in
+    between. It trades memory consumption for simplified algorithm and data
+    structure, which has better performance and uses less memory for metadata.
+
+    By using this flag, you can achieve behavior of free-at-once, stack,
+    ring buffer, and double stack. For details, see documentation chapter
+    \ref linear_algorithm.
+
+    When using this flag, you must specify VmaPoolCreateInfo::maxBlockCount == 1 (or 0 for default).
+
+    For more details, see [Linear allocation algorithm](@ref linear_algorithm).
+    */
+    VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT = 0x00000004,
+
+    /** \brief Enables alternative, buddy allocation algorithm in this pool.
+
+    It operates on a tree of blocks, each having size that is a power of two and
+    a half of its parent's size. Comparing to default algorithm, this one provides
+    faster allocation and deallocation and decreased external fragmentation,
+    at the expense of more memory wasted (internal fragmentation).
+
+    For more details, see [Buddy allocation algorithm](@ref buddy_algorithm).
+    */
+    VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT = 0x00000008,
+
+    /** Bit mask to extract only `ALGORITHM` bits from entire set of flags.
+    */
+    VMA_POOL_CREATE_ALGORITHM_MASK =
+        VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT |
+        VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT,
+
+    VMA_POOL_CREATE_EXPORTABLE_BIT = 0x00000010,
+
+    VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VmaPoolCreateFlagBits;
+typedef VkFlags VmaPoolCreateFlags;
+
+/** \brief Describes parameter of created #VmaPool.
+*/
+typedef struct VmaPoolCreateInfo {
+    /** \brief Vulkan memory type index to allocate this pool from.
+    */
+    uint32_t memoryTypeIndex;
+    /** \brief Use combination of #VmaPoolCreateFlagBits.
+    */
+    VmaPoolCreateFlags flags;
+    /** \brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional.
+
+    Specify nonzero to set explicit, constant size of memory blocks used by this
+    pool.
+
+    Leave 0 to use default and let the library manage block sizes automatically.
+    Sizes of particular blocks may vary.
+    */
+    VkDeviceSize blockSize;
+    /** \brief Minimum number of blocks to be always allocated in this pool, even if they stay empty.
+
+    Set to 0 to have no preallocated blocks and allow the pool be completely empty.
+    */
+    size_t minBlockCount;
+    /** \brief Maximum number of blocks that can be allocated in this pool. Optional.
+
+    Set to 0 to use default, which is `SIZE_MAX`, which means no limit.
+
+    Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated
+    throughout whole lifetime of this pool.
+    */
+    size_t maxBlockCount;
+    /** \brief Maximum number of additional frames that are in use at the same time as current frame.
+
+    This value is used only when you make allocations with
+    #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become
+    lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount.
+
+    For example, if you double-buffer your command buffers, so resources used for
+    rendering in previous frame may still be in use by the GPU at the moment you
+    allocate resources needed for the current frame, set this value to 1.
+
+    If you want to allow any allocations other than used in the current frame to
+    become lost, set this value to 0.
+    */
+    uint32_t frameInUseCount;
+} VmaPoolCreateInfo;
+
+/** \brief Describes parameter of existing #VmaPool.
+*/
+typedef struct VmaPoolStats {
+    /** \brief Total amount of `VkDeviceMemory` allocated from Vulkan for this pool, in bytes.
+    */
+    VkDeviceSize size;
+    /** \brief Total number of bytes in the pool not used by any #VmaAllocation.
+    */
+    VkDeviceSize unusedSize;
+    /** \brief Number of #VmaAllocation objects created from this pool that were not destroyed or lost.
+    */
+    size_t allocationCount;
+    /** \brief Number of continuous memory ranges in the pool not used by any #VmaAllocation.
+    */
+    size_t unusedRangeCount;
+    /** \brief Size of the largest continuous free memory region available for new allocation.
+
+    Making a new allocation of that size is not guaranteed to succeed because of
+    possible additional margin required to respect alignment and buffer/image
+    granularity.
+    */
+    VkDeviceSize unusedRangeSizeMax;
+    /** \brief Number of `VkDeviceMemory` blocks allocated for this pool.
+    */
+    size_t blockCount;
+} VmaPoolStats;
+
+/** \brief Allocates Vulkan device memory and creates #VmaPool object.
+
+@param allocator Allocator object.
+@param pCreateInfo Parameters of pool to create.
+@param[out] pPool Handle to created pool.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreatePool(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VmaPoolCreateInfo* VMA_NOT_NULL pCreateInfo,
+    VmaPool VMA_NULLABLE * VMA_NOT_NULL pPool);
+
+/** \brief Destroys #VmaPool object and frees Vulkan device memory.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaPool VMA_NULLABLE pool);
+
+/** \brief Retrieves statistics of existing #VmaPool object.
+
+@param allocator Allocator object.
+@param pool Pool object.
+@param[out] pPoolStats Statistics of specified pool.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolStats(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaPool VMA_NOT_NULL pool,
+    VmaPoolStats* VMA_NOT_NULL pPoolStats);
+
+/** \brief Marks all allocations in given pool as lost if they are not used in current frame or VmaPoolCreateInfo::frameInUseCount back from now.
+
+@param allocator Allocator object.
+@param pool Pool.
+@param[out] pLostAllocationCount Number of allocations marked as lost. Optional - pass null if you don't need this information.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaMakePoolAllocationsLost(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaPool VMA_NOT_NULL pool,
+    size_t* VMA_NULLABLE pLostAllocationCount);
+
+/** \brief Checks magic number in margins around all allocations in given memory pool in search for corruptions.
+
+Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,
+`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is
+`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).
+
+Possible return values:
+
+- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.
+- `VK_SUCCESS` - corruption detection has been performed and succeeded.
+- `VK_ERROR_VALIDATION_FAILED_EXT` - corruption detection has been performed and found memory corruptions around one of the allocations.
+  `VMA_ASSERT` is also fired in that case.
+- Other value: Error returned by Vulkan, e.g. memory mapping failure.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckPoolCorruption(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool);
+
+/** \brief Retrieves name of a custom pool.
+
+After the call `ppName` is either null or points to an internally-owned null-terminated string
+containing name of the pool that was previously set. The pointer becomes invalid when the pool is
+destroyed or its name is changed using vmaSetPoolName().
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolName(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaPool VMA_NOT_NULL pool,
+    const char* VMA_NULLABLE * VMA_NOT_NULL ppName);
+
+/** \brief Sets name of a custom pool.
+
+`pName` can be either null or pointer to a null-terminated string with new name for the pool.
+Function makes internal copy of the string, so it can be changed or freed immediately after this call.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaSetPoolName(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaPool VMA_NOT_NULL pool,
+    const char* VMA_NULLABLE pName);
+
+/** \struct VmaAllocation
+\brief Represents single memory allocation.
+
+It may be either dedicated block of `VkDeviceMemory` or a specific region of a bigger block of this type
+plus unique offset.
+
+There are multiple ways to create such object.
+You need to fill structure VmaAllocationCreateInfo.
+For more information see [Choosing memory type](@ref choosing_memory_type).
+
+Although the library provides convenience functions that create Vulkan buffer or image,
+allocate memory for it and bind them together,
+binding of the allocation to a buffer or an image is out of scope of the allocation itself.
+Allocation object can exist without buffer/image bound,
+binding can be done manually by the user, and destruction of it can be done
+independently of destruction of the allocation.
+
+The object also remembers its size and some other information.
+To retrieve this information, use function vmaGetAllocationInfo() and inspect
+returned structure VmaAllocationInfo.
+
+Some kinds allocations can be in lost state.
+For more information, see [Lost allocations](@ref lost_allocations).
+*/
+VK_DEFINE_HANDLE(VmaAllocation)
+
+/** \brief Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().
+*/
+typedef struct VmaAllocationInfo {
+    /** \brief Memory type index that this allocation was allocated from.
+
+    It never changes.
+    */
+    uint32_t memoryType;
+    /** \brief Handle to Vulkan memory object.
+
+    Same memory object can be shared by multiple allocations.
+
+    It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.
+
+    If the allocation is lost, it is equal to `VK_NULL_HANDLE`.
+    */
+    VkDeviceMemory VMA_NULLABLE_NON_DISPATCHABLE deviceMemory;
+    /** \brief Offset in `VkDeviceMemory` object to the beginning of this allocation, in bytes. `(deviceMemory, offset)` pair is unique to this allocation.
+
+    You usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function
+    vmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,
+    not entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation
+    and apply this offset automatically.
+
+    It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.
+    */
+    VkDeviceSize offset;
+    /** \brief Size of this allocation, in bytes.
+
+    It never changes, unless allocation is lost.
+
+    \note Allocation size returned in this variable may be greater than the size
+    requested for the resource e.g. as `VkBufferCreateInfo::size`. Whole size of the
+    allocation is accessible for operations on memory e.g. using a pointer after
+    mapping with vmaMapMemory(), but operations on the resource e.g. using
+    `vkCmdCopyBuffer` must be limited to the size of the resource.
+    */
+    VkDeviceSize size;
+    /** \brief Pointer to the beginning of this allocation as mapped data.
+
+    If the allocation hasn't been mapped using vmaMapMemory() and hasn't been
+    created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null.
+
+    It can change after call to vmaMapMemory(), vmaUnmapMemory().
+    It can also change after call to vmaDefragment() if this allocation is passed to the function.
+    */
+    void* VMA_NULLABLE pMappedData;
+    /** \brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData().
+
+    It can change after call to vmaSetAllocationUserData() for this allocation.
+    */
+    void* VMA_NULLABLE pUserData;
+} VmaAllocationInfo;
+
+/** \brief General purpose memory allocation.
+
+@param[out] pAllocation Handle to allocated memory.
+@param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().
+
+You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().
+
+It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),
+vmaCreateBuffer(), vmaCreateImage() instead whenever possible.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemory(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkMemoryRequirements* VMA_NOT_NULL pVkMemoryRequirements,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pCreateInfo,
+    VmaAllocation VMA_NULLABLE * VMA_NOT_NULL pAllocation,
+    VmaAllocationInfo* VMA_NULLABLE pAllocationInfo);
+
+/** \brief General purpose memory allocation for multiple allocation objects at once.
+
+@param allocator Allocator object.
+@param pVkMemoryRequirements Memory requirements for each allocation.
+@param pCreateInfo Creation parameters for each alloction.
+@param allocationCount Number of allocations to make.
+@param[out] pAllocations Pointer to array that will be filled with handles to created allocations.
+@param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters of created allocations.
+
+You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().
+
+Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.
+It is just a general purpose allocation function able to make multiple allocations at once.
+It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.
+
+All allocations are made using same parameters. All of them are created out of the same memory pool and type.
+If any allocation fails, all allocations already made within this function call are also freed, so that when
+returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryPages(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkMemoryRequirements* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pVkMemoryRequirements,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pCreateInfo,
+    size_t allocationCount,
+    VmaAllocation VMA_NULLABLE * VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations,
+    VmaAllocationInfo* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocationInfo);
+
+/**
+@param[out] pAllocation Handle to allocated memory.
+@param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().
+
+You should free the memory using vmaFreeMemory().
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForBuffer(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pCreateInfo,
+    VmaAllocation VMA_NULLABLE * VMA_NOT_NULL pAllocation,
+    VmaAllocationInfo* VMA_NULLABLE pAllocationInfo);
+
+/// Function similar to vmaAllocateMemoryForBuffer().
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForImage(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VkImage VMA_NOT_NULL_NON_DISPATCHABLE image,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pCreateInfo,
+    VmaAllocation VMA_NULLABLE * VMA_NOT_NULL pAllocation,
+    VmaAllocationInfo* VMA_NULLABLE pAllocationInfo);
+
+/** \brief Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage().
+
+Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VmaAllocation VMA_NULLABLE allocation);
+
+/** \brief Frees memory and destroys multiple allocations.
+
+Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.
+It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),
+vmaAllocateMemoryPages() and other functions.
+It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.
+
+Allocations in `pAllocations` array can come from any memory pools and types.
+Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemoryPages(
+    VmaAllocator VMA_NOT_NULL allocator,
+    size_t allocationCount,
+    const VmaAllocation VMA_NULLABLE * VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations);
+
+/** \brief Deprecated.
+
+\deprecated
+In version 2.2.0 it used to try to change allocation's size without moving or reallocating it.
+In current version it returns `VK_SUCCESS` only if `newSize` equals current allocation's size.
+Otherwise returns `VK_ERROR_OUT_OF_POOL_MEMORY`, indicating that allocation's size could not be changed.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaResizeAllocation(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VkDeviceSize newSize);
+
+/** \brief Returns current information about specified allocation and atomically marks it as used in current frame.
+
+Current paramteres of given allocation are returned in `pAllocationInfo`.
+
+This function also atomically "touches" allocation - marks it as used in current frame,
+just like vmaTouchAllocation().
+If the allocation is in lost state, `pAllocationInfo->deviceMemory == VK_NULL_HANDLE`.
+
+Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient,
+you can avoid calling it too often.
+
+- You can retrieve same VmaAllocationInfo structure while creating your resource, from function
+  vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change
+  (e.g. due to defragmentation or allocation becoming lost).
+- If you just want to check if allocation is not lost, vmaTouchAllocation() will work faster.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VmaAllocationInfo* VMA_NOT_NULL pAllocationInfo);
+
+/** \brief Returns `VK_TRUE` if allocation is not lost and atomically marks it as used in current frame.
+
+If the allocation has been created with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
+this function returns `VK_TRUE` if it's not in lost state, so it can still be used.
+It then also atomically "touches" the allocation - marks it as used in current frame,
+so that you can be sure it won't become lost in current frame or next `frameInUseCount` frames.
+
+If the allocation is in lost state, the function returns `VK_FALSE`.
+Memory of such allocation, as well as buffer or image bound to it, should not be used.
+Lost allocation and the buffer/image still need to be destroyed.
+
+If the allocation has been created without #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
+this function always returns `VK_TRUE`.
+*/
+VMA_CALL_PRE VkBool32 VMA_CALL_POST vmaTouchAllocation(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation);
+
+/** \brief Sets pUserData in given allocation to new value.
+
+If the allocation was created with VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT,
+pUserData must be either null, or pointer to a null-terminated string. The function
+makes local copy of the string and sets it as allocation's `pUserData`. String
+passed as pUserData doesn't need to be valid for whole lifetime of the allocation -
+you can free it after this call. String previously pointed by allocation's
+pUserData is freed from memory.
+
+If the flag was not used, the value of pointer `pUserData` is just copied to
+allocation's `pUserData`. It is opaque, so you can use it however you want - e.g.
+as a pointer, ordinal number or some handle to you own data.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationUserData(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    void* VMA_NULLABLE pUserData);
+
+/** \brief Creates new allocation that is in lost state from the beginning.
+
+It can be useful if you need a dummy, non-null allocation.
+
+You still need to destroy created object using vmaFreeMemory().
+
+Returned allocation is not tied to any specific memory pool or memory type and
+not bound to any image or buffer. It has size = 0. It cannot be turned into
+a real, non-empty allocation.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaCreateLostAllocation(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NULLABLE * VMA_NOT_NULL pAllocation);
+
+/** \brief Maps memory represented by given allocation and returns pointer to it.
+
+Maps memory represented by given allocation to make it accessible to CPU code.
+When succeeded, `*ppData` contains pointer to first byte of this memory.
+If the allocation is part of bigger `VkDeviceMemory` block, the pointer is
+correctly offseted to the beginning of region assigned to this particular
+allocation.
+
+Mapping is internally reference-counted and synchronized, so despite raw Vulkan
+function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`
+multiple times simultaneously, it is safe to call this function on allocations
+assigned to the same memory block. Actual Vulkan memory will be mapped on first
+mapping and unmapped on last unmapping.
+
+If the function succeeded, you must call vmaUnmapMemory() to unmap the
+allocation when mapping is no longer needed or before freeing the allocation, at
+the latest.
+
+It also safe to call this function multiple times on the same allocation. You
+must call vmaUnmapMemory() same number of times as you called vmaMapMemory().
+
+It is also safe to call this function on allocation created with
+#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.
+You must still call vmaUnmapMemory() same number of times as you called
+vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the
+"0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.
+
+This function fails when used on allocation made in memory type that is not
+`HOST_VISIBLE`.
+
+This function always fails when called for allocation that was created with
+#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocations cannot be
+mapped.
+
+This function doesn't automatically flush or invalidate caches.
+If the allocation is made from a memory types that is not `HOST_COHERENT`,
+you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaMapMemory(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    void* VMA_NULLABLE * VMA_NOT_NULL ppData);
+
+/** \brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().
+
+For details, see description of vmaMapMemory().
+
+This function doesn't automatically flush or invalidate caches.
+If the allocation is made from a memory types that is not `HOST_COHERENT`,
+you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaUnmapMemory(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation);
+
+/** \brief Flushes memory of given allocation.
+
+Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.
+It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.
+Unmap operation doesn't do that automatically.
+
+- `offset` must be relative to the beginning of allocation.
+- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.
+- `offset` and `size` don't have to be aligned.
+  They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
+- If `size` is 0, this call is ignored.
+- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,
+  this call is ignored.
+
+Warning! `offset` and `size` are relative to the contents of given `allocation`.
+If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
+Do not pass allocation's offset as `offset`!!!
+
+This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is
+called, otherwise `VK_SUCCESS`.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocation(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VkDeviceSize offset,
+    VkDeviceSize size);
+
+/** \brief Invalidates memory of given allocation.
+
+Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.
+It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.
+Map operation doesn't do that automatically.
+
+- `offset` must be relative to the beginning of allocation.
+- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.
+- `offset` and `size` don't have to be aligned.
+  They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
+- If `size` is 0, this call is ignored.
+- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,
+  this call is ignored.
+
+Warning! `offset` and `size` are relative to the contents of given `allocation`.
+If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
+Do not pass allocation's offset as `offset`!!!
+
+This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if
+it is called, otherwise `VK_SUCCESS`.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocation(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VkDeviceSize offset,
+    VkDeviceSize size);
+
+/** \brief Flushes memory of given set of allocations.
+
+Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.
+For more information, see documentation of vmaFlushAllocation().
+
+\param allocator
+\param allocationCount
+\param allocations
+\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero.
+\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.
+
+This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is
+called, otherwise `VK_SUCCESS`.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocations(
+    VmaAllocator VMA_NOT_NULL allocator,
+    uint32_t allocationCount,
+    const VmaAllocation VMA_NOT_NULL * VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations,
+    const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets,
+    const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes);
+
+/** \brief Invalidates memory of given set of allocations.
+
+Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.
+For more information, see documentation of vmaInvalidateAllocation().
+
+\param allocator
+\param allocationCount
+\param allocations
+\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero.
+\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.
+
+This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is
+called, otherwise `VK_SUCCESS`.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocations(
+    VmaAllocator VMA_NOT_NULL allocator,
+    uint32_t allocationCount,
+    const VmaAllocation VMA_NOT_NULL * VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations,
+    const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets,
+    const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes);
+
+/** \brief Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.
+
+@param memoryTypeBits Bit mask, where each bit set means that a memory type with that index should be checked.
+
+Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,
+`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are
+`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).
+
+Possible return values:
+
+- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.
+- `VK_SUCCESS` - corruption detection has been performed and succeeded.
+- `VK_ERROR_VALIDATION_FAILED_EXT` - corruption detection has been performed and found memory corruptions around one of the allocations.
+  `VMA_ASSERT` is also fired in that case.
+- Other value: Error returned by Vulkan, e.g. memory mapping failure.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckCorruption(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeBits);
+
+/** \struct VmaDefragmentationContext
+\brief Represents Opaque object that represents started defragmentation process.
+
+Fill structure #VmaDefragmentationInfo2 and call function vmaDefragmentationBegin() to create it.
+Call function vmaDefragmentationEnd() to destroy it.
+*/
+VK_DEFINE_HANDLE(VmaDefragmentationContext)
+
+/// Flags to be used in vmaDefragmentationBegin(). None at the moment. Reserved for future use.
+typedef enum VmaDefragmentationFlagBits {
+    VMA_DEFRAGMENTATION_FLAG_INCREMENTAL = 0x1,
+    VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VmaDefragmentationFlagBits;
+typedef VkFlags VmaDefragmentationFlags;
+
+/** \brief Parameters for defragmentation.
+
+To be used with function vmaDefragmentationBegin().
+*/
+typedef struct VmaDefragmentationInfo2 {
+    /** \brief Reserved for future use. Should be 0.
+    */
+    VmaDefragmentationFlags flags;
+    /** \brief Number of allocations in `pAllocations` array.
+    */
+    uint32_t allocationCount;
+    /** \brief Pointer to array of allocations that can be defragmented.
+
+    The array should have `allocationCount` elements.
+    The array should not contain nulls.
+    Elements in the array should be unique - same allocation cannot occur twice.
+    It is safe to pass allocations that are in the lost state - they are ignored.
+    All allocations not present in this array are considered non-moveable during this defragmentation.
+    */
+    const VmaAllocation VMA_NOT_NULL * VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations;
+    /** \brief Optional, output. Pointer to array that will be filled with information whether the allocation at certain index has been changed during defragmentation.
+
+    The array should have `allocationCount` elements.
+    You can pass null if you are not interested in this information.
+    */
+    VkBool32* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocationsChanged;
+    /** \brief Numer of pools in `pPools` array.
+    */
+    uint32_t poolCount;
+    /** \brief Either null or pointer to array of pools to be defragmented.
+
+    All the allocations in the specified pools can be moved during defragmentation
+    and there is no way to check if they were really moved as in `pAllocationsChanged`,
+    so you must query all the allocations in all these pools for new `VkDeviceMemory`
+    and offset using vmaGetAllocationInfo() if you might need to recreate buffers
+    and images bound to them.
+
+    The array should have `poolCount` elements.
+    The array should not contain nulls.
+    Elements in the array should be unique - same pool cannot occur twice.
+
+    Using this array is equivalent to specifying all allocations from the pools in `pAllocations`.
+    It might be more efficient.
+    */
+    const VmaPool VMA_NOT_NULL * VMA_NULLABLE VMA_LEN_IF_NOT_NULL(poolCount) pPools;
+    /** \brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on CPU side, like `memcpy()`, `memmove()`.
+
+    `VK_WHOLE_SIZE` means no limit.
+    */
+    VkDeviceSize maxCpuBytesToMove;
+    /** \brief Maximum number of allocations that can be moved to a different place using transfers on CPU side, like `memcpy()`, `memmove()`.
+
+    `UINT32_MAX` means no limit.
+    */
+    uint32_t maxCpuAllocationsToMove;
+    /** \brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on GPU side, posted to `commandBuffer`.
+
+    `VK_WHOLE_SIZE` means no limit.
+    */
+    VkDeviceSize maxGpuBytesToMove;
+    /** \brief Maximum number of allocations that can be moved to a different place using transfers on GPU side, posted to `commandBuffer`.
+
+    `UINT32_MAX` means no limit.
+    */
+    uint32_t maxGpuAllocationsToMove;
+    /** \brief Optional. Command buffer where GPU copy commands will be posted.
+
+    If not null, it must be a valid command buffer handle that supports Transfer queue type.
+    It must be in the recording state and outside of a render pass instance.
+    You need to submit it and make sure it finished execution before calling vmaDefragmentationEnd().
+
+    Passing null means that only CPU defragmentation will be performed.
+    */
+    VkCommandBuffer VMA_NULLABLE commandBuffer;
+} VmaDefragmentationInfo2;
+
+typedef struct VmaDefragmentationPassMoveInfo {
+    VmaAllocation VMA_NOT_NULL allocation;
+    VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory;
+    VkDeviceSize offset;
+} VmaDefragmentationPassMoveInfo;
+
+/** \brief Parameters for incremental defragmentation steps.
+
+To be used with function vmaBeginDefragmentationPass().
+*/
+typedef struct VmaDefragmentationPassInfo {
+    uint32_t moveCount;
+    VmaDefragmentationPassMoveInfo* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(moveCount) pMoves;
+} VmaDefragmentationPassInfo;
+
+/** \brief Deprecated. Optional configuration parameters to be passed to function vmaDefragment().
+
+\deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead.
+*/
+typedef struct VmaDefragmentationInfo {
+    /** \brief Maximum total numbers of bytes that can be copied while moving allocations to different places.
+
+    Default is `VK_WHOLE_SIZE`, which means no limit.
+    */
+    VkDeviceSize maxBytesToMove;
+    /** \brief Maximum number of allocations that can be moved to different place.
+
+    Default is `UINT32_MAX`, which means no limit.
+    */
+    uint32_t maxAllocationsToMove;
+} VmaDefragmentationInfo;
+
+/** \brief Statistics returned by function vmaDefragment(). */
+typedef struct VmaDefragmentationStats {
+    /// Total number of bytes that have been copied while moving allocations to different places.
+    VkDeviceSize bytesMoved;
+    /// Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects.
+    VkDeviceSize bytesFreed;
+    /// Number of allocations that have been moved to different places.
+    uint32_t allocationsMoved;
+    /// Number of empty `VkDeviceMemory` objects that have been released to the system.
+    uint32_t deviceMemoryBlocksFreed;
+} VmaDefragmentationStats;
+
+/** \brief Begins defragmentation process.
+
+@param allocator Allocator object.
+@param pInfo Structure filled with parameters of defragmentation.
+@param[out] pStats Optional. Statistics of defragmentation. You can pass null if you are not interested in this information.
+@param[out] pContext Context object that must be passed to vmaDefragmentationEnd() to finish defragmentation.
+@return `VK_SUCCESS` and `*pContext == null` if defragmentation finished within this function call. `VK_NOT_READY` and `*pContext != null` if defragmentation has been started and you need to call vmaDefragmentationEnd() to finish it. Negative value in case of error.
+
+Use this function instead of old, deprecated vmaDefragment().
+
+Warning! Between the call to vmaDefragmentationBegin() and vmaDefragmentationEnd():
+
+- You should not use any of allocations passed as `pInfo->pAllocations` or
+  any allocations that belong to pools passed as `pInfo->pPools`,
+  including calling vmaGetAllocationInfo(), vmaTouchAllocation(), or access
+  their data.
+- Some mutexes protecting internal data structures may be locked, so trying to
+  make or free any allocations, bind buffers or images, map memory, or launch
+  another simultaneous defragmentation in between may cause stall (when done on
+  another thread) or deadlock (when done on the same thread), unless you are
+  100% sure that defragmented allocations are in different pools.
+- Information returned via `pStats` and `pInfo->pAllocationsChanged` are undefined.
+  They become valid after call to vmaDefragmentationEnd().
+- If `pInfo->commandBuffer` is not null, you must submit that command buffer
+  and make sure it finished execution before calling vmaDefragmentationEnd().
+
+For more information and important limitations regarding defragmentation, see documentation chapter:
+[Defragmentation](@ref defragmentation).
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationBegin(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VmaDefragmentationInfo2* VMA_NOT_NULL pInfo,
+    VmaDefragmentationStats* VMA_NULLABLE pStats,
+    VmaDefragmentationContext VMA_NULLABLE * VMA_NOT_NULL pContext);
+
+/** \brief Ends defragmentation process.
+
+Use this function to finish defragmentation started by vmaDefragmentationBegin().
+It is safe to pass `context == null`. The function then does nothing.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationEnd(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaDefragmentationContext VMA_NULLABLE context);
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentationPass(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaDefragmentationContext VMA_NULLABLE context,
+    VmaDefragmentationPassInfo* VMA_NOT_NULL pInfo
+);
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaEndDefragmentationPass(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaDefragmentationContext VMA_NULLABLE context
+);
+
+/** \brief Deprecated. Compacts memory by moving allocations.
+
+@param pAllocations Array of allocations that can be moved during this compation.
+@param allocationCount Number of elements in pAllocations and pAllocationsChanged arrays.
+@param[out] pAllocationsChanged Array of boolean values that will indicate whether matching allocation in pAllocations array has been moved. This parameter is optional. Pass null if you don't need this information.
+@param pDefragmentationInfo Configuration parameters. Optional - pass null to use default values.
+@param[out] pDefragmentationStats Statistics returned by the function. Optional - pass null if you don't need this information.
+@return `VK_SUCCESS` if completed, negative error code in case of error.
+
+\deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead.
+
+This function works by moving allocations to different places (different
+`VkDeviceMemory` objects and/or different offsets) in order to optimize memory
+usage. Only allocations that are in `pAllocations` array can be moved. All other
+allocations are considered nonmovable in this call. Basic rules:
+
+- Only allocations made in memory types that have
+  `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`
+  flags can be compacted. You may pass other allocations but it makes no sense -
+  these will never be moved.
+- Custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT or
+  #VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT flag are not defragmented. Allocations
+  passed to this function that come from such pools are ignored.
+- Allocations created with #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT or
+  created as dedicated allocations for any other reason are also ignored.
+- Both allocations made with or without #VMA_ALLOCATION_CREATE_MAPPED_BIT
+  flag can be compacted. If not persistently mapped, memory will be mapped
+  temporarily inside this function if needed.
+- You must not pass same #VmaAllocation object multiple times in `pAllocations` array.
+
+The function also frees empty `VkDeviceMemory` blocks.
+
+Warning: This function may be time-consuming, so you shouldn't call it too often
+(like after every resource creation/destruction).
+You can call it on special occasions (like when reloading a game level or
+when you just destroyed a lot of objects). Calling it every frame may be OK, but
+you should measure that on your platform.
+
+For more information, see [Defragmentation](@ref defragmentation) chapter.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragment(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VmaAllocation VMA_NOT_NULL * VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations,
+    size_t allocationCount,
+    VkBool32* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocationsChanged,
+    const VmaDefragmentationInfo* VMA_NULLABLE pDefragmentationInfo,
+    VmaDefragmentationStats* VMA_NULLABLE pDefragmentationStats);
+
+/** \brief Binds buffer to allocation.
+
+Binds specified buffer to region of memory represented by specified allocation.
+Gets `VkDeviceMemory` handle and offset from the allocation.
+If you want to create a buffer, allocate memory for it and bind them together separately,
+you should use this function for binding instead of standard `vkBindBufferMemory()`,
+because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
+allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
+(which is illegal in Vulkan).
+
+It is recommended to use function vmaCreateBuffer() instead of this one.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer);
+
+/** \brief Binds buffer to allocation with additional parameters.
+
+@param allocationLocalOffset Additional offset to be added while binding, relative to the beginnig of the `allocation`. Normally it should be 0.
+@param pNext A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null.
+
+This function is similar to vmaBindBufferMemory(), but it provides additional parameters.
+
+If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
+or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory2(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VkDeviceSize allocationLocalOffset,
+    VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer,
+    const void* VMA_NULLABLE pNext);
+
+/** \brief Binds image to allocation.
+
+Binds specified image to region of memory represented by specified allocation.
+Gets `VkDeviceMemory` handle and offset from the allocation.
+If you want to create an image, allocate memory for it and bind them together separately,
+you should use this function for binding instead of standard `vkBindImageMemory()`,
+because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
+allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
+(which is illegal in Vulkan).
+
+It is recommended to use function vmaCreateImage() instead of this one.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VkImage VMA_NOT_NULL_NON_DISPATCHABLE image);
+
+/** \brief Binds image to allocation with additional parameters.
+
+@param allocationLocalOffset Additional offset to be added while binding, relative to the beginnig of the `allocation`. Normally it should be 0.
+@param pNext A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null.
+
+This function is similar to vmaBindImageMemory(), but it provides additional parameters.
+
+If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
+or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory2(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VmaAllocation VMA_NOT_NULL allocation,
+    VkDeviceSize allocationLocalOffset,
+    VkImage VMA_NOT_NULL_NON_DISPATCHABLE image,
+    const void* VMA_NULLABLE pNext);
+
+/**
+@param[out] pBuffer Buffer that was created.
+@param[out] pAllocation Allocation that was created.
+@param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().
+
+This function automatically:
+
+-# Creates buffer.
+-# Allocates appropriate memory for it.
+-# Binds the buffer with the memory.
+
+If any of these operations fail, buffer and allocation are not created,
+returned value is negative error code, *pBuffer and *pAllocation are null.
+
+If the function succeeded, you must destroy both buffer and allocation when you
+no longer need them using either convenience function vmaDestroyBuffer() or
+separately, using `vkDestroyBuffer()` and vmaFreeMemory().
+
+If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,
+VK_KHR_dedicated_allocation extension is used internally to query driver whether
+it requires or prefers the new buffer to have dedicated allocation. If yes,
+and if dedicated allocation is possible (VmaAllocationCreateInfo::pool is null
+and #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated
+allocation for this buffer, just like when using
+#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
+
+\note This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer,
+although recommended as a good practice, is out of scope of this library and could be implemented
+by the user as a higher-level logic on top of VMA.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkBufferCreateInfo* VMA_NOT_NULL pBufferCreateInfo,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo,
+    VkBuffer VMA_NULLABLE_NON_DISPATCHABLE * VMA_NOT_NULL pBuffer,
+    VmaAllocation VMA_NULLABLE * VMA_NOT_NULL pAllocation,
+    VmaAllocationInfo* VMA_NULLABLE pAllocationInfo);
+
+/** \brief Destroys Vulkan buffer and frees allocated memory.
+
+This is just a convenience function equivalent to:
+
+\code
+vkDestroyBuffer(device, buffer, allocationCallbacks);
+vmaFreeMemory(allocator, allocation);
+\endcode
+
+It it safe to pass null as buffer and/or allocation.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VkBuffer VMA_NULLABLE_NON_DISPATCHABLE buffer,
+    VmaAllocation VMA_NULLABLE allocation);
+
+/// Function similar to vmaCreateBuffer().
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateImage(
+    VmaAllocator VMA_NOT_NULL allocator,
+    const VkImageCreateInfo* VMA_NOT_NULL pImageCreateInfo,
+    const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo,
+    VkImage VMA_NULLABLE_NON_DISPATCHABLE * VMA_NOT_NULL pImage,
+    VmaAllocation VMA_NULLABLE * VMA_NOT_NULL pAllocation,
+    VmaAllocationInfo* VMA_NULLABLE pAllocationInfo);
+
+/** \brief Destroys Vulkan image and frees allocated memory.
+
+This is just a convenience function equivalent to:
+
+\code
+vkDestroyImage(device, image, allocationCallbacks);
+vmaFreeMemory(allocator, allocation);
+\endcode
+
+It it safe to pass null as image and/or allocation.
+*/
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyImage(
+    VmaAllocator VMA_NOT_NULL allocator,
+    VkImage VMA_NULLABLE_NON_DISPATCHABLE image,
+    VmaAllocation VMA_NULLABLE allocation);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // AMD_VULKAN_MEMORY_ALLOCATOR_H
+
+// For Visual Studio IntelliSense.
+#if defined(__cplusplus) && defined(__INTELLISENSE__)
+#define VMA_IMPLEMENTATION
+#endif
+
+#ifdef VMA_IMPLEMENTATION
+#undef VMA_IMPLEMENTATION
+
+#include <cstdint>
+#include <cstdlib>
+#include <cstring>
+#include <utility>
+
+#if VMA_RECORDING_ENABLED
+    #include <chrono>
+    #if defined(_WIN32)
+        #include <windows.h>
+    #else
+        #include <sstream>
+        #include <thread>
+    #endif
+#endif
+
+/*******************************************************************************
+CONFIGURATION SECTION
+
+Define some of these macros before each #include of this header or change them
+here if you need other then default behavior depending on your environment.
+*/
+
+/*
+Define this macro to 1 to make the library fetch pointers to Vulkan functions
+internally, like:
+
+    vulkanFunctions.vkAllocateMemory = &vkAllocateMemory;
+*/
+#if !defined(VMA_STATIC_VULKAN_FUNCTIONS) && !defined(VK_NO_PROTOTYPES)
+    #define VMA_STATIC_VULKAN_FUNCTIONS 1
+#endif
+
+/*
+Define this macro to 1 to make the library fetch pointers to Vulkan functions
+internally, like:
+
+    vulkanFunctions.vkAllocateMemory = (PFN_vkAllocateMemory)vkGetDeviceProcAddr(m_hDevice, vkAllocateMemory);
+*/
+#if !defined(VMA_DYNAMIC_VULKAN_FUNCTIONS)
+    #define VMA_DYNAMIC_VULKAN_FUNCTIONS 1
+    #if defined(VK_NO_PROTOTYPES)
+        extern PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
+        extern PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;
+    #endif
+#endif
+
+// Define this macro to 1 to make the library use STL containers instead of its own implementation.
+//#define VMA_USE_STL_CONTAINERS 1
+
+/* Set this macro to 1 to make the library including and using STL containers:
+std::pair, std::vector, std::list, std::unordered_map.
+
+Set it to 0 or undefined to make the library using its own implementation of
+the containers.
+*/
+#if VMA_USE_STL_CONTAINERS
+   #define VMA_USE_STL_VECTOR 1
+   #define VMA_USE_STL_UNORDERED_MAP 1
+   #define VMA_USE_STL_LIST 1
+#endif
+
+#ifndef VMA_USE_STL_SHARED_MUTEX
+    // Compiler conforms to C++17.
+    #if __cplusplus >= 201703L
+        #define VMA_USE_STL_SHARED_MUTEX 1
+    // Visual studio defines __cplusplus properly only when passed additional parameter: /Zc:__cplusplus
+    // Otherwise it's always 199711L, despite shared_mutex works since Visual Studio 2015 Update 2.
+    // See: https://blogs.msdn.microsoft.com/vcblog/2018/04/09/msvc-now-correctly-reports-__cplusplus/
+    #elif defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 190023918 && __cplusplus == 199711L && _MSVC_LANG >= 201703L
+        #define VMA_USE_STL_SHARED_MUTEX 1
+    #else
+        #define VMA_USE_STL_SHARED_MUTEX 0
+    #endif
+#endif
+
+/*
+THESE INCLUDES ARE NOT ENABLED BY DEFAULT.
+Library has its own container implementation.
+*/
+#if VMA_USE_STL_VECTOR
+   #include <vector>
+#endif
+
+#if VMA_USE_STL_UNORDERED_MAP
+   #include <unordered_map>
+#endif
+
+#if VMA_USE_STL_LIST
+   #include <list>
+#endif
+
+/*
+Following headers are used in this CONFIGURATION section only, so feel free to
+remove them if not needed.
+*/
+#include <cassert> // for assert
+#include <algorithm> // for min, max
+#include <mutex>
+
+#ifndef VMA_NULL
+   // Value used as null pointer. Define it to e.g.: nullptr, NULL, 0, (void*)0.
+   #define VMA_NULL   nullptr
+#endif
+
+#if defined(__ANDROID_API__) && (__ANDROID_API__ < 16)
+#include <cstdlib>
+static void* vma_aligned_alloc(size_t alignment, size_t size)
+{
+    // alignment must be >= sizeof(void*)
+    if(alignment < sizeof(void*))
+    {
+        alignment = sizeof(void*);
+    }
+
+    return memalign(alignment, size);
+}
+#elif defined(__APPLE__) || defined(__ANDROID__) || (defined(__linux__) && defined(__GLIBCXX__) && !defined(_GLIBCXX_HAVE_ALIGNED_ALLOC))
+#include <cstdlib>
+
+#if defined(__APPLE__)
+#include <AvailabilityMacros.h>
+#endif
+
+static void* vma_aligned_alloc(size_t alignment, size_t size)
+{
+#if defined(__APPLE__) && (defined(MAC_OS_X_VERSION_10_16) || defined(__IPHONE_14_0))
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_16 || __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_14_0
+    // For C++14, usr/include/malloc/_malloc.h declares aligned_alloc()) only
+    // with the MacOSX11.0 SDK in Xcode 12 (which is what adds
+    // MAC_OS_X_VERSION_10_16), even though the function is marked
+    // availabe for 10.15. That's why the preprocessor checks for 10.16 but
+    // the __builtin_available checks for 10.15.
+    // People who use C++17 could call aligned_alloc with the 10.15 SDK already.
+    if (__builtin_available(macOS 10.15, iOS 13, *))
+        return aligned_alloc(alignment, size);
+#endif
+#endif
+    // alignment must be >= sizeof(void*)
+    if(alignment < sizeof(void*))
+    {
+        alignment = sizeof(void*);
+    }
+
+    void *pointer;
+    if(posix_memalign(&pointer, alignment, size) == 0)
+        return pointer;
+    return VMA_NULL;
+}
+#elif defined(_WIN32)
+static void* vma_aligned_alloc(size_t alignment, size_t size)
+{
+    return _aligned_malloc(size, alignment);
+}
+#else
+static void* vma_aligned_alloc(size_t alignment, size_t size)
+{
+    return aligned_alloc(alignment, size);
+}
+#endif
+
+#if defined(_WIN32)
+static void vma_aligned_free(void* ptr)
+{
+    _aligned_free(ptr);
+}
+#else
+static void vma_aligned_free(void* ptr)
+{
+    free(ptr);
+}
+#endif
+
+// If your compiler is not compatible with C++11 and definition of
+// aligned_alloc() function is missing, uncommeting following line may help:
+
+//#include <malloc.h>
+
+// Normal assert to check for programmer's errors, especially in Debug configuration.
+#ifndef VMA_ASSERT
+   #ifdef NDEBUG
+       #define VMA_ASSERT(expr)
+   #else
+       #define VMA_ASSERT(expr)         assert(expr)
+   #endif
+#endif
+
+// Assert that will be called very often, like inside data structures e.g. operator[].
+// Making it non-empty can make program slow.
+#ifndef VMA_HEAVY_ASSERT
+   #ifdef NDEBUG
+       #define VMA_HEAVY_ASSERT(expr)
+   #else
+       #define VMA_HEAVY_ASSERT(expr)   //VMA_ASSERT(expr)
+   #endif
+#endif
+
+#ifndef VMA_ALIGN_OF
+   #define VMA_ALIGN_OF(type)       (__alignof(type))
+#endif
+
+#ifndef VMA_SYSTEM_ALIGNED_MALLOC
+   #define VMA_SYSTEM_ALIGNED_MALLOC(size, alignment) vma_aligned_alloc((alignment), (size))
+#endif
+
+#ifndef VMA_SYSTEM_ALIGNED_FREE
+   // VMA_SYSTEM_FREE is the old name, but might have been defined by the user
+   #if defined(VMA_SYSTEM_FREE)
+      #define VMA_SYSTEM_ALIGNED_FREE(ptr)     VMA_SYSTEM_FREE(ptr)
+   #else
+      #define VMA_SYSTEM_ALIGNED_FREE(ptr)     vma_aligned_free(ptr)
+    #endif
+#endif
+
+#ifndef VMA_MIN
+   #define VMA_MIN(v1, v2)    (std::min((v1), (v2)))
+#endif
+
+#ifndef VMA_MAX
+   #define VMA_MAX(v1, v2)    (std::max((v1), (v2)))
+#endif
+
+#ifndef VMA_SWAP
+   #define VMA_SWAP(v1, v2)   std::swap((v1), (v2))
+#endif
+
+#ifndef VMA_SORT
+   #define VMA_SORT(beg, end, cmp)  std::sort(beg, end, cmp)
+#endif
+
+#ifndef VMA_DEBUG_LOG
+   #define VMA_DEBUG_LOG(format, ...)
+   /*
+   #define VMA_DEBUG_LOG(format, ...) do { \
+       printf(format, __VA_ARGS__); \
+       printf("\n"); \
+   } while(false)
+   */
+#endif
+
+// Define this macro to 1 to enable functions: vmaBuildStatsString, vmaFreeStatsString.
+#if VMA_STATS_STRING_ENABLED
+    static inline void VmaUint32ToStr(char* outStr, size_t strLen, uint32_t num)
+    {
+        snprintf(outStr, strLen, "%u", static_cast<unsigned int>(num));
+    }
+    static inline void VmaUint64ToStr(char* outStr, size_t strLen, uint64_t num)
+    {
+        snprintf(outStr, strLen, "%llu", static_cast<unsigned long long>(num));
+    }
+    static inline void VmaPtrToStr(char* outStr, size_t strLen, const void* ptr)
+    {
+        snprintf(outStr, strLen, "%p", ptr);
+    }
+#endif
+
+#ifndef VMA_MUTEX
+    class VmaMutex
+    {
+    public:
+        void Lock() { m_Mutex.lock(); }
+        void Unlock() { m_Mutex.unlock(); }
+        bool TryLock() { return m_Mutex.try_lock(); }
+    private:
+        std::mutex m_Mutex;
+    };
+    #define VMA_MUTEX VmaMutex
+#endif
+
+// Read-write mutex, where "read" is shared access, "write" is exclusive access.
+#ifndef VMA_RW_MUTEX
+    #if VMA_USE_STL_SHARED_MUTEX
+        // Use std::shared_mutex from C++17.
+        #include <shared_mutex>
+        class VmaRWMutex
+        {
+        public:
+            void LockRead() { m_Mutex.lock_shared(); }
+            void UnlockRead() { m_Mutex.unlock_shared(); }
+            bool TryLockRead() { return m_Mutex.try_lock_shared(); }
+            void LockWrite() { m_Mutex.lock(); }
+            void UnlockWrite() { m_Mutex.unlock(); }
+            bool TryLockWrite() { return m_Mutex.try_lock(); }
+        private:
+            std::shared_mutex m_Mutex;
+        };
+        #define VMA_RW_MUTEX VmaRWMutex
+    #elif defined(_WIN32) && defined(WINVER) && WINVER >= 0x0600
+        // Use SRWLOCK from WinAPI.
+        // Minimum supported client = Windows Vista, server = Windows Server 2008.
+        class VmaRWMutex
+        {
+        public:
+            VmaRWMutex() { InitializeSRWLock(&m_Lock); }
+            void LockRead() { AcquireSRWLockShared(&m_Lock); }
+            void UnlockRead() { ReleaseSRWLockShared(&m_Lock); }
+            bool TryLockRead() { return TryAcquireSRWLockShared(&m_Lock) != FALSE; }
+            void LockWrite() { AcquireSRWLockExclusive(&m_Lock); }
+            void UnlockWrite() { ReleaseSRWLockExclusive(&m_Lock); }
+            bool TryLockWrite() { return TryAcquireSRWLockExclusive(&m_Lock) != FALSE; }
+        private:
+            SRWLOCK m_Lock;
+        };
+        #define VMA_RW_MUTEX VmaRWMutex
+    #else
+        // Less efficient fallback: Use normal mutex.
+        class VmaRWMutex
+        {
+        public:
+            void LockRead() { m_Mutex.Lock(); }
+            void UnlockRead() { m_Mutex.Unlock(); }
+            bool TryLockRead() { return m_Mutex.TryLock(); }
+            void LockWrite() { m_Mutex.Lock(); }
+            void UnlockWrite() { m_Mutex.Unlock(); }
+            bool TryLockWrite() { return m_Mutex.TryLock(); }
+        private:
+            VMA_MUTEX m_Mutex;
+        };
+        #define VMA_RW_MUTEX VmaRWMutex
+    #endif // #if VMA_USE_STL_SHARED_MUTEX
+#endif // #ifndef VMA_RW_MUTEX
+
+/*
+If providing your own implementation, you need to implement a subset of std::atomic.
+*/
+#ifndef VMA_ATOMIC_UINT32
+    #include <atomic>
+    #define VMA_ATOMIC_UINT32 std::atomic<uint32_t>
+#endif
+
+#ifndef VMA_ATOMIC_UINT64
+    #include <atomic>
+    #define VMA_ATOMIC_UINT64 std::atomic<uint64_t>
+#endif
+
+#ifndef VMA_DEBUG_ALWAYS_DEDICATED_MEMORY
+    /**
+    Every allocation will have its own memory block.
+    Define to 1 for debugging purposes only.
+    */
+    #define VMA_DEBUG_ALWAYS_DEDICATED_MEMORY (0)
+#endif
+
+#ifndef VMA_DEBUG_ALIGNMENT
+    /**
+    Minimum alignment of all allocations, in bytes.
+    Set to more than 1 for debugging purposes only. Must be power of two.
+    */
+    #define VMA_DEBUG_ALIGNMENT (1)
+#endif
+
+#ifndef VMA_DEBUG_MARGIN
+    /**
+    Minimum margin before and after every allocation, in bytes.
+    Set nonzero for debugging purposes only.
+    */
+    #define VMA_DEBUG_MARGIN (0)
+#endif
+
+#ifndef VMA_DEBUG_INITIALIZE_ALLOCATIONS
+    /**
+    Define this macro to 1 to automatically fill new allocations and destroyed
+    allocations with some bit pattern.
+    */
+    #define VMA_DEBUG_INITIALIZE_ALLOCATIONS (0)
+#endif
+
+#ifndef VMA_DEBUG_DETECT_CORRUPTION
+    /**
+    Define this macro to 1 together with non-zero value of VMA_DEBUG_MARGIN to
+    enable writing magic value to the margin before and after every allocation and
+    validating it, so that memory corruptions (out-of-bounds writes) are detected.
+    */
+    #define VMA_DEBUG_DETECT_CORRUPTION (0)
+#endif
+
+#ifndef VMA_DEBUG_GLOBAL_MUTEX
+    /**
+    Set this to 1 for debugging purposes only, to enable single mutex protecting all
+    entry calls to the library. Can be useful for debugging multithreading issues.
+    */
+    #define VMA_DEBUG_GLOBAL_MUTEX (0)
+#endif
+
+#ifndef VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY
+    /**
+    Minimum value for VkPhysicalDeviceLimits::bufferImageGranularity.
+    Set to more than 1 for debugging purposes only. Must be power of two.
+    */
+    #define VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY (1)
+#endif
+
+#ifndef VMA_SMALL_HEAP_MAX_SIZE
+   /// Maximum size of a memory heap in Vulkan to consider it "small".
+   #define VMA_SMALL_HEAP_MAX_SIZE (1024ull * 1024 * 1024)
+#endif
+
+#ifndef VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE
+   /// Default size of a block allocated as single VkDeviceMemory from a "large" heap.
+   #define VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE (256ull * 1024 * 1024)
+#endif
+
+#ifndef VMA_CLASS_NO_COPY
+    #define VMA_CLASS_NO_COPY(className) \
+        private: \
+            className(const className&) = delete; \
+            className& operator=(const className&) = delete;
+#endif
+
+static const uint32_t VMA_FRAME_INDEX_LOST = UINT32_MAX;
+
+// Decimal 2139416166, float NaN, little-endian binary 66 E6 84 7F.
+static const uint32_t VMA_CORRUPTION_DETECTION_MAGIC_VALUE = 0x7F84E666;
+
+static const uint8_t VMA_ALLOCATION_FILL_PATTERN_CREATED   = 0xDC;
+static const uint8_t VMA_ALLOCATION_FILL_PATTERN_DESTROYED = 0xEF;
+
+/*******************************************************************************
+END OF CONFIGURATION
+*/
+
+// # Copy of some Vulkan definitions so we don't need to check their existence just to handle few constants.
+
+static const uint32_t VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY = 0x00000040;
+static const uint32_t VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY = 0x00000080;
+static const uint32_t VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_COPY = 0x00020000;
+
+static const uint32_t VMA_ALLOCATION_INTERNAL_STRATEGY_MIN_OFFSET = 0x10000000u;
+
+static VkAllocationCallbacks VmaEmptyAllocationCallbacks = {
+    VMA_NULL, VMA_NULL, VMA_NULL, VMA_NULL, VMA_NULL, VMA_NULL };
+
+// Returns number of bits set to 1 in (v).
+static inline uint32_t VmaCountBitsSet(uint32_t v)
+{
+    uint32_t c = v - ((v >> 1) & 0x55555555);
+    c = ((c >>  2) & 0x33333333) + (c & 0x33333333);
+    c = ((c >>  4) + c) & 0x0F0F0F0F;
+    c = ((c >>  8) + c) & 0x00FF00FF;
+    c = ((c >> 16) + c) & 0x0000FFFF;
+    return c;
+}
+
+/*
+Returns true if given number is a power of two.
+T must be unsigned integer number or signed integer but always nonnegative.
+For 0 returns true.
+*/
+template <typename T>
+inline bool VmaIsPow2(T x)
+{
+    return (x & (x-1)) == 0;
+}
+
+// Aligns given value up to nearest multiply of align value. For example: VmaAlignUp(11, 8) = 16.
+// Use types like uint32_t, uint64_t as T.
+template <typename T>
+static inline T VmaAlignUp(T val, T alignment)
+{
+    VMA_HEAVY_ASSERT(VmaIsPow2(alignment));
+    return (val + alignment - 1) & ~(alignment - 1);
+}
+// Aligns given value down to nearest multiply of align value. For example: VmaAlignUp(11, 8) = 8.
+// Use types like uint32_t, uint64_t as T.
+template <typename T>
+static inline T VmaAlignDown(T val, T alignment)
+{
+    VMA_HEAVY_ASSERT(VmaIsPow2(alignment));
+    return val & ~(alignment - 1);
+}
+
+// Division with mathematical rounding to nearest number.
+template <typename T>
+static inline T VmaRoundDiv(T x, T y)
+{
+    return (x + (y / (T)2)) / y;
+}
+
+// Returns smallest power of 2 greater or equal to v.
+static inline uint32_t VmaNextPow2(uint32_t v)
+{
+    v--;
+    v |= v >> 1;
+    v |= v >> 2;
+    v |= v >> 4;
+    v |= v >> 8;
+    v |= v >> 16;
+    v++;
+    return v;
+}
+static inline uint64_t VmaNextPow2(uint64_t v)
+{
+    v--;
+    v |= v >> 1;
+    v |= v >> 2;
+    v |= v >> 4;
+    v |= v >> 8;
+    v |= v >> 16;
+    v |= v >> 32;
+    v++;
+    return v;
+}
+
+// Returns largest power of 2 less or equal to v.
+static inline uint32_t VmaPrevPow2(uint32_t v)
+{
+    v |= v >> 1;
+    v |= v >> 2;
+    v |= v >> 4;
+    v |= v >> 8;
+    v |= v >> 16;
+    v = v ^ (v >> 1);
+    return v;
+}
+static inline uint64_t VmaPrevPow2(uint64_t v)
+{
+    v |= v >> 1;
+    v |= v >> 2;
+    v |= v >> 4;
+    v |= v >> 8;
+    v |= v >> 16;
+    v |= v >> 32;
+    v = v ^ (v >> 1);
+    return v;
+}
+
+static inline bool VmaStrIsEmpty(const char* pStr)
+{
+    return pStr == VMA_NULL || *pStr == '\0';
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+static const char* VmaAlgorithmToStr(uint32_t algorithm)
+{
+    switch(algorithm)
+    {
+    case VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT:
+        return "Linear";
+    case VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT:
+        return "Buddy";
+    case 0:
+        return "Default";
+    default:
+        VMA_ASSERT(0);
+        return "";
+    }
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+#ifndef VMA_SORT
+
+template<typename Iterator, typename Compare>
+Iterator VmaQuickSortPartition(Iterator beg, Iterator end, Compare cmp)
+{
+    Iterator centerValue = end; --centerValue;
+    Iterator insertIndex = beg;
+    for(Iterator memTypeIndex = beg; memTypeIndex < centerValue; ++memTypeIndex)
+    {
+        if(cmp(*memTypeIndex, *centerValue))
+        {
+            if(insertIndex != memTypeIndex)
+            {
+                VMA_SWAP(*memTypeIndex, *insertIndex);
+            }
+            ++insertIndex;
+        }
+    }
+    if(insertIndex != centerValue)
+    {
+        VMA_SWAP(*insertIndex, *centerValue);
+    }
+    return insertIndex;
+}
+
+template<typename Iterator, typename Compare>
+void VmaQuickSort(Iterator beg, Iterator end, Compare cmp)
+{
+    if(beg < end)
+    {
+        Iterator it = VmaQuickSortPartition<Iterator, Compare>(beg, end, cmp);
+        VmaQuickSort<Iterator, Compare>(beg, it, cmp);
+        VmaQuickSort<Iterator, Compare>(it + 1, end, cmp);
+    }
+}
+
+#define VMA_SORT(beg, end, cmp) VmaQuickSort(beg, end, cmp)
+
+#endif // #ifndef VMA_SORT
+
+/*
+Returns true if two memory blocks occupy overlapping pages.
+ResourceA must be in less memory offset than ResourceB.
+
+Algorithm is based on "Vulkan 1.0.39 - A Specification (with all registered Vulkan extensions)"
+chapter 11.6 "Resource Memory Association", paragraph "Buffer-Image Granularity".
+*/
+static inline bool VmaBlocksOnSamePage(
+    VkDeviceSize resourceAOffset,
+    VkDeviceSize resourceASize,
+    VkDeviceSize resourceBOffset,
+    VkDeviceSize pageSize)
+{
+    VMA_ASSERT(resourceAOffset + resourceASize <= resourceBOffset && resourceASize > 0 && pageSize > 0);
+    VkDeviceSize resourceAEnd = resourceAOffset + resourceASize - 1;
+    VkDeviceSize resourceAEndPage = resourceAEnd & ~(pageSize - 1);
+    VkDeviceSize resourceBStart = resourceBOffset;
+    VkDeviceSize resourceBStartPage = resourceBStart & ~(pageSize - 1);
+    return resourceAEndPage == resourceBStartPage;
+}
+
+enum VmaSuballocationType
+{
+    VMA_SUBALLOCATION_TYPE_FREE = 0,
+    VMA_SUBALLOCATION_TYPE_UNKNOWN = 1,
+    VMA_SUBALLOCATION_TYPE_BUFFER = 2,
+    VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN = 3,
+    VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR = 4,
+    VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL = 5,
+    VMA_SUBALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
+};
+
+/*
+Returns true if given suballocation types could conflict and must respect
+VkPhysicalDeviceLimits::bufferImageGranularity. They conflict if one is buffer
+or linear image and another one is optimal image. If type is unknown, behave
+conservatively.
+*/
+static inline bool VmaIsBufferImageGranularityConflict(
+    VmaSuballocationType suballocType1,
+    VmaSuballocationType suballocType2)
+{
+    if(suballocType1 > suballocType2)
+    {
+        VMA_SWAP(suballocType1, suballocType2);
+    }
+
+    switch(suballocType1)
+    {
+    case VMA_SUBALLOCATION_TYPE_FREE:
+        return false;
+    case VMA_SUBALLOCATION_TYPE_UNKNOWN:
+        return true;
+    case VMA_SUBALLOCATION_TYPE_BUFFER:
+        return
+            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN ||
+            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;
+    case VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN:
+        return
+            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN ||
+            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR ||
+            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;
+    case VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR:
+        return
+            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;
+    case VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL:
+        return false;
+    default:
+        VMA_ASSERT(0);
+        return true;
+    }
+}
+
+static void VmaWriteMagicValue(void* pData, VkDeviceSize offset)
+{
+#if VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_DETECT_CORRUPTION
+    uint32_t* pDst = (uint32_t*)((char*)pData + offset);
+    const size_t numberCount = VMA_DEBUG_MARGIN / sizeof(uint32_t);
+    for(size_t i = 0; i < numberCount; ++i, ++pDst)
+    {
+        *pDst = VMA_CORRUPTION_DETECTION_MAGIC_VALUE;
+    }
+#else
+    // no-op
+#endif
+}
+
+static bool VmaValidateMagicValue(const void* pData, VkDeviceSize offset)
+{
+#if VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_DETECT_CORRUPTION
+    const uint32_t* pSrc = (const uint32_t*)((const char*)pData + offset);
+    const size_t numberCount = VMA_DEBUG_MARGIN / sizeof(uint32_t);
+    for(size_t i = 0; i < numberCount; ++i, ++pSrc)
+    {
+        if(*pSrc != VMA_CORRUPTION_DETECTION_MAGIC_VALUE)
+        {
+            return false;
+        }
+    }
+#endif
+    return true;
+}
+
+/*
+Fills structure with parameters of an example buffer to be used for transfers
+during GPU memory defragmentation.
+*/
+static void VmaFillGpuDefragmentationBufferCreateInfo(VkBufferCreateInfo& outBufCreateInfo)
+{
+    memset(&outBufCreateInfo, 0, sizeof(outBufCreateInfo));
+    outBufCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
+    outBufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+    outBufCreateInfo.size = (VkDeviceSize)VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE; // Example size.
+}
+
+// Helper RAII class to lock a mutex in constructor and unlock it in destructor (at the end of scope).
+struct VmaMutexLock
+{
+    VMA_CLASS_NO_COPY(VmaMutexLock)
+public:
+    VmaMutexLock(VMA_MUTEX& mutex, bool useMutex = true) :
+        m_pMutex(useMutex ? &mutex : VMA_NULL)
+    { if(m_pMutex) { m_pMutex->Lock(); } }
+    ~VmaMutexLock()
+    { if(m_pMutex) { m_pMutex->Unlock(); } }
+private:
+    VMA_MUTEX* m_pMutex;
+};
+
+// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for reading.
+struct VmaMutexLockRead
+{
+    VMA_CLASS_NO_COPY(VmaMutexLockRead)
+public:
+    VmaMutexLockRead(VMA_RW_MUTEX& mutex, bool useMutex) :
+        m_pMutex(useMutex ? &mutex : VMA_NULL)
+    { if(m_pMutex) { m_pMutex->LockRead(); } }
+    ~VmaMutexLockRead() { if(m_pMutex) { m_pMutex->UnlockRead(); } }
+private:
+    VMA_RW_MUTEX* m_pMutex;
+};
+
+// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for writing.
+struct VmaMutexLockWrite
+{
+    VMA_CLASS_NO_COPY(VmaMutexLockWrite)
+public:
+    VmaMutexLockWrite(VMA_RW_MUTEX& mutex, bool useMutex) :
+        m_pMutex(useMutex ? &mutex : VMA_NULL)
+    { if(m_pMutex) { m_pMutex->LockWrite(); } }
+    ~VmaMutexLockWrite() { if(m_pMutex) { m_pMutex->UnlockWrite(); } }
+private:
+    VMA_RW_MUTEX* m_pMutex;
+};
+
+#if VMA_DEBUG_GLOBAL_MUTEX
+    static VMA_MUTEX gDebugGlobalMutex;
+    #define VMA_DEBUG_GLOBAL_MUTEX_LOCK VmaMutexLock debugGlobalMutexLock(gDebugGlobalMutex, true);
+#else
+    #define VMA_DEBUG_GLOBAL_MUTEX_LOCK
+#endif
+
+// Minimum size of a free suballocation to register it in the free suballocation collection.
+static const VkDeviceSize VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER = 16;
+
+/*
+Performs binary search and returns iterator to first element that is greater or
+equal to (key), according to comparison (cmp).
+
+Cmp should return true if first argument is less than second argument.
+
+Returned value is the found element, if present in the collection or place where
+new element with value (key) should be inserted.
+*/
+template <typename CmpLess, typename IterT, typename KeyT>
+static IterT VmaBinaryFindFirstNotLess(IterT beg, IterT end, const KeyT &key, const CmpLess& cmp)
+{
+    size_t down = 0, up = (end - beg);
+    while(down < up)
+    {
+        const size_t mid = down + (up - down) / 2;  // Overflow-safe midpoint calculation
+        if(cmp(*(beg+mid), key))
+        {
+            down = mid + 1;
+        }
+        else
+        {
+            up = mid;
+        }
+    }
+    return beg + down;
+}
+
+template<typename CmpLess, typename IterT, typename KeyT>
+IterT VmaBinaryFindSorted(const IterT& beg, const IterT& end, const KeyT& value, const CmpLess& cmp)
+{
+    IterT it = VmaBinaryFindFirstNotLess<CmpLess, IterT, KeyT>(
+        beg, end, value, cmp);
+    if(it == end ||
+        (!cmp(*it, value) && !cmp(value, *it)))
+    {
+        return it;
+    }
+    return end;
+}
+
+/*
+Returns true if all pointers in the array are not-null and unique.
+Warning! O(n^2) complexity. Use only inside VMA_HEAVY_ASSERT.
+T must be pointer type, e.g. VmaAllocation, VmaPool.
+*/
+template<typename T>
+static bool VmaValidatePointerArray(uint32_t count, const T* arr)
+{
+    for(uint32_t i = 0; i < count; ++i)
+    {
+        const T iPtr = arr[i];
+        if(iPtr == VMA_NULL)
+        {
+            return false;
+        }
+        for(uint32_t j = i + 1; j < count; ++j)
+        {
+            if(iPtr == arr[j])
+            {
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+template<typename MainT, typename NewT>
+static inline void VmaPnextChainPushFront(MainT* mainStruct, NewT* newStruct)
+{
+    newStruct->pNext = mainStruct->pNext;
+    mainStruct->pNext = newStruct;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Memory allocation
+
+static void* VmaMalloc(const VkAllocationCallbacks* pAllocationCallbacks, size_t size, size_t alignment)
+{
+    void* result = VMA_NULL;
+    if((pAllocationCallbacks != VMA_NULL) &&
+        (pAllocationCallbacks->pfnAllocation != VMA_NULL))
+    {
+        result = (*pAllocationCallbacks->pfnAllocation)(
+            pAllocationCallbacks->pUserData,
+            size,
+            alignment,
+            VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+    }
+    else
+    {
+        result = VMA_SYSTEM_ALIGNED_MALLOC(size, alignment);
+    }
+    VMA_ASSERT(result != VMA_NULL && "CPU memory allocation failed.");
+    return result;
+}
+
+static void VmaFree(const VkAllocationCallbacks* pAllocationCallbacks, void* ptr)
+{
+    if((pAllocationCallbacks != VMA_NULL) &&
+        (pAllocationCallbacks->pfnFree != VMA_NULL))
+    {
+        (*pAllocationCallbacks->pfnFree)(pAllocationCallbacks->pUserData, ptr);
+    }
+    else
+    {
+        VMA_SYSTEM_ALIGNED_FREE(ptr);
+    }
+}
+
+template<typename T>
+static T* VmaAllocate(const VkAllocationCallbacks* pAllocationCallbacks)
+{
+    return (T*)VmaMalloc(pAllocationCallbacks, sizeof(T), VMA_ALIGN_OF(T));
+}
+
+template<typename T>
+static T* VmaAllocateArray(const VkAllocationCallbacks* pAllocationCallbacks, size_t count)
+{
+    return (T*)VmaMalloc(pAllocationCallbacks, sizeof(T) * count, VMA_ALIGN_OF(T));
+}
+
+#define vma_new(allocator, type)   new(VmaAllocate<type>(allocator))(type)
+
+#define vma_new_array(allocator, type, count)   new(VmaAllocateArray<type>((allocator), (count)))(type)
+
+template<typename T>
+static void vma_delete(const VkAllocationCallbacks* pAllocationCallbacks, T* ptr)
+{
+    ptr->~T();
+    VmaFree(pAllocationCallbacks, ptr);
+}
+
+template<typename T>
+static void vma_delete_array(const VkAllocationCallbacks* pAllocationCallbacks, T* ptr, size_t count)
+{
+    if(ptr != VMA_NULL)
+    {
+        for(size_t i = count; i--; )
+        {
+            ptr[i].~T();
+        }
+        VmaFree(pAllocationCallbacks, ptr);
+    }
+}
+
+static char* VmaCreateStringCopy(const VkAllocationCallbacks* allocs, const char* srcStr)
+{
+    if(srcStr != VMA_NULL)
+    {
+        const size_t len = strlen(srcStr);
+        char* const result = vma_new_array(allocs, char, len + 1);
+        memcpy(result, srcStr, len + 1);
+        return result;
+    }
+    else
+    {
+        return VMA_NULL;
+    }
+}
+
+static void VmaFreeString(const VkAllocationCallbacks* allocs, char* str)
+{
+    if(str != VMA_NULL)
+    {
+        const size_t len = strlen(str);
+        vma_delete_array(allocs, str, len + 1);
+    }
+}
+
+// STL-compatible allocator.
+template<typename T>
+class VmaStlAllocator
+{
+public:
+    const VkAllocationCallbacks* const m_pCallbacks;
+    typedef T value_type;
+
+    VmaStlAllocator(const VkAllocationCallbacks* pCallbacks) : m_pCallbacks(pCallbacks) { }
+    template<typename U> VmaStlAllocator(const VmaStlAllocator<U>& src) : m_pCallbacks(src.m_pCallbacks) { }
+
+    T* allocate(size_t n) { return VmaAllocateArray<T>(m_pCallbacks, n); }
+    void deallocate(T* p, size_t n) { VmaFree(m_pCallbacks, p); }
+
+    template<typename U>
+    bool operator==(const VmaStlAllocator<U>& rhs) const
+    {
+        return m_pCallbacks == rhs.m_pCallbacks;
+    }
+    template<typename U>
+    bool operator!=(const VmaStlAllocator<U>& rhs) const
+    {
+        return m_pCallbacks != rhs.m_pCallbacks;
+    }
+
+    VmaStlAllocator& operator=(const VmaStlAllocator& x) = delete;
+};
+
+#if VMA_USE_STL_VECTOR
+
+#define VmaVector std::vector
+
+template<typename T, typename allocatorT>
+static void VmaVectorInsert(std::vector<T, allocatorT>& vec, size_t index, const T& item)
+{
+    vec.insert(vec.begin() + index, item);
+}
+
+template<typename T, typename allocatorT>
+static void VmaVectorRemove(std::vector<T, allocatorT>& vec, size_t index)
+{
+    vec.erase(vec.begin() + index);
+}
+
+#else // #if VMA_USE_STL_VECTOR
+
+/* Class with interface compatible with subset of std::vector.
+T must be POD because constructors and destructors are not called and memcpy is
+used for these objects. */
+template<typename T, typename AllocatorT>
+class VmaVector
+{
+public:
+    typedef T value_type;
+
+    VmaVector(const AllocatorT& allocator) :
+        m_Allocator(allocator),
+        m_pArray(VMA_NULL),
+        m_Count(0),
+        m_Capacity(0)
+    {
+    }
+
+    VmaVector(size_t count, const AllocatorT& allocator) :
+        m_Allocator(allocator),
+        m_pArray(count ? (T*)VmaAllocateArray<T>(allocator.m_pCallbacks, count) : VMA_NULL),
+        m_Count(count),
+        m_Capacity(count)
+    {
+    }
+
+    // This version of the constructor is here for compatibility with pre-C++14 std::vector.
+    // value is unused.
+    VmaVector(size_t count, const T& value, const AllocatorT& allocator)
+        : VmaVector(count, allocator) {}
+
+    VmaVector(const VmaVector<T, AllocatorT>& src) :
+        m_Allocator(src.m_Allocator),
+        m_pArray(src.m_Count ? (T*)VmaAllocateArray<T>(src.m_Allocator.m_pCallbacks, src.m_Count) : VMA_NULL),
+        m_Count(src.m_Count),
+        m_Capacity(src.m_Count)
+    {
+        if(m_Count != 0)
+        {
+            memcpy(m_pArray, src.m_pArray, m_Count * sizeof(T));
+        }
+    }
+
+    ~VmaVector()
+    {
+        VmaFree(m_Allocator.m_pCallbacks, m_pArray);
+    }
+
+    VmaVector& operator=(const VmaVector<T, AllocatorT>& rhs)
+    {
+        if(&rhs != this)
+        {
+            resize(rhs.m_Count);
+            if(m_Count != 0)
+            {
+                memcpy(m_pArray, rhs.m_pArray, m_Count * sizeof(T));
+            }
+        }
+        return *this;
+    }
+
+    bool empty() const { return m_Count == 0; }
+    size_t size() const { return m_Count; }
+    T* data() { return m_pArray; }
+    const T* data() const { return m_pArray; }
+
+    T& operator[](size_t index)
+    {
+        VMA_HEAVY_ASSERT(index < m_Count);
+        return m_pArray[index];
+    }
+    const T& operator[](size_t index) const
+    {
+        VMA_HEAVY_ASSERT(index < m_Count);
+        return m_pArray[index];
+    }
+
+    T& front()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return m_pArray[0];
+    }
+    const T& front() const
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return m_pArray[0];
+    }
+    T& back()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return m_pArray[m_Count - 1];
+    }
+    const T& back() const
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return m_pArray[m_Count - 1];
+    }
+
+    void reserve(size_t newCapacity, bool freeMemory = false)
+    {
+        newCapacity = VMA_MAX(newCapacity, m_Count);
+
+        if((newCapacity < m_Capacity) && !freeMemory)
+        {
+            newCapacity = m_Capacity;
+        }
+
+        if(newCapacity != m_Capacity)
+        {
+            T* const newArray = newCapacity ? VmaAllocateArray<T>(m_Allocator, newCapacity) : VMA_NULL;
+            if(m_Count != 0)
+            {
+                memcpy(newArray, m_pArray, m_Count * sizeof(T));
+            }
+            VmaFree(m_Allocator.m_pCallbacks, m_pArray);
+            m_Capacity = newCapacity;
+            m_pArray = newArray;
+        }
+    }
+
+    void resize(size_t newCount, bool freeMemory = false)
+    {
+        size_t newCapacity = m_Capacity;
+        if(newCount > m_Capacity)
+        {
+            newCapacity = VMA_MAX(newCount, VMA_MAX(m_Capacity * 3 / 2, (size_t)8));
+        }
+        else if(freeMemory)
+        {
+            newCapacity = newCount;
+        }
+
+        if(newCapacity != m_Capacity)
+        {
+            T* const newArray = newCapacity ? VmaAllocateArray<T>(m_Allocator.m_pCallbacks, newCapacity) : VMA_NULL;
+            const size_t elementsToCopy = VMA_MIN(m_Count, newCount);
+            if(elementsToCopy != 0)
+            {
+                memcpy(newArray, m_pArray, elementsToCopy * sizeof(T));
+            }
+            VmaFree(m_Allocator.m_pCallbacks, m_pArray);
+            m_Capacity = newCapacity;
+            m_pArray = newArray;
+        }
+
+        m_Count = newCount;
+    }
+
+    void clear(bool freeMemory = false)
+    {
+        resize(0, freeMemory);
+    }
+
+    void insert(size_t index, const T& src)
+    {
+        VMA_HEAVY_ASSERT(index <= m_Count);
+        const size_t oldCount = size();
+        resize(oldCount + 1);
+        if(index < oldCount)
+        {
+            memmove(m_pArray + (index + 1), m_pArray + index, (oldCount - index) * sizeof(T));
+        }
+        m_pArray[index] = src;
+    }
+
+    void remove(size_t index)
+    {
+        VMA_HEAVY_ASSERT(index < m_Count);
+        const size_t oldCount = size();
+        if(index < oldCount - 1)
+        {
+            memmove(m_pArray + index, m_pArray + (index + 1), (oldCount - index - 1) * sizeof(T));
+        }
+        resize(oldCount - 1);
+    }
+
+    void push_back(const T& src)
+    {
+        const size_t newIndex = size();
+        resize(newIndex + 1);
+        m_pArray[newIndex] = src;
+    }
+
+    void pop_back()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        resize(size() - 1);
+    }
+
+    void push_front(const T& src)
+    {
+        insert(0, src);
+    }
+
+    void pop_front()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        remove(0);
+    }
+
+    typedef T* iterator;
+
+    iterator begin() { return m_pArray; }
+    iterator end() { return m_pArray + m_Count; }
+
+private:
+    AllocatorT m_Allocator;
+    T* m_pArray;
+    size_t m_Count;
+    size_t m_Capacity;
+};
+
+template<typename T, typename allocatorT>
+static void VmaVectorInsert(VmaVector<T, allocatorT>& vec, size_t index, const T& item)
+{
+    vec.insert(index, item);
+}
+
+template<typename T, typename allocatorT>
+static void VmaVectorRemove(VmaVector<T, allocatorT>& vec, size_t index)
+{
+    vec.remove(index);
+}
+
+#endif // #if VMA_USE_STL_VECTOR
+
+template<typename CmpLess, typename VectorT>
+size_t VmaVectorInsertSorted(VectorT& vector, const typename VectorT::value_type& value)
+{
+    const size_t indexToInsert = VmaBinaryFindFirstNotLess(
+        vector.data(),
+        vector.data() + vector.size(),
+        value,
+        CmpLess()) - vector.data();
+    VmaVectorInsert(vector, indexToInsert, value);
+    return indexToInsert;
+}
+
+template<typename CmpLess, typename VectorT>
+bool VmaVectorRemoveSorted(VectorT& vector, const typename VectorT::value_type& value)
+{
+    CmpLess comparator;
+    typename VectorT::iterator it = VmaBinaryFindFirstNotLess(
+        vector.begin(),
+        vector.end(),
+        value,
+        comparator);
+    if((it != vector.end()) && !comparator(*it, value) && !comparator(value, *it))
+    {
+        size_t indexToRemove = it - vector.begin();
+        VmaVectorRemove(vector, indexToRemove);
+        return true;
+    }
+    return false;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaSmallVector
+
+/*
+This is a vector (a variable-sized array), optimized for the case when the array is small.
+
+It contains some number of elements in-place, which allows it to avoid heap allocation
+when the actual number of elements is below that threshold. This allows normal "small"
+cases to be fast without losing generality for large inputs.
+*/
+
+template<typename T, typename AllocatorT, size_t N>
+class VmaSmallVector
+{
+public:
+    typedef T value_type;
+
+    VmaSmallVector(const AllocatorT& allocator) :
+        m_Count(0),
+        m_DynamicArray(allocator)
+    {
+    }
+    VmaSmallVector(size_t count, const AllocatorT& allocator) :
+        m_Count(count),
+        m_DynamicArray(count > N ? count : 0, allocator)
+    {
+    }
+    template<typename SrcT, typename SrcAllocatorT, size_t SrcN>
+    VmaSmallVector(const VmaSmallVector<SrcT, SrcAllocatorT, SrcN>& src) = delete;
+    template<typename SrcT, typename SrcAllocatorT, size_t SrcN>
+    VmaSmallVector<T, AllocatorT, N>& operator=(const VmaSmallVector<SrcT, SrcAllocatorT, SrcN>& rhs) = delete;
+
+    bool empty() const { return m_Count == 0; }
+    size_t size() const { return m_Count; }
+    T* data() { return m_Count > N ? m_DynamicArray.data() : m_StaticArray; }
+    const T* data() const { return m_Count > N ? m_DynamicArray.data() : m_StaticArray; }
+
+    T& operator[](size_t index)
+    {
+        VMA_HEAVY_ASSERT(index < m_Count);
+        return data()[index];
+    }
+    const T& operator[](size_t index) const
+    {
+        VMA_HEAVY_ASSERT(index < m_Count);
+        return data()[index];
+    }
+
+    T& front()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return data()[0];
+    }
+    const T& front() const
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return data()[0];
+    }
+    T& back()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return data()[m_Count - 1];
+    }
+    const T& back() const
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        return data()[m_Count - 1];
+    }
+
+    void resize(size_t newCount, bool freeMemory = false)
+    {
+        if(newCount > N && m_Count > N)
+        {
+            // Any direction, staying in m_DynamicArray
+            m_DynamicArray.resize(newCount, freeMemory);
+        }
+        else if(newCount > N && m_Count <= N)
+        {
+            // Growing, moving from m_StaticArray to m_DynamicArray
+            m_DynamicArray.resize(newCount, freeMemory);
+            if(m_Count > 0)
+            {
+                memcpy(m_DynamicArray.data(), m_StaticArray, m_Count * sizeof(T));
+            }
+        }
+        else if(newCount <= N && m_Count > N)
+        {
+            // Shrinking, moving from m_DynamicArray to m_StaticArray
+            if(newCount > 0)
+            {
+                memcpy(m_StaticArray, m_DynamicArray.data(), newCount * sizeof(T));
+            }
+            m_DynamicArray.resize(0, freeMemory);
+        }
+        else
+        {
+            // Any direction, staying in m_StaticArray - nothing to do here
+        }
+        m_Count = newCount;
+    }
+
+    void clear(bool freeMemory = false)
+    {
+        m_DynamicArray.clear(freeMemory);
+        m_Count = 0;
+    }
+
+    void insert(size_t index, const T& src)
+    {
+        VMA_HEAVY_ASSERT(index <= m_Count);
+        const size_t oldCount = size();
+        resize(oldCount + 1);
+        T* const dataPtr = data();
+        if(index < oldCount)
+        {
+            //  I know, this could be more optimal for case where memmove can be memcpy directly from m_StaticArray to m_DynamicArray.
+            memmove(dataPtr + (index + 1), dataPtr + index, (oldCount - index) * sizeof(T));
+        }
+        dataPtr[index] = src;
+    }
+
+    void remove(size_t index)
+    {
+        VMA_HEAVY_ASSERT(index < m_Count);
+        const size_t oldCount = size();
+        if(index < oldCount - 1)
+        {
+            //  I know, this could be more optimal for case where memmove can be memcpy directly from m_DynamicArray to m_StaticArray.
+            T* const dataPtr = data();
+            memmove(dataPtr + index, dataPtr + (index + 1), (oldCount - index - 1) * sizeof(T));
+        }
+        resize(oldCount - 1);
+    }
+
+    void push_back(const T& src)
+    {
+        const size_t newIndex = size();
+        resize(newIndex + 1);
+        data()[newIndex] = src;
+    }
+
+    void pop_back()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        resize(size() - 1);
+    }
+
+    void push_front(const T& src)
+    {
+        insert(0, src);
+    }
+
+    void pop_front()
+    {
+        VMA_HEAVY_ASSERT(m_Count > 0);
+        remove(0);
+    }
+
+    typedef T* iterator;
+
+    iterator begin() { return data(); }
+    iterator end() { return data() + m_Count; }
+
+private:
+    size_t m_Count;
+    T m_StaticArray[N]; // Used when m_Size <= N
+    VmaVector<T, AllocatorT> m_DynamicArray; // Used when m_Size > N
+};
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaPoolAllocator
+
+/*
+Allocator for objects of type T using a list of arrays (pools) to speed up
+allocation. Number of elements that can be allocated is not bounded because
+allocator can create multiple blocks.
+*/
+template<typename T>
+class VmaPoolAllocator
+{
+    VMA_CLASS_NO_COPY(VmaPoolAllocator)
+public:
+    VmaPoolAllocator(const VkAllocationCallbacks* pAllocationCallbacks, uint32_t firstBlockCapacity);
+    ~VmaPoolAllocator();
+    template<typename... Types> T* Alloc(Types... args);
+    void Free(T* ptr);
+
+private:
+    union Item
+    {
+        uint32_t NextFreeIndex;
+        alignas(T) char Value[sizeof(T)];
+    };
+
+    struct ItemBlock
+    {
+        Item* pItems;
+        uint32_t Capacity;
+        uint32_t FirstFreeIndex;
+    };
+
+    const VkAllocationCallbacks* m_pAllocationCallbacks;
+    const uint32_t m_FirstBlockCapacity;
+    VmaVector< ItemBlock, VmaStlAllocator<ItemBlock> > m_ItemBlocks;
+
+    ItemBlock& CreateNewBlock();
+};
+
+template<typename T>
+VmaPoolAllocator<T>::VmaPoolAllocator(const VkAllocationCallbacks* pAllocationCallbacks, uint32_t firstBlockCapacity) :
+    m_pAllocationCallbacks(pAllocationCallbacks),
+    m_FirstBlockCapacity(firstBlockCapacity),
+    m_ItemBlocks(VmaStlAllocator<ItemBlock>(pAllocationCallbacks))
+{
+    VMA_ASSERT(m_FirstBlockCapacity > 1);
+}
+
+template<typename T>
+VmaPoolAllocator<T>::~VmaPoolAllocator()
+{
+    for(size_t i = m_ItemBlocks.size(); i--; )
+        vma_delete_array(m_pAllocationCallbacks, m_ItemBlocks[i].pItems, m_ItemBlocks[i].Capacity);
+    m_ItemBlocks.clear();
+}
+
+template<typename T>
+template<typename... Types> T* VmaPoolAllocator<T>::Alloc(Types... args)
+{
+    for(size_t i = m_ItemBlocks.size(); i--; )
+    {
+        ItemBlock& block = m_ItemBlocks[i];
+        // This block has some free items: Use first one.
+        if(block.FirstFreeIndex != UINT32_MAX)
+        {
+            Item* const pItem = &block.pItems[block.FirstFreeIndex];
+            block.FirstFreeIndex = pItem->NextFreeIndex;
+            T* result = (T*)&pItem->Value;
+            new(result)T(std::forward<Types>(args)...); // Explicit constructor call.
+            return result;
+        }
+    }
+
+    // No block has free item: Create new one and use it.
+    ItemBlock& newBlock = CreateNewBlock();
+    Item* const pItem = &newBlock.pItems[0];
+    newBlock.FirstFreeIndex = pItem->NextFreeIndex;
+    T* result = (T*)&pItem->Value;
+    new(result)T(std::forward<Types>(args)...); // Explicit constructor call.
+    return result;
+}
+
+template<typename T>
+void VmaPoolAllocator<T>::Free(T* ptr)
+{
+    // Search all memory blocks to find ptr.
+    for(size_t i = m_ItemBlocks.size(); i--; )
+    {
+        ItemBlock& block = m_ItemBlocks[i];
+
+        // Casting to union.
+        Item* pItemPtr;
+        memcpy(&pItemPtr, &ptr, sizeof(pItemPtr));
+
+        // Check if pItemPtr is in address range of this block.
+        if((pItemPtr >= block.pItems) && (pItemPtr < block.pItems + block.Capacity))
+        {
+            ptr->~T(); // Explicit destructor call.
+            const uint32_t index = static_cast<uint32_t>(pItemPtr - block.pItems);
+            pItemPtr->NextFreeIndex = block.FirstFreeIndex;
+            block.FirstFreeIndex = index;
+            return;
+        }
+    }
+    VMA_ASSERT(0 && "Pointer doesn't belong to this memory pool.");
+}
+
+template<typename T>
+typename VmaPoolAllocator<T>::ItemBlock& VmaPoolAllocator<T>::CreateNewBlock()
+{
+    const uint32_t newBlockCapacity = m_ItemBlocks.empty() ?
+        m_FirstBlockCapacity : m_ItemBlocks.back().Capacity * 3 / 2;
+
+    const ItemBlock newBlock = {
+        vma_new_array(m_pAllocationCallbacks, Item, newBlockCapacity),
+        newBlockCapacity,
+        0 };
+
+    m_ItemBlocks.push_back(newBlock);
+
+    // Setup singly-linked list of all free items in this block.
+    for(uint32_t i = 0; i < newBlockCapacity - 1; ++i)
+        newBlock.pItems[i].NextFreeIndex = i + 1;
+    newBlock.pItems[newBlockCapacity - 1].NextFreeIndex = UINT32_MAX;
+    return m_ItemBlocks.back();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaRawList, VmaList
+
+#if VMA_USE_STL_LIST
+
+#define VmaList std::list
+
+#else // #if VMA_USE_STL_LIST
+
+template<typename T>
+struct VmaListItem
+{
+    VmaListItem* pPrev;
+    VmaListItem* pNext;
+    T Value;
+};
+
+// Doubly linked list.
+template<typename T>
+class VmaRawList
+{
+    VMA_CLASS_NO_COPY(VmaRawList)
+public:
+    typedef VmaListItem<T> ItemType;
+
+    VmaRawList(const VkAllocationCallbacks* pAllocationCallbacks);
+    ~VmaRawList();
+    void Clear();
+
+    size_t GetCount() const { return m_Count; }
+    bool IsEmpty() const { return m_Count == 0; }
+
+    ItemType* Front() { return m_pFront; }
+    const ItemType* Front() const { return m_pFront; }
+    ItemType* Back() { return m_pBack; }
+    const ItemType* Back() const { return m_pBack; }
+
+    ItemType* PushBack();
+    ItemType* PushFront();
+    ItemType* PushBack(const T& value);
+    ItemType* PushFront(const T& value);
+    void PopBack();
+    void PopFront();
+
+    // Item can be null - it means PushBack.
+    ItemType* InsertBefore(ItemType* pItem);
+    // Item can be null - it means PushFront.
+    ItemType* InsertAfter(ItemType* pItem);
+
+    ItemType* InsertBefore(ItemType* pItem, const T& value);
+    ItemType* InsertAfter(ItemType* pItem, const T& value);
+
+    void Remove(ItemType* pItem);
+
+private:
+    const VkAllocationCallbacks* const m_pAllocationCallbacks;
+    VmaPoolAllocator<ItemType> m_ItemAllocator;
+    ItemType* m_pFront;
+    ItemType* m_pBack;
+    size_t m_Count;
+};
+
+template<typename T>
+VmaRawList<T>::VmaRawList(const VkAllocationCallbacks* pAllocationCallbacks) :
+    m_pAllocationCallbacks(pAllocationCallbacks),
+    m_ItemAllocator(pAllocationCallbacks, 128),
+    m_pFront(VMA_NULL),
+    m_pBack(VMA_NULL),
+    m_Count(0)
+{
+}
+
+template<typename T>
+VmaRawList<T>::~VmaRawList()
+{
+    // Intentionally not calling Clear, because that would be unnecessary
+    // computations to return all items to m_ItemAllocator as free.
+}
+
+template<typename T>
+void VmaRawList<T>::Clear()
+{
+    if(IsEmpty() == false)
+    {
+        ItemType* pItem = m_pBack;
+        while(pItem != VMA_NULL)
+        {
+            ItemType* const pPrevItem = pItem->pPrev;
+            m_ItemAllocator.Free(pItem);
+            pItem = pPrevItem;
+        }
+        m_pFront = VMA_NULL;
+        m_pBack = VMA_NULL;
+        m_Count = 0;
+    }
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::PushBack()
+{
+    ItemType* const pNewItem = m_ItemAllocator.Alloc();
+    pNewItem->pNext = VMA_NULL;
+    if(IsEmpty())
+    {
+        pNewItem->pPrev = VMA_NULL;
+        m_pFront = pNewItem;
+        m_pBack = pNewItem;
+        m_Count = 1;
+    }
+    else
+    {
+        pNewItem->pPrev = m_pBack;
+        m_pBack->pNext = pNewItem;
+        m_pBack = pNewItem;
+        ++m_Count;
+    }
+    return pNewItem;
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::PushFront()
+{
+    ItemType* const pNewItem = m_ItemAllocator.Alloc();
+    pNewItem->pPrev = VMA_NULL;
+    if(IsEmpty())
+    {
+        pNewItem->pNext = VMA_NULL;
+        m_pFront = pNewItem;
+        m_pBack = pNewItem;
+        m_Count = 1;
+    }
+    else
+    {
+        pNewItem->pNext = m_pFront;
+        m_pFront->pPrev = pNewItem;
+        m_pFront = pNewItem;
+        ++m_Count;
+    }
+    return pNewItem;
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::PushBack(const T& value)
+{
+    ItemType* const pNewItem = PushBack();
+    pNewItem->Value = value;
+    return pNewItem;
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::PushFront(const T& value)
+{
+    ItemType* const pNewItem = PushFront();
+    pNewItem->Value = value;
+    return pNewItem;
+}
+
+template<typename T>
+void VmaRawList<T>::PopBack()
+{
+    VMA_HEAVY_ASSERT(m_Count > 0);
+    ItemType* const pBackItem = m_pBack;
+    ItemType* const pPrevItem = pBackItem->pPrev;
+    if(pPrevItem != VMA_NULL)
+    {
+        pPrevItem->pNext = VMA_NULL;
+    }
+    m_pBack = pPrevItem;
+    m_ItemAllocator.Free(pBackItem);
+    --m_Count;
+}
+
+template<typename T>
+void VmaRawList<T>::PopFront()
+{
+    VMA_HEAVY_ASSERT(m_Count > 0);
+    ItemType* const pFrontItem = m_pFront;
+    ItemType* const pNextItem = pFrontItem->pNext;
+    if(pNextItem != VMA_NULL)
+    {
+        pNextItem->pPrev = VMA_NULL;
+    }
+    m_pFront = pNextItem;
+    m_ItemAllocator.Free(pFrontItem);
+    --m_Count;
+}
+
+template<typename T>
+void VmaRawList<T>::Remove(ItemType* pItem)
+{
+    VMA_HEAVY_ASSERT(pItem != VMA_NULL);
+    VMA_HEAVY_ASSERT(m_Count > 0);
+
+    if(pItem->pPrev != VMA_NULL)
+    {
+        pItem->pPrev->pNext = pItem->pNext;
+    }
+    else
+    {
+        VMA_HEAVY_ASSERT(m_pFront == pItem);
+        m_pFront = pItem->pNext;
+    }
+
+    if(pItem->pNext != VMA_NULL)
+    {
+        pItem->pNext->pPrev = pItem->pPrev;
+    }
+    else
+    {
+        VMA_HEAVY_ASSERT(m_pBack == pItem);
+        m_pBack = pItem->pPrev;
+    }
+
+    m_ItemAllocator.Free(pItem);
+    --m_Count;
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::InsertBefore(ItemType* pItem)
+{
+    if(pItem != VMA_NULL)
+    {
+        ItemType* const prevItem = pItem->pPrev;
+        ItemType* const newItem = m_ItemAllocator.Alloc();
+        newItem->pPrev = prevItem;
+        newItem->pNext = pItem;
+        pItem->pPrev = newItem;
+        if(prevItem != VMA_NULL)
+        {
+            prevItem->pNext = newItem;
+        }
+        else
+        {
+            VMA_HEAVY_ASSERT(m_pFront == pItem);
+            m_pFront = newItem;
+        }
+        ++m_Count;
+        return newItem;
+    }
+    else
+        return PushBack();
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::InsertAfter(ItemType* pItem)
+{
+    if(pItem != VMA_NULL)
+    {
+        ItemType* const nextItem = pItem->pNext;
+        ItemType* const newItem = m_ItemAllocator.Alloc();
+        newItem->pNext = nextItem;
+        newItem->pPrev = pItem;
+        pItem->pNext = newItem;
+        if(nextItem != VMA_NULL)
+        {
+            nextItem->pPrev = newItem;
+        }
+        else
+        {
+            VMA_HEAVY_ASSERT(m_pBack == pItem);
+            m_pBack = newItem;
+        }
+        ++m_Count;
+        return newItem;
+    }
+    else
+        return PushFront();
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::InsertBefore(ItemType* pItem, const T& value)
+{
+    ItemType* const newItem = InsertBefore(pItem);
+    newItem->Value = value;
+    return newItem;
+}
+
+template<typename T>
+VmaListItem<T>* VmaRawList<T>::InsertAfter(ItemType* pItem, const T& value)
+{
+    ItemType* const newItem = InsertAfter(pItem);
+    newItem->Value = value;
+    return newItem;
+}
+
+template<typename T, typename AllocatorT>
+class VmaList
+{
+    VMA_CLASS_NO_COPY(VmaList)
+public:
+    class iterator
+    {
+    public:
+        iterator() :
+            m_pList(VMA_NULL),
+            m_pItem(VMA_NULL)
+        {
+        }
+
+        T& operator*() const
+        {
+            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
+            return m_pItem->Value;
+        }
+        T* operator->() const
+        {
+            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
+            return &m_pItem->Value;
+        }
+
+        iterator& operator++()
+        {
+            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
+            m_pItem = m_pItem->pNext;
+            return *this;
+        }
+        iterator& operator--()
+        {
+            if(m_pItem != VMA_NULL)
+            {
+                m_pItem = m_pItem->pPrev;
+            }
+            else
+            {
+                VMA_HEAVY_ASSERT(!m_pList->IsEmpty());
+                m_pItem = m_pList->Back();
+            }
+            return *this;
+        }
+
+        iterator operator++(int)
+        {
+            iterator result = *this;
+            ++*this;
+            return result;
+        }
+        iterator operator--(int)
+        {
+            iterator result = *this;
+            --*this;
+            return result;
+        }
+
+        bool operator==(const iterator& rhs) const
+        {
+            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
+            return m_pItem == rhs.m_pItem;
+        }
+        bool operator!=(const iterator& rhs) const
+        {
+            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
+            return m_pItem != rhs.m_pItem;
+        }
+
+    private:
+        VmaRawList<T>* m_pList;
+        VmaListItem<T>* m_pItem;
+
+        iterator(VmaRawList<T>* pList, VmaListItem<T>* pItem) :
+            m_pList(pList),
+            m_pItem(pItem)
+        {
+        }
+
+        friend class VmaList<T, AllocatorT>;
+    };
+
+    class const_iterator
+    {
+    public:
+        const_iterator() :
+            m_pList(VMA_NULL),
+            m_pItem(VMA_NULL)
+        {
+        }
+
+        const_iterator(const iterator& src) :
+            m_pList(src.m_pList),
+            m_pItem(src.m_pItem)
+        {
+        }
+
+        const T& operator*() const
+        {
+            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
+            return m_pItem->Value;
+        }
+        const T* operator->() const
+        {
+            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
+            return &m_pItem->Value;
+        }
+
+        const_iterator& operator++()
+        {
+            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
+            m_pItem = m_pItem->pNext;
+            return *this;
+        }
+        const_iterator& operator--()
+        {
+            if(m_pItem != VMA_NULL)
+            {
+                m_pItem = m_pItem->pPrev;
+            }
+            else
+            {
+                VMA_HEAVY_ASSERT(!m_pList->IsEmpty());
+                m_pItem = m_pList->Back();
+            }
+            return *this;
+        }
+
+        const_iterator operator++(int)
+        {
+            const_iterator result = *this;
+            ++*this;
+            return result;
+        }
+        const_iterator operator--(int)
+        {
+            const_iterator result = *this;
+            --*this;
+            return result;
+        }
+
+        bool operator==(const const_iterator& rhs) const
+        {
+            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
+            return m_pItem == rhs.m_pItem;
+        }
+        bool operator!=(const const_iterator& rhs) const
+        {
+            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
+            return m_pItem != rhs.m_pItem;
+        }
+
+    private:
+        const_iterator(const VmaRawList<T>* pList, const VmaListItem<T>* pItem) :
+            m_pList(pList),
+            m_pItem(pItem)
+        {
+        }
+
+        const VmaRawList<T>* m_pList;
+        const VmaListItem<T>* m_pItem;
+
+        friend class VmaList<T, AllocatorT>;
+    };
+
+    VmaList(const AllocatorT& allocator) : m_RawList(allocator.m_pCallbacks) { }
+
+    bool empty() const { return m_RawList.IsEmpty(); }
+    size_t size() const { return m_RawList.GetCount(); }
+
+    iterator begin() { return iterator(&m_RawList, m_RawList.Front()); }
+    iterator end() { return iterator(&m_RawList, VMA_NULL); }
+
+    const_iterator cbegin() const { return const_iterator(&m_RawList, m_RawList.Front()); }
+    const_iterator cend() const { return const_iterator(&m_RawList, VMA_NULL); }
+
+    void clear() { m_RawList.Clear(); }
+    void push_back(const T& value) { m_RawList.PushBack(value); }
+    void erase(iterator it) { m_RawList.Remove(it.m_pItem); }
+    iterator insert(iterator it, const T& value) { return iterator(&m_RawList, m_RawList.InsertBefore(it.m_pItem, value)); }
+
+private:
+    VmaRawList<T> m_RawList;
+};
+
+#endif // #if VMA_USE_STL_LIST
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaMap
+
+// Unused in this version.
+#if 0
+
+#if VMA_USE_STL_UNORDERED_MAP
+
+#define VmaPair std::pair
+
+#define VMA_MAP_TYPE(KeyT, ValueT) \
+    std::unordered_map< KeyT, ValueT, std::hash<KeyT>, std::equal_to<KeyT>, VmaStlAllocator< std::pair<KeyT, ValueT> > >
+
+#else // #if VMA_USE_STL_UNORDERED_MAP
+
+template<typename T1, typename T2>
+struct VmaPair
+{
+    T1 first;
+    T2 second;
+
+    VmaPair() : first(), second() { }
+    VmaPair(const T1& firstSrc, const T2& secondSrc) : first(firstSrc), second(secondSrc) { }
+};
+
+/* Class compatible with subset of interface of std::unordered_map.
+KeyT, ValueT must be POD because they will be stored in VmaVector.
+*/
+template<typename KeyT, typename ValueT>
+class VmaMap
+{
+public:
+    typedef VmaPair<KeyT, ValueT> PairType;
+    typedef PairType* iterator;
+
+    VmaMap(const VmaStlAllocator<PairType>& allocator) : m_Vector(allocator) { }
+
+    iterator begin() { return m_Vector.begin(); }
+    iterator end() { return m_Vector.end(); }
+
+    void insert(const PairType& pair);
+    iterator find(const KeyT& key);
+    void erase(iterator it);
+
+private:
+    VmaVector< PairType, VmaStlAllocator<PairType> > m_Vector;
+};
+
+#define VMA_MAP_TYPE(KeyT, ValueT) VmaMap<KeyT, ValueT>
+
+template<typename FirstT, typename SecondT>
+struct VmaPairFirstLess
+{
+    bool operator()(const VmaPair<FirstT, SecondT>& lhs, const VmaPair<FirstT, SecondT>& rhs) const
+    {
+        return lhs.first < rhs.first;
+    }
+    bool operator()(const VmaPair<FirstT, SecondT>& lhs, const FirstT& rhsFirst) const
+    {
+        return lhs.first < rhsFirst;
+    }
+};
+
+template<typename KeyT, typename ValueT>
+void VmaMap<KeyT, ValueT>::insert(const PairType& pair)
+{
+    const size_t indexToInsert = VmaBinaryFindFirstNotLess(
+        m_Vector.data(),
+        m_Vector.data() + m_Vector.size(),
+        pair,
+        VmaPairFirstLess<KeyT, ValueT>()) - m_Vector.data();
+    VmaVectorInsert(m_Vector, indexToInsert, pair);
+}
+
+template<typename KeyT, typename ValueT>
+VmaPair<KeyT, ValueT>* VmaMap<KeyT, ValueT>::find(const KeyT& key)
+{
+    PairType* it = VmaBinaryFindFirstNotLess(
+        m_Vector.data(),
+        m_Vector.data() + m_Vector.size(),
+        key,
+        VmaPairFirstLess<KeyT, ValueT>());
+    if((it != m_Vector.end()) && (it->first == key))
+    {
+        return it;
+    }
+    else
+    {
+        return m_Vector.end();
+    }
+}
+
+template<typename KeyT, typename ValueT>
+void VmaMap<KeyT, ValueT>::erase(iterator it)
+{
+    VmaVectorRemove(m_Vector, it - m_Vector.begin());
+}
+
+#endif // #if VMA_USE_STL_UNORDERED_MAP
+
+#endif // #if 0
+
+////////////////////////////////////////////////////////////////////////////////
+
+class VmaDeviceMemoryBlock;
+
+enum VMA_CACHE_OPERATION { VMA_CACHE_FLUSH, VMA_CACHE_INVALIDATE };
+
+struct VmaAllocation_T
+{
+private:
+    static const uint8_t MAP_COUNT_FLAG_PERSISTENT_MAP = 0x80;
+
+    enum FLAGS
+    {
+        FLAG_USER_DATA_STRING = 0x01,
+    };
+
+public:
+    enum ALLOCATION_TYPE
+    {
+        ALLOCATION_TYPE_NONE,
+        ALLOCATION_TYPE_BLOCK,
+        ALLOCATION_TYPE_DEDICATED,
+    };
+
+    /*
+    This struct is allocated using VmaPoolAllocator.
+    */
+
+    VmaAllocation_T(uint32_t currentFrameIndex, bool userDataString) :
+        m_Alignment{1},
+        m_Size{0},
+        m_pUserData{VMA_NULL},
+        m_LastUseFrameIndex{currentFrameIndex},
+        m_MemoryTypeIndex{0},
+        m_Type{(uint8_t)ALLOCATION_TYPE_NONE},
+        m_SuballocationType{(uint8_t)VMA_SUBALLOCATION_TYPE_UNKNOWN},
+        m_MapCount{0},
+        m_Flags{userDataString ? (uint8_t)FLAG_USER_DATA_STRING : (uint8_t)0}
+    {
+#if VMA_STATS_STRING_ENABLED
+        m_CreationFrameIndex = currentFrameIndex;
+        m_BufferImageUsage = 0;
+#endif
+    }
+
+    ~VmaAllocation_T()
+    {
+        VMA_ASSERT((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) == 0 && "Allocation was not unmapped before destruction.");
+
+        // Check if owned string was freed.
+        VMA_ASSERT(m_pUserData == VMA_NULL);
+    }
+
+    void InitBlockAllocation(
+        VmaDeviceMemoryBlock* block,
+        VkDeviceSize offset,
+        VkDeviceSize alignment,
+        VkDeviceSize size,
+        uint32_t memoryTypeIndex,
+        VmaSuballocationType suballocationType,
+        bool mapped,
+        bool canBecomeLost)
+    {
+        VMA_ASSERT(m_Type == ALLOCATION_TYPE_NONE);
+        VMA_ASSERT(block != VMA_NULL);
+        m_Type = (uint8_t)ALLOCATION_TYPE_BLOCK;
+        m_Alignment = alignment;
+        m_Size = size;
+        m_MemoryTypeIndex = memoryTypeIndex;
+        m_MapCount = mapped ? MAP_COUNT_FLAG_PERSISTENT_MAP : 0;
+        m_SuballocationType = (uint8_t)suballocationType;
+        m_BlockAllocation.m_Block = block;
+        m_BlockAllocation.m_Offset = offset;
+        m_BlockAllocation.m_CanBecomeLost = canBecomeLost;
+    }
+
+    void InitLost()
+    {
+        VMA_ASSERT(m_Type == ALLOCATION_TYPE_NONE);
+        VMA_ASSERT(m_LastUseFrameIndex.load() == VMA_FRAME_INDEX_LOST);
+        m_Type = (uint8_t)ALLOCATION_TYPE_BLOCK;
+        m_MemoryTypeIndex = 0;
+        m_BlockAllocation.m_Block = VMA_NULL;
+        m_BlockAllocation.m_Offset = 0;
+        m_BlockAllocation.m_CanBecomeLost = true;
+    }
+
+    void ChangeBlockAllocation(
+        VmaAllocator hAllocator,
+        VmaDeviceMemoryBlock* block,
+        VkDeviceSize offset);
+
+    void ChangeOffset(VkDeviceSize newOffset);
+
+    // pMappedData not null means allocation is created with MAPPED flag.
+    void InitDedicatedAllocation(
+        uint32_t memoryTypeIndex,
+        VkDeviceMemory hMemory,
+        VmaSuballocationType suballocationType,
+        void* pMappedData,
+        VkDeviceSize size)
+    {
+        VMA_ASSERT(m_Type == ALLOCATION_TYPE_NONE);
+        VMA_ASSERT(hMemory != VK_NULL_HANDLE);
+        m_Type = (uint8_t)ALLOCATION_TYPE_DEDICATED;
+        m_Alignment = 0;
+        m_Size = size;
+        m_MemoryTypeIndex = memoryTypeIndex;
+        m_SuballocationType = (uint8_t)suballocationType;
+        m_MapCount = (pMappedData != VMA_NULL) ? MAP_COUNT_FLAG_PERSISTENT_MAP : 0;
+        m_DedicatedAllocation.m_hMemory = hMemory;
+        m_DedicatedAllocation.m_pMappedData = pMappedData;
+    }
+
+    ALLOCATION_TYPE GetType() const { return (ALLOCATION_TYPE)m_Type; }
+    VkDeviceSize GetAlignment() const { return m_Alignment; }
+    VkDeviceSize GetSize() const { return m_Size; }
+    bool IsUserDataString() const { return (m_Flags & FLAG_USER_DATA_STRING) != 0; }
+    void* GetUserData() const { return m_pUserData; }
+    void SetUserData(VmaAllocator hAllocator, void* pUserData);
+    VmaSuballocationType GetSuballocationType() const { return (VmaSuballocationType)m_SuballocationType; }
+
+    VmaDeviceMemoryBlock* GetBlock() const
+    {
+        VMA_ASSERT(m_Type == ALLOCATION_TYPE_BLOCK);
+        return m_BlockAllocation.m_Block;
+    }
+    VkDeviceSize GetOffset() const;
+    VkDeviceMemory GetMemory() const;
+    uint32_t GetMemoryTypeIndex() const { return m_MemoryTypeIndex; }
+    bool IsPersistentMap() const { return (m_MapCount & MAP_COUNT_FLAG_PERSISTENT_MAP) != 0; }
+    void* GetMappedData() const;
+    bool CanBecomeLost() const;
+
+    uint32_t GetLastUseFrameIndex() const
+    {
+        return m_LastUseFrameIndex.load();
+    }
+    bool CompareExchangeLastUseFrameIndex(uint32_t& expected, uint32_t desired)
+    {
+        return m_LastUseFrameIndex.compare_exchange_weak(expected, desired);
+    }
+    /*
+    - If hAllocation.LastUseFrameIndex + frameInUseCount < allocator.CurrentFrameIndex,
+      makes it lost by setting LastUseFrameIndex = VMA_FRAME_INDEX_LOST and returns true.
+    - Else, returns false.
+
+    If hAllocation is already lost, assert - you should not call it then.
+    If hAllocation was not created with CAN_BECOME_LOST_BIT, assert.
+    */
+    bool MakeLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);
+
+    void DedicatedAllocCalcStatsInfo(VmaStatInfo& outInfo)
+    {
+        VMA_ASSERT(m_Type == ALLOCATION_TYPE_DEDICATED);
+        outInfo.blockCount = 1;
+        outInfo.allocationCount = 1;
+        outInfo.unusedRangeCount = 0;
+        outInfo.usedBytes = m_Size;
+        outInfo.unusedBytes = 0;
+        outInfo.allocationSizeMin = outInfo.allocationSizeMax = m_Size;
+        outInfo.unusedRangeSizeMin = UINT64_MAX;
+        outInfo.unusedRangeSizeMax = 0;
+    }
+
+    void BlockAllocMap();
+    void BlockAllocUnmap();
+    VkResult DedicatedAllocMap(VmaAllocator hAllocator, void** ppData);
+    void DedicatedAllocUnmap(VmaAllocator hAllocator);
+
+#if VMA_STATS_STRING_ENABLED
+    uint32_t GetCreationFrameIndex() const { return m_CreationFrameIndex; }
+    uint32_t GetBufferImageUsage() const { return m_BufferImageUsage; }
+
+    void InitBufferImageUsage(uint32_t bufferImageUsage)
+    {
+        VMA_ASSERT(m_BufferImageUsage == 0);
+        m_BufferImageUsage = bufferImageUsage;
+    }
+
+    void PrintParameters(class VmaJsonWriter& json) const;
+#endif
+
+private:
+    VkDeviceSize m_Alignment;
+    VkDeviceSize m_Size;
+    void* m_pUserData;
+    VMA_ATOMIC_UINT32 m_LastUseFrameIndex;
+    uint32_t m_MemoryTypeIndex;
+    uint8_t m_Type; // ALLOCATION_TYPE
+    uint8_t m_SuballocationType; // VmaSuballocationType
+    // Bit 0x80 is set when allocation was created with VMA_ALLOCATION_CREATE_MAPPED_BIT.
+    // Bits with mask 0x7F are reference counter for vmaMapMemory()/vmaUnmapMemory().
+    uint8_t m_MapCount;
+    uint8_t m_Flags; // enum FLAGS
+
+    // Allocation out of VmaDeviceMemoryBlock.
+    struct BlockAllocation
+    {
+        VmaDeviceMemoryBlock* m_Block;
+        VkDeviceSize m_Offset;
+        bool m_CanBecomeLost;
+    };
+
+    // Allocation for an object that has its own private VkDeviceMemory.
+    struct DedicatedAllocation
+    {
+        VkDeviceMemory m_hMemory;
+        void* m_pMappedData; // Not null means memory is mapped.
+    };
+
+    union
+    {
+        // Allocation out of VmaDeviceMemoryBlock.
+        BlockAllocation m_BlockAllocation;
+        // Allocation for an object that has its own private VkDeviceMemory.
+        DedicatedAllocation m_DedicatedAllocation;
+    };
+
+#if VMA_STATS_STRING_ENABLED
+    uint32_t m_CreationFrameIndex;
+    uint32_t m_BufferImageUsage; // 0 if unknown.
+#endif
+
+    void FreeUserDataString(VmaAllocator hAllocator);
+};
+
+/*
+Represents a region of VmaDeviceMemoryBlock that is either assigned and returned as
+allocated memory block or free.
+*/
+struct VmaSuballocation
+{
+    VkDeviceSize offset;
+    VkDeviceSize size;
+    VmaAllocation hAllocation;
+    VmaSuballocationType type;
+};
+
+// Comparator for offsets.
+struct VmaSuballocationOffsetLess
+{
+    bool operator()(const VmaSuballocation& lhs, const VmaSuballocation& rhs) const
+    {
+        return lhs.offset < rhs.offset;
+    }
+};
+struct VmaSuballocationOffsetGreater
+{
+    bool operator()(const VmaSuballocation& lhs, const VmaSuballocation& rhs) const
+    {
+        return lhs.offset > rhs.offset;
+    }
+};
+
+typedef VmaList< VmaSuballocation, VmaStlAllocator<VmaSuballocation> > VmaSuballocationList;
+
+// Cost of one additional allocation lost, as equivalent in bytes.
+static const VkDeviceSize VMA_LOST_ALLOCATION_COST = 1048576;
+
+enum class VmaAllocationRequestType
+{
+    Normal,
+    // Used by "Linear" algorithm.
+    UpperAddress,
+    EndOf1st,
+    EndOf2nd,
+};
+
+/*
+Parameters of planned allocation inside a VmaDeviceMemoryBlock.
+
+If canMakeOtherLost was false:
+- item points to a FREE suballocation.
+- itemsToMakeLostCount is 0.
+
+If canMakeOtherLost was true:
+- item points to first of sequence of suballocations, which are either FREE,
+  or point to VmaAllocations that can become lost.
+- itemsToMakeLostCount is the number of VmaAllocations that need to be made lost for
+  the requested allocation to succeed.
+*/
+struct VmaAllocationRequest
+{
+    VkDeviceSize offset;
+    VkDeviceSize sumFreeSize; // Sum size of free items that overlap with proposed allocation.
+    VkDeviceSize sumItemSize; // Sum size of items to make lost that overlap with proposed allocation.
+    VmaSuballocationList::iterator item;
+    size_t itemsToMakeLostCount;
+    void* customData;
+    VmaAllocationRequestType type;
+
+    VkDeviceSize CalcCost() const
+    {
+        return sumItemSize + itemsToMakeLostCount * VMA_LOST_ALLOCATION_COST;
+    }
+};
+
+/*
+Data structure used for bookkeeping of allocations and unused ranges of memory
+in a single VkDeviceMemory block.
+*/
+class VmaBlockMetadata
+{
+public:
+    VmaBlockMetadata(VmaAllocator hAllocator);
+    virtual ~VmaBlockMetadata() { }
+    virtual void Init(VkDeviceSize size) { m_Size = size; }
+
+    // Validates all data structures inside this object. If not valid, returns false.
+    virtual bool Validate() const = 0;
+    VkDeviceSize GetSize() const { return m_Size; }
+    virtual size_t GetAllocationCount() const = 0;
+    virtual VkDeviceSize GetSumFreeSize() const = 0;
+    virtual VkDeviceSize GetUnusedRangeSizeMax() const = 0;
+    // Returns true if this block is empty - contains only single free suballocation.
+    virtual bool IsEmpty() const = 0;
+
+    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const = 0;
+    // Shouldn't modify blockCount.
+    virtual void AddPoolStats(VmaPoolStats& inoutStats) const = 0;
+
+#if VMA_STATS_STRING_ENABLED
+    virtual void PrintDetailedMap(class VmaJsonWriter& json) const = 0;
+#endif
+
+    // Tries to find a place for suballocation with given parameters inside this block.
+    // If succeeded, fills pAllocationRequest and returns true.
+    // If failed, returns false.
+    virtual bool CreateAllocationRequest(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VkDeviceSize bufferImageGranularity,
+        VkDeviceSize allocSize,
+        VkDeviceSize allocAlignment,
+        bool upperAddress,
+        VmaSuballocationType allocType,
+        bool canMakeOtherLost,
+        // Always one of VMA_ALLOCATION_CREATE_STRATEGY_* or VMA_ALLOCATION_INTERNAL_STRATEGY_* flags.
+        uint32_t strategy,
+        VmaAllocationRequest* pAllocationRequest) = 0;
+
+    virtual bool MakeRequestedAllocationsLost(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VmaAllocationRequest* pAllocationRequest) = 0;
+
+    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount) = 0;
+
+    virtual VkResult CheckCorruption(const void* pBlockData) = 0;
+
+    // Makes actual allocation based on request. Request must already be checked and valid.
+    virtual void Alloc(
+        const VmaAllocationRequest& request,
+        VmaSuballocationType type,
+        VkDeviceSize allocSize,
+        VmaAllocation hAllocation) = 0;
+
+    // Frees suballocation assigned to given memory region.
+    virtual void Free(const VmaAllocation allocation) = 0;
+    virtual void FreeAtOffset(VkDeviceSize offset) = 0;
+
+protected:
+    const VkAllocationCallbacks* GetAllocationCallbacks() const { return m_pAllocationCallbacks; }
+
+#if VMA_STATS_STRING_ENABLED
+    void PrintDetailedMap_Begin(class VmaJsonWriter& json,
+        VkDeviceSize unusedBytes,
+        size_t allocationCount,
+        size_t unusedRangeCount) const;
+    void PrintDetailedMap_Allocation(class VmaJsonWriter& json,
+        VkDeviceSize offset,
+        VmaAllocation hAllocation) const;
+    void PrintDetailedMap_UnusedRange(class VmaJsonWriter& json,
+        VkDeviceSize offset,
+        VkDeviceSize size) const;
+    void PrintDetailedMap_End(class VmaJsonWriter& json) const;
+#endif
+
+private:
+    VkDeviceSize m_Size;
+    const VkAllocationCallbacks* m_pAllocationCallbacks;
+};
+
+#define VMA_VALIDATE(cond) do { if(!(cond)) { \
+        VMA_ASSERT(0 && "Validation failed: " #cond); \
+        return false; \
+    } } while(false)
+
+class VmaBlockMetadata_Generic : public VmaBlockMetadata
+{
+    VMA_CLASS_NO_COPY(VmaBlockMetadata_Generic)
+public:
+    VmaBlockMetadata_Generic(VmaAllocator hAllocator);
+    virtual ~VmaBlockMetadata_Generic();
+    virtual void Init(VkDeviceSize size);
+
+    virtual bool Validate() const;
+    virtual size_t GetAllocationCount() const { return m_Suballocations.size() - m_FreeCount; }
+    virtual VkDeviceSize GetSumFreeSize() const { return m_SumFreeSize; }
+    virtual VkDeviceSize GetUnusedRangeSizeMax() const;
+    virtual bool IsEmpty() const;
+
+    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const;
+    virtual void AddPoolStats(VmaPoolStats& inoutStats) const;
+
+#if VMA_STATS_STRING_ENABLED
+    virtual void PrintDetailedMap(class VmaJsonWriter& json) const;
+#endif
+
+    virtual bool CreateAllocationRequest(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VkDeviceSize bufferImageGranularity,
+        VkDeviceSize allocSize,
+        VkDeviceSize allocAlignment,
+        bool upperAddress,
+        VmaSuballocationType allocType,
+        bool canMakeOtherLost,
+        uint32_t strategy,
+        VmaAllocationRequest* pAllocationRequest);
+
+    virtual bool MakeRequestedAllocationsLost(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VmaAllocationRequest* pAllocationRequest);
+
+    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);
+
+    virtual VkResult CheckCorruption(const void* pBlockData);
+
+    virtual void Alloc(
+        const VmaAllocationRequest& request,
+        VmaSuballocationType type,
+        VkDeviceSize allocSize,
+        VmaAllocation hAllocation);
+
+    virtual void Free(const VmaAllocation allocation);
+    virtual void FreeAtOffset(VkDeviceSize offset);
+
+    ////////////////////////////////////////////////////////////////////////////////
+    // For defragmentation
+
+    bool IsBufferImageGranularityConflictPossible(
+        VkDeviceSize bufferImageGranularity,
+        VmaSuballocationType& inOutPrevSuballocType) const;
+
+private:
+    friend class VmaDefragmentationAlgorithm_Generic;
+    friend class VmaDefragmentationAlgorithm_Fast;
+
+    uint32_t m_FreeCount;
+    VkDeviceSize m_SumFreeSize;
+    VmaSuballocationList m_Suballocations;
+    // Suballocations that are free and have size greater than certain threshold.
+    // Sorted by size, ascending.
+    VmaVector< VmaSuballocationList::iterator, VmaStlAllocator< VmaSuballocationList::iterator > > m_FreeSuballocationsBySize;
+
+    bool ValidateFreeSuballocationList() const;
+
+    // Checks if requested suballocation with given parameters can be placed in given pFreeSuballocItem.
+    // If yes, fills pOffset and returns true. If no, returns false.
+    bool CheckAllocation(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VkDeviceSize bufferImageGranularity,
+        VkDeviceSize allocSize,
+        VkDeviceSize allocAlignment,
+        VmaSuballocationType allocType,
+        VmaSuballocationList::const_iterator suballocItem,
+        bool canMakeOtherLost,
+        VkDeviceSize* pOffset,
+        size_t* itemsToMakeLostCount,
+        VkDeviceSize* pSumFreeSize,
+        VkDeviceSize* pSumItemSize) const;
+    // Given free suballocation, it merges it with following one, which must also be free.
+    void MergeFreeWithNext(VmaSuballocationList::iterator item);
+    // Releases given suballocation, making it free.
+    // Merges it with adjacent free suballocations if applicable.
+    // Returns iterator to new free suballocation at this place.
+    VmaSuballocationList::iterator FreeSuballocation(VmaSuballocationList::iterator suballocItem);
+    // Given free suballocation, it inserts it into sorted list of
+    // m_FreeSuballocationsBySize if it's suitable.
+    void RegisterFreeSuballocation(VmaSuballocationList::iterator item);
+    // Given free suballocation, it removes it from sorted list of
+    // m_FreeSuballocationsBySize if it's suitable.
+    void UnregisterFreeSuballocation(VmaSuballocationList::iterator item);
+};
+
+/*
+Allocations and their references in internal data structure look like this:
+
+if(m_2ndVectorMode == SECOND_VECTOR_EMPTY):
+
+        0 +-------+
+          |       |
+          |       |
+          |       |
+          +-------+
+          | Alloc |  1st[m_1stNullItemsBeginCount]
+          +-------+
+          | Alloc |  1st[m_1stNullItemsBeginCount + 1]
+          +-------+
+          |  ...  |
+          +-------+
+          | Alloc |  1st[1st.size() - 1]
+          +-------+
+          |       |
+          |       |
+          |       |
+GetSize() +-------+
+
+if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER):
+
+        0 +-------+
+          | Alloc |  2nd[0]
+          +-------+
+          | Alloc |  2nd[1]
+          +-------+
+          |  ...  |
+          +-------+
+          | Alloc |  2nd[2nd.size() - 1]
+          +-------+
+          |       |
+          |       |
+          |       |
+          +-------+
+          | Alloc |  1st[m_1stNullItemsBeginCount]
+          +-------+
+          | Alloc |  1st[m_1stNullItemsBeginCount + 1]
+          +-------+
+          |  ...  |
+          +-------+
+          | Alloc |  1st[1st.size() - 1]
+          +-------+
+          |       |
+GetSize() +-------+
+
+if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK):
+
+        0 +-------+
+          |       |
+          |       |
+          |       |
+          +-------+
+          | Alloc |  1st[m_1stNullItemsBeginCount]
+          +-------+
+          | Alloc |  1st[m_1stNullItemsBeginCount + 1]
+          +-------+
+          |  ...  |
+          +-------+
+          | Alloc |  1st[1st.size() - 1]
+          +-------+
+          |       |
+          |       |
+          |       |
+          +-------+
+          | Alloc |  2nd[2nd.size() - 1]
+          +-------+
+          |  ...  |
+          +-------+
+          | Alloc |  2nd[1]
+          +-------+
+          | Alloc |  2nd[0]
+GetSize() +-------+
+
+*/
+class VmaBlockMetadata_Linear : public VmaBlockMetadata
+{
+    VMA_CLASS_NO_COPY(VmaBlockMetadata_Linear)
+public:
+    VmaBlockMetadata_Linear(VmaAllocator hAllocator);
+    virtual ~VmaBlockMetadata_Linear();
+    virtual void Init(VkDeviceSize size);
+
+    virtual bool Validate() const;
+    virtual size_t GetAllocationCount() const;
+    virtual VkDeviceSize GetSumFreeSize() const { return m_SumFreeSize; }
+    virtual VkDeviceSize GetUnusedRangeSizeMax() const;
+    virtual bool IsEmpty() const { return GetAllocationCount() == 0; }
+
+    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const;
+    virtual void AddPoolStats(VmaPoolStats& inoutStats) const;
+
+#if VMA_STATS_STRING_ENABLED
+    virtual void PrintDetailedMap(class VmaJsonWriter& json) const;
+#endif
+
+    virtual bool CreateAllocationRequest(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VkDeviceSize bufferImageGranularity,
+        VkDeviceSize allocSize,
+        VkDeviceSize allocAlignment,
+        bool upperAddress,
+        VmaSuballocationType allocType,
+        bool canMakeOtherLost,
+        uint32_t strategy,
+        VmaAllocationRequest* pAllocationRequest);
+
+    virtual bool MakeRequestedAllocationsLost(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VmaAllocationRequest* pAllocationRequest);
+
+    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);
+
+    virtual VkResult CheckCorruption(const void* pBlockData);
+
+    virtual void Alloc(
+        const VmaAllocationRequest& request,
+        VmaSuballocationType type,
+        VkDeviceSize allocSize,
+        VmaAllocation hAllocation);
+
+    virtual void Free(const VmaAllocation allocation);
+    virtual void FreeAtOffset(VkDeviceSize offset);
+
+private:
+    /*
+    There are two suballocation vectors, used in ping-pong way.
+    The one with index m_1stVectorIndex is called 1st.
+    The one with index (m_1stVectorIndex ^ 1) is called 2nd.
+    2nd can be non-empty only when 1st is not empty.
+    When 2nd is not empty, m_2ndVectorMode indicates its mode of operation.
+    */
+    typedef VmaVector< VmaSuballocation, VmaStlAllocator<VmaSuballocation> > SuballocationVectorType;
+
+    enum SECOND_VECTOR_MODE
+    {
+        SECOND_VECTOR_EMPTY,
+        /*
+        Suballocations in 2nd vector are created later than the ones in 1st, but they
+        all have smaller offset.
+        */
+        SECOND_VECTOR_RING_BUFFER,
+        /*
+        Suballocations in 2nd vector are upper side of double stack.
+        They all have offsets higher than those in 1st vector.
+        Top of this stack means smaller offsets, but higher indices in this vector.
+        */
+        SECOND_VECTOR_DOUBLE_STACK,
+    };
+
+    VkDeviceSize m_SumFreeSize;
+    SuballocationVectorType m_Suballocations0, m_Suballocations1;
+    uint32_t m_1stVectorIndex;
+    SECOND_VECTOR_MODE m_2ndVectorMode;
+
+    SuballocationVectorType& AccessSuballocations1st() { return m_1stVectorIndex ? m_Suballocations1 : m_Suballocations0; }
+    SuballocationVectorType& AccessSuballocations2nd() { return m_1stVectorIndex ? m_Suballocations0 : m_Suballocations1; }
+    const SuballocationVectorType& AccessSuballocations1st() const { return m_1stVectorIndex ? m_Suballocations1 : m_Suballocations0; }
+    const SuballocationVectorType& AccessSuballocations2nd() const { return m_1stVectorIndex ? m_Suballocations0 : m_Suballocations1; }
+
+    // Number of items in 1st vector with hAllocation = null at the beginning.
+    size_t m_1stNullItemsBeginCount;
+    // Number of other items in 1st vector with hAllocation = null somewhere in the middle.
+    size_t m_1stNullItemsMiddleCount;
+    // Number of items in 2nd vector with hAllocation = null.
+    size_t m_2ndNullItemsCount;
+
+    bool ShouldCompact1st() const;
+    void CleanupAfterFree();
+
+    bool CreateAllocationRequest_LowerAddress(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VkDeviceSize bufferImageGranularity,
+        VkDeviceSize allocSize,
+        VkDeviceSize allocAlignment,
+        VmaSuballocationType allocType,
+        bool canMakeOtherLost,
+        uint32_t strategy,
+        VmaAllocationRequest* pAllocationRequest);
+    bool CreateAllocationRequest_UpperAddress(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VkDeviceSize bufferImageGranularity,
+        VkDeviceSize allocSize,
+        VkDeviceSize allocAlignment,
+        VmaSuballocationType allocType,
+        bool canMakeOtherLost,
+        uint32_t strategy,
+        VmaAllocationRequest* pAllocationRequest);
+};
+
+/*
+- GetSize() is the original size of allocated memory block.
+- m_UsableSize is this size aligned down to a power of two.
+  All allocations and calculations happen relative to m_UsableSize.
+- GetUnusableSize() is the difference between them.
+  It is repoted as separate, unused range, not available for allocations.
+
+Node at level 0 has size = m_UsableSize.
+Each next level contains nodes with size 2 times smaller than current level.
+m_LevelCount is the maximum number of levels to use in the current object.
+*/
+class VmaBlockMetadata_Buddy : public VmaBlockMetadata
+{
+    VMA_CLASS_NO_COPY(VmaBlockMetadata_Buddy)
+public:
+    VmaBlockMetadata_Buddy(VmaAllocator hAllocator);
+    virtual ~VmaBlockMetadata_Buddy();
+    virtual void Init(VkDeviceSize size);
+
+    virtual bool Validate() const;
+    virtual size_t GetAllocationCount() const { return m_AllocationCount; }
+    virtual VkDeviceSize GetSumFreeSize() const { return m_SumFreeSize + GetUnusableSize(); }
+    virtual VkDeviceSize GetUnusedRangeSizeMax() const;
+    virtual bool IsEmpty() const { return m_Root->type == Node::TYPE_FREE; }
+
+    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const;
+    virtual void AddPoolStats(VmaPoolStats& inoutStats) const;
+
+#if VMA_STATS_STRING_ENABLED
+    virtual void PrintDetailedMap(class VmaJsonWriter& json) const;
+#endif
+
+    virtual bool CreateAllocationRequest(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VkDeviceSize bufferImageGranularity,
+        VkDeviceSize allocSize,
+        VkDeviceSize allocAlignment,
+        bool upperAddress,
+        VmaSuballocationType allocType,
+        bool canMakeOtherLost,
+        uint32_t strategy,
+        VmaAllocationRequest* pAllocationRequest);
+
+    virtual bool MakeRequestedAllocationsLost(
+        uint32_t currentFrameIndex,
+        uint32_t frameInUseCount,
+        VmaAllocationRequest* pAllocationRequest);
+
+    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);
+
+    virtual VkResult CheckCorruption(const void* pBlockData) { return VK_ERROR_FEATURE_NOT_PRESENT; }
+
+    virtual void Alloc(
+        const VmaAllocationRequest& request,
+        VmaSuballocationType type,
+        VkDeviceSize allocSize,
+        VmaAllocation hAllocation);
+
+    virtual void Free(const VmaAllocation allocation) { FreeAtOffset(allocation, allocation->GetOffset()); }
+    virtual void FreeAtOffset(VkDeviceSize offset) { FreeAtOffset(VMA_NULL, offset); }
+
+private:
+    static const VkDeviceSize MIN_NODE_SIZE = 32;
+    static const size_t MAX_LEVELS = 30;
+
+    struct ValidationContext
+    {
+        size_t calculatedAllocationCount;
+        size_t calculatedFreeCount;
+        VkDeviceSize calculatedSumFreeSize;
+
+        ValidationContext() :
+            calculatedAllocationCount(0),
+            calculatedFreeCount(0),
+            calculatedSumFreeSize(0) { }
+    };
+
+    struct Node
+    {
+        VkDeviceSize offset;
+        enum TYPE
+        {
+            TYPE_FREE,
+            TYPE_ALLOCATION,
+            TYPE_SPLIT,
+            TYPE_COUNT
+        } type;
+        Node* parent;
+        Node* buddy;
+
+        union
+        {
+            struct
+            {
+                Node* prev;
+                Node* next;
+            } free;
+            struct
+            {
+                VmaAllocation alloc;
+            } allocation;
+            struct
+            {
+                Node* leftChild;
+            } split;
+        };
+    };
+
+    // Size of the memory block aligned down to a power of two.
+    VkDeviceSize m_UsableSize;
+    uint32_t m_LevelCount;
+
+    Node* m_Root;
+    struct {
+        Node* front;
+        Node* back;
+    } m_FreeList[MAX_LEVELS];
+    // Number of nodes in the tree with type == TYPE_ALLOCATION.
+    size_t m_AllocationCount;
+    // Number of nodes in the tree with type == TYPE_FREE.
+    size_t m_FreeCount;
+    // This includes space wasted due to internal fragmentation. Doesn't include unusable size.
+    VkDeviceSize m_SumFreeSize;
+
+    VkDeviceSize GetUnusableSize() const { return GetSize() - m_UsableSize; }
+    void DeleteNode(Node* node);
+    bool ValidateNode(ValidationContext& ctx, const Node* parent, const Node* curr, uint32_t level, VkDeviceSize levelNodeSize) const;
+    uint32_t AllocSizeToLevel(VkDeviceSize allocSize) const;
+    inline VkDeviceSize LevelToNodeSize(uint32_t level) const { return m_UsableSize >> level; }
+    // Alloc passed just for validation. Can be null.
+    void FreeAtOffset(VmaAllocation alloc, VkDeviceSize offset);
+    void CalcAllocationStatInfoNode(VmaStatInfo& outInfo, const Node* node, VkDeviceSize levelNodeSize) const;
+    // Adds node to the front of FreeList at given level.
+    // node->type must be FREE.
+    // node->free.prev, next can be undefined.
+    void AddToFreeListFront(uint32_t level, Node* node);
+    // Removes node from FreeList at given level.
+    // node->type must be FREE.
+    // node->free.prev, next stay untouched.
+    void RemoveFromFreeList(uint32_t level, Node* node);
+
+#if VMA_STATS_STRING_ENABLED
+    void PrintDetailedMapNode(class VmaJsonWriter& json, const Node* node, VkDeviceSize levelNodeSize) const;
+#endif
+};
+
+/*
+Represents a single block of device memory (`VkDeviceMemory`) with all the
+data about its regions (aka suballocations, #VmaAllocation), assigned and free.
+
+Thread-safety: This class must be externally synchronized.
+*/
+class VmaDeviceMemoryBlock
+{
+    VMA_CLASS_NO_COPY(VmaDeviceMemoryBlock)
+public:
+    VmaBlockMetadata* m_pMetadata;
+
+    VmaDeviceMemoryBlock(VmaAllocator hAllocator);
+
+    ~VmaDeviceMemoryBlock()
+    {
+        VMA_ASSERT(m_MapCount == 0 && "VkDeviceMemory block is being destroyed while it is still mapped.");
+        VMA_ASSERT(m_hMemory == VK_NULL_HANDLE);
+    }
+
+    // Always call after construction.
+    void Init(
+        VmaAllocator hAllocator,
+        VmaPool hParentPool,
+        uint32_t newMemoryTypeIndex,
+        VkDeviceMemory newMemory,
+        VkDeviceSize newSize,
+        uint32_t id,
+        uint32_t algorithm);
+    // Always call before destruction.
+    void Destroy(VmaAllocator allocator);
+
+    VmaPool GetParentPool() const { return m_hParentPool; }
+    VkDeviceMemory GetDeviceMemory() const { return m_hMemory; }
+    uint32_t GetMemoryTypeIndex() const { return m_MemoryTypeIndex; }
+    uint32_t GetId() const { return m_Id; }
+    void* GetMappedData() const { return m_pMappedData; }
+
+    // Validates all data structures inside this object. If not valid, returns false.
+    bool Validate() const;
+
+    VkResult CheckCorruption(VmaAllocator hAllocator);
+
+    // ppData can be null.
+    VkResult Map(VmaAllocator hAllocator, uint32_t count, void** ppData);
+    void Unmap(VmaAllocator hAllocator, uint32_t count);
+
+    VkResult WriteMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize);
+    VkResult ValidateMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize);
+
+    VkResult BindBufferMemory(
+        const VmaAllocator hAllocator,
+        const VmaAllocation hAllocation,
+        VkDeviceSize allocationLocalOffset,
+        VkBuffer hBuffer,
+        const void* pNext);
+    VkResult BindImageMemory(
+        const VmaAllocator hAllocator,
+        const VmaAllocation hAllocation,
+        VkDeviceSize allocationLocalOffset,
+        VkImage hImage,
+        const void* pNext);
+
+private:
+    VmaPool m_hParentPool; // VK_NULL_HANDLE if not belongs to custom pool.
+    uint32_t m_MemoryTypeIndex;
+    uint32_t m_Id;
+    VkDeviceMemory m_hMemory;
+
+    /*
+    Protects access to m_hMemory so it's not used by multiple threads simultaneously, e.g. vkMapMemory, vkBindBufferMemory.
+    Also protects m_MapCount, m_pMappedData.
+    Allocations, deallocations, any change in m_pMetadata is protected by parent's VmaBlockVector::m_Mutex.
+    */
+    VMA_MUTEX m_Mutex;
+    uint32_t m_MapCount;
+    void* m_pMappedData;
+};
+
+struct VmaPointerLess
+{
+    bool operator()(const void* lhs, const void* rhs) const
+    {
+        return lhs < rhs;
+    }
+};
+
+struct VmaDefragmentationMove
+{
+    size_t srcBlockIndex;
+    size_t dstBlockIndex;
+    VkDeviceSize srcOffset;
+    VkDeviceSize dstOffset;
+    VkDeviceSize size;
+    VmaAllocation hAllocation;
+    VmaDeviceMemoryBlock* pSrcBlock;
+    VmaDeviceMemoryBlock* pDstBlock;
+};
+
+class VmaDefragmentationAlgorithm;
+
+/*
+Sequence of VmaDeviceMemoryBlock. Represents memory blocks allocated for a specific
+Vulkan memory type.
+
+Synchronized internally with a mutex.
+*/
+struct VmaBlockVector
+{
+    VMA_CLASS_NO_COPY(VmaBlockVector)
+public:
+    VmaBlockVector(
+        VmaAllocator hAllocator,
+        VmaPool hParentPool,
+        uint32_t memoryTypeIndex,
+        VkDeviceSize preferredBlockSize,
+        size_t minBlockCount,
+        size_t maxBlockCount,
+        VkDeviceSize bufferImageGranularity,
+        uint32_t frameInUseCount,
+        bool explicitBlockSize,
+        uint32_t algorithm,
+        bool exportable);
+    ~VmaBlockVector();
+
+    VkResult CreateMinBlocks();
+
+    VmaAllocator GetAllocator() const { return m_hAllocator; }
+    VmaPool GetParentPool() const { return m_hParentPool; }
+    bool IsCustomPool() const { return m_hParentPool != VMA_NULL; }
+    uint32_t GetMemoryTypeIndex() const { return m_MemoryTypeIndex; }
+    VkDeviceSize GetPreferredBlockSize() const { return m_PreferredBlockSize; }
+    VkDeviceSize GetBufferImageGranularity() const { return m_BufferImageGranularity; }
+    uint32_t GetFrameInUseCount() const { return m_FrameInUseCount; }
+    uint32_t GetAlgorithm() const { return m_Algorithm; }
+
+    void GetPoolStats(VmaPoolStats* pStats);
+
+    bool IsEmpty();
+    bool IsCorruptionDetectionEnabled() const;
+
+    VkResult Allocate(
+        uint32_t currentFrameIndex,
+        VkDeviceSize size,
+        VkDeviceSize alignment,
+        const VmaAllocationCreateInfo& createInfo,
+        VmaSuballocationType suballocType,
+        size_t allocationCount,
+        VmaAllocation* pAllocations);
+
+    void Free(const VmaAllocation hAllocation);
+
+    // Adds statistics of this BlockVector to pStats.
+    void AddStats(VmaStats* pStats);
+
+#if VMA_STATS_STRING_ENABLED
+    void PrintDetailedMap(class VmaJsonWriter& json);
+#endif
+
+    void MakePoolAllocationsLost(
+        uint32_t currentFrameIndex,
+        size_t* pLostAllocationCount);
+    VkResult CheckCorruption();
+
+    // Saves results in pCtx->res.
+    void Defragment(
+        class VmaBlockVectorDefragmentationContext* pCtx,
+        VmaDefragmentationStats* pStats, VmaDefragmentationFlags flags,
+        VkDeviceSize& maxCpuBytesToMove, uint32_t& maxCpuAllocationsToMove,
+        VkDeviceSize& maxGpuBytesToMove, uint32_t& maxGpuAllocationsToMove,
+        VkCommandBuffer commandBuffer);
+    void DefragmentationEnd(
+        class VmaBlockVectorDefragmentationContext* pCtx,
+        uint32_t flags,
+        VmaDefragmentationStats* pStats);
+
+    uint32_t ProcessDefragmentations(
+        class VmaBlockVectorDefragmentationContext *pCtx,
+        VmaDefragmentationPassMoveInfo* pMove, uint32_t maxMoves);
+
+    void CommitDefragmentations(
+        class VmaBlockVectorDefragmentationContext *pCtx,
+        VmaDefragmentationStats* pStats);
+
+    ////////////////////////////////////////////////////////////////////////////////
+    // To be used only while the m_Mutex is locked. Used during defragmentation.
+
+    size_t GetBlockCount() const { return m_Blocks.size(); }
+    VmaDeviceMemoryBlock* GetBlock(size_t index) const { return m_Blocks[index]; }
+    size_t CalcAllocationCount() const;
+    bool IsBufferImageGranularityConflictPossible() const;
+
+private:
+    friend class VmaDefragmentationAlgorithm_Generic;
+
+    const VmaAllocator m_hAllocator;
+    const VmaPool m_hParentPool;
+    const uint32_t m_MemoryTypeIndex;
+    const VkDeviceSize m_PreferredBlockSize;
+    const size_t m_MinBlockCount;
+    const size_t m_MaxBlockCount;
+    const VkDeviceSize m_BufferImageGranularity;
+    const uint32_t m_FrameInUseCount;
+    const bool m_ExplicitBlockSize;
+    const uint32_t m_Algorithm;
+    const bool m_Exportable;
+    VMA_RW_MUTEX m_Mutex;
+
+    /* There can be at most one allocation that is completely empty (except when minBlockCount > 0) -
+    a hysteresis to avoid pessimistic case of alternating creation and destruction of a VkDeviceMemory. */
+    bool m_HasEmptyBlock;
+    // Incrementally sorted by sumFreeSize, ascending.
+    VmaVector< VmaDeviceMemoryBlock*, VmaStlAllocator<VmaDeviceMemoryBlock*> > m_Blocks;
+    uint32_t m_NextBlockId;
+
+    VkDeviceSize CalcMaxBlockSize() const;
+
+    // Finds and removes given block from vector.
+    void Remove(VmaDeviceMemoryBlock* pBlock);
+
+    // Performs single step in sorting m_Blocks. They may not be fully sorted
+    // after this call.
+    void IncrementallySortBlocks();
+
+    VkResult AllocatePage(
+        uint32_t currentFrameIndex,
+        VkDeviceSize size,
+        VkDeviceSize alignment,
+        const VmaAllocationCreateInfo& createInfo,
+        VmaSuballocationType suballocType,
+        VmaAllocation* pAllocation);
+
+    // To be used only without CAN_MAKE_OTHER_LOST flag.
+    VkResult AllocateFromBlock(
+        VmaDeviceMemoryBlock* pBlock,
+        uint32_t currentFrameIndex,
+        VkDeviceSize size,
+        VkDeviceSize alignment,
+        VmaAllocationCreateFlags allocFlags,
+        void* pUserData,
+        VmaSuballocationType suballocType,
+        uint32_t strategy,
+        VmaAllocation* pAllocation);
+
+    VkResult CreateBlock(VkDeviceSize blockSize, size_t* pNewBlockIndex);
+
+    // Saves result to pCtx->res.
+    void ApplyDefragmentationMovesCpu(
+        class VmaBlockVectorDefragmentationContext* pDefragCtx,
+        const VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves);
+    // Saves result to pCtx->res.
+    void ApplyDefragmentationMovesGpu(
+        class VmaBlockVectorDefragmentationContext* pDefragCtx,
+        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+        VkCommandBuffer commandBuffer);
+
+    /*
+    Used during defragmentation. pDefragmentationStats is optional. It's in/out
+    - updated with new data.
+    */
+    void FreeEmptyBlocks(VmaDefragmentationStats* pDefragmentationStats);
+
+    void UpdateHasEmptyBlock();
+};
+
+struct VmaPool_T
+{
+    VMA_CLASS_NO_COPY(VmaPool_T)
+public:
+    VmaBlockVector m_BlockVector;
+
+    VmaPool_T(
+        VmaAllocator hAllocator,
+        const VmaPoolCreateInfo& createInfo,
+        VkDeviceSize preferredBlockSize);
+    ~VmaPool_T();
+
+    uint32_t GetId() const { return m_Id; }
+    void SetId(uint32_t id) { VMA_ASSERT(m_Id == 0); m_Id = id; }
+
+    const char* GetName() const { return m_Name; }
+    void SetName(const char* pName);
+
+#if VMA_STATS_STRING_ENABLED
+    //void PrintDetailedMap(class VmaStringBuilder& sb);
+#endif
+
+private:
+    uint32_t m_Id;
+    char* m_Name;
+};
+
+/*
+Performs defragmentation:
+
+- Updates `pBlockVector->m_pMetadata`.
+- Updates allocations by calling ChangeBlockAllocation() or ChangeOffset().
+- Does not move actual data, only returns requested moves as `moves`.
+*/
+class VmaDefragmentationAlgorithm
+{
+    VMA_CLASS_NO_COPY(VmaDefragmentationAlgorithm)
+public:
+    VmaDefragmentationAlgorithm(
+        VmaAllocator hAllocator,
+        VmaBlockVector* pBlockVector,
+        uint32_t currentFrameIndex) :
+        m_hAllocator(hAllocator),
+        m_pBlockVector(pBlockVector),
+        m_CurrentFrameIndex(currentFrameIndex)
+    {
+    }
+    virtual ~VmaDefragmentationAlgorithm()
+    {
+    }
+
+    virtual void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged) = 0;
+    virtual void AddAll() = 0;
+
+    virtual VkResult Defragment(
+        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+        VkDeviceSize maxBytesToMove,
+        uint32_t maxAllocationsToMove,
+        VmaDefragmentationFlags flags) = 0;
+
+    virtual VkDeviceSize GetBytesMoved() const = 0;
+    virtual uint32_t GetAllocationsMoved() const = 0;
+
+protected:
+    VmaAllocator const m_hAllocator;
+    VmaBlockVector* const m_pBlockVector;
+    const uint32_t m_CurrentFrameIndex;
+
+    struct AllocationInfo
+    {
+        VmaAllocation m_hAllocation;
+        VkBool32* m_pChanged;
+
+        AllocationInfo() :
+            m_hAllocation(VK_NULL_HANDLE),
+            m_pChanged(VMA_NULL)
+        {
+        }
+        AllocationInfo(VmaAllocation hAlloc, VkBool32* pChanged) :
+            m_hAllocation(hAlloc),
+            m_pChanged(pChanged)
+        {
+        }
+    };
+};
+
+class VmaDefragmentationAlgorithm_Generic : public VmaDefragmentationAlgorithm
+{
+    VMA_CLASS_NO_COPY(VmaDefragmentationAlgorithm_Generic)
+public:
+    VmaDefragmentationAlgorithm_Generic(
+        VmaAllocator hAllocator,
+        VmaBlockVector* pBlockVector,
+        uint32_t currentFrameIndex,
+        bool overlappingMoveSupported);
+    virtual ~VmaDefragmentationAlgorithm_Generic();
+
+    virtual void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged);
+    virtual void AddAll() { m_AllAllocations = true; }
+
+    virtual VkResult Defragment(
+        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+        VkDeviceSize maxBytesToMove,
+        uint32_t maxAllocationsToMove,
+        VmaDefragmentationFlags flags);
+
+    virtual VkDeviceSize GetBytesMoved() const { return m_BytesMoved; }
+    virtual uint32_t GetAllocationsMoved() const { return m_AllocationsMoved; }
+
+private:
+    uint32_t m_AllocationCount;
+    bool m_AllAllocations;
+
+    VkDeviceSize m_BytesMoved;
+    uint32_t m_AllocationsMoved;
+
+    struct AllocationInfoSizeGreater
+    {
+        bool operator()(const AllocationInfo& lhs, const AllocationInfo& rhs) const
+        {
+            return lhs.m_hAllocation->GetSize() > rhs.m_hAllocation->GetSize();
+        }
+    };
+
+    struct AllocationInfoOffsetGreater
+    {
+        bool operator()(const AllocationInfo& lhs, const AllocationInfo& rhs) const
+        {
+            return lhs.m_hAllocation->GetOffset() > rhs.m_hAllocation->GetOffset();
+        }
+    };
+
+    struct BlockInfo
+    {
+        size_t m_OriginalBlockIndex;
+        VmaDeviceMemoryBlock* m_pBlock;
+        bool m_HasNonMovableAllocations;
+        VmaVector< AllocationInfo, VmaStlAllocator<AllocationInfo> > m_Allocations;
+
+        BlockInfo(const VkAllocationCallbacks* pAllocationCallbacks) :
+            m_OriginalBlockIndex(SIZE_MAX),
+            m_pBlock(VMA_NULL),
+            m_HasNonMovableAllocations(true),
+            m_Allocations(pAllocationCallbacks)
+        {
+        }
+
+        void CalcHasNonMovableAllocations()
+        {
+            const size_t blockAllocCount = m_pBlock->m_pMetadata->GetAllocationCount();
+            const size_t defragmentAllocCount = m_Allocations.size();
+            m_HasNonMovableAllocations = blockAllocCount != defragmentAllocCount;
+        }
+
+        void SortAllocationsBySizeDescending()
+        {
+            VMA_SORT(m_Allocations.begin(), m_Allocations.end(), AllocationInfoSizeGreater());
+        }
+
+        void SortAllocationsByOffsetDescending()
+        {
+            VMA_SORT(m_Allocations.begin(), m_Allocations.end(), AllocationInfoOffsetGreater());
+        }
+    };
+
+    struct BlockPointerLess
+    {
+        bool operator()(const BlockInfo* pLhsBlockInfo, const VmaDeviceMemoryBlock* pRhsBlock) const
+        {
+            return pLhsBlockInfo->m_pBlock < pRhsBlock;
+        }
+        bool operator()(const BlockInfo* pLhsBlockInfo, const BlockInfo* pRhsBlockInfo) const
+        {
+            return pLhsBlockInfo->m_pBlock < pRhsBlockInfo->m_pBlock;
+        }
+    };
+
+    // 1. Blocks with some non-movable allocations go first.
+    // 2. Blocks with smaller sumFreeSize go first.
+    struct BlockInfoCompareMoveDestination
+    {
+        bool operator()(const BlockInfo* pLhsBlockInfo, const BlockInfo* pRhsBlockInfo) const
+        {
+            if(pLhsBlockInfo->m_HasNonMovableAllocations && !pRhsBlockInfo->m_HasNonMovableAllocations)
+            {
+                return true;
+            }
+            if(!pLhsBlockInfo->m_HasNonMovableAllocations && pRhsBlockInfo->m_HasNonMovableAllocations)
+            {
+                return false;
+            }
+            if(pLhsBlockInfo->m_pBlock->m_pMetadata->GetSumFreeSize() < pRhsBlockInfo->m_pBlock->m_pMetadata->GetSumFreeSize())
+            {
+                return true;
+            }
+            return false;
+        }
+    };
+
+    typedef VmaVector< BlockInfo*, VmaStlAllocator<BlockInfo*> > BlockInfoVector;
+    BlockInfoVector m_Blocks;
+
+    VkResult DefragmentRound(
+        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+        VkDeviceSize maxBytesToMove,
+        uint32_t maxAllocationsToMove,
+        bool freeOldAllocations);
+
+    size_t CalcBlocksWithNonMovableCount() const;
+
+    static bool MoveMakesSense(
+        size_t dstBlockIndex, VkDeviceSize dstOffset,
+        size_t srcBlockIndex, VkDeviceSize srcOffset);
+};
+
+class VmaDefragmentationAlgorithm_Fast : public VmaDefragmentationAlgorithm
+{
+    VMA_CLASS_NO_COPY(VmaDefragmentationAlgorithm_Fast)
+public:
+    VmaDefragmentationAlgorithm_Fast(
+        VmaAllocator hAllocator,
+        VmaBlockVector* pBlockVector,
+        uint32_t currentFrameIndex,
+        bool overlappingMoveSupported);
+    virtual ~VmaDefragmentationAlgorithm_Fast();
+
+    virtual void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged) { ++m_AllocationCount; }
+    virtual void AddAll() { m_AllAllocations = true; }
+
+    virtual VkResult Defragment(
+        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+        VkDeviceSize maxBytesToMove,
+        uint32_t maxAllocationsToMove,
+        VmaDefragmentationFlags flags);
+
+    virtual VkDeviceSize GetBytesMoved() const { return m_BytesMoved; }
+    virtual uint32_t GetAllocationsMoved() const { return m_AllocationsMoved; }
+
+private:
+    struct BlockInfo
+    {
+        size_t origBlockIndex;
+    };
+
+    class FreeSpaceDatabase
+    {
+    public:
+        FreeSpaceDatabase()
+        {
+            FreeSpace s = {};
+            s.blockInfoIndex = SIZE_MAX;
+            for(size_t i = 0; i < MAX_COUNT; ++i)
+            {
+                m_FreeSpaces[i] = s;
+            }
+        }
+
+        void Register(size_t blockInfoIndex, VkDeviceSize offset, VkDeviceSize size)
+        {
+            if(size < VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
+            {
+                return;
+            }
+
+            // Find first invalid or the smallest structure.
+            size_t bestIndex = SIZE_MAX;
+            for(size_t i = 0; i < MAX_COUNT; ++i)
+            {
+                // Empty structure.
+                if(m_FreeSpaces[i].blockInfoIndex == SIZE_MAX)
+                {
+                    bestIndex = i;
+                    break;
+                }
+                if(m_FreeSpaces[i].size < size &&
+                    (bestIndex == SIZE_MAX || m_FreeSpaces[bestIndex].size > m_FreeSpaces[i].size))
+                {
+                    bestIndex = i;
+                }
+            }
+
+            if(bestIndex != SIZE_MAX)
+            {
+                m_FreeSpaces[bestIndex].blockInfoIndex = blockInfoIndex;
+                m_FreeSpaces[bestIndex].offset = offset;
+                m_FreeSpaces[bestIndex].size = size;
+            }
+        }
+
+        bool Fetch(VkDeviceSize alignment, VkDeviceSize size,
+            size_t& outBlockInfoIndex, VkDeviceSize& outDstOffset)
+        {
+            size_t bestIndex = SIZE_MAX;
+            VkDeviceSize bestFreeSpaceAfter = 0;
+            for(size_t i = 0; i < MAX_COUNT; ++i)
+            {
+                // Structure is valid.
+                if(m_FreeSpaces[i].blockInfoIndex != SIZE_MAX)
+                {
+                    const VkDeviceSize dstOffset = VmaAlignUp(m_FreeSpaces[i].offset, alignment);
+                    // Allocation fits into this structure.
+                    if(dstOffset + size <= m_FreeSpaces[i].offset + m_FreeSpaces[i].size)
+                    {
+                        const VkDeviceSize freeSpaceAfter = (m_FreeSpaces[i].offset + m_FreeSpaces[i].size) -
+                            (dstOffset + size);
+                        if(bestIndex == SIZE_MAX || freeSpaceAfter > bestFreeSpaceAfter)
+                        {
+                            bestIndex = i;
+                            bestFreeSpaceAfter = freeSpaceAfter;
+                        }
+                    }
+                }
+            }
+
+            if(bestIndex != SIZE_MAX)
+            {
+                outBlockInfoIndex = m_FreeSpaces[bestIndex].blockInfoIndex;
+                outDstOffset = VmaAlignUp(m_FreeSpaces[bestIndex].offset, alignment);
+
+                if(bestFreeSpaceAfter >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
+                {
+                    // Leave this structure for remaining empty space.
+                    const VkDeviceSize alignmentPlusSize = (outDstOffset - m_FreeSpaces[bestIndex].offset) + size;
+                    m_FreeSpaces[bestIndex].offset += alignmentPlusSize;
+                    m_FreeSpaces[bestIndex].size -= alignmentPlusSize;
+                }
+                else
+                {
+                    // This structure becomes invalid.
+                    m_FreeSpaces[bestIndex].blockInfoIndex = SIZE_MAX;
+                }
+
+                return true;
+            }
+
+            return false;
+        }
+
+    private:
+        static const size_t MAX_COUNT = 4;
+
+        struct FreeSpace
+        {
+            size_t blockInfoIndex; // SIZE_MAX means this structure is invalid.
+            VkDeviceSize offset;
+            VkDeviceSize size;
+        } m_FreeSpaces[MAX_COUNT];
+    };
+
+    const bool m_OverlappingMoveSupported;
+
+    uint32_t m_AllocationCount;
+    bool m_AllAllocations;
+
+    VkDeviceSize m_BytesMoved;
+    uint32_t m_AllocationsMoved;
+
+    VmaVector< BlockInfo, VmaStlAllocator<BlockInfo> > m_BlockInfos;
+
+    void PreprocessMetadata();
+    void PostprocessMetadata();
+    void InsertSuballoc(VmaBlockMetadata_Generic* pMetadata, const VmaSuballocation& suballoc);
+};
+
+struct VmaBlockDefragmentationContext
+{
+    enum BLOCK_FLAG
+    {
+        BLOCK_FLAG_USED = 0x00000001,
+    };
+    uint32_t flags;
+    VkBuffer hBuffer;
+};
+
+class VmaBlockVectorDefragmentationContext
+{
+    VMA_CLASS_NO_COPY(VmaBlockVectorDefragmentationContext)
+public:
+    VkResult res;
+    bool mutexLocked;
+    VmaVector< VmaBlockDefragmentationContext, VmaStlAllocator<VmaBlockDefragmentationContext> > blockContexts;
+    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> > defragmentationMoves;
+    uint32_t defragmentationMovesProcessed;
+    uint32_t defragmentationMovesCommitted;
+    bool hasDefragmentationPlan;
+
+    VmaBlockVectorDefragmentationContext(
+        VmaAllocator hAllocator,
+        VmaPool hCustomPool, // Optional.
+        VmaBlockVector* pBlockVector,
+        uint32_t currFrameIndex);
+    ~VmaBlockVectorDefragmentationContext();
+
+    VmaPool GetCustomPool() const { return m_hCustomPool; }
+    VmaBlockVector* GetBlockVector() const { return m_pBlockVector; }
+    VmaDefragmentationAlgorithm* GetAlgorithm() const { return m_pAlgorithm; }
+
+    void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged);
+    void AddAll() { m_AllAllocations = true; }
+
+    void Begin(bool overlappingMoveSupported, VmaDefragmentationFlags flags);
+
+private:
+    const VmaAllocator m_hAllocator;
+    // Null if not from custom pool.
+    const VmaPool m_hCustomPool;
+    // Redundant, for convenience not to fetch from m_hCustomPool->m_BlockVector or m_hAllocator->m_pBlockVectors.
+    VmaBlockVector* const m_pBlockVector;
+    const uint32_t m_CurrFrameIndex;
+    // Owner of this object.
+    VmaDefragmentationAlgorithm* m_pAlgorithm;
+
+    struct AllocInfo
+    {
+        VmaAllocation hAlloc;
+        VkBool32* pChanged;
+    };
+    // Used between constructor and Begin.
+    VmaVector< AllocInfo, VmaStlAllocator<AllocInfo> > m_Allocations;
+    bool m_AllAllocations;
+};
+
+struct VmaDefragmentationContext_T
+{
+private:
+    VMA_CLASS_NO_COPY(VmaDefragmentationContext_T)
+public:
+    VmaDefragmentationContext_T(
+        VmaAllocator hAllocator,
+        uint32_t currFrameIndex,
+        uint32_t flags,
+        VmaDefragmentationStats* pStats);
+    ~VmaDefragmentationContext_T();
+
+    void AddPools(uint32_t poolCount, const VmaPool* pPools);
+    void AddAllocations(
+        uint32_t allocationCount,
+        const VmaAllocation* pAllocations,
+        VkBool32* pAllocationsChanged);
+
+    /*
+    Returns:
+    - `VK_SUCCESS` if succeeded and object can be destroyed immediately.
+    - `VK_NOT_READY` if succeeded but the object must remain alive until vmaDefragmentationEnd().
+    - Negative value if error occured and object can be destroyed immediately.
+    */
+    VkResult Defragment(
+        VkDeviceSize maxCpuBytesToMove, uint32_t maxCpuAllocationsToMove,
+        VkDeviceSize maxGpuBytesToMove, uint32_t maxGpuAllocationsToMove,
+        VkCommandBuffer commandBuffer, VmaDefragmentationStats* pStats, VmaDefragmentationFlags flags);
+
+    VkResult DefragmentPassBegin(VmaDefragmentationPassInfo* pInfo);
+    VkResult DefragmentPassEnd();
+
+private:
+    const VmaAllocator m_hAllocator;
+    const uint32_t m_CurrFrameIndex;
+    const uint32_t m_Flags;
+    VmaDefragmentationStats* const m_pStats;
+
+    VkDeviceSize m_MaxCpuBytesToMove;
+    uint32_t m_MaxCpuAllocationsToMove;
+    VkDeviceSize m_MaxGpuBytesToMove;
+    uint32_t m_MaxGpuAllocationsToMove;
+
+    // Owner of these objects.
+    VmaBlockVectorDefragmentationContext* m_DefaultPoolContexts[VK_MAX_MEMORY_TYPES];
+    // Owner of these objects.
+    VmaVector< VmaBlockVectorDefragmentationContext*, VmaStlAllocator<VmaBlockVectorDefragmentationContext*> > m_CustomPoolContexts;
+};
+
+#if VMA_RECORDING_ENABLED
+
+class VmaRecorder
+{
+public:
+    VmaRecorder();
+    VkResult Init(const VmaRecordSettings& settings, bool useMutex);
+    void WriteConfiguration(
+        const VkPhysicalDeviceProperties& devProps,
+        const VkPhysicalDeviceMemoryProperties& memProps,
+        uint32_t vulkanApiVersion,
+        bool dedicatedAllocationExtensionEnabled,
+        bool bindMemory2ExtensionEnabled,
+        bool memoryBudgetExtensionEnabled,
+        bool deviceCoherentMemoryExtensionEnabled);
+    ~VmaRecorder();
+
+    void RecordCreateAllocator(uint32_t frameIndex);
+    void RecordDestroyAllocator(uint32_t frameIndex);
+    void RecordCreatePool(uint32_t frameIndex,
+        const VmaPoolCreateInfo& createInfo,
+        VmaPool pool);
+    void RecordDestroyPool(uint32_t frameIndex, VmaPool pool);
+    void RecordAllocateMemory(uint32_t frameIndex,
+        const VkMemoryRequirements& vkMemReq,
+        const VmaAllocationCreateInfo& createInfo,
+        VmaAllocation allocation);
+    void RecordAllocateMemoryPages(uint32_t frameIndex,
+        const VkMemoryRequirements& vkMemReq,
+        const VmaAllocationCreateInfo& createInfo,
+        uint64_t allocationCount,
+        const VmaAllocation* pAllocations);
+    void RecordAllocateMemoryForBuffer(uint32_t frameIndex,
+        const VkMemoryRequirements& vkMemReq,
+        bool requiresDedicatedAllocation,
+        bool prefersDedicatedAllocation,
+        const VmaAllocationCreateInfo& createInfo,
+        VmaAllocation allocation);
+    void RecordAllocateMemoryForImage(uint32_t frameIndex,
+        const VkMemoryRequirements& vkMemReq,
+        bool requiresDedicatedAllocation,
+        bool prefersDedicatedAllocation,
+        const VmaAllocationCreateInfo& createInfo,
+        VmaAllocation allocation);
+    void RecordFreeMemory(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordFreeMemoryPages(uint32_t frameIndex,
+        uint64_t allocationCount,
+        const VmaAllocation* pAllocations);
+    void RecordSetAllocationUserData(uint32_t frameIndex,
+        VmaAllocation allocation,
+        const void* pUserData);
+    void RecordCreateLostAllocation(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordMapMemory(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordUnmapMemory(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordFlushAllocation(uint32_t frameIndex,
+        VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size);
+    void RecordInvalidateAllocation(uint32_t frameIndex,
+        VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size);
+    void RecordCreateBuffer(uint32_t frameIndex,
+        const VkBufferCreateInfo& bufCreateInfo,
+        const VmaAllocationCreateInfo& allocCreateInfo,
+        VmaAllocation allocation);
+    void RecordCreateImage(uint32_t frameIndex,
+        const VkImageCreateInfo& imageCreateInfo,
+        const VmaAllocationCreateInfo& allocCreateInfo,
+        VmaAllocation allocation);
+    void RecordDestroyBuffer(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordDestroyImage(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordTouchAllocation(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordGetAllocationInfo(uint32_t frameIndex,
+        VmaAllocation allocation);
+    void RecordMakePoolAllocationsLost(uint32_t frameIndex,
+        VmaPool pool);
+    void RecordDefragmentationBegin(uint32_t frameIndex,
+        const VmaDefragmentationInfo2& info,
+        VmaDefragmentationContext ctx);
+    void RecordDefragmentationEnd(uint32_t frameIndex,
+        VmaDefragmentationContext ctx);
+    void RecordSetPoolName(uint32_t frameIndex,
+        VmaPool pool,
+        const char* name);
+
+private:
+    struct CallParams
+    {
+        uint32_t threadId;
+        double time;
+    };
+
+    class UserDataString
+    {
+    public:
+        UserDataString(VmaAllocationCreateFlags allocFlags, const void* pUserData);
+        const char* GetString() const { return m_Str; }
+
+    private:
+        char m_PtrStr[17];
+        const char* m_Str;
+    };
+
+    bool m_UseMutex;
+    VmaRecordFlags m_Flags;
+    FILE* m_File;
+    VMA_MUTEX m_FileMutex;
+    std::chrono::time_point<std::chrono::high_resolution_clock> m_RecordingStartTime;
+
+    void GetBasicParams(CallParams& outParams);
+
+    // T must be a pointer type, e.g. VmaAllocation, VmaPool.
+    template<typename T>
+    void PrintPointerList(uint64_t count, const T* pItems)
+    {
+        if(count)
+        {
+            fprintf(m_File, "%p", pItems[0]);
+            for(uint64_t i = 1; i < count; ++i)
+            {
+                fprintf(m_File, " %p", pItems[i]);
+            }
+        }
+    }
+
+    void PrintPointerList(uint64_t count, const VmaAllocation* pItems);
+    void Flush();
+};
+
+#endif // #if VMA_RECORDING_ENABLED
+
+/*
+Thread-safe wrapper over VmaPoolAllocator free list, for allocation of VmaAllocation_T objects.
+*/
+class VmaAllocationObjectAllocator
+{
+    VMA_CLASS_NO_COPY(VmaAllocationObjectAllocator)
+public:
+    VmaAllocationObjectAllocator(const VkAllocationCallbacks* pAllocationCallbacks);
+
+    template<typename... Types> VmaAllocation Allocate(Types... args);
+    void Free(VmaAllocation hAlloc);
+
+private:
+    VMA_MUTEX m_Mutex;
+    VmaPoolAllocator<VmaAllocation_T> m_Allocator;
+};
+
+struct VmaCurrentBudgetData
+{
+    VMA_ATOMIC_UINT64 m_BlockBytes[VK_MAX_MEMORY_HEAPS];
+    VMA_ATOMIC_UINT64 m_AllocationBytes[VK_MAX_MEMORY_HEAPS];
+
+#if VMA_MEMORY_BUDGET
+    VMA_ATOMIC_UINT32 m_OperationsSinceBudgetFetch;
+    VMA_RW_MUTEX m_BudgetMutex;
+    uint64_t m_VulkanUsage[VK_MAX_MEMORY_HEAPS];
+    uint64_t m_VulkanBudget[VK_MAX_MEMORY_HEAPS];
+    uint64_t m_BlockBytesAtBudgetFetch[VK_MAX_MEMORY_HEAPS];
+#endif // #if VMA_MEMORY_BUDGET
+
+    VmaCurrentBudgetData()
+    {
+        for(uint32_t heapIndex = 0; heapIndex < VK_MAX_MEMORY_HEAPS; ++heapIndex)
+        {
+            m_BlockBytes[heapIndex] = 0;
+            m_AllocationBytes[heapIndex] = 0;
+#if VMA_MEMORY_BUDGET
+            m_VulkanUsage[heapIndex] = 0;
+            m_VulkanBudget[heapIndex] = 0;
+            m_BlockBytesAtBudgetFetch[heapIndex] = 0;
+#endif
+        }
+
+#if VMA_MEMORY_BUDGET
+        m_OperationsSinceBudgetFetch = 0;
+#endif
+    }
+
+    void AddAllocation(uint32_t heapIndex, VkDeviceSize allocationSize)
+    {
+        m_AllocationBytes[heapIndex] += allocationSize;
+#if VMA_MEMORY_BUDGET
+        ++m_OperationsSinceBudgetFetch;
+#endif
+    }
+
+    void RemoveAllocation(uint32_t heapIndex, VkDeviceSize allocationSize)
+    {
+        VMA_ASSERT(m_AllocationBytes[heapIndex] >= allocationSize); // DELME
+        m_AllocationBytes[heapIndex] -= allocationSize;
+#if VMA_MEMORY_BUDGET
+        ++m_OperationsSinceBudgetFetch;
+#endif
+    }
+};
+
+// Main allocator object.
+struct VmaAllocator_T
+{
+    VMA_CLASS_NO_COPY(VmaAllocator_T)
+public:
+    bool m_UseMutex;
+    uint32_t m_VulkanApiVersion;
+    bool m_UseKhrDedicatedAllocation; // Can be set only if m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0).
+    bool m_UseKhrBindMemory2; // Can be set only if m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0).
+    bool m_UseExtMemoryBudget;
+    bool m_UseAmdDeviceCoherentMemory;
+    bool m_UseKhrBufferDeviceAddress;
+    VkDevice m_hDevice;
+    VkInstance m_hInstance;
+    bool m_AllocationCallbacksSpecified;
+    VkAllocationCallbacks m_AllocationCallbacks;
+    VmaDeviceMemoryCallbacks m_DeviceMemoryCallbacks;
+    VmaAllocationObjectAllocator m_AllocationObjectAllocator;
+
+    // Each bit (1 << i) is set if HeapSizeLimit is enabled for that heap, so cannot allocate more than the heap size.
+    uint32_t m_HeapSizeLimitMask;
+
+    VkPhysicalDeviceProperties m_PhysicalDeviceProperties;
+    VkPhysicalDeviceMemoryProperties m_MemProps;
+
+    // Default pools.
+    VmaBlockVector* m_pBlockVectors[VK_MAX_MEMORY_TYPES];
+
+    // Each vector is sorted by memory (handle value).
+    typedef VmaVector< VmaAllocation, VmaStlAllocator<VmaAllocation> > AllocationVectorType;
+    AllocationVectorType* m_pDedicatedAllocations[VK_MAX_MEMORY_TYPES];
+    VMA_RW_MUTEX m_DedicatedAllocationsMutex[VK_MAX_MEMORY_TYPES];
+
+    VmaCurrentBudgetData m_Budget;
+
+    VmaAllocator_T(const VmaAllocatorCreateInfo* pCreateInfo);
+    VkResult Init(const VmaAllocatorCreateInfo* pCreateInfo);
+    ~VmaAllocator_T();
+
+    const VkAllocationCallbacks* GetAllocationCallbacks() const
+    {
+        return m_AllocationCallbacksSpecified ? &m_AllocationCallbacks : 0;
+    }
+    const VmaVulkanFunctions& GetVulkanFunctions() const
+    {
+        return m_VulkanFunctions;
+    }
+
+    VkPhysicalDevice GetPhysicalDevice() const { return m_PhysicalDevice; }
+
+    VkDeviceSize GetBufferImageGranularity() const
+    {
+        return VMA_MAX(
+            static_cast<VkDeviceSize>(VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY),
+            m_PhysicalDeviceProperties.limits.bufferImageGranularity);
+    }
+
+    uint32_t GetMemoryHeapCount() const { return m_MemProps.memoryHeapCount; }
+    uint32_t GetMemoryTypeCount() const { return m_MemProps.memoryTypeCount; }
+
+    uint32_t MemoryTypeIndexToHeapIndex(uint32_t memTypeIndex) const
+    {
+        VMA_ASSERT(memTypeIndex < m_MemProps.memoryTypeCount);
+        return m_MemProps.memoryTypes[memTypeIndex].heapIndex;
+    }
+    // True when specific memory type is HOST_VISIBLE but not HOST_COHERENT.
+    bool IsMemoryTypeNonCoherent(uint32_t memTypeIndex) const
+    {
+        return (m_MemProps.memoryTypes[memTypeIndex].propertyFlags & (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) ==
+            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
+    }
+    // Minimum alignment for all allocations in specific memory type.
+    VkDeviceSize GetMemoryTypeMinAlignment(uint32_t memTypeIndex) const
+    {
+        return IsMemoryTypeNonCoherent(memTypeIndex) ?
+            VMA_MAX((VkDeviceSize)VMA_DEBUG_ALIGNMENT, m_PhysicalDeviceProperties.limits.nonCoherentAtomSize) :
+            (VkDeviceSize)VMA_DEBUG_ALIGNMENT;
+    }
+
+    bool IsIntegratedGpu() const
+    {
+        return m_PhysicalDeviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU;
+    }
+
+    uint32_t GetGlobalMemoryTypeBits() const { return m_GlobalMemoryTypeBits; }
+
+#if VMA_RECORDING_ENABLED
+    VmaRecorder* GetRecorder() const { return m_pRecorder; }
+#endif
+
+    void GetBufferMemoryRequirements(
+        VkBuffer hBuffer,
+        VkMemoryRequirements& memReq,
+        bool& requiresDedicatedAllocation,
+        bool& prefersDedicatedAllocation) const;
+    void GetImageMemoryRequirements(
+        VkImage hImage,
+        VkMemoryRequirements& memReq,
+        bool& requiresDedicatedAllocation,
+        bool& prefersDedicatedAllocation) const;
+
+    // Main allocation function.
+    VkResult AllocateMemory(
+        const VkMemoryRequirements& vkMemReq,
+        bool requiresDedicatedAllocation,
+        bool prefersDedicatedAllocation,
+        VkBuffer dedicatedBuffer,
+        VkBufferUsageFlags dedicatedBufferUsage, // UINT32_MAX when unknown.
+        VkImage dedicatedImage,
+        const VmaAllocationCreateInfo& createInfo,
+        VmaSuballocationType suballocType,
+        size_t allocationCount,
+        VmaAllocation* pAllocations);
+
+    // Main deallocation function.
+    void FreeMemory(
+        size_t allocationCount,
+        const VmaAllocation* pAllocations);
+
+    VkResult ResizeAllocation(
+        const VmaAllocation alloc,
+        VkDeviceSize newSize);
+
+    void CalculateStats(VmaStats* pStats);
+
+    void GetBudget(
+        VmaBudget* outBudget, uint32_t firstHeap, uint32_t heapCount);
+
+#if VMA_STATS_STRING_ENABLED
+    void PrintDetailedMap(class VmaJsonWriter& json);
+#endif
+
+    VkResult DefragmentationBegin(
+        const VmaDefragmentationInfo2& info,
+        VmaDefragmentationStats* pStats,
+        VmaDefragmentationContext* pContext);
+    VkResult DefragmentationEnd(
+        VmaDefragmentationContext context);
+
+    VkResult DefragmentationPassBegin(
+        VmaDefragmentationPassInfo* pInfo,
+        VmaDefragmentationContext context);
+    VkResult DefragmentationPassEnd(
+        VmaDefragmentationContext context);
+
+    void GetAllocationInfo(VmaAllocation hAllocation, VmaAllocationInfo* pAllocationInfo);
+    bool TouchAllocation(VmaAllocation hAllocation);
+
+    VkResult CreatePool(const VmaPoolCreateInfo* pCreateInfo, VmaPool* pPool);
+    void DestroyPool(VmaPool pool);
+    void GetPoolStats(VmaPool pool, VmaPoolStats* pPoolStats);
+
+    void SetCurrentFrameIndex(uint32_t frameIndex);
+    uint32_t GetCurrentFrameIndex() const { return m_CurrentFrameIndex.load(); }
+
+    void MakePoolAllocationsLost(
+        VmaPool hPool,
+        size_t* pLostAllocationCount);
+    VkResult CheckPoolCorruption(VmaPool hPool);
+    VkResult CheckCorruption(uint32_t memoryTypeBits);
+
+    void CreateLostAllocation(VmaAllocation* pAllocation);
+
+    // Call to Vulkan function vkAllocateMemory with accompanying bookkeeping.
+    VkResult AllocateVulkanMemory(const VkMemoryAllocateInfo* pAllocateInfo, VkDeviceMemory* pMemory);
+    // Call to Vulkan function vkFreeMemory with accompanying bookkeeping.
+    void FreeVulkanMemory(uint32_t memoryType, VkDeviceSize size, VkDeviceMemory hMemory);
+    // Call to Vulkan function vkBindBufferMemory or vkBindBufferMemory2KHR.
+    VkResult BindVulkanBuffer(
+        VkDeviceMemory memory,
+        VkDeviceSize memoryOffset,
+        VkBuffer buffer,
+        const void* pNext);
+    // Call to Vulkan function vkBindImageMemory or vkBindImageMemory2KHR.
+    VkResult BindVulkanImage(
+        VkDeviceMemory memory,
+        VkDeviceSize memoryOffset,
+        VkImage image,
+        const void* pNext);
+
+    VkResult Map(VmaAllocation hAllocation, void** ppData);
+    void Unmap(VmaAllocation hAllocation);
+
+    VkResult BindBufferMemory(
+        VmaAllocation hAllocation,
+        VkDeviceSize allocationLocalOffset,
+        VkBuffer hBuffer,
+        const void* pNext);
+    VkResult BindImageMemory(
+        VmaAllocation hAllocation,
+        VkDeviceSize allocationLocalOffset,
+        VkImage hImage,
+        const void* pNext);
+
+    VkResult FlushOrInvalidateAllocation(
+        VmaAllocation hAllocation,
+        VkDeviceSize offset, VkDeviceSize size,
+        VMA_CACHE_OPERATION op);
+    VkResult FlushOrInvalidateAllocations(
+        uint32_t allocationCount,
+        const VmaAllocation* allocations,
+        const VkDeviceSize* offsets, const VkDeviceSize* sizes,
+        VMA_CACHE_OPERATION op);
+
+    void FillAllocation(const VmaAllocation hAllocation, uint8_t pattern);
+
+    /*
+    Returns bit mask of memory types that can support defragmentation on GPU as
+    they support creation of required buffer for copy operations.
+    */
+    uint32_t GetGpuDefragmentationMemoryTypeBits();
+
+private:
+    VkDeviceSize m_PreferredLargeHeapBlockSize;
+
+    VkPhysicalDevice m_PhysicalDevice;
+    VMA_ATOMIC_UINT32 m_CurrentFrameIndex;
+    VMA_ATOMIC_UINT32 m_GpuDefragmentationMemoryTypeBits; // UINT32_MAX means uninitialized.
+
+    VMA_RW_MUTEX m_PoolsMutex;
+    // Protected by m_PoolsMutex. Sorted by pointer value.
+    VmaVector<VmaPool, VmaStlAllocator<VmaPool> > m_Pools;
+    uint32_t m_NextPoolId;
+
+    VmaVulkanFunctions m_VulkanFunctions;
+
+    // Global bit mask AND-ed with any memoryTypeBits to disallow certain memory types.
+    uint32_t m_GlobalMemoryTypeBits;
+
+#if VMA_RECORDING_ENABLED
+    VmaRecorder* m_pRecorder;
+#endif
+
+    void ImportVulkanFunctions(const VmaVulkanFunctions* pVulkanFunctions);
+
+#if VMA_STATIC_VULKAN_FUNCTIONS == 1
+    void ImportVulkanFunctions_Static();
+#endif
+
+    void ImportVulkanFunctions_Custom(const VmaVulkanFunctions* pVulkanFunctions);
+
+#if VMA_DYNAMIC_VULKAN_FUNCTIONS == 1
+    void ImportVulkanFunctions_Dynamic();
+#endif
+
+    void ValidateVulkanFunctions();
+
+    VkDeviceSize CalcPreferredBlockSize(uint32_t memTypeIndex);
+
+    VkResult AllocateMemoryOfType(
+        VkDeviceSize size,
+        VkDeviceSize alignment,
+        bool dedicatedAllocation,
+        VkBuffer dedicatedBuffer,
+        VkBufferUsageFlags dedicatedBufferUsage,
+        VkImage dedicatedImage,
+        const VmaAllocationCreateInfo& createInfo,
+        uint32_t memTypeIndex,
+        VmaSuballocationType suballocType,
+        size_t allocationCount,
+        VmaAllocation* pAllocations);
+
+    // Helper function only to be used inside AllocateDedicatedMemory.
+    VkResult AllocateDedicatedMemoryPage(
+        VkDeviceSize size,
+        VmaSuballocationType suballocType,
+        uint32_t memTypeIndex,
+        const VkMemoryAllocateInfo& allocInfo,
+        bool map,
+        bool isUserDataString,
+        void* pUserData,
+        VmaAllocation* pAllocation);
+
+    // Allocates and registers new VkDeviceMemory specifically for dedicated allocations.
+    VkResult AllocateDedicatedMemory(
+        VkDeviceSize size,
+        VmaSuballocationType suballocType,
+        uint32_t memTypeIndex,
+        bool withinBudget,
+        bool map,
+        bool isUserDataString,
+        void* pUserData,
+        VkBuffer dedicatedBuffer,
+        VkBufferUsageFlags dedicatedBufferUsage,
+        VkImage dedicatedImage,
+        size_t allocationCount,
+        VmaAllocation* pAllocations);
+
+    void FreeDedicatedMemory(const VmaAllocation allocation);
+
+    /*
+    Calculates and returns bit mask of memory types that can support defragmentation
+    on GPU as they support creation of required buffer for copy operations.
+    */
+    uint32_t CalculateGpuDefragmentationMemoryTypeBits() const;
+
+    uint32_t CalculateGlobalMemoryTypeBits() const;
+
+    bool GetFlushOrInvalidateRange(
+        VmaAllocation allocation,
+        VkDeviceSize offset, VkDeviceSize size,
+        VkMappedMemoryRange& outRange) const;
+
+#if VMA_MEMORY_BUDGET
+    void UpdateVulkanBudget();
+#endif // #if VMA_MEMORY_BUDGET
+};
+
+////////////////////////////////////////////////////////////////////////////////
+// Memory allocation #2 after VmaAllocator_T definition
+
+static void* VmaMalloc(VmaAllocator hAllocator, size_t size, size_t alignment)
+{
+    return VmaMalloc(&hAllocator->m_AllocationCallbacks, size, alignment);
+}
+
+static void VmaFree(VmaAllocator hAllocator, void* ptr)
+{
+    VmaFree(&hAllocator->m_AllocationCallbacks, ptr);
+}
+
+template<typename T>
+static T* VmaAllocate(VmaAllocator hAllocator)
+{
+    return (T*)VmaMalloc(hAllocator, sizeof(T), VMA_ALIGN_OF(T));
+}
+
+template<typename T>
+static T* VmaAllocateArray(VmaAllocator hAllocator, size_t count)
+{
+    return (T*)VmaMalloc(hAllocator, sizeof(T) * count, VMA_ALIGN_OF(T));
+}
+
+template<typename T>
+static void vma_delete(VmaAllocator hAllocator, T* ptr)
+{
+    if(ptr != VMA_NULL)
+    {
+        ptr->~T();
+        VmaFree(hAllocator, ptr);
+    }
+}
+
+template<typename T>
+static void vma_delete_array(VmaAllocator hAllocator, T* ptr, size_t count)
+{
+    if(ptr != VMA_NULL)
+    {
+        for(size_t i = count; i--; )
+            ptr[i].~T();
+        VmaFree(hAllocator, ptr);
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaStringBuilder
+
+#if VMA_STATS_STRING_ENABLED
+
+class VmaStringBuilder
+{
+public:
+    VmaStringBuilder(VmaAllocator alloc) : m_Data(VmaStlAllocator<char>(alloc->GetAllocationCallbacks())) { }
+    size_t GetLength() const { return m_Data.size(); }
+    const char* GetData() const { return m_Data.data(); }
+
+    void Add(char ch) { m_Data.push_back(ch); }
+    void Add(const char* pStr);
+    void AddNewLine() { Add('\n'); }
+    void AddNumber(uint32_t num);
+    void AddNumber(uint64_t num);
+    void AddPointer(const void* ptr);
+
+private:
+    VmaVector< char, VmaStlAllocator<char> > m_Data;
+};
+
+void VmaStringBuilder::Add(const char* pStr)
+{
+    const size_t strLen = strlen(pStr);
+    if(strLen > 0)
+    {
+        const size_t oldCount = m_Data.size();
+        m_Data.resize(oldCount + strLen);
+        memcpy(m_Data.data() + oldCount, pStr, strLen);
+    }
+}
+
+void VmaStringBuilder::AddNumber(uint32_t num)
+{
+    char buf[11];
+    buf[10] = '\0';
+    char *p = &buf[10];
+    do
+    {
+        *--p = '0' + (num % 10);
+        num /= 10;
+    }
+    while(num);
+    Add(p);
+}
+
+void VmaStringBuilder::AddNumber(uint64_t num)
+{
+    char buf[21];
+    buf[20] = '\0';
+    char *p = &buf[20];
+    do
+    {
+        *--p = '0' + (num % 10);
+        num /= 10;
+    }
+    while(num);
+    Add(p);
+}
+
+void VmaStringBuilder::AddPointer(const void* ptr)
+{
+    char buf[21];
+    VmaPtrToStr(buf, sizeof(buf), ptr);
+    Add(buf);
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaJsonWriter
+
+#if VMA_STATS_STRING_ENABLED
+
+class VmaJsonWriter
+{
+    VMA_CLASS_NO_COPY(VmaJsonWriter)
+public:
+    VmaJsonWriter(const VkAllocationCallbacks* pAllocationCallbacks, VmaStringBuilder& sb);
+    ~VmaJsonWriter();
+
+    void BeginObject(bool singleLine = false);
+    void EndObject();
+
+    void BeginArray(bool singleLine = false);
+    void EndArray();
+
+    void WriteString(const char* pStr);
+    void BeginString(const char* pStr = VMA_NULL);
+    void ContinueString(const char* pStr);
+    void ContinueString(uint32_t n);
+    void ContinueString(uint64_t n);
+    void ContinueString_Pointer(const void* ptr);
+    void EndString(const char* pStr = VMA_NULL);
+
+    void WriteNumber(uint32_t n);
+    void WriteNumber(uint64_t n);
+    void WriteBool(bool b);
+    void WriteNull();
+
+private:
+    static const char* const INDENT;
+
+    enum COLLECTION_TYPE
+    {
+        COLLECTION_TYPE_OBJECT,
+        COLLECTION_TYPE_ARRAY,
+    };
+    struct StackItem
+    {
+        COLLECTION_TYPE type;
+        uint32_t valueCount;
+        bool singleLineMode;
+    };
+
+    VmaStringBuilder& m_SB;
+    VmaVector< StackItem, VmaStlAllocator<StackItem> > m_Stack;
+    bool m_InsideString;
+
+    void BeginValue(bool isString);
+    void WriteIndent(bool oneLess = false);
+};
+
+const char* const VmaJsonWriter::INDENT = "  ";
+
+VmaJsonWriter::VmaJsonWriter(const VkAllocationCallbacks* pAllocationCallbacks, VmaStringBuilder& sb) :
+    m_SB(sb),
+    m_Stack(VmaStlAllocator<StackItem>(pAllocationCallbacks)),
+    m_InsideString(false)
+{
+}
+
+VmaJsonWriter::~VmaJsonWriter()
+{
+    VMA_ASSERT(!m_InsideString);
+    VMA_ASSERT(m_Stack.empty());
+}
+
+void VmaJsonWriter::BeginObject(bool singleLine)
+{
+    VMA_ASSERT(!m_InsideString);
+
+    BeginValue(false);
+    m_SB.Add('{');
+
+    StackItem item;
+    item.type = COLLECTION_TYPE_OBJECT;
+    item.valueCount = 0;
+    item.singleLineMode = singleLine;
+    m_Stack.push_back(item);
+}
+
+void VmaJsonWriter::EndObject()
+{
+    VMA_ASSERT(!m_InsideString);
+
+    WriteIndent(true);
+    m_SB.Add('}');
+
+    VMA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_OBJECT);
+    m_Stack.pop_back();
+}
+
+void VmaJsonWriter::BeginArray(bool singleLine)
+{
+    VMA_ASSERT(!m_InsideString);
+
+    BeginValue(false);
+    m_SB.Add('[');
+
+    StackItem item;
+    item.type = COLLECTION_TYPE_ARRAY;
+    item.valueCount = 0;
+    item.singleLineMode = singleLine;
+    m_Stack.push_back(item);
+}
+
+void VmaJsonWriter::EndArray()
+{
+    VMA_ASSERT(!m_InsideString);
+
+    WriteIndent(true);
+    m_SB.Add(']');
+
+    VMA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_ARRAY);
+    m_Stack.pop_back();
+}
+
+void VmaJsonWriter::WriteString(const char* pStr)
+{
+    BeginString(pStr);
+    EndString();
+}
+
+void VmaJsonWriter::BeginString(const char* pStr)
+{
+    VMA_ASSERT(!m_InsideString);
+
+    BeginValue(true);
+    m_SB.Add('"');
+    m_InsideString = true;
+    if(pStr != VMA_NULL && pStr[0] != '\0')
+    {
+        ContinueString(pStr);
+    }
+}
+
+void VmaJsonWriter::ContinueString(const char* pStr)
+{
+    VMA_ASSERT(m_InsideString);
+
+    const size_t strLen = strlen(pStr);
+    for(size_t i = 0; i < strLen; ++i)
+    {
+        char ch = pStr[i];
+        if(ch == '\\')
+        {
+            m_SB.Add("\\\\");
+        }
+        else if(ch == '"')
+        {
+            m_SB.Add("\\\"");
+        }
+        else if(ch >= 32)
+        {
+            m_SB.Add(ch);
+        }
+        else switch(ch)
+        {
+        case '\b':
+            m_SB.Add("\\b");
+            break;
+        case '\f':
+            m_SB.Add("\\f");
+            break;
+        case '\n':
+            m_SB.Add("\\n");
+            break;
+        case '\r':
+            m_SB.Add("\\r");
+            break;
+        case '\t':
+            m_SB.Add("\\t");
+            break;
+        default:
+            VMA_ASSERT(0 && "Character not currently supported.");
+            break;
+        }
+    }
+}
+
+void VmaJsonWriter::ContinueString(uint32_t n)
+{
+    VMA_ASSERT(m_InsideString);
+    m_SB.AddNumber(n);
+}
+
+void VmaJsonWriter::ContinueString(uint64_t n)
+{
+    VMA_ASSERT(m_InsideString);
+    m_SB.AddNumber(n);
+}
+
+void VmaJsonWriter::ContinueString_Pointer(const void* ptr)
+{
+    VMA_ASSERT(m_InsideString);
+    m_SB.AddPointer(ptr);
+}
+
+void VmaJsonWriter::EndString(const char* pStr)
+{
+    VMA_ASSERT(m_InsideString);
+    if(pStr != VMA_NULL && pStr[0] != '\0')
+    {
+        ContinueString(pStr);
+    }
+    m_SB.Add('"');
+    m_InsideString = false;
+}
+
+void VmaJsonWriter::WriteNumber(uint32_t n)
+{
+    VMA_ASSERT(!m_InsideString);
+    BeginValue(false);
+    m_SB.AddNumber(n);
+}
+
+void VmaJsonWriter::WriteNumber(uint64_t n)
+{
+    VMA_ASSERT(!m_InsideString);
+    BeginValue(false);
+    m_SB.AddNumber(n);
+}
+
+void VmaJsonWriter::WriteBool(bool b)
+{
+    VMA_ASSERT(!m_InsideString);
+    BeginValue(false);
+    m_SB.Add(b ? "true" : "false");
+}
+
+void VmaJsonWriter::WriteNull()
+{
+    VMA_ASSERT(!m_InsideString);
+    BeginValue(false);
+    m_SB.Add("null");
+}
+
+void VmaJsonWriter::BeginValue(bool isString)
+{
+    if(!m_Stack.empty())
+    {
+        StackItem& currItem = m_Stack.back();
+        if(currItem.type == COLLECTION_TYPE_OBJECT &&
+            currItem.valueCount % 2 == 0)
+        {
+            VMA_ASSERT(isString);
+        }
+
+        if(currItem.type == COLLECTION_TYPE_OBJECT &&
+            currItem.valueCount % 2 != 0)
+        {
+            m_SB.Add(": ");
+        }
+        else if(currItem.valueCount > 0)
+        {
+            m_SB.Add(", ");
+            WriteIndent();
+        }
+        else
+        {
+            WriteIndent();
+        }
+        ++currItem.valueCount;
+    }
+}
+
+void VmaJsonWriter::WriteIndent(bool oneLess)
+{
+    if(!m_Stack.empty() && !m_Stack.back().singleLineMode)
+    {
+        m_SB.AddNewLine();
+
+        size_t count = m_Stack.size();
+        if(count > 0 && oneLess)
+        {
+            --count;
+        }
+        for(size_t i = 0; i < count; ++i)
+        {
+            m_SB.Add(INDENT);
+        }
+    }
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////
+
+void VmaAllocation_T::SetUserData(VmaAllocator hAllocator, void* pUserData)
+{
+    if(IsUserDataString())
+    {
+        VMA_ASSERT(pUserData == VMA_NULL || pUserData != m_pUserData);
+
+        FreeUserDataString(hAllocator);
+
+        if(pUserData != VMA_NULL)
+        {
+            m_pUserData = VmaCreateStringCopy(hAllocator->GetAllocationCallbacks(), (const char*)pUserData);
+        }
+    }
+    else
+    {
+        m_pUserData = pUserData;
+    }
+}
+
+void VmaAllocation_T::ChangeBlockAllocation(
+    VmaAllocator hAllocator,
+    VmaDeviceMemoryBlock* block,
+    VkDeviceSize offset)
+{
+    VMA_ASSERT(block != VMA_NULL);
+    VMA_ASSERT(m_Type == ALLOCATION_TYPE_BLOCK);
+
+    // Move mapping reference counter from old block to new block.
+    if(block != m_BlockAllocation.m_Block)
+    {
+        uint32_t mapRefCount = m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP;
+        if(IsPersistentMap())
+            ++mapRefCount;
+        m_BlockAllocation.m_Block->Unmap(hAllocator, mapRefCount);
+        block->Map(hAllocator, mapRefCount, VMA_NULL);
+    }
+
+    m_BlockAllocation.m_Block = block;
+    m_BlockAllocation.m_Offset = offset;
+}
+
+void VmaAllocation_T::ChangeOffset(VkDeviceSize newOffset)
+{
+    VMA_ASSERT(m_Type == ALLOCATION_TYPE_BLOCK);
+    m_BlockAllocation.m_Offset = newOffset;
+}
+
+VkDeviceSize VmaAllocation_T::GetOffset() const
+{
+    switch(m_Type)
+    {
+    case ALLOCATION_TYPE_BLOCK:
+        return m_BlockAllocation.m_Offset;
+    case ALLOCATION_TYPE_DEDICATED:
+        return 0;
+    default:
+        VMA_ASSERT(0);
+        return 0;
+    }
+}
+
+VkDeviceMemory VmaAllocation_T::GetMemory() const
+{
+    switch(m_Type)
+    {
+    case ALLOCATION_TYPE_BLOCK:
+        return m_BlockAllocation.m_Block->GetDeviceMemory();
+    case ALLOCATION_TYPE_DEDICATED:
+        return m_DedicatedAllocation.m_hMemory;
+    default:
+        VMA_ASSERT(0);
+        return VK_NULL_HANDLE;
+    }
+}
+
+void* VmaAllocation_T::GetMappedData() const
+{
+    switch(m_Type)
+    {
+    case ALLOCATION_TYPE_BLOCK:
+        if(m_MapCount != 0)
+        {
+            void* pBlockData = m_BlockAllocation.m_Block->GetMappedData();
+            VMA_ASSERT(pBlockData != VMA_NULL);
+            return (char*)pBlockData + m_BlockAllocation.m_Offset;
+        }
+        else
+        {
+            return VMA_NULL;
+        }
+        break;
+    case ALLOCATION_TYPE_DEDICATED:
+        VMA_ASSERT((m_DedicatedAllocation.m_pMappedData != VMA_NULL) == (m_MapCount != 0));
+        return m_DedicatedAllocation.m_pMappedData;
+    default:
+        VMA_ASSERT(0);
+        return VMA_NULL;
+    }
+}
+
+bool VmaAllocation_T::CanBecomeLost() const
+{
+    switch(m_Type)
+    {
+    case ALLOCATION_TYPE_BLOCK:
+        return m_BlockAllocation.m_CanBecomeLost;
+    case ALLOCATION_TYPE_DEDICATED:
+        return false;
+    default:
+        VMA_ASSERT(0);
+        return false;
+    }
+}
+
+bool VmaAllocation_T::MakeLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
+{
+    VMA_ASSERT(CanBecomeLost());
+
+    /*
+    Warning: This is a carefully designed algorithm.
+    Do not modify unless you really know what you're doing :)
+    */
+    uint32_t localLastUseFrameIndex = GetLastUseFrameIndex();
+    for(;;)
+    {
+        if(localLastUseFrameIndex == VMA_FRAME_INDEX_LOST)
+        {
+            VMA_ASSERT(0);
+            return false;
+        }
+        else if(localLastUseFrameIndex + frameInUseCount >= currentFrameIndex)
+        {
+            return false;
+        }
+        else // Last use time earlier than current time.
+        {
+            if(CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, VMA_FRAME_INDEX_LOST))
+            {
+                // Setting hAllocation.LastUseFrameIndex atomic to VMA_FRAME_INDEX_LOST is enough to mark it as LOST.
+                // Calling code just needs to unregister this allocation in owning VmaDeviceMemoryBlock.
+                return true;
+            }
+        }
+    }
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+// Correspond to values of enum VmaSuballocationType.
+static const char* VMA_SUBALLOCATION_TYPE_NAMES[] = {
+    "FREE",
+    "UNKNOWN",
+    "BUFFER",
+    "IMAGE_UNKNOWN",
+    "IMAGE_LINEAR",
+    "IMAGE_OPTIMAL",
+};
+
+void VmaAllocation_T::PrintParameters(class VmaJsonWriter& json) const
+{
+    json.WriteString("Type");
+    json.WriteString(VMA_SUBALLOCATION_TYPE_NAMES[m_SuballocationType]);
+
+    json.WriteString("Size");
+    json.WriteNumber(m_Size);
+
+    if(m_pUserData != VMA_NULL)
+    {
+        json.WriteString("UserData");
+        if(IsUserDataString())
+        {
+            json.WriteString((const char*)m_pUserData);
+        }
+        else
+        {
+            json.BeginString();
+            json.ContinueString_Pointer(m_pUserData);
+            json.EndString();
+        }
+    }
+
+    json.WriteString("CreationFrameIndex");
+    json.WriteNumber(m_CreationFrameIndex);
+
+    json.WriteString("LastUseFrameIndex");
+    json.WriteNumber(GetLastUseFrameIndex());
+
+    if(m_BufferImageUsage != 0)
+    {
+        json.WriteString("Usage");
+        json.WriteNumber(m_BufferImageUsage);
+    }
+}
+
+#endif
+
+void VmaAllocation_T::FreeUserDataString(VmaAllocator hAllocator)
+{
+    VMA_ASSERT(IsUserDataString());
+    VmaFreeString(hAllocator->GetAllocationCallbacks(), (char*)m_pUserData);
+    m_pUserData = VMA_NULL;
+}
+
+void VmaAllocation_T::BlockAllocMap()
+{
+    VMA_ASSERT(GetType() == ALLOCATION_TYPE_BLOCK);
+
+    if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) < 0x7F)
+    {
+        ++m_MapCount;
+    }
+    else
+    {
+        VMA_ASSERT(0 && "Allocation mapped too many times simultaneously.");
+    }
+}
+
+void VmaAllocation_T::BlockAllocUnmap()
+{
+    VMA_ASSERT(GetType() == ALLOCATION_TYPE_BLOCK);
+
+    if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) != 0)
+    {
+        --m_MapCount;
+    }
+    else
+    {
+        VMA_ASSERT(0 && "Unmapping allocation not previously mapped.");
+    }
+}
+
+VkResult VmaAllocation_T::DedicatedAllocMap(VmaAllocator hAllocator, void** ppData)
+{
+    VMA_ASSERT(GetType() == ALLOCATION_TYPE_DEDICATED);
+
+    if(m_MapCount != 0)
+    {
+        if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) < 0x7F)
+        {
+            VMA_ASSERT(m_DedicatedAllocation.m_pMappedData != VMA_NULL);
+            *ppData = m_DedicatedAllocation.m_pMappedData;
+            ++m_MapCount;
+            return VK_SUCCESS;
+        }
+        else
+        {
+            VMA_ASSERT(0 && "Dedicated allocation mapped too many times simultaneously.");
+            return VK_ERROR_MEMORY_MAP_FAILED;
+        }
+    }
+    else
+    {
+        VkResult result = (*hAllocator->GetVulkanFunctions().vkMapMemory)(
+            hAllocator->m_hDevice,
+            m_DedicatedAllocation.m_hMemory,
+            0, // offset
+            VK_WHOLE_SIZE,
+            0, // flags
+            ppData);
+        if(result == VK_SUCCESS)
+        {
+            m_DedicatedAllocation.m_pMappedData = *ppData;
+            m_MapCount = 1;
+        }
+        return result;
+    }
+}
+
+void VmaAllocation_T::DedicatedAllocUnmap(VmaAllocator hAllocator)
+{
+    VMA_ASSERT(GetType() == ALLOCATION_TYPE_DEDICATED);
+
+    if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) != 0)
+    {
+        --m_MapCount;
+        if(m_MapCount == 0)
+        {
+            m_DedicatedAllocation.m_pMappedData = VMA_NULL;
+            (*hAllocator->GetVulkanFunctions().vkUnmapMemory)(
+                hAllocator->m_hDevice,
+                m_DedicatedAllocation.m_hMemory);
+        }
+    }
+    else
+    {
+        VMA_ASSERT(0 && "Unmapping dedicated allocation not previously mapped.");
+    }
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+static void VmaPrintStatInfo(VmaJsonWriter& json, const VmaStatInfo& stat)
+{
+    json.BeginObject();
+
+    json.WriteString("Blocks");
+    json.WriteNumber(stat.blockCount);
+
+    json.WriteString("Allocations");
+    json.WriteNumber(stat.allocationCount);
+
+    json.WriteString("UnusedRanges");
+    json.WriteNumber(stat.unusedRangeCount);
+
+    json.WriteString("UsedBytes");
+    json.WriteNumber(stat.usedBytes);
+
+    json.WriteString("UnusedBytes");
+    json.WriteNumber(stat.unusedBytes);
+
+    if(stat.allocationCount > 1)
+    {
+        json.WriteString("AllocationSize");
+        json.BeginObject(true);
+        json.WriteString("Min");
+        json.WriteNumber(stat.allocationSizeMin);
+        json.WriteString("Avg");
+        json.WriteNumber(stat.allocationSizeAvg);
+        json.WriteString("Max");
+        json.WriteNumber(stat.allocationSizeMax);
+        json.EndObject();
+    }
+
+    if(stat.unusedRangeCount > 1)
+    {
+        json.WriteString("UnusedRangeSize");
+        json.BeginObject(true);
+        json.WriteString("Min");
+        json.WriteNumber(stat.unusedRangeSizeMin);
+        json.WriteString("Avg");
+        json.WriteNumber(stat.unusedRangeSizeAvg);
+        json.WriteString("Max");
+        json.WriteNumber(stat.unusedRangeSizeMax);
+        json.EndObject();
+    }
+
+    json.EndObject();
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+struct VmaSuballocationItemSizeLess
+{
+    bool operator()(
+        const VmaSuballocationList::iterator lhs,
+        const VmaSuballocationList::iterator rhs) const
+    {
+        return lhs->size < rhs->size;
+    }
+    bool operator()(
+        const VmaSuballocationList::iterator lhs,
+        VkDeviceSize rhsSize) const
+    {
+        return lhs->size < rhsSize;
+    }
+};
+
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaBlockMetadata
+
+VmaBlockMetadata::VmaBlockMetadata(VmaAllocator hAllocator) :
+    m_Size(0),
+    m_pAllocationCallbacks(hAllocator->GetAllocationCallbacks())
+{
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+void VmaBlockMetadata::PrintDetailedMap_Begin(class VmaJsonWriter& json,
+    VkDeviceSize unusedBytes,
+    size_t allocationCount,
+    size_t unusedRangeCount) const
+{
+    json.BeginObject();
+
+    json.WriteString("TotalBytes");
+    json.WriteNumber(GetSize());
+
+    json.WriteString("UnusedBytes");
+    json.WriteNumber(unusedBytes);
+
+    json.WriteString("Allocations");
+    json.WriteNumber((uint64_t)allocationCount);
+
+    json.WriteString("UnusedRanges");
+    json.WriteNumber((uint64_t)unusedRangeCount);
+
+    json.WriteString("Suballocations");
+    json.BeginArray();
+}
+
+void VmaBlockMetadata::PrintDetailedMap_Allocation(class VmaJsonWriter& json,
+    VkDeviceSize offset,
+    VmaAllocation hAllocation) const
+{
+    json.BeginObject(true);
+
+    json.WriteString("Offset");
+    json.WriteNumber(offset);
+
+    hAllocation->PrintParameters(json);
+
+    json.EndObject();
+}
+
+void VmaBlockMetadata::PrintDetailedMap_UnusedRange(class VmaJsonWriter& json,
+    VkDeviceSize offset,
+    VkDeviceSize size) const
+{
+    json.BeginObject(true);
+
+    json.WriteString("Offset");
+    json.WriteNumber(offset);
+
+    json.WriteString("Type");
+    json.WriteString(VMA_SUBALLOCATION_TYPE_NAMES[VMA_SUBALLOCATION_TYPE_FREE]);
+
+    json.WriteString("Size");
+    json.WriteNumber(size);
+
+    json.EndObject();
+}
+
+void VmaBlockMetadata::PrintDetailedMap_End(class VmaJsonWriter& json) const
+{
+    json.EndArray();
+    json.EndObject();
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaBlockMetadata_Generic
+
+VmaBlockMetadata_Generic::VmaBlockMetadata_Generic(VmaAllocator hAllocator) :
+    VmaBlockMetadata(hAllocator),
+    m_FreeCount(0),
+    m_SumFreeSize(0),
+    m_Suballocations(VmaStlAllocator<VmaSuballocation>(hAllocator->GetAllocationCallbacks())),
+    m_FreeSuballocationsBySize(VmaStlAllocator<VmaSuballocationList::iterator>(hAllocator->GetAllocationCallbacks()))
+{
+}
+
+VmaBlockMetadata_Generic::~VmaBlockMetadata_Generic()
+{
+}
+
+void VmaBlockMetadata_Generic::Init(VkDeviceSize size)
+{
+    VmaBlockMetadata::Init(size);
+
+    m_FreeCount = 1;
+    m_SumFreeSize = size;
+
+    VmaSuballocation suballoc = {};
+    suballoc.offset = 0;
+    suballoc.size = size;
+    suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+    suballoc.hAllocation = VK_NULL_HANDLE;
+
+    VMA_ASSERT(size > VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER);
+    m_Suballocations.push_back(suballoc);
+    VmaSuballocationList::iterator suballocItem = m_Suballocations.end();
+    --suballocItem;
+    m_FreeSuballocationsBySize.push_back(suballocItem);
+}
+
+bool VmaBlockMetadata_Generic::Validate() const
+{
+    VMA_VALIDATE(!m_Suballocations.empty());
+
+    // Expected offset of new suballocation as calculated from previous ones.
+    VkDeviceSize calculatedOffset = 0;
+    // Expected number of free suballocations as calculated from traversing their list.
+    uint32_t calculatedFreeCount = 0;
+    // Expected sum size of free suballocations as calculated from traversing their list.
+    VkDeviceSize calculatedSumFreeSize = 0;
+    // Expected number of free suballocations that should be registered in
+    // m_FreeSuballocationsBySize calculated from traversing their list.
+    size_t freeSuballocationsToRegister = 0;
+    // True if previous visited suballocation was free.
+    bool prevFree = false;
+
+    for(VmaSuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
+        suballocItem != m_Suballocations.cend();
+        ++suballocItem)
+    {
+        const VmaSuballocation& subAlloc = *suballocItem;
+
+        // Actual offset of this suballocation doesn't match expected one.
+        VMA_VALIDATE(subAlloc.offset == calculatedOffset);
+
+        const bool currFree = (subAlloc.type == VMA_SUBALLOCATION_TYPE_FREE);
+        // Two adjacent free suballocations are invalid. They should be merged.
+        VMA_VALIDATE(!prevFree || !currFree);
+
+        VMA_VALIDATE(currFree == (subAlloc.hAllocation == VK_NULL_HANDLE));
+
+        if(currFree)
+        {
+            calculatedSumFreeSize += subAlloc.size;
+            ++calculatedFreeCount;
+            if(subAlloc.size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
+            {
+                ++freeSuballocationsToRegister;
+            }
+
+            // Margin required between allocations - every free space must be at least that large.
+            VMA_VALIDATE(subAlloc.size >= VMA_DEBUG_MARGIN);
+        }
+        else
+        {
+            VMA_VALIDATE(subAlloc.hAllocation->GetOffset() == subAlloc.offset);
+            VMA_VALIDATE(subAlloc.hAllocation->GetSize() == subAlloc.size);
+
+            // Margin required between allocations - previous allocation must be free.
+            VMA_VALIDATE(VMA_DEBUG_MARGIN == 0 || prevFree);
+        }
+
+        calculatedOffset += subAlloc.size;
+        prevFree = currFree;
+    }
+
+    // Number of free suballocations registered in m_FreeSuballocationsBySize doesn't
+    // match expected one.
+    VMA_VALIDATE(m_FreeSuballocationsBySize.size() == freeSuballocationsToRegister);
+
+    VkDeviceSize lastSize = 0;
+    for(size_t i = 0; i < m_FreeSuballocationsBySize.size(); ++i)
+    {
+        VmaSuballocationList::iterator suballocItem = m_FreeSuballocationsBySize[i];
+
+        // Only free suballocations can be registered in m_FreeSuballocationsBySize.
+        VMA_VALIDATE(suballocItem->type == VMA_SUBALLOCATION_TYPE_FREE);
+        // They must be sorted by size ascending.
+        VMA_VALIDATE(suballocItem->size >= lastSize);
+
+        lastSize = suballocItem->size;
+    }
+
+    // Check if totals match calculacted values.
+    VMA_VALIDATE(ValidateFreeSuballocationList());
+    VMA_VALIDATE(calculatedOffset == GetSize());
+    VMA_VALIDATE(calculatedSumFreeSize == m_SumFreeSize);
+    VMA_VALIDATE(calculatedFreeCount == m_FreeCount);
+
+    return true;
+}
+
+VkDeviceSize VmaBlockMetadata_Generic::GetUnusedRangeSizeMax() const
+{
+    if(!m_FreeSuballocationsBySize.empty())
+    {
+        return m_FreeSuballocationsBySize.back()->size;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+bool VmaBlockMetadata_Generic::IsEmpty() const
+{
+    return (m_Suballocations.size() == 1) && (m_FreeCount == 1);
+}
+
+void VmaBlockMetadata_Generic::CalcAllocationStatInfo(VmaStatInfo& outInfo) const
+{
+    outInfo.blockCount = 1;
+
+    const uint32_t rangeCount = (uint32_t)m_Suballocations.size();
+    outInfo.allocationCount = rangeCount - m_FreeCount;
+    outInfo.unusedRangeCount = m_FreeCount;
+
+    outInfo.unusedBytes = m_SumFreeSize;
+    outInfo.usedBytes = GetSize() - outInfo.unusedBytes;
+
+    outInfo.allocationSizeMin = UINT64_MAX;
+    outInfo.allocationSizeMax = 0;
+    outInfo.unusedRangeSizeMin = UINT64_MAX;
+    outInfo.unusedRangeSizeMax = 0;
+
+    for(VmaSuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
+        suballocItem != m_Suballocations.cend();
+        ++suballocItem)
+    {
+        const VmaSuballocation& suballoc = *suballocItem;
+        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
+            outInfo.allocationSizeMax = VMA_MAX(outInfo.allocationSizeMax, suballoc.size);
+        }
+        else
+        {
+            outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, suballoc.size);
+            outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, suballoc.size);
+        }
+    }
+}
+
+void VmaBlockMetadata_Generic::AddPoolStats(VmaPoolStats& inoutStats) const
+{
+    const uint32_t rangeCount = (uint32_t)m_Suballocations.size();
+
+    inoutStats.size += GetSize();
+    inoutStats.unusedSize += m_SumFreeSize;
+    inoutStats.allocationCount += rangeCount - m_FreeCount;
+    inoutStats.unusedRangeCount += m_FreeCount;
+    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, GetUnusedRangeSizeMax());
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+void VmaBlockMetadata_Generic::PrintDetailedMap(class VmaJsonWriter& json) const
+{
+    PrintDetailedMap_Begin(json,
+        m_SumFreeSize, // unusedBytes
+        m_Suballocations.size() - (size_t)m_FreeCount, // allocationCount
+        m_FreeCount); // unusedRangeCount
+
+    size_t i = 0;
+    for(VmaSuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
+        suballocItem != m_Suballocations.cend();
+        ++suballocItem, ++i)
+    {
+        if(suballocItem->type == VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            PrintDetailedMap_UnusedRange(json, suballocItem->offset, suballocItem->size);
+        }
+        else
+        {
+            PrintDetailedMap_Allocation(json, suballocItem->offset, suballocItem->hAllocation);
+        }
+    }
+
+    PrintDetailedMap_End(json);
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+bool VmaBlockMetadata_Generic::CreateAllocationRequest(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VkDeviceSize bufferImageGranularity,
+    VkDeviceSize allocSize,
+    VkDeviceSize allocAlignment,
+    bool upperAddress,
+    VmaSuballocationType allocType,
+    bool canMakeOtherLost,
+    uint32_t strategy,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    VMA_ASSERT(allocSize > 0);
+    VMA_ASSERT(!upperAddress);
+    VMA_ASSERT(allocType != VMA_SUBALLOCATION_TYPE_FREE);
+    VMA_ASSERT(pAllocationRequest != VMA_NULL);
+    VMA_HEAVY_ASSERT(Validate());
+
+    pAllocationRequest->type = VmaAllocationRequestType::Normal;
+
+    // There is not enough total free space in this block to fullfill the request: Early return.
+    if(canMakeOtherLost == false &&
+        m_SumFreeSize < allocSize + 2 * VMA_DEBUG_MARGIN)
+    {
+        return false;
+    }
+
+    // New algorithm, efficiently searching freeSuballocationsBySize.
+    const size_t freeSuballocCount = m_FreeSuballocationsBySize.size();
+    if(freeSuballocCount > 0)
+    {
+        if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT)
+        {
+            // Find first free suballocation with size not less than allocSize + 2 * VMA_DEBUG_MARGIN.
+            VmaSuballocationList::iterator* const it = VmaBinaryFindFirstNotLess(
+                m_FreeSuballocationsBySize.data(),
+                m_FreeSuballocationsBySize.data() + freeSuballocCount,
+                allocSize + 2 * VMA_DEBUG_MARGIN,
+                VmaSuballocationItemSizeLess());
+            size_t index = it - m_FreeSuballocationsBySize.data();
+            for(; index < freeSuballocCount; ++index)
+            {
+                if(CheckAllocation(
+                    currentFrameIndex,
+                    frameInUseCount,
+                    bufferImageGranularity,
+                    allocSize,
+                    allocAlignment,
+                    allocType,
+                    m_FreeSuballocationsBySize[index],
+                    false, // canMakeOtherLost
+                    &pAllocationRequest->offset,
+                    &pAllocationRequest->itemsToMakeLostCount,
+                    &pAllocationRequest->sumFreeSize,
+                    &pAllocationRequest->sumItemSize))
+                {
+                    pAllocationRequest->item = m_FreeSuballocationsBySize[index];
+                    return true;
+                }
+            }
+        }
+        else if(strategy == VMA_ALLOCATION_INTERNAL_STRATEGY_MIN_OFFSET)
+        {
+            for(VmaSuballocationList::iterator it = m_Suballocations.begin();
+                it != m_Suballocations.end();
+                ++it)
+            {
+                if(it->type == VMA_SUBALLOCATION_TYPE_FREE && CheckAllocation(
+                    currentFrameIndex,
+                    frameInUseCount,
+                    bufferImageGranularity,
+                    allocSize,
+                    allocAlignment,
+                    allocType,
+                    it,
+                    false, // canMakeOtherLost
+                    &pAllocationRequest->offset,
+                    &pAllocationRequest->itemsToMakeLostCount,
+                    &pAllocationRequest->sumFreeSize,
+                    &pAllocationRequest->sumItemSize))
+                {
+                    pAllocationRequest->item = it;
+                    return true;
+                }
+            }
+        }
+        else // WORST_FIT, FIRST_FIT
+        {
+            // Search staring from biggest suballocations.
+            for(size_t index = freeSuballocCount; index--; )
+            {
+                if(CheckAllocation(
+                    currentFrameIndex,
+                    frameInUseCount,
+                    bufferImageGranularity,
+                    allocSize,
+                    allocAlignment,
+                    allocType,
+                    m_FreeSuballocationsBySize[index],
+                    false, // canMakeOtherLost
+                    &pAllocationRequest->offset,
+                    &pAllocationRequest->itemsToMakeLostCount,
+                    &pAllocationRequest->sumFreeSize,
+                    &pAllocationRequest->sumItemSize))
+                {
+                    pAllocationRequest->item = m_FreeSuballocationsBySize[index];
+                    return true;
+                }
+            }
+        }
+    }
+
+    if(canMakeOtherLost)
+    {
+        // Brute-force algorithm. TODO: Come up with something better.
+
+        bool found = false;
+        VmaAllocationRequest tmpAllocRequest = {};
+        tmpAllocRequest.type = VmaAllocationRequestType::Normal;
+        for(VmaSuballocationList::iterator suballocIt = m_Suballocations.begin();
+            suballocIt != m_Suballocations.end();
+            ++suballocIt)
+        {
+            if(suballocIt->type == VMA_SUBALLOCATION_TYPE_FREE ||
+                suballocIt->hAllocation->CanBecomeLost())
+            {
+                if(CheckAllocation(
+                    currentFrameIndex,
+                    frameInUseCount,
+                    bufferImageGranularity,
+                    allocSize,
+                    allocAlignment,
+                    allocType,
+                    suballocIt,
+                    canMakeOtherLost,
+                    &tmpAllocRequest.offset,
+                    &tmpAllocRequest.itemsToMakeLostCount,
+                    &tmpAllocRequest.sumFreeSize,
+                    &tmpAllocRequest.sumItemSize))
+                {
+                    if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT)
+                    {
+                        *pAllocationRequest = tmpAllocRequest;
+                        pAllocationRequest->item = suballocIt;
+                        break;
+                    }
+                    if(!found || tmpAllocRequest.CalcCost() < pAllocationRequest->CalcCost())
+                    {
+                        *pAllocationRequest = tmpAllocRequest;
+                        pAllocationRequest->item = suballocIt;
+                        found = true;
+                    }
+                }
+            }
+        }
+
+        return found;
+    }
+
+    return false;
+}
+
+bool VmaBlockMetadata_Generic::MakeRequestedAllocationsLost(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    VMA_ASSERT(pAllocationRequest && pAllocationRequest->type == VmaAllocationRequestType::Normal);
+
+    while(pAllocationRequest->itemsToMakeLostCount > 0)
+    {
+        if(pAllocationRequest->item->type == VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            ++pAllocationRequest->item;
+        }
+        VMA_ASSERT(pAllocationRequest->item != m_Suballocations.end());
+        VMA_ASSERT(pAllocationRequest->item->hAllocation != VK_NULL_HANDLE);
+        VMA_ASSERT(pAllocationRequest->item->hAllocation->CanBecomeLost());
+        if(pAllocationRequest->item->hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
+        {
+            pAllocationRequest->item = FreeSuballocation(pAllocationRequest->item);
+            --pAllocationRequest->itemsToMakeLostCount;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    VMA_HEAVY_ASSERT(Validate());
+    VMA_ASSERT(pAllocationRequest->item != m_Suballocations.end());
+    VMA_ASSERT(pAllocationRequest->item->type == VMA_SUBALLOCATION_TYPE_FREE);
+
+    return true;
+}
+
+uint32_t VmaBlockMetadata_Generic::MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
+{
+    uint32_t lostAllocationCount = 0;
+    for(VmaSuballocationList::iterator it = m_Suballocations.begin();
+        it != m_Suballocations.end();
+        ++it)
+    {
+        if(it->type != VMA_SUBALLOCATION_TYPE_FREE &&
+            it->hAllocation->CanBecomeLost() &&
+            it->hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
+        {
+            it = FreeSuballocation(it);
+            ++lostAllocationCount;
+        }
+    }
+    return lostAllocationCount;
+}
+
+VkResult VmaBlockMetadata_Generic::CheckCorruption(const void* pBlockData)
+{
+    for(VmaSuballocationList::iterator it = m_Suballocations.begin();
+        it != m_Suballocations.end();
+        ++it)
+    {
+        if(it->type != VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            if(!VmaValidateMagicValue(pBlockData, it->offset - VMA_DEBUG_MARGIN))
+            {
+                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE VALIDATED ALLOCATION!");
+                return VK_ERROR_VALIDATION_FAILED_EXT;
+            }
+            if(!VmaValidateMagicValue(pBlockData, it->offset + it->size))
+            {
+                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER VALIDATED ALLOCATION!");
+                return VK_ERROR_VALIDATION_FAILED_EXT;
+            }
+        }
+    }
+
+    return VK_SUCCESS;
+}
+
+void VmaBlockMetadata_Generic::Alloc(
+    const VmaAllocationRequest& request,
+    VmaSuballocationType type,
+    VkDeviceSize allocSize,
+    VmaAllocation hAllocation)
+{
+    VMA_ASSERT(request.type == VmaAllocationRequestType::Normal);
+    VMA_ASSERT(request.item != m_Suballocations.end());
+    VmaSuballocation& suballoc = *request.item;
+    // Given suballocation is a free block.
+    VMA_ASSERT(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);
+    // Given offset is inside this suballocation.
+    VMA_ASSERT(request.offset >= suballoc.offset);
+    const VkDeviceSize paddingBegin = request.offset - suballoc.offset;
+    VMA_ASSERT(suballoc.size >= paddingBegin + allocSize);
+    const VkDeviceSize paddingEnd = suballoc.size - paddingBegin - allocSize;
+
+    // Unregister this free suballocation from m_FreeSuballocationsBySize and update
+    // it to become used.
+    UnregisterFreeSuballocation(request.item);
+
+    suballoc.offset = request.offset;
+    suballoc.size = allocSize;
+    suballoc.type = type;
+    suballoc.hAllocation = hAllocation;
+
+    // If there are any free bytes remaining at the end, insert new free suballocation after current one.
+    if(paddingEnd)
+    {
+        VmaSuballocation paddingSuballoc = {};
+        paddingSuballoc.offset = request.offset + allocSize;
+        paddingSuballoc.size = paddingEnd;
+        paddingSuballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+        VmaSuballocationList::iterator next = request.item;
+        ++next;
+        const VmaSuballocationList::iterator paddingEndItem =
+            m_Suballocations.insert(next, paddingSuballoc);
+        RegisterFreeSuballocation(paddingEndItem);
+    }
+
+    // If there are any free bytes remaining at the beginning, insert new free suballocation before current one.
+    if(paddingBegin)
+    {
+        VmaSuballocation paddingSuballoc = {};
+        paddingSuballoc.offset = request.offset - paddingBegin;
+        paddingSuballoc.size = paddingBegin;
+        paddingSuballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+        const VmaSuballocationList::iterator paddingBeginItem =
+            m_Suballocations.insert(request.item, paddingSuballoc);
+        RegisterFreeSuballocation(paddingBeginItem);
+    }
+
+    // Update totals.
+    m_FreeCount = m_FreeCount - 1;
+    if(paddingBegin > 0)
+    {
+        ++m_FreeCount;
+    }
+    if(paddingEnd > 0)
+    {
+        ++m_FreeCount;
+    }
+    m_SumFreeSize -= allocSize;
+}
+
+void VmaBlockMetadata_Generic::Free(const VmaAllocation allocation)
+{
+    for(VmaSuballocationList::iterator suballocItem = m_Suballocations.begin();
+        suballocItem != m_Suballocations.end();
+        ++suballocItem)
+    {
+        VmaSuballocation& suballoc = *suballocItem;
+        if(suballoc.hAllocation == allocation)
+        {
+            FreeSuballocation(suballocItem);
+            VMA_HEAVY_ASSERT(Validate());
+            return;
+        }
+    }
+    VMA_ASSERT(0 && "Not found!");
+}
+
+void VmaBlockMetadata_Generic::FreeAtOffset(VkDeviceSize offset)
+{
+    for(VmaSuballocationList::iterator suballocItem = m_Suballocations.begin();
+        suballocItem != m_Suballocations.end();
+        ++suballocItem)
+    {
+        VmaSuballocation& suballoc = *suballocItem;
+        if(suballoc.offset == offset)
+        {
+            FreeSuballocation(suballocItem);
+            return;
+        }
+    }
+    VMA_ASSERT(0 && "Not found!");
+}
+
+bool VmaBlockMetadata_Generic::ValidateFreeSuballocationList() const
+{
+    VkDeviceSize lastSize = 0;
+    for(size_t i = 0, count = m_FreeSuballocationsBySize.size(); i < count; ++i)
+    {
+        const VmaSuballocationList::iterator it = m_FreeSuballocationsBySize[i];
+
+        VMA_VALIDATE(it->type == VMA_SUBALLOCATION_TYPE_FREE);
+        VMA_VALIDATE(it->size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER);
+        VMA_VALIDATE(it->size >= lastSize);
+        lastSize = it->size;
+    }
+    return true;
+}
+
+bool VmaBlockMetadata_Generic::CheckAllocation(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VkDeviceSize bufferImageGranularity,
+    VkDeviceSize allocSize,
+    VkDeviceSize allocAlignment,
+    VmaSuballocationType allocType,
+    VmaSuballocationList::const_iterator suballocItem,
+    bool canMakeOtherLost,
+    VkDeviceSize* pOffset,
+    size_t* itemsToMakeLostCount,
+    VkDeviceSize* pSumFreeSize,
+    VkDeviceSize* pSumItemSize) const
+{
+    VMA_ASSERT(allocSize > 0);
+    VMA_ASSERT(allocType != VMA_SUBALLOCATION_TYPE_FREE);
+    VMA_ASSERT(suballocItem != m_Suballocations.cend());
+    VMA_ASSERT(pOffset != VMA_NULL);
+
+    *itemsToMakeLostCount = 0;
+    *pSumFreeSize = 0;
+    *pSumItemSize = 0;
+
+    if(canMakeOtherLost)
+    {
+        if(suballocItem->type == VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            *pSumFreeSize = suballocItem->size;
+        }
+        else
+        {
+            if(suballocItem->hAllocation->CanBecomeLost() &&
+                suballocItem->hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
+            {
+                ++*itemsToMakeLostCount;
+                *pSumItemSize = suballocItem->size;
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        // Remaining size is too small for this request: Early return.
+        if(GetSize() - suballocItem->offset < allocSize)
+        {
+            return false;
+        }
+
+        // Start from offset equal to beginning of this suballocation.
+        *pOffset = suballocItem->offset;
+
+        // Apply VMA_DEBUG_MARGIN at the beginning.
+        if(VMA_DEBUG_MARGIN > 0)
+        {
+            *pOffset += VMA_DEBUG_MARGIN;
+        }
+
+        // Apply alignment.
+        *pOffset = VmaAlignUp(*pOffset, allocAlignment);
+
+        // Check previous suballocations for BufferImageGranularity conflicts.
+        // Make bigger alignment if necessary.
+        if(bufferImageGranularity > 1)
+        {
+            bool bufferImageGranularityConflict = false;
+            VmaSuballocationList::const_iterator prevSuballocItem = suballocItem;
+            while(prevSuballocItem != m_Suballocations.cbegin())
+            {
+                --prevSuballocItem;
+                const VmaSuballocation& prevSuballoc = *prevSuballocItem;
+                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, *pOffset, bufferImageGranularity))
+                {
+                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
+                    {
+                        bufferImageGranularityConflict = true;
+                        break;
+                    }
+                }
+                else
+                    // Already on previous page.
+                    break;
+            }
+            if(bufferImageGranularityConflict)
+            {
+                *pOffset = VmaAlignUp(*pOffset, bufferImageGranularity);
+            }
+        }
+
+        // Now that we have final *pOffset, check if we are past suballocItem.
+        // If yes, return false - this function should be called for another suballocItem as starting point.
+        if(*pOffset >= suballocItem->offset + suballocItem->size)
+        {
+            return false;
+        }
+
+        // Calculate padding at the beginning based on current offset.
+        const VkDeviceSize paddingBegin = *pOffset - suballocItem->offset;
+
+        // Calculate required margin at the end.
+        const VkDeviceSize requiredEndMargin = VMA_DEBUG_MARGIN;
+
+        const VkDeviceSize totalSize = paddingBegin + allocSize + requiredEndMargin;
+        // Another early return check.
+        if(suballocItem->offset + totalSize > GetSize())
+        {
+            return false;
+        }
+
+        // Advance lastSuballocItem until desired size is reached.
+        // Update itemsToMakeLostCount.
+        VmaSuballocationList::const_iterator lastSuballocItem = suballocItem;
+        if(totalSize > suballocItem->size)
+        {
+            VkDeviceSize remainingSize = totalSize - suballocItem->size;
+            while(remainingSize > 0)
+            {
+                ++lastSuballocItem;
+                if(lastSuballocItem == m_Suballocations.cend())
+                {
+                    return false;
+                }
+                if(lastSuballocItem->type == VMA_SUBALLOCATION_TYPE_FREE)
+                {
+                    *pSumFreeSize += lastSuballocItem->size;
+                }
+                else
+                {
+                    VMA_ASSERT(lastSuballocItem->hAllocation != VK_NULL_HANDLE);
+                    if(lastSuballocItem->hAllocation->CanBecomeLost() &&
+                        lastSuballocItem->hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
+                    {
+                        ++*itemsToMakeLostCount;
+                        *pSumItemSize += lastSuballocItem->size;
+                    }
+                    else
+                    {
+                        return false;
+                    }
+                }
+                remainingSize = (lastSuballocItem->size < remainingSize) ?
+                    remainingSize - lastSuballocItem->size : 0;
+            }
+        }
+
+        // Check next suballocations for BufferImageGranularity conflicts.
+        // If conflict exists, we must mark more allocations lost or fail.
+        if(bufferImageGranularity > 1)
+        {
+            VmaSuballocationList::const_iterator nextSuballocItem = lastSuballocItem;
+            ++nextSuballocItem;
+            while(nextSuballocItem != m_Suballocations.cend())
+            {
+                const VmaSuballocation& nextSuballoc = *nextSuballocItem;
+                if(VmaBlocksOnSamePage(*pOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
+                {
+                    if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
+                    {
+                        VMA_ASSERT(nextSuballoc.hAllocation != VK_NULL_HANDLE);
+                        if(nextSuballoc.hAllocation->CanBecomeLost() &&
+                            nextSuballoc.hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
+                        {
+                            ++*itemsToMakeLostCount;
+                        }
+                        else
+                        {
+                            return false;
+                        }
+                    }
+                }
+                else
+                {
+                    // Already on next page.
+                    break;
+                }
+                ++nextSuballocItem;
+            }
+        }
+    }
+    else
+    {
+        const VmaSuballocation& suballoc = *suballocItem;
+        VMA_ASSERT(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);
+
+        *pSumFreeSize = suballoc.size;
+
+        // Size of this suballocation is too small for this request: Early return.
+        if(suballoc.size < allocSize)
+        {
+            return false;
+        }
+
+        // Start from offset equal to beginning of this suballocation.
+        *pOffset = suballoc.offset;
+
+        // Apply VMA_DEBUG_MARGIN at the beginning.
+        if(VMA_DEBUG_MARGIN > 0)
+        {
+            *pOffset += VMA_DEBUG_MARGIN;
+        }
+
+        // Apply alignment.
+        *pOffset = VmaAlignUp(*pOffset, allocAlignment);
+
+        // Check previous suballocations for BufferImageGranularity conflicts.
+        // Make bigger alignment if necessary.
+        if(bufferImageGranularity > 1)
+        {
+            bool bufferImageGranularityConflict = false;
+            VmaSuballocationList::const_iterator prevSuballocItem = suballocItem;
+            while(prevSuballocItem != m_Suballocations.cbegin())
+            {
+                --prevSuballocItem;
+                const VmaSuballocation& prevSuballoc = *prevSuballocItem;
+                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, *pOffset, bufferImageGranularity))
+                {
+                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
+                    {
+                        bufferImageGranularityConflict = true;
+                        break;
+                    }
+                }
+                else
+                    // Already on previous page.
+                    break;
+            }
+            if(bufferImageGranularityConflict)
+            {
+                *pOffset = VmaAlignUp(*pOffset, bufferImageGranularity);
+            }
+        }
+
+        // Calculate padding at the beginning based on current offset.
+        const VkDeviceSize paddingBegin = *pOffset - suballoc.offset;
+
+        // Calculate required margin at the end.
+        const VkDeviceSize requiredEndMargin = VMA_DEBUG_MARGIN;
+
+        // Fail if requested size plus margin before and after is bigger than size of this suballocation.
+        if(paddingBegin + allocSize + requiredEndMargin > suballoc.size)
+        {
+            return false;
+        }
+
+        // Check next suballocations for BufferImageGranularity conflicts.
+        // If conflict exists, allocation cannot be made here.
+        if(bufferImageGranularity > 1)
+        {
+            VmaSuballocationList::const_iterator nextSuballocItem = suballocItem;
+            ++nextSuballocItem;
+            while(nextSuballocItem != m_Suballocations.cend())
+            {
+                const VmaSuballocation& nextSuballoc = *nextSuballocItem;
+                if(VmaBlocksOnSamePage(*pOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
+                {
+                    if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
+                    {
+                        return false;
+                    }
+                }
+                else
+                {
+                    // Already on next page.
+                    break;
+                }
+                ++nextSuballocItem;
+            }
+        }
+    }
+
+    // All tests passed: Success. pOffset is already filled.
+    return true;
+}
+
+void VmaBlockMetadata_Generic::MergeFreeWithNext(VmaSuballocationList::iterator item)
+{
+    VMA_ASSERT(item != m_Suballocations.end());
+    VMA_ASSERT(item->type == VMA_SUBALLOCATION_TYPE_FREE);
+
+    VmaSuballocationList::iterator nextItem = item;
+    ++nextItem;
+    VMA_ASSERT(nextItem != m_Suballocations.end());
+    VMA_ASSERT(nextItem->type == VMA_SUBALLOCATION_TYPE_FREE);
+
+    item->size += nextItem->size;
+    --m_FreeCount;
+    m_Suballocations.erase(nextItem);
+}
+
+VmaSuballocationList::iterator VmaBlockMetadata_Generic::FreeSuballocation(VmaSuballocationList::iterator suballocItem)
+{
+    // Change this suballocation to be marked as free.
+    VmaSuballocation& suballoc = *suballocItem;
+    suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+    suballoc.hAllocation = VK_NULL_HANDLE;
+
+    // Update totals.
+    ++m_FreeCount;
+    m_SumFreeSize += suballoc.size;
+
+    // Merge with previous and/or next suballocation if it's also free.
+    bool mergeWithNext = false;
+    bool mergeWithPrev = false;
+
+    VmaSuballocationList::iterator nextItem = suballocItem;
+    ++nextItem;
+    if((nextItem != m_Suballocations.end()) && (nextItem->type == VMA_SUBALLOCATION_TYPE_FREE))
+    {
+        mergeWithNext = true;
+    }
+
+    VmaSuballocationList::iterator prevItem = suballocItem;
+    if(suballocItem != m_Suballocations.begin())
+    {
+        --prevItem;
+        if(prevItem->type == VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            mergeWithPrev = true;
+        }
+    }
+
+    if(mergeWithNext)
+    {
+        UnregisterFreeSuballocation(nextItem);
+        MergeFreeWithNext(suballocItem);
+    }
+
+    if(mergeWithPrev)
+    {
+        UnregisterFreeSuballocation(prevItem);
+        MergeFreeWithNext(prevItem);
+        RegisterFreeSuballocation(prevItem);
+        return prevItem;
+    }
+    else
+    {
+        RegisterFreeSuballocation(suballocItem);
+        return suballocItem;
+    }
+}
+
+void VmaBlockMetadata_Generic::RegisterFreeSuballocation(VmaSuballocationList::iterator item)
+{
+    VMA_ASSERT(item->type == VMA_SUBALLOCATION_TYPE_FREE);
+    VMA_ASSERT(item->size > 0);
+
+    // You may want to enable this validation at the beginning or at the end of
+    // this function, depending on what do you want to check.
+    VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());
+
+    if(item->size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
+    {
+        if(m_FreeSuballocationsBySize.empty())
+        {
+            m_FreeSuballocationsBySize.push_back(item);
+        }
+        else
+        {
+            VmaVectorInsertSorted<VmaSuballocationItemSizeLess>(m_FreeSuballocationsBySize, item);
+        }
+    }
+
+    //VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());
+}
+
+
+void VmaBlockMetadata_Generic::UnregisterFreeSuballocation(VmaSuballocationList::iterator item)
+{
+    VMA_ASSERT(item->type == VMA_SUBALLOCATION_TYPE_FREE);
+    VMA_ASSERT(item->size > 0);
+
+    // You may want to enable this validation at the beginning or at the end of
+    // this function, depending on what do you want to check.
+    VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());
+
+    if(item->size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
+    {
+        VmaSuballocationList::iterator* const it = VmaBinaryFindFirstNotLess(
+            m_FreeSuballocationsBySize.data(),
+            m_FreeSuballocationsBySize.data() + m_FreeSuballocationsBySize.size(),
+            item,
+            VmaSuballocationItemSizeLess());
+        for(size_t index = it - m_FreeSuballocationsBySize.data();
+            index < m_FreeSuballocationsBySize.size();
+            ++index)
+        {
+            if(m_FreeSuballocationsBySize[index] == item)
+            {
+                VmaVectorRemove(m_FreeSuballocationsBySize, index);
+                return;
+            }
+            VMA_ASSERT((m_FreeSuballocationsBySize[index]->size == item->size) && "Not found.");
+        }
+        VMA_ASSERT(0 && "Not found.");
+    }
+
+    //VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());
+}
+
+bool VmaBlockMetadata_Generic::IsBufferImageGranularityConflictPossible(
+    VkDeviceSize bufferImageGranularity,
+    VmaSuballocationType& inOutPrevSuballocType) const
+{
+    if(bufferImageGranularity == 1 || IsEmpty())
+    {
+        return false;
+    }
+
+    VkDeviceSize minAlignment = VK_WHOLE_SIZE;
+    bool typeConflictFound = false;
+    for(VmaSuballocationList::const_iterator it = m_Suballocations.cbegin();
+        it != m_Suballocations.cend();
+        ++it)
+    {
+        const VmaSuballocationType suballocType = it->type;
+        if(suballocType != VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            minAlignment = VMA_MIN(minAlignment, it->hAllocation->GetAlignment());
+            if(VmaIsBufferImageGranularityConflict(inOutPrevSuballocType, suballocType))
+            {
+                typeConflictFound = true;
+            }
+            inOutPrevSuballocType = suballocType;
+        }
+    }
+
+    return typeConflictFound || minAlignment >= bufferImageGranularity;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaBlockMetadata_Linear
+
+VmaBlockMetadata_Linear::VmaBlockMetadata_Linear(VmaAllocator hAllocator) :
+    VmaBlockMetadata(hAllocator),
+    m_SumFreeSize(0),
+    m_Suballocations0(VmaStlAllocator<VmaSuballocation>(hAllocator->GetAllocationCallbacks())),
+    m_Suballocations1(VmaStlAllocator<VmaSuballocation>(hAllocator->GetAllocationCallbacks())),
+    m_1stVectorIndex(0),
+    m_2ndVectorMode(SECOND_VECTOR_EMPTY),
+    m_1stNullItemsBeginCount(0),
+    m_1stNullItemsMiddleCount(0),
+    m_2ndNullItemsCount(0)
+{
+}
+
+VmaBlockMetadata_Linear::~VmaBlockMetadata_Linear()
+{
+}
+
+void VmaBlockMetadata_Linear::Init(VkDeviceSize size)
+{
+    VmaBlockMetadata::Init(size);
+    m_SumFreeSize = size;
+}
+
+bool VmaBlockMetadata_Linear::Validate() const
+{
+    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+
+    VMA_VALIDATE(suballocations2nd.empty() == (m_2ndVectorMode == SECOND_VECTOR_EMPTY));
+    VMA_VALIDATE(!suballocations1st.empty() ||
+        suballocations2nd.empty() ||
+        m_2ndVectorMode != SECOND_VECTOR_RING_BUFFER);
+
+    if(!suballocations1st.empty())
+    {
+        // Null item at the beginning should be accounted into m_1stNullItemsBeginCount.
+        VMA_VALIDATE(suballocations1st[m_1stNullItemsBeginCount].hAllocation != VK_NULL_HANDLE);
+        // Null item at the end should be just pop_back().
+        VMA_VALIDATE(suballocations1st.back().hAllocation != VK_NULL_HANDLE);
+    }
+    if(!suballocations2nd.empty())
+    {
+        // Null item at the end should be just pop_back().
+        VMA_VALIDATE(suballocations2nd.back().hAllocation != VK_NULL_HANDLE);
+    }
+
+    VMA_VALIDATE(m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount <= suballocations1st.size());
+    VMA_VALIDATE(m_2ndNullItemsCount <= suballocations2nd.size());
+
+    VkDeviceSize sumUsedSize = 0;
+    const size_t suballoc1stCount = suballocations1st.size();
+    VkDeviceSize offset = VMA_DEBUG_MARGIN;
+
+    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+    {
+        const size_t suballoc2ndCount = suballocations2nd.size();
+        size_t nullItem2ndCount = 0;
+        for(size_t i = 0; i < suballoc2ndCount; ++i)
+        {
+            const VmaSuballocation& suballoc = suballocations2nd[i];
+            const bool currFree = (suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);
+
+            VMA_VALIDATE(currFree == (suballoc.hAllocation == VK_NULL_HANDLE));
+            VMA_VALIDATE(suballoc.offset >= offset);
+
+            if(!currFree)
+            {
+                VMA_VALIDATE(suballoc.hAllocation->GetOffset() == suballoc.offset);
+                VMA_VALIDATE(suballoc.hAllocation->GetSize() == suballoc.size);
+                sumUsedSize += suballoc.size;
+            }
+            else
+            {
+                ++nullItem2ndCount;
+            }
+
+            offset = suballoc.offset + suballoc.size + VMA_DEBUG_MARGIN;
+        }
+
+        VMA_VALIDATE(nullItem2ndCount == m_2ndNullItemsCount);
+    }
+
+    for(size_t i = 0; i < m_1stNullItemsBeginCount; ++i)
+    {
+        const VmaSuballocation& suballoc = suballocations1st[i];
+        VMA_VALIDATE(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE &&
+            suballoc.hAllocation == VK_NULL_HANDLE);
+    }
+
+    size_t nullItem1stCount = m_1stNullItemsBeginCount;
+
+    for(size_t i = m_1stNullItemsBeginCount; i < suballoc1stCount; ++i)
+    {
+        const VmaSuballocation& suballoc = suballocations1st[i];
+        const bool currFree = (suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);
+
+        VMA_VALIDATE(currFree == (suballoc.hAllocation == VK_NULL_HANDLE));
+        VMA_VALIDATE(suballoc.offset >= offset);
+        VMA_VALIDATE(i >= m_1stNullItemsBeginCount || currFree);
+
+        if(!currFree)
+        {
+            VMA_VALIDATE(suballoc.hAllocation->GetOffset() == suballoc.offset);
+            VMA_VALIDATE(suballoc.hAllocation->GetSize() == suballoc.size);
+            sumUsedSize += suballoc.size;
+        }
+        else
+        {
+            ++nullItem1stCount;
+        }
+
+        offset = suballoc.offset + suballoc.size + VMA_DEBUG_MARGIN;
+    }
+    VMA_VALIDATE(nullItem1stCount == m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount);
+
+    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+    {
+        const size_t suballoc2ndCount = suballocations2nd.size();
+        size_t nullItem2ndCount = 0;
+        for(size_t i = suballoc2ndCount; i--; )
+        {
+            const VmaSuballocation& suballoc = suballocations2nd[i];
+            const bool currFree = (suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);
+
+            VMA_VALIDATE(currFree == (suballoc.hAllocation == VK_NULL_HANDLE));
+            VMA_VALIDATE(suballoc.offset >= offset);
+
+            if(!currFree)
+            {
+                VMA_VALIDATE(suballoc.hAllocation->GetOffset() == suballoc.offset);
+                VMA_VALIDATE(suballoc.hAllocation->GetSize() == suballoc.size);
+                sumUsedSize += suballoc.size;
+            }
+            else
+            {
+                ++nullItem2ndCount;
+            }
+
+            offset = suballoc.offset + suballoc.size + VMA_DEBUG_MARGIN;
+        }
+
+        VMA_VALIDATE(nullItem2ndCount == m_2ndNullItemsCount);
+    }
+
+    VMA_VALIDATE(offset <= GetSize());
+    VMA_VALIDATE(m_SumFreeSize == GetSize() - sumUsedSize);
+
+    return true;
+}
+
+size_t VmaBlockMetadata_Linear::GetAllocationCount() const
+{
+    return AccessSuballocations1st().size() - (m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount) +
+        AccessSuballocations2nd().size() - m_2ndNullItemsCount;
+}
+
+VkDeviceSize VmaBlockMetadata_Linear::GetUnusedRangeSizeMax() const
+{
+    const VkDeviceSize size = GetSize();
+
+    /*
+    We don't consider gaps inside allocation vectors with freed allocations because
+    they are not suitable for reuse in linear allocator. We consider only space that
+    is available for new allocations.
+    */
+    if(IsEmpty())
+    {
+        return size;
+    }
+
+    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+
+    switch(m_2ndVectorMode)
+    {
+    case SECOND_VECTOR_EMPTY:
+        /*
+        Available space is after end of 1st, as well as before beginning of 1st (which
+        whould make it a ring buffer).
+        */
+        {
+            const size_t suballocations1stCount = suballocations1st.size();
+            VMA_ASSERT(suballocations1stCount > m_1stNullItemsBeginCount);
+            const VmaSuballocation& firstSuballoc = suballocations1st[m_1stNullItemsBeginCount];
+            const VmaSuballocation& lastSuballoc  = suballocations1st[suballocations1stCount - 1];
+            return VMA_MAX(
+                firstSuballoc.offset,
+                size - (lastSuballoc.offset + lastSuballoc.size));
+        }
+        break;
+
+    case SECOND_VECTOR_RING_BUFFER:
+        /*
+        Available space is only between end of 2nd and beginning of 1st.
+        */
+        {
+            const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+            const VmaSuballocation& lastSuballoc2nd = suballocations2nd.back();
+            const VmaSuballocation& firstSuballoc1st = suballocations1st[m_1stNullItemsBeginCount];
+            return firstSuballoc1st.offset - (lastSuballoc2nd.offset + lastSuballoc2nd.size);
+        }
+        break;
+
+    case SECOND_VECTOR_DOUBLE_STACK:
+        /*
+        Available space is only between end of 1st and top of 2nd.
+        */
+        {
+            const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+            const VmaSuballocation& topSuballoc2nd = suballocations2nd.back();
+            const VmaSuballocation& lastSuballoc1st = suballocations1st.back();
+            return topSuballoc2nd.offset - (lastSuballoc1st.offset + lastSuballoc1st.size);
+        }
+        break;
+
+    default:
+        VMA_ASSERT(0);
+        return 0;
+    }
+}
+
+void VmaBlockMetadata_Linear::CalcAllocationStatInfo(VmaStatInfo& outInfo) const
+{
+    const VkDeviceSize size = GetSize();
+    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+    const size_t suballoc1stCount = suballocations1st.size();
+    const size_t suballoc2ndCount = suballocations2nd.size();
+
+    outInfo.blockCount = 1;
+    outInfo.allocationCount = (uint32_t)GetAllocationCount();
+    outInfo.unusedRangeCount = 0;
+    outInfo.usedBytes = 0;
+    outInfo.allocationSizeMin = UINT64_MAX;
+    outInfo.allocationSizeMax = 0;
+    outInfo.unusedRangeSizeMin = UINT64_MAX;
+    outInfo.unusedRangeSizeMax = 0;
+
+    VkDeviceSize lastOffset = 0;
+
+    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+    {
+        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
+        size_t nextAlloc2ndIndex = 0;
+        while(lastOffset < freeSpace2ndTo1stEnd)
+        {
+            // Find next non-null allocation or move nextAllocIndex to the end.
+            while(nextAlloc2ndIndex < suballoc2ndCount &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                ++nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex < suballoc2ndCount)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                    ++outInfo.unusedRangeCount;
+                    outInfo.unusedBytes += unusedRangeSize;
+                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
+                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                outInfo.usedBytes += suballoc.size;
+                outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
+                outInfo.allocationSizeMax = VMA_MIN(outInfo.allocationSizeMax, suballoc.size);
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                ++nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                // There is free space from lastOffset to freeSpace2ndTo1stEnd.
+                if(lastOffset < freeSpace2ndTo1stEnd)
+                {
+                    const VkDeviceSize unusedRangeSize = freeSpace2ndTo1stEnd - lastOffset;
+                    ++outInfo.unusedRangeCount;
+                    outInfo.unusedBytes += unusedRangeSize;
+                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
+                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
+               }
+
+                // End of loop.
+                lastOffset = freeSpace2ndTo1stEnd;
+            }
+        }
+    }
+
+    size_t nextAlloc1stIndex = m_1stNullItemsBeginCount;
+    const VkDeviceSize freeSpace1stTo2ndEnd =
+        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ? suballocations2nd.back().offset : size;
+    while(lastOffset < freeSpace1stTo2ndEnd)
+    {
+        // Find next non-null allocation or move nextAllocIndex to the end.
+        while(nextAlloc1stIndex < suballoc1stCount &&
+            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
+        {
+            ++nextAlloc1stIndex;
+        }
+
+        // Found non-null allocation.
+        if(nextAlloc1stIndex < suballoc1stCount)
+        {
+            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
+
+            // 1. Process free space before this allocation.
+            if(lastOffset < suballoc.offset)
+            {
+                // There is free space from lastOffset to suballoc.offset.
+                const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                ++outInfo.unusedRangeCount;
+                outInfo.unusedBytes += unusedRangeSize;
+                outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
+                outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
+            }
+
+            // 2. Process this allocation.
+            // There is allocation with suballoc.offset, suballoc.size.
+            outInfo.usedBytes += suballoc.size;
+            outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
+            outInfo.allocationSizeMax = VMA_MIN(outInfo.allocationSizeMax, suballoc.size);
+
+            // 3. Prepare for next iteration.
+            lastOffset = suballoc.offset + suballoc.size;
+            ++nextAlloc1stIndex;
+        }
+        // We are at the end.
+        else
+        {
+            // There is free space from lastOffset to freeSpace1stTo2ndEnd.
+            if(lastOffset < freeSpace1stTo2ndEnd)
+            {
+                const VkDeviceSize unusedRangeSize = freeSpace1stTo2ndEnd - lastOffset;
+                ++outInfo.unusedRangeCount;
+                outInfo.unusedBytes += unusedRangeSize;
+                outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
+                outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
+           }
+
+            // End of loop.
+            lastOffset = freeSpace1stTo2ndEnd;
+        }
+    }
+
+    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+    {
+        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
+        while(lastOffset < size)
+        {
+            // Find next non-null allocation or move nextAllocIndex to the end.
+            while(nextAlloc2ndIndex != SIZE_MAX &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                --nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex != SIZE_MAX)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                    ++outInfo.unusedRangeCount;
+                    outInfo.unusedBytes += unusedRangeSize;
+                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
+                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                outInfo.usedBytes += suballoc.size;
+                outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
+                outInfo.allocationSizeMax = VMA_MIN(outInfo.allocationSizeMax, suballoc.size);
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                --nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                // There is free space from lastOffset to size.
+                if(lastOffset < size)
+                {
+                    const VkDeviceSize unusedRangeSize = size - lastOffset;
+                    ++outInfo.unusedRangeCount;
+                    outInfo.unusedBytes += unusedRangeSize;
+                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
+                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
+               }
+
+                // End of loop.
+                lastOffset = size;
+            }
+        }
+    }
+
+    outInfo.unusedBytes = size - outInfo.usedBytes;
+}
+
+void VmaBlockMetadata_Linear::AddPoolStats(VmaPoolStats& inoutStats) const
+{
+    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+    const VkDeviceSize size = GetSize();
+    const size_t suballoc1stCount = suballocations1st.size();
+    const size_t suballoc2ndCount = suballocations2nd.size();
+
+    inoutStats.size += size;
+
+    VkDeviceSize lastOffset = 0;
+
+    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+    {
+        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
+        size_t nextAlloc2ndIndex = m_1stNullItemsBeginCount;
+        while(lastOffset < freeSpace2ndTo1stEnd)
+        {
+            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
+            while(nextAlloc2ndIndex < suballoc2ndCount &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                ++nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex < suballoc2ndCount)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                    inoutStats.unusedSize += unusedRangeSize;
+                    ++inoutStats.unusedRangeCount;
+                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                ++inoutStats.allocationCount;
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                ++nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                if(lastOffset < freeSpace2ndTo1stEnd)
+                {
+                    // There is free space from lastOffset to freeSpace2ndTo1stEnd.
+                    const VkDeviceSize unusedRangeSize = freeSpace2ndTo1stEnd - lastOffset;
+                    inoutStats.unusedSize += unusedRangeSize;
+                    ++inoutStats.unusedRangeCount;
+                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
+                }
+
+                // End of loop.
+                lastOffset = freeSpace2ndTo1stEnd;
+            }
+        }
+    }
+
+    size_t nextAlloc1stIndex = m_1stNullItemsBeginCount;
+    const VkDeviceSize freeSpace1stTo2ndEnd =
+        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ? suballocations2nd.back().offset : size;
+    while(lastOffset < freeSpace1stTo2ndEnd)
+    {
+        // Find next non-null allocation or move nextAllocIndex to the end.
+        while(nextAlloc1stIndex < suballoc1stCount &&
+            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
+        {
+            ++nextAlloc1stIndex;
+        }
+
+        // Found non-null allocation.
+        if(nextAlloc1stIndex < suballoc1stCount)
+        {
+            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
+
+            // 1. Process free space before this allocation.
+            if(lastOffset < suballoc.offset)
+            {
+                // There is free space from lastOffset to suballoc.offset.
+                const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                inoutStats.unusedSize += unusedRangeSize;
+                ++inoutStats.unusedRangeCount;
+                inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
+            }
+
+            // 2. Process this allocation.
+            // There is allocation with suballoc.offset, suballoc.size.
+            ++inoutStats.allocationCount;
+
+            // 3. Prepare for next iteration.
+            lastOffset = suballoc.offset + suballoc.size;
+            ++nextAlloc1stIndex;
+        }
+        // We are at the end.
+        else
+        {
+            if(lastOffset < freeSpace1stTo2ndEnd)
+            {
+                // There is free space from lastOffset to freeSpace1stTo2ndEnd.
+                const VkDeviceSize unusedRangeSize = freeSpace1stTo2ndEnd - lastOffset;
+                inoutStats.unusedSize += unusedRangeSize;
+                ++inoutStats.unusedRangeCount;
+                inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
+            }
+
+            // End of loop.
+            lastOffset = freeSpace1stTo2ndEnd;
+        }
+    }
+
+    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+    {
+        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
+        while(lastOffset < size)
+        {
+            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
+            while(nextAlloc2ndIndex != SIZE_MAX &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                --nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex != SIZE_MAX)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                    inoutStats.unusedSize += unusedRangeSize;
+                    ++inoutStats.unusedRangeCount;
+                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                ++inoutStats.allocationCount;
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                --nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                if(lastOffset < size)
+                {
+                    // There is free space from lastOffset to size.
+                    const VkDeviceSize unusedRangeSize = size - lastOffset;
+                    inoutStats.unusedSize += unusedRangeSize;
+                    ++inoutStats.unusedRangeCount;
+                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
+                }
+
+                // End of loop.
+                lastOffset = size;
+            }
+        }
+    }
+}
+
+#if VMA_STATS_STRING_ENABLED
+void VmaBlockMetadata_Linear::PrintDetailedMap(class VmaJsonWriter& json) const
+{
+    const VkDeviceSize size = GetSize();
+    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+    const size_t suballoc1stCount = suballocations1st.size();
+    const size_t suballoc2ndCount = suballocations2nd.size();
+
+    // FIRST PASS
+
+    size_t unusedRangeCount = 0;
+    VkDeviceSize usedBytes = 0;
+
+    VkDeviceSize lastOffset = 0;
+
+    size_t alloc2ndCount = 0;
+    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+    {
+        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
+        size_t nextAlloc2ndIndex = 0;
+        while(lastOffset < freeSpace2ndTo1stEnd)
+        {
+            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
+            while(nextAlloc2ndIndex < suballoc2ndCount &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                ++nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex < suballoc2ndCount)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    ++unusedRangeCount;
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                ++alloc2ndCount;
+                usedBytes += suballoc.size;
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                ++nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                if(lastOffset < freeSpace2ndTo1stEnd)
+                {
+                    // There is free space from lastOffset to freeSpace2ndTo1stEnd.
+                    ++unusedRangeCount;
+                }
+
+                // End of loop.
+                lastOffset = freeSpace2ndTo1stEnd;
+            }
+        }
+    }
+
+    size_t nextAlloc1stIndex = m_1stNullItemsBeginCount;
+    size_t alloc1stCount = 0;
+    const VkDeviceSize freeSpace1stTo2ndEnd =
+        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ? suballocations2nd.back().offset : size;
+    while(lastOffset < freeSpace1stTo2ndEnd)
+    {
+        // Find next non-null allocation or move nextAllocIndex to the end.
+        while(nextAlloc1stIndex < suballoc1stCount &&
+            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
+        {
+            ++nextAlloc1stIndex;
+        }
+
+        // Found non-null allocation.
+        if(nextAlloc1stIndex < suballoc1stCount)
+        {
+            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
+
+            // 1. Process free space before this allocation.
+            if(lastOffset < suballoc.offset)
+            {
+                // There is free space from lastOffset to suballoc.offset.
+                ++unusedRangeCount;
+            }
+
+            // 2. Process this allocation.
+            // There is allocation with suballoc.offset, suballoc.size.
+            ++alloc1stCount;
+            usedBytes += suballoc.size;
+
+            // 3. Prepare for next iteration.
+            lastOffset = suballoc.offset + suballoc.size;
+            ++nextAlloc1stIndex;
+        }
+        // We are at the end.
+        else
+        {
+            if(lastOffset < size)
+            {
+                // There is free space from lastOffset to freeSpace1stTo2ndEnd.
+                ++unusedRangeCount;
+            }
+
+            // End of loop.
+            lastOffset = freeSpace1stTo2ndEnd;
+        }
+    }
+
+    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+    {
+        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
+        while(lastOffset < size)
+        {
+            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
+            while(nextAlloc2ndIndex != SIZE_MAX &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                --nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex != SIZE_MAX)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    ++unusedRangeCount;
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                ++alloc2ndCount;
+                usedBytes += suballoc.size;
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                --nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                if(lastOffset < size)
+                {
+                    // There is free space from lastOffset to size.
+                    ++unusedRangeCount;
+                }
+
+                // End of loop.
+                lastOffset = size;
+            }
+        }
+    }
+
+    const VkDeviceSize unusedBytes = size - usedBytes;
+    PrintDetailedMap_Begin(json, unusedBytes, alloc1stCount + alloc2ndCount, unusedRangeCount);
+
+    // SECOND PASS
+    lastOffset = 0;
+
+    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+    {
+        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
+        size_t nextAlloc2ndIndex = 0;
+        while(lastOffset < freeSpace2ndTo1stEnd)
+        {
+            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
+            while(nextAlloc2ndIndex < suballoc2ndCount &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                ++nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex < suballoc2ndCount)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                PrintDetailedMap_Allocation(json, suballoc.offset, suballoc.hAllocation);
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                ++nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                if(lastOffset < freeSpace2ndTo1stEnd)
+                {
+                    // There is free space from lastOffset to freeSpace2ndTo1stEnd.
+                    const VkDeviceSize unusedRangeSize = freeSpace2ndTo1stEnd - lastOffset;
+                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
+                }
+
+                // End of loop.
+                lastOffset = freeSpace2ndTo1stEnd;
+            }
+        }
+    }
+
+    nextAlloc1stIndex = m_1stNullItemsBeginCount;
+    while(lastOffset < freeSpace1stTo2ndEnd)
+    {
+        // Find next non-null allocation or move nextAllocIndex to the end.
+        while(nextAlloc1stIndex < suballoc1stCount &&
+            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
+        {
+            ++nextAlloc1stIndex;
+        }
+
+        // Found non-null allocation.
+        if(nextAlloc1stIndex < suballoc1stCount)
+        {
+            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
+
+            // 1. Process free space before this allocation.
+            if(lastOffset < suballoc.offset)
+            {
+                // There is free space from lastOffset to suballoc.offset.
+                const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
+            }
+
+            // 2. Process this allocation.
+            // There is allocation with suballoc.offset, suballoc.size.
+            PrintDetailedMap_Allocation(json, suballoc.offset, suballoc.hAllocation);
+
+            // 3. Prepare for next iteration.
+            lastOffset = suballoc.offset + suballoc.size;
+            ++nextAlloc1stIndex;
+        }
+        // We are at the end.
+        else
+        {
+            if(lastOffset < freeSpace1stTo2ndEnd)
+            {
+                // There is free space from lastOffset to freeSpace1stTo2ndEnd.
+                const VkDeviceSize unusedRangeSize = freeSpace1stTo2ndEnd - lastOffset;
+                PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
+            }
+
+            // End of loop.
+            lastOffset = freeSpace1stTo2ndEnd;
+        }
+    }
+
+    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+    {
+        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
+        while(lastOffset < size)
+        {
+            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
+            while(nextAlloc2ndIndex != SIZE_MAX &&
+                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
+            {
+                --nextAlloc2ndIndex;
+            }
+
+            // Found non-null allocation.
+            if(nextAlloc2ndIndex != SIZE_MAX)
+            {
+                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
+
+                // 1. Process free space before this allocation.
+                if(lastOffset < suballoc.offset)
+                {
+                    // There is free space from lastOffset to suballoc.offset.
+                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
+                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
+                }
+
+                // 2. Process this allocation.
+                // There is allocation with suballoc.offset, suballoc.size.
+                PrintDetailedMap_Allocation(json, suballoc.offset, suballoc.hAllocation);
+
+                // 3. Prepare for next iteration.
+                lastOffset = suballoc.offset + suballoc.size;
+                --nextAlloc2ndIndex;
+            }
+            // We are at the end.
+            else
+            {
+                if(lastOffset < size)
+                {
+                    // There is free space from lastOffset to size.
+                    const VkDeviceSize unusedRangeSize = size - lastOffset;
+                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
+                }
+
+                // End of loop.
+                lastOffset = size;
+            }
+        }
+    }
+
+    PrintDetailedMap_End(json);
+}
+#endif // #if VMA_STATS_STRING_ENABLED
+
+bool VmaBlockMetadata_Linear::CreateAllocationRequest(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VkDeviceSize bufferImageGranularity,
+    VkDeviceSize allocSize,
+    VkDeviceSize allocAlignment,
+    bool upperAddress,
+    VmaSuballocationType allocType,
+    bool canMakeOtherLost,
+    uint32_t strategy,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    VMA_ASSERT(allocSize > 0);
+    VMA_ASSERT(allocType != VMA_SUBALLOCATION_TYPE_FREE);
+    VMA_ASSERT(pAllocationRequest != VMA_NULL);
+    VMA_HEAVY_ASSERT(Validate());
+    return upperAddress ?
+        CreateAllocationRequest_UpperAddress(
+            currentFrameIndex, frameInUseCount, bufferImageGranularity,
+            allocSize, allocAlignment, allocType, canMakeOtherLost, strategy, pAllocationRequest) :
+        CreateAllocationRequest_LowerAddress(
+            currentFrameIndex, frameInUseCount, bufferImageGranularity,
+            allocSize, allocAlignment, allocType, canMakeOtherLost, strategy, pAllocationRequest);
+}
+
+bool VmaBlockMetadata_Linear::CreateAllocationRequest_UpperAddress(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VkDeviceSize bufferImageGranularity,
+    VkDeviceSize allocSize,
+    VkDeviceSize allocAlignment,
+    VmaSuballocationType allocType,
+    bool canMakeOtherLost,
+    uint32_t strategy,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    const VkDeviceSize size = GetSize();
+    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+
+    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+    {
+        VMA_ASSERT(0 && "Trying to use pool with linear algorithm as double stack, while it is already being used as ring buffer.");
+        return false;
+    }
+
+    // Try to allocate before 2nd.back(), or end of block if 2nd.empty().
+    if(allocSize > size)
+    {
+        return false;
+    }
+    VkDeviceSize resultBaseOffset = size - allocSize;
+    if(!suballocations2nd.empty())
+    {
+        const VmaSuballocation& lastSuballoc = suballocations2nd.back();
+        resultBaseOffset = lastSuballoc.offset - allocSize;
+        if(allocSize > lastSuballoc.offset)
+        {
+            return false;
+        }
+    }
+
+    // Start from offset equal to end of free space.
+    VkDeviceSize resultOffset = resultBaseOffset;
+
+    // Apply VMA_DEBUG_MARGIN at the end.
+    if(VMA_DEBUG_MARGIN > 0)
+    {
+        if(resultOffset < VMA_DEBUG_MARGIN)
+        {
+            return false;
+        }
+        resultOffset -= VMA_DEBUG_MARGIN;
+    }
+
+    // Apply alignment.
+    resultOffset = VmaAlignDown(resultOffset, allocAlignment);
+
+    // Check next suballocations from 2nd for BufferImageGranularity conflicts.
+    // Make bigger alignment if necessary.
+    if(bufferImageGranularity > 1 && !suballocations2nd.empty())
+    {
+        bool bufferImageGranularityConflict = false;
+        for(size_t nextSuballocIndex = suballocations2nd.size(); nextSuballocIndex--; )
+        {
+            const VmaSuballocation& nextSuballoc = suballocations2nd[nextSuballocIndex];
+            if(VmaBlocksOnSamePage(resultOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
+            {
+                if(VmaIsBufferImageGranularityConflict(nextSuballoc.type, allocType))
+                {
+                    bufferImageGranularityConflict = true;
+                    break;
+                }
+            }
+            else
+                // Already on previous page.
+                break;
+        }
+        if(bufferImageGranularityConflict)
+        {
+            resultOffset = VmaAlignDown(resultOffset, bufferImageGranularity);
+        }
+    }
+
+    // There is enough free space.
+    const VkDeviceSize endOf1st = !suballocations1st.empty() ?
+        suballocations1st.back().offset + suballocations1st.back().size :
+        0;
+    if(endOf1st + VMA_DEBUG_MARGIN <= resultOffset)
+    {
+        // Check previous suballocations for BufferImageGranularity conflicts.
+        // If conflict exists, allocation cannot be made here.
+        if(bufferImageGranularity > 1)
+        {
+            for(size_t prevSuballocIndex = suballocations1st.size(); prevSuballocIndex--; )
+            {
+                const VmaSuballocation& prevSuballoc = suballocations1st[prevSuballocIndex];
+                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, resultOffset, bufferImageGranularity))
+                {
+                    if(VmaIsBufferImageGranularityConflict(allocType, prevSuballoc.type))
+                    {
+                        return false;
+                    }
+                }
+                else
+                {
+                    // Already on next page.
+                    break;
+                }
+            }
+        }
+
+        // All tests passed: Success.
+        pAllocationRequest->offset = resultOffset;
+        pAllocationRequest->sumFreeSize = resultBaseOffset + allocSize - endOf1st;
+        pAllocationRequest->sumItemSize = 0;
+        // pAllocationRequest->item unused.
+        pAllocationRequest->itemsToMakeLostCount = 0;
+        pAllocationRequest->type = VmaAllocationRequestType::UpperAddress;
+        return true;
+    }
+
+    return false;
+}
+
+bool VmaBlockMetadata_Linear::CreateAllocationRequest_LowerAddress(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VkDeviceSize bufferImageGranularity,
+    VkDeviceSize allocSize,
+    VkDeviceSize allocAlignment,
+    VmaSuballocationType allocType,
+    bool canMakeOtherLost,
+    uint32_t strategy,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    const VkDeviceSize size = GetSize();
+    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+
+    if(m_2ndVectorMode == SECOND_VECTOR_EMPTY || m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+    {
+        // Try to allocate at the end of 1st vector.
+
+        VkDeviceSize resultBaseOffset = 0;
+        if(!suballocations1st.empty())
+        {
+            const VmaSuballocation& lastSuballoc = suballocations1st.back();
+            resultBaseOffset = lastSuballoc.offset + lastSuballoc.size;
+        }
+
+        // Start from offset equal to beginning of free space.
+        VkDeviceSize resultOffset = resultBaseOffset;
+
+        // Apply VMA_DEBUG_MARGIN at the beginning.
+        if(VMA_DEBUG_MARGIN > 0)
+        {
+            resultOffset += VMA_DEBUG_MARGIN;
+        }
+
+        // Apply alignment.
+        resultOffset = VmaAlignUp(resultOffset, allocAlignment);
+
+        // Check previous suballocations for BufferImageGranularity conflicts.
+        // Make bigger alignment if necessary.
+        if(bufferImageGranularity > 1 && !suballocations1st.empty())
+        {
+            bool bufferImageGranularityConflict = false;
+            for(size_t prevSuballocIndex = suballocations1st.size(); prevSuballocIndex--; )
+            {
+                const VmaSuballocation& prevSuballoc = suballocations1st[prevSuballocIndex];
+                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, resultOffset, bufferImageGranularity))
+                {
+                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
+                    {
+                        bufferImageGranularityConflict = true;
+                        break;
+                    }
+                }
+                else
+                    // Already on previous page.
+                    break;
+            }
+            if(bufferImageGranularityConflict)
+            {
+                resultOffset = VmaAlignUp(resultOffset, bufferImageGranularity);
+            }
+        }
+
+        const VkDeviceSize freeSpaceEnd = m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ?
+            suballocations2nd.back().offset : size;
+
+        // There is enough free space at the end after alignment.
+        if(resultOffset + allocSize + VMA_DEBUG_MARGIN <= freeSpaceEnd)
+        {
+            // Check next suballocations for BufferImageGranularity conflicts.
+            // If conflict exists, allocation cannot be made here.
+            if(bufferImageGranularity > 1 && m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+            {
+                for(size_t nextSuballocIndex = suballocations2nd.size(); nextSuballocIndex--; )
+                {
+                    const VmaSuballocation& nextSuballoc = suballocations2nd[nextSuballocIndex];
+                    if(VmaBlocksOnSamePage(resultOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
+                    {
+                        if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
+                        {
+                            return false;
+                        }
+                    }
+                    else
+                    {
+                        // Already on previous page.
+                        break;
+                    }
+                }
+            }
+
+            // All tests passed: Success.
+            pAllocationRequest->offset = resultOffset;
+            pAllocationRequest->sumFreeSize = freeSpaceEnd - resultBaseOffset;
+            pAllocationRequest->sumItemSize = 0;
+            // pAllocationRequest->item, customData unused.
+            pAllocationRequest->type = VmaAllocationRequestType::EndOf1st;
+            pAllocationRequest->itemsToMakeLostCount = 0;
+            return true;
+        }
+    }
+
+    // Wrap-around to end of 2nd vector. Try to allocate there, watching for the
+    // beginning of 1st vector as the end of free space.
+    if(m_2ndVectorMode == SECOND_VECTOR_EMPTY || m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+    {
+        VMA_ASSERT(!suballocations1st.empty());
+
+        VkDeviceSize resultBaseOffset = 0;
+        if(!suballocations2nd.empty())
+        {
+            const VmaSuballocation& lastSuballoc = suballocations2nd.back();
+            resultBaseOffset = lastSuballoc.offset + lastSuballoc.size;
+        }
+
+        // Start from offset equal to beginning of free space.
+        VkDeviceSize resultOffset = resultBaseOffset;
+
+        // Apply VMA_DEBUG_MARGIN at the beginning.
+        if(VMA_DEBUG_MARGIN > 0)
+        {
+            resultOffset += VMA_DEBUG_MARGIN;
+        }
+
+        // Apply alignment.
+        resultOffset = VmaAlignUp(resultOffset, allocAlignment);
+
+        // Check previous suballocations for BufferImageGranularity conflicts.
+        // Make bigger alignment if necessary.
+        if(bufferImageGranularity > 1 && !suballocations2nd.empty())
+        {
+            bool bufferImageGranularityConflict = false;
+            for(size_t prevSuballocIndex = suballocations2nd.size(); prevSuballocIndex--; )
+            {
+                const VmaSuballocation& prevSuballoc = suballocations2nd[prevSuballocIndex];
+                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, resultOffset, bufferImageGranularity))
+                {
+                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
+                    {
+                        bufferImageGranularityConflict = true;
+                        break;
+                    }
+                }
+                else
+                    // Already on previous page.
+                    break;
+            }
+            if(bufferImageGranularityConflict)
+            {
+                resultOffset = VmaAlignUp(resultOffset, bufferImageGranularity);
+            }
+        }
+
+        pAllocationRequest->itemsToMakeLostCount = 0;
+        pAllocationRequest->sumItemSize = 0;
+        size_t index1st = m_1stNullItemsBeginCount;
+
+        if(canMakeOtherLost)
+        {
+            while(index1st < suballocations1st.size() &&
+                resultOffset + allocSize + VMA_DEBUG_MARGIN > suballocations1st[index1st].offset)
+            {
+                // Next colliding allocation at the beginning of 1st vector found. Try to make it lost.
+                const VmaSuballocation& suballoc = suballocations1st[index1st];
+                if(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE)
+                {
+                    // No problem.
+                }
+                else
+                {
+                    VMA_ASSERT(suballoc.hAllocation != VK_NULL_HANDLE);
+                    if(suballoc.hAllocation->CanBecomeLost() &&
+                        suballoc.hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
+                    {
+                        ++pAllocationRequest->itemsToMakeLostCount;
+                        pAllocationRequest->sumItemSize += suballoc.size;
+                    }
+                    else
+                    {
+                        return false;
+                    }
+                }
+                ++index1st;
+            }
+
+            // Check next suballocations for BufferImageGranularity conflicts.
+            // If conflict exists, we must mark more allocations lost or fail.
+            if(bufferImageGranularity > 1)
+            {
+                while(index1st < suballocations1st.size())
+                {
+                    const VmaSuballocation& suballoc = suballocations1st[index1st];
+                    if(VmaBlocksOnSamePage(resultOffset, allocSize, suballoc.offset, bufferImageGranularity))
+                    {
+                        if(suballoc.hAllocation != VK_NULL_HANDLE)
+                        {
+                            // Not checking actual VmaIsBufferImageGranularityConflict(allocType, suballoc.type).
+                            if(suballoc.hAllocation->CanBecomeLost() &&
+                                suballoc.hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
+                            {
+                                ++pAllocationRequest->itemsToMakeLostCount;
+                                pAllocationRequest->sumItemSize += suballoc.size;
+                            }
+                            else
+                            {
+                                return false;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        // Already on next page.
+                        break;
+                    }
+                    ++index1st;
+                }
+            }
+
+            // Special case: There is not enough room at the end for this allocation, even after making all from the 1st lost.
+            if(index1st == suballocations1st.size() &&
+                resultOffset + allocSize + VMA_DEBUG_MARGIN > size)
+            {
+                // TODO: This is a known bug that it's not yet implemented and the allocation is failing.
+                VMA_DEBUG_LOG("Unsupported special case in custom pool with linear allocation algorithm used as ring buffer with allocations that can be lost.");
+            }
+        }
+
+        // There is enough free space at the end after alignment.
+        if((index1st == suballocations1st.size() && resultOffset + allocSize + VMA_DEBUG_MARGIN <= size) ||
+            (index1st < suballocations1st.size() && resultOffset + allocSize + VMA_DEBUG_MARGIN <= suballocations1st[index1st].offset))
+        {
+            // Check next suballocations for BufferImageGranularity conflicts.
+            // If conflict exists, allocation cannot be made here.
+            if(bufferImageGranularity > 1)
+            {
+                for(size_t nextSuballocIndex = index1st;
+                    nextSuballocIndex < suballocations1st.size();
+                    nextSuballocIndex++)
+                {
+                    const VmaSuballocation& nextSuballoc = suballocations1st[nextSuballocIndex];
+                    if(VmaBlocksOnSamePage(resultOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
+                    {
+                        if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
+                        {
+                            return false;
+                        }
+                    }
+                    else
+                    {
+                        // Already on next page.
+                        break;
+                    }
+                }
+            }
+
+            // All tests passed: Success.
+            pAllocationRequest->offset = resultOffset;
+            pAllocationRequest->sumFreeSize =
+                (index1st < suballocations1st.size() ? suballocations1st[index1st].offset : size)
+                - resultBaseOffset
+                - pAllocationRequest->sumItemSize;
+            pAllocationRequest->type = VmaAllocationRequestType::EndOf2nd;
+            // pAllocationRequest->item, customData unused.
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool VmaBlockMetadata_Linear::MakeRequestedAllocationsLost(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    if(pAllocationRequest->itemsToMakeLostCount == 0)
+    {
+        return true;
+    }
+
+    VMA_ASSERT(m_2ndVectorMode == SECOND_VECTOR_EMPTY || m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER);
+
+    // We always start from 1st.
+    SuballocationVectorType* suballocations = &AccessSuballocations1st();
+    size_t index = m_1stNullItemsBeginCount;
+    size_t madeLostCount = 0;
+    while(madeLostCount < pAllocationRequest->itemsToMakeLostCount)
+    {
+        if(index == suballocations->size())
+        {
+            index = 0;
+            // If we get to the end of 1st, we wrap around to beginning of 2nd of 1st.
+            if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+            {
+                suballocations = &AccessSuballocations2nd();
+            }
+            // else: m_2ndVectorMode == SECOND_VECTOR_EMPTY:
+            // suballocations continues pointing at AccessSuballocations1st().
+            VMA_ASSERT(!suballocations->empty());
+        }
+        VmaSuballocation& suballoc = (*suballocations)[index];
+        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            VMA_ASSERT(suballoc.hAllocation != VK_NULL_HANDLE);
+            VMA_ASSERT(suballoc.hAllocation->CanBecomeLost());
+            if(suballoc.hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
+            {
+                suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+                suballoc.hAllocation = VK_NULL_HANDLE;
+                m_SumFreeSize += suballoc.size;
+                if(suballocations == &AccessSuballocations1st())
+                {
+                    ++m_1stNullItemsMiddleCount;
+                }
+                else
+                {
+                    ++m_2ndNullItemsCount;
+                }
+                ++madeLostCount;
+            }
+            else
+            {
+                return false;
+            }
+        }
+        ++index;
+    }
+
+    CleanupAfterFree();
+    //VMA_HEAVY_ASSERT(Validate()); // Already called by ClanupAfterFree().
+
+    return true;
+}
+
+uint32_t VmaBlockMetadata_Linear::MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
+{
+    uint32_t lostAllocationCount = 0;
+
+    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    for(size_t i = m_1stNullItemsBeginCount, count = suballocations1st.size(); i < count; ++i)
+    {
+        VmaSuballocation& suballoc = suballocations1st[i];
+        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE &&
+            suballoc.hAllocation->CanBecomeLost() &&
+            suballoc.hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
+        {
+            suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+            suballoc.hAllocation = VK_NULL_HANDLE;
+            ++m_1stNullItemsMiddleCount;
+            m_SumFreeSize += suballoc.size;
+            ++lostAllocationCount;
+        }
+    }
+
+    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+    for(size_t i = 0, count = suballocations2nd.size(); i < count; ++i)
+    {
+        VmaSuballocation& suballoc = suballocations2nd[i];
+        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE &&
+            suballoc.hAllocation->CanBecomeLost() &&
+            suballoc.hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
+        {
+            suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+            suballoc.hAllocation = VK_NULL_HANDLE;
+            ++m_2ndNullItemsCount;
+            m_SumFreeSize += suballoc.size;
+            ++lostAllocationCount;
+        }
+    }
+
+    if(lostAllocationCount)
+    {
+        CleanupAfterFree();
+    }
+
+    return lostAllocationCount;
+}
+
+VkResult VmaBlockMetadata_Linear::CheckCorruption(const void* pBlockData)
+{
+    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    for(size_t i = m_1stNullItemsBeginCount, count = suballocations1st.size(); i < count; ++i)
+    {
+        const VmaSuballocation& suballoc = suballocations1st[i];
+        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            if(!VmaValidateMagicValue(pBlockData, suballoc.offset - VMA_DEBUG_MARGIN))
+            {
+                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE VALIDATED ALLOCATION!");
+                return VK_ERROR_VALIDATION_FAILED_EXT;
+            }
+            if(!VmaValidateMagicValue(pBlockData, suballoc.offset + suballoc.size))
+            {
+                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER VALIDATED ALLOCATION!");
+                return VK_ERROR_VALIDATION_FAILED_EXT;
+            }
+        }
+    }
+
+    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+    for(size_t i = 0, count = suballocations2nd.size(); i < count; ++i)
+    {
+        const VmaSuballocation& suballoc = suballocations2nd[i];
+        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
+        {
+            if(!VmaValidateMagicValue(pBlockData, suballoc.offset - VMA_DEBUG_MARGIN))
+            {
+                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE VALIDATED ALLOCATION!");
+                return VK_ERROR_VALIDATION_FAILED_EXT;
+            }
+            if(!VmaValidateMagicValue(pBlockData, suballoc.offset + suballoc.size))
+            {
+                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER VALIDATED ALLOCATION!");
+                return VK_ERROR_VALIDATION_FAILED_EXT;
+            }
+        }
+    }
+
+    return VK_SUCCESS;
+}
+
+void VmaBlockMetadata_Linear::Alloc(
+    const VmaAllocationRequest& request,
+    VmaSuballocationType type,
+    VkDeviceSize allocSize,
+    VmaAllocation hAllocation)
+{
+    const VmaSuballocation newSuballoc = { request.offset, allocSize, hAllocation, type };
+
+    switch(request.type)
+    {
+    case VmaAllocationRequestType::UpperAddress:
+        {
+            VMA_ASSERT(m_2ndVectorMode != SECOND_VECTOR_RING_BUFFER &&
+                "CRITICAL ERROR: Trying to use linear allocator as double stack while it was already used as ring buffer.");
+            SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+            suballocations2nd.push_back(newSuballoc);
+            m_2ndVectorMode = SECOND_VECTOR_DOUBLE_STACK;
+        }
+        break;
+    case VmaAllocationRequestType::EndOf1st:
+        {
+            SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+
+            VMA_ASSERT(suballocations1st.empty() ||
+                request.offset >= suballocations1st.back().offset + suballocations1st.back().size);
+            // Check if it fits before the end of the block.
+            VMA_ASSERT(request.offset + allocSize <= GetSize());
+
+            suballocations1st.push_back(newSuballoc);
+        }
+        break;
+    case VmaAllocationRequestType::EndOf2nd:
+        {
+            SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+            // New allocation at the end of 2-part ring buffer, so before first allocation from 1st vector.
+            VMA_ASSERT(!suballocations1st.empty() &&
+                request.offset + allocSize <= suballocations1st[m_1stNullItemsBeginCount].offset);
+            SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+
+            switch(m_2ndVectorMode)
+            {
+            case SECOND_VECTOR_EMPTY:
+                // First allocation from second part ring buffer.
+                VMA_ASSERT(suballocations2nd.empty());
+                m_2ndVectorMode = SECOND_VECTOR_RING_BUFFER;
+                break;
+            case SECOND_VECTOR_RING_BUFFER:
+                // 2-part ring buffer is already started.
+                VMA_ASSERT(!suballocations2nd.empty());
+                break;
+            case SECOND_VECTOR_DOUBLE_STACK:
+                VMA_ASSERT(0 && "CRITICAL ERROR: Trying to use linear allocator as ring buffer while it was already used as double stack.");
+                break;
+            default:
+                VMA_ASSERT(0);
+            }
+
+            suballocations2nd.push_back(newSuballoc);
+        }
+        break;
+    default:
+        VMA_ASSERT(0 && "CRITICAL INTERNAL ERROR.");
+    }
+
+    m_SumFreeSize -= newSuballoc.size;
+}
+
+void VmaBlockMetadata_Linear::Free(const VmaAllocation allocation)
+{
+    FreeAtOffset(allocation->GetOffset());
+}
+
+void VmaBlockMetadata_Linear::FreeAtOffset(VkDeviceSize offset)
+{
+    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+
+    if(!suballocations1st.empty())
+    {
+        // First allocation: Mark it as next empty at the beginning.
+        VmaSuballocation& firstSuballoc = suballocations1st[m_1stNullItemsBeginCount];
+        if(firstSuballoc.offset == offset)
+        {
+            firstSuballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
+            firstSuballoc.hAllocation = VK_NULL_HANDLE;
+            m_SumFreeSize += firstSuballoc.size;
+            ++m_1stNullItemsBeginCount;
+            CleanupAfterFree();
+            return;
+        }
+    }
+
+    // Last allocation in 2-part ring buffer or top of upper stack (same logic).
+    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER ||
+        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
+    {
+        VmaSuballocation& lastSuballoc = suballocations2nd.back();
+        if(lastSuballoc.offset == offset)
+        {
+            m_SumFreeSize += lastSuballoc.size;
+            suballocations2nd.pop_back();
+            CleanupAfterFree();
+            return;
+        }
+    }
+    // Last allocation in 1st vector.
+    else if(m_2ndVectorMode == SECOND_VECTOR_EMPTY)
+    {
+        VmaSuballocation& lastSuballoc = suballocations1st.back();
+        if(lastSuballoc.offset == offset)
+        {
+            m_SumFreeSize += lastSuballoc.size;
+            suballocations1st.pop_back();
+            CleanupAfterFree();
+            return;
+        }
+    }
+
+    // Item from the middle of 1st vector.
+    {
+        VmaSuballocation refSuballoc;
+        refSuballoc.offset = offset;
+        // Rest of members stays uninitialized intentionally for better performance.
+        SuballocationVectorType::iterator it = VmaBinaryFindSorted(
+            suballocations1st.begin() + m_1stNullItemsBeginCount,
+            suballocations1st.end(),
+            refSuballoc,
+            VmaSuballocationOffsetLess());
+        if(it != suballocations1st.end())
+        {
+            it->type = VMA_SUBALLOCATION_TYPE_FREE;
+            it->hAllocation = VK_NULL_HANDLE;
+            ++m_1stNullItemsMiddleCount;
+            m_SumFreeSize += it->size;
+            CleanupAfterFree();
+            return;
+        }
+    }
+
+    if(m_2ndVectorMode != SECOND_VECTOR_EMPTY)
+    {
+        // Item from the middle of 2nd vector.
+        VmaSuballocation refSuballoc;
+        refSuballoc.offset = offset;
+        // Rest of members stays uninitialized intentionally for better performance.
+        SuballocationVectorType::iterator it = m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER ?
+            VmaBinaryFindSorted(suballocations2nd.begin(), suballocations2nd.end(), refSuballoc, VmaSuballocationOffsetLess()) :
+            VmaBinaryFindSorted(suballocations2nd.begin(), suballocations2nd.end(), refSuballoc, VmaSuballocationOffsetGreater());
+        if(it != suballocations2nd.end())
+        {
+            it->type = VMA_SUBALLOCATION_TYPE_FREE;
+            it->hAllocation = VK_NULL_HANDLE;
+            ++m_2ndNullItemsCount;
+            m_SumFreeSize += it->size;
+            CleanupAfterFree();
+            return;
+        }
+    }
+
+    VMA_ASSERT(0 && "Allocation to free not found in linear allocator!");
+}
+
+bool VmaBlockMetadata_Linear::ShouldCompact1st() const
+{
+    const size_t nullItemCount = m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount;
+    const size_t suballocCount = AccessSuballocations1st().size();
+    return suballocCount > 32 && nullItemCount * 2 >= (suballocCount - nullItemCount) * 3;
+}
+
+void VmaBlockMetadata_Linear::CleanupAfterFree()
+{
+    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
+    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
+
+    if(IsEmpty())
+    {
+        suballocations1st.clear();
+        suballocations2nd.clear();
+        m_1stNullItemsBeginCount = 0;
+        m_1stNullItemsMiddleCount = 0;
+        m_2ndNullItemsCount = 0;
+        m_2ndVectorMode = SECOND_VECTOR_EMPTY;
+    }
+    else
+    {
+        const size_t suballoc1stCount = suballocations1st.size();
+        const size_t nullItem1stCount = m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount;
+        VMA_ASSERT(nullItem1stCount <= suballoc1stCount);
+
+        // Find more null items at the beginning of 1st vector.
+        while(m_1stNullItemsBeginCount < suballoc1stCount &&
+            suballocations1st[m_1stNullItemsBeginCount].hAllocation == VK_NULL_HANDLE)
+        {
+            ++m_1stNullItemsBeginCount;
+            --m_1stNullItemsMiddleCount;
+        }
+
+        // Find more null items at the end of 1st vector.
+        while(m_1stNullItemsMiddleCount > 0 &&
+            suballocations1st.back().hAllocation == VK_NULL_HANDLE)
+        {
+            --m_1stNullItemsMiddleCount;
+            suballocations1st.pop_back();
+        }
+
+        // Find more null items at the end of 2nd vector.
+        while(m_2ndNullItemsCount > 0 &&
+            suballocations2nd.back().hAllocation == VK_NULL_HANDLE)
+        {
+            --m_2ndNullItemsCount;
+            suballocations2nd.pop_back();
+        }
+
+        // Find more null items at the beginning of 2nd vector.
+        while(m_2ndNullItemsCount > 0 &&
+            suballocations2nd[0].hAllocation == VK_NULL_HANDLE)
+        {
+            --m_2ndNullItemsCount;
+            VmaVectorRemove(suballocations2nd, 0);
+        }
+
+        if(ShouldCompact1st())
+        {
+            const size_t nonNullItemCount = suballoc1stCount - nullItem1stCount;
+            size_t srcIndex = m_1stNullItemsBeginCount;
+            for(size_t dstIndex = 0; dstIndex < nonNullItemCount; ++dstIndex)
+            {
+                while(suballocations1st[srcIndex].hAllocation == VK_NULL_HANDLE)
+                {
+                    ++srcIndex;
+                }
+                if(dstIndex != srcIndex)
+                {
+                    suballocations1st[dstIndex] = suballocations1st[srcIndex];
+                }
+                ++srcIndex;
+            }
+            suballocations1st.resize(nonNullItemCount);
+            m_1stNullItemsBeginCount = 0;
+            m_1stNullItemsMiddleCount = 0;
+        }
+
+        // 2nd vector became empty.
+        if(suballocations2nd.empty())
+        {
+            m_2ndVectorMode = SECOND_VECTOR_EMPTY;
+        }
+
+        // 1st vector became empty.
+        if(suballocations1st.size() - m_1stNullItemsBeginCount == 0)
+        {
+            suballocations1st.clear();
+            m_1stNullItemsBeginCount = 0;
+
+            if(!suballocations2nd.empty() && m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
+            {
+                // Swap 1st with 2nd. Now 2nd is empty.
+                m_2ndVectorMode = SECOND_VECTOR_EMPTY;
+                m_1stNullItemsMiddleCount = m_2ndNullItemsCount;
+                while(m_1stNullItemsBeginCount < suballocations2nd.size() &&
+                    suballocations2nd[m_1stNullItemsBeginCount].hAllocation == VK_NULL_HANDLE)
+                {
+                    ++m_1stNullItemsBeginCount;
+                    --m_1stNullItemsMiddleCount;
+                }
+                m_2ndNullItemsCount = 0;
+                m_1stVectorIndex ^= 1;
+            }
+        }
+    }
+
+    VMA_HEAVY_ASSERT(Validate());
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaBlockMetadata_Buddy
+
+VmaBlockMetadata_Buddy::VmaBlockMetadata_Buddy(VmaAllocator hAllocator) :
+    VmaBlockMetadata(hAllocator),
+    m_Root(VMA_NULL),
+    m_AllocationCount(0),
+    m_FreeCount(1),
+    m_SumFreeSize(0)
+{
+    memset(m_FreeList, 0, sizeof(m_FreeList));
+}
+
+VmaBlockMetadata_Buddy::~VmaBlockMetadata_Buddy()
+{
+    DeleteNode(m_Root);
+}
+
+void VmaBlockMetadata_Buddy::Init(VkDeviceSize size)
+{
+    VmaBlockMetadata::Init(size);
+
+    m_UsableSize = VmaPrevPow2(size);
+    m_SumFreeSize = m_UsableSize;
+
+    // Calculate m_LevelCount.
+    m_LevelCount = 1;
+    while(m_LevelCount < MAX_LEVELS &&
+        LevelToNodeSize(m_LevelCount) >= MIN_NODE_SIZE)
+    {
+        ++m_LevelCount;
+    }
+
+    Node* rootNode = vma_new(GetAllocationCallbacks(), Node)();
+    rootNode->offset = 0;
+    rootNode->type = Node::TYPE_FREE;
+    rootNode->parent = VMA_NULL;
+    rootNode->buddy = VMA_NULL;
+
+    m_Root = rootNode;
+    AddToFreeListFront(0, rootNode);
+}
+
+bool VmaBlockMetadata_Buddy::Validate() const
+{
+    // Validate tree.
+    ValidationContext ctx;
+    if(!ValidateNode(ctx, VMA_NULL, m_Root, 0, LevelToNodeSize(0)))
+    {
+        VMA_VALIDATE(false && "ValidateNode failed.");
+    }
+    VMA_VALIDATE(m_AllocationCount == ctx.calculatedAllocationCount);
+    VMA_VALIDATE(m_SumFreeSize == ctx.calculatedSumFreeSize);
+
+    // Validate free node lists.
+    for(uint32_t level = 0; level < m_LevelCount; ++level)
+    {
+        VMA_VALIDATE(m_FreeList[level].front == VMA_NULL ||
+            m_FreeList[level].front->free.prev == VMA_NULL);
+
+        for(Node* node = m_FreeList[level].front;
+            node != VMA_NULL;
+            node = node->free.next)
+        {
+            VMA_VALIDATE(node->type == Node::TYPE_FREE);
+
+            if(node->free.next == VMA_NULL)
+            {
+                VMA_VALIDATE(m_FreeList[level].back == node);
+            }
+            else
+            {
+                VMA_VALIDATE(node->free.next->free.prev == node);
+            }
+        }
+    }
+
+    // Validate that free lists ar higher levels are empty.
+    for(uint32_t level = m_LevelCount; level < MAX_LEVELS; ++level)
+    {
+        VMA_VALIDATE(m_FreeList[level].front == VMA_NULL && m_FreeList[level].back == VMA_NULL);
+    }
+
+    return true;
+}
+
+VkDeviceSize VmaBlockMetadata_Buddy::GetUnusedRangeSizeMax() const
+{
+    for(uint32_t level = 0; level < m_LevelCount; ++level)
+    {
+        if(m_FreeList[level].front != VMA_NULL)
+        {
+            return LevelToNodeSize(level);
+        }
+    }
+    return 0;
+}
+
+void VmaBlockMetadata_Buddy::CalcAllocationStatInfo(VmaStatInfo& outInfo) const
+{
+    const VkDeviceSize unusableSize = GetUnusableSize();
+
+    outInfo.blockCount = 1;
+
+    outInfo.allocationCount = outInfo.unusedRangeCount = 0;
+    outInfo.usedBytes = outInfo.unusedBytes = 0;
+
+    outInfo.allocationSizeMax = outInfo.unusedRangeSizeMax = 0;
+    outInfo.allocationSizeMin = outInfo.unusedRangeSizeMin = UINT64_MAX;
+    outInfo.allocationSizeAvg = outInfo.unusedRangeSizeAvg = 0; // Unused.
+
+    CalcAllocationStatInfoNode(outInfo, m_Root, LevelToNodeSize(0));
+
+    if(unusableSize > 0)
+    {
+        ++outInfo.unusedRangeCount;
+        outInfo.unusedBytes += unusableSize;
+        outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, unusableSize);
+        outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusableSize);
+    }
+}
+
+void VmaBlockMetadata_Buddy::AddPoolStats(VmaPoolStats& inoutStats) const
+{
+    const VkDeviceSize unusableSize = GetUnusableSize();
+
+    inoutStats.size += GetSize();
+    inoutStats.unusedSize += m_SumFreeSize + unusableSize;
+    inoutStats.allocationCount += m_AllocationCount;
+    inoutStats.unusedRangeCount += m_FreeCount;
+    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, GetUnusedRangeSizeMax());
+
+    if(unusableSize > 0)
+    {
+        ++inoutStats.unusedRangeCount;
+        // Not updating inoutStats.unusedRangeSizeMax with unusableSize because this space is not available for allocations.
+    }
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+void VmaBlockMetadata_Buddy::PrintDetailedMap(class VmaJsonWriter& json) const
+{
+    // TODO optimize
+    VmaStatInfo stat;
+    CalcAllocationStatInfo(stat);
+
+    PrintDetailedMap_Begin(
+        json,
+        stat.unusedBytes,
+        stat.allocationCount,
+        stat.unusedRangeCount);
+
+    PrintDetailedMapNode(json, m_Root, LevelToNodeSize(0));
+
+    const VkDeviceSize unusableSize = GetUnusableSize();
+    if(unusableSize > 0)
+    {
+        PrintDetailedMap_UnusedRange(json,
+            m_UsableSize, // offset
+            unusableSize); // size
+    }
+
+    PrintDetailedMap_End(json);
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+bool VmaBlockMetadata_Buddy::CreateAllocationRequest(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VkDeviceSize bufferImageGranularity,
+    VkDeviceSize allocSize,
+    VkDeviceSize allocAlignment,
+    bool upperAddress,
+    VmaSuballocationType allocType,
+    bool canMakeOtherLost,
+    uint32_t strategy,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    VMA_ASSERT(!upperAddress && "VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT can be used only with linear algorithm.");
+
+    // Simple way to respect bufferImageGranularity. May be optimized some day.
+    // Whenever it might be an OPTIMAL image...
+    if(allocType == VMA_SUBALLOCATION_TYPE_UNKNOWN ||
+        allocType == VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN ||
+        allocType == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL)
+    {
+        allocAlignment = VMA_MAX(allocAlignment, bufferImageGranularity);
+        allocSize = VMA_MAX(allocSize, bufferImageGranularity);
+    }
+
+    if(allocSize > m_UsableSize)
+    {
+        return false;
+    }
+
+    const uint32_t targetLevel = AllocSizeToLevel(allocSize);
+    for(uint32_t level = targetLevel + 1; level--; )
+    {
+        for(Node* freeNode = m_FreeList[level].front;
+            freeNode != VMA_NULL;
+            freeNode = freeNode->free.next)
+        {
+            if(freeNode->offset % allocAlignment == 0)
+            {
+                pAllocationRequest->type = VmaAllocationRequestType::Normal;
+                pAllocationRequest->offset = freeNode->offset;
+                pAllocationRequest->sumFreeSize = LevelToNodeSize(level);
+                pAllocationRequest->sumItemSize = 0;
+                pAllocationRequest->itemsToMakeLostCount = 0;
+                pAllocationRequest->customData = (void*)(uintptr_t)level;
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool VmaBlockMetadata_Buddy::MakeRequestedAllocationsLost(
+    uint32_t currentFrameIndex,
+    uint32_t frameInUseCount,
+    VmaAllocationRequest* pAllocationRequest)
+{
+    /*
+    Lost allocations are not supported in buddy allocator at the moment.
+    Support might be added in the future.
+    */
+    return pAllocationRequest->itemsToMakeLostCount == 0;
+}
+
+uint32_t VmaBlockMetadata_Buddy::MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
+{
+    /*
+    Lost allocations are not supported in buddy allocator at the moment.
+    Support might be added in the future.
+    */
+    return 0;
+}
+
+void VmaBlockMetadata_Buddy::Alloc(
+    const VmaAllocationRequest& request,
+    VmaSuballocationType type,
+    VkDeviceSize allocSize,
+    VmaAllocation hAllocation)
+{
+    VMA_ASSERT(request.type == VmaAllocationRequestType::Normal);
+
+    const uint32_t targetLevel = AllocSizeToLevel(allocSize);
+    uint32_t currLevel = (uint32_t)(uintptr_t)request.customData;
+
+    Node* currNode = m_FreeList[currLevel].front;
+    VMA_ASSERT(currNode != VMA_NULL && currNode->type == Node::TYPE_FREE);
+    while(currNode->offset != request.offset)
+    {
+        currNode = currNode->free.next;
+        VMA_ASSERT(currNode != VMA_NULL && currNode->type == Node::TYPE_FREE);
+    }
+
+    // Go down, splitting free nodes.
+    while(currLevel < targetLevel)
+    {
+        // currNode is already first free node at currLevel.
+        // Remove it from list of free nodes at this currLevel.
+        RemoveFromFreeList(currLevel, currNode);
+
+        const uint32_t childrenLevel = currLevel + 1;
+
+        // Create two free sub-nodes.
+        Node* leftChild = vma_new(GetAllocationCallbacks(), Node)();
+        Node* rightChild = vma_new(GetAllocationCallbacks(), Node)();
+
+        leftChild->offset = currNode->offset;
+        leftChild->type = Node::TYPE_FREE;
+        leftChild->parent = currNode;
+        leftChild->buddy = rightChild;
+
+        rightChild->offset = currNode->offset + LevelToNodeSize(childrenLevel);
+        rightChild->type = Node::TYPE_FREE;
+        rightChild->parent = currNode;
+        rightChild->buddy = leftChild;
+
+        // Convert current currNode to split type.
+        currNode->type = Node::TYPE_SPLIT;
+        currNode->split.leftChild = leftChild;
+
+        // Add child nodes to free list. Order is important!
+        AddToFreeListFront(childrenLevel, rightChild);
+        AddToFreeListFront(childrenLevel, leftChild);
+
+        ++m_FreeCount;
+        //m_SumFreeSize -= LevelToNodeSize(currLevel) % 2; // Useful only when level node sizes can be non power of 2.
+        ++currLevel;
+        currNode = m_FreeList[currLevel].front;
+
+        /*
+        We can be sure that currNode, as left child of node previously split,
+        also fullfills the alignment requirement.
+        */
+    }
+
+    // Remove from free list.
+    VMA_ASSERT(currLevel == targetLevel &&
+        currNode != VMA_NULL &&
+        currNode->type == Node::TYPE_FREE);
+    RemoveFromFreeList(currLevel, currNode);
+
+    // Convert to allocation node.
+    currNode->type = Node::TYPE_ALLOCATION;
+    currNode->allocation.alloc = hAllocation;
+
+    ++m_AllocationCount;
+    --m_FreeCount;
+    m_SumFreeSize -= allocSize;
+}
+
+void VmaBlockMetadata_Buddy::DeleteNode(Node* node)
+{
+    if(node->type == Node::TYPE_SPLIT)
+    {
+        DeleteNode(node->split.leftChild->buddy);
+        DeleteNode(node->split.leftChild);
+    }
+
+    vma_delete(GetAllocationCallbacks(), node);
+}
+
+bool VmaBlockMetadata_Buddy::ValidateNode(ValidationContext& ctx, const Node* parent, const Node* curr, uint32_t level, VkDeviceSize levelNodeSize) const
+{
+    VMA_VALIDATE(level < m_LevelCount);
+    VMA_VALIDATE(curr->parent == parent);
+    VMA_VALIDATE((curr->buddy == VMA_NULL) == (parent == VMA_NULL));
+    VMA_VALIDATE(curr->buddy == VMA_NULL || curr->buddy->buddy == curr);
+    switch(curr->type)
+    {
+    case Node::TYPE_FREE:
+        // curr->free.prev, next are validated separately.
+        ctx.calculatedSumFreeSize += levelNodeSize;
+        ++ctx.calculatedFreeCount;
+        break;
+    case Node::TYPE_ALLOCATION:
+        ++ctx.calculatedAllocationCount;
+        ctx.calculatedSumFreeSize += levelNodeSize - curr->allocation.alloc->GetSize();
+        VMA_VALIDATE(curr->allocation.alloc != VK_NULL_HANDLE);
+        break;
+    case Node::TYPE_SPLIT:
+        {
+            const uint32_t childrenLevel = level + 1;
+            const VkDeviceSize childrenLevelNodeSize = levelNodeSize / 2;
+            const Node* const leftChild = curr->split.leftChild;
+            VMA_VALIDATE(leftChild != VMA_NULL);
+            VMA_VALIDATE(leftChild->offset == curr->offset);
+            if(!ValidateNode(ctx, curr, leftChild, childrenLevel, childrenLevelNodeSize))
+            {
+                VMA_VALIDATE(false && "ValidateNode for left child failed.");
+            }
+            const Node* const rightChild = leftChild->buddy;
+            VMA_VALIDATE(rightChild->offset == curr->offset + childrenLevelNodeSize);
+            if(!ValidateNode(ctx, curr, rightChild, childrenLevel, childrenLevelNodeSize))
+            {
+                VMA_VALIDATE(false && "ValidateNode for right child failed.");
+            }
+        }
+        break;
+    default:
+        return false;
+    }
+
+    return true;
+}
+
+uint32_t VmaBlockMetadata_Buddy::AllocSizeToLevel(VkDeviceSize allocSize) const
+{
+    // I know this could be optimized somehow e.g. by using std::log2p1 from C++20.
+    uint32_t level = 0;
+    VkDeviceSize currLevelNodeSize = m_UsableSize;
+    VkDeviceSize nextLevelNodeSize = currLevelNodeSize >> 1;
+    while(allocSize <= nextLevelNodeSize && level + 1 < m_LevelCount)
+    {
+        ++level;
+        currLevelNodeSize = nextLevelNodeSize;
+        nextLevelNodeSize = currLevelNodeSize >> 1;
+    }
+    return level;
+}
+
+void VmaBlockMetadata_Buddy::FreeAtOffset(VmaAllocation alloc, VkDeviceSize offset)
+{
+    // Find node and level.
+    Node* node = m_Root;
+    VkDeviceSize nodeOffset = 0;
+    uint32_t level = 0;
+    VkDeviceSize levelNodeSize = LevelToNodeSize(0);
+    while(node->type == Node::TYPE_SPLIT)
+    {
+        const VkDeviceSize nextLevelSize = levelNodeSize >> 1;
+        if(offset < nodeOffset + nextLevelSize)
+        {
+            node = node->split.leftChild;
+        }
+        else
+        {
+            node = node->split.leftChild->buddy;
+            nodeOffset += nextLevelSize;
+        }
+        ++level;
+        levelNodeSize = nextLevelSize;
+    }
+
+    VMA_ASSERT(node != VMA_NULL && node->type == Node::TYPE_ALLOCATION);
+    VMA_ASSERT(alloc == VK_NULL_HANDLE || node->allocation.alloc == alloc);
+
+    ++m_FreeCount;
+    --m_AllocationCount;
+    m_SumFreeSize += alloc->GetSize();
+
+    node->type = Node::TYPE_FREE;
+
+    // Join free nodes if possible.
+    while(level > 0 && node->buddy->type == Node::TYPE_FREE)
+    {
+        RemoveFromFreeList(level, node->buddy);
+        Node* const parent = node->parent;
+
+        vma_delete(GetAllocationCallbacks(), node->buddy);
+        vma_delete(GetAllocationCallbacks(), node);
+        parent->type = Node::TYPE_FREE;
+
+        node = parent;
+        --level;
+        //m_SumFreeSize += LevelToNodeSize(level) % 2; // Useful only when level node sizes can be non power of 2.
+        --m_FreeCount;
+    }
+
+    AddToFreeListFront(level, node);
+}
+
+void VmaBlockMetadata_Buddy::CalcAllocationStatInfoNode(VmaStatInfo& outInfo, const Node* node, VkDeviceSize levelNodeSize) const
+{
+    switch(node->type)
+    {
+    case Node::TYPE_FREE:
+        ++outInfo.unusedRangeCount;
+        outInfo.unusedBytes += levelNodeSize;
+        outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, levelNodeSize);
+        outInfo.unusedRangeSizeMin = VMA_MAX(outInfo.unusedRangeSizeMin, levelNodeSize);
+        break;
+    case Node::TYPE_ALLOCATION:
+        {
+            const VkDeviceSize allocSize = node->allocation.alloc->GetSize();
+            ++outInfo.allocationCount;
+            outInfo.usedBytes += allocSize;
+            outInfo.allocationSizeMax = VMA_MAX(outInfo.allocationSizeMax, allocSize);
+            outInfo.allocationSizeMin = VMA_MAX(outInfo.allocationSizeMin, allocSize);
+
+            const VkDeviceSize unusedRangeSize = levelNodeSize - allocSize;
+            if(unusedRangeSize > 0)
+            {
+                ++outInfo.unusedRangeCount;
+                outInfo.unusedBytes += unusedRangeSize;
+                outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, unusedRangeSize);
+                outInfo.unusedRangeSizeMin = VMA_MAX(outInfo.unusedRangeSizeMin, unusedRangeSize);
+            }
+        }
+        break;
+    case Node::TYPE_SPLIT:
+        {
+            const VkDeviceSize childrenNodeSize = levelNodeSize / 2;
+            const Node* const leftChild = node->split.leftChild;
+            CalcAllocationStatInfoNode(outInfo, leftChild, childrenNodeSize);
+            const Node* const rightChild = leftChild->buddy;
+            CalcAllocationStatInfoNode(outInfo, rightChild, childrenNodeSize);
+        }
+        break;
+    default:
+        VMA_ASSERT(0);
+    }
+}
+
+void VmaBlockMetadata_Buddy::AddToFreeListFront(uint32_t level, Node* node)
+{
+    VMA_ASSERT(node->type == Node::TYPE_FREE);
+
+    // List is empty.
+    Node* const frontNode = m_FreeList[level].front;
+    if(frontNode == VMA_NULL)
+    {
+        VMA_ASSERT(m_FreeList[level].back == VMA_NULL);
+        node->free.prev = node->free.next = VMA_NULL;
+        m_FreeList[level].front = m_FreeList[level].back = node;
+    }
+    else
+    {
+        VMA_ASSERT(frontNode->free.prev == VMA_NULL);
+        node->free.prev = VMA_NULL;
+        node->free.next = frontNode;
+        frontNode->free.prev = node;
+        m_FreeList[level].front = node;
+    }
+}
+
+void VmaBlockMetadata_Buddy::RemoveFromFreeList(uint32_t level, Node* node)
+{
+    VMA_ASSERT(m_FreeList[level].front != VMA_NULL);
+
+    // It is at the front.
+    if(node->free.prev == VMA_NULL)
+    {
+        VMA_ASSERT(m_FreeList[level].front == node);
+        m_FreeList[level].front = node->free.next;
+    }
+    else
+    {
+        Node* const prevFreeNode = node->free.prev;
+        VMA_ASSERT(prevFreeNode->free.next == node);
+        prevFreeNode->free.next = node->free.next;
+    }
+
+    // It is at the back.
+    if(node->free.next == VMA_NULL)
+    {
+        VMA_ASSERT(m_FreeList[level].back == node);
+        m_FreeList[level].back = node->free.prev;
+    }
+    else
+    {
+        Node* const nextFreeNode = node->free.next;
+        VMA_ASSERT(nextFreeNode->free.prev == node);
+        nextFreeNode->free.prev = node->free.prev;
+    }
+}
+
+#if VMA_STATS_STRING_ENABLED
+void VmaBlockMetadata_Buddy::PrintDetailedMapNode(class VmaJsonWriter& json, const Node* node, VkDeviceSize levelNodeSize) const
+{
+    switch(node->type)
+    {
+    case Node::TYPE_FREE:
+        PrintDetailedMap_UnusedRange(json, node->offset, levelNodeSize);
+        break;
+    case Node::TYPE_ALLOCATION:
+        {
+            PrintDetailedMap_Allocation(json, node->offset, node->allocation.alloc);
+            const VkDeviceSize allocSize = node->allocation.alloc->GetSize();
+            if(allocSize < levelNodeSize)
+            {
+                PrintDetailedMap_UnusedRange(json, node->offset + allocSize, levelNodeSize - allocSize);
+            }
+        }
+        break;
+    case Node::TYPE_SPLIT:
+        {
+            const VkDeviceSize childrenNodeSize = levelNodeSize / 2;
+            const Node* const leftChild = node->split.leftChild;
+            PrintDetailedMapNode(json, leftChild, childrenNodeSize);
+            const Node* const rightChild = leftChild->buddy;
+            PrintDetailedMapNode(json, rightChild, childrenNodeSize);
+        }
+        break;
+    default:
+        VMA_ASSERT(0);
+    }
+}
+#endif // #if VMA_STATS_STRING_ENABLED
+
+
+////////////////////////////////////////////////////////////////////////////////
+// class VmaDeviceMemoryBlock
+
+VmaDeviceMemoryBlock::VmaDeviceMemoryBlock(VmaAllocator hAllocator) :
+    m_pMetadata(VMA_NULL),
+    m_MemoryTypeIndex(UINT32_MAX),
+    m_Id(0),
+    m_hMemory(VK_NULL_HANDLE),
+    m_MapCount(0),
+    m_pMappedData(VMA_NULL)
+{
+}
+
+void VmaDeviceMemoryBlock::Init(
+    VmaAllocator hAllocator,
+    VmaPool hParentPool,
+    uint32_t newMemoryTypeIndex,
+    VkDeviceMemory newMemory,
+    VkDeviceSize newSize,
+    uint32_t id,
+    uint32_t algorithm)
+{
+    VMA_ASSERT(m_hMemory == VK_NULL_HANDLE);
+
+    m_hParentPool = hParentPool;
+    m_MemoryTypeIndex = newMemoryTypeIndex;
+    m_Id = id;
+    m_hMemory = newMemory;
+
+    switch(algorithm)
+    {
+    case VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT:
+        m_pMetadata = vma_new(hAllocator, VmaBlockMetadata_Linear)(hAllocator);
+        break;
+    case VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT:
+        m_pMetadata = vma_new(hAllocator, VmaBlockMetadata_Buddy)(hAllocator);
+        break;
+    default:
+        VMA_ASSERT(0);
+        // Fall-through.
+    case 0:
+        m_pMetadata = vma_new(hAllocator, VmaBlockMetadata_Generic)(hAllocator);
+    }
+    m_pMetadata->Init(newSize);
+}
+
+void VmaDeviceMemoryBlock::Destroy(VmaAllocator allocator)
+{
+    // This is the most important assert in the entire library.
+    // Hitting it means you have some memory leak - unreleased VmaAllocation objects.
+    VMA_ASSERT(m_pMetadata->IsEmpty() && "Some allocations were not freed before destruction of this memory block!");
+
+    VMA_ASSERT(m_hMemory != VK_NULL_HANDLE);
+    allocator->FreeVulkanMemory(m_MemoryTypeIndex, m_pMetadata->GetSize(), m_hMemory);
+    m_hMemory = VK_NULL_HANDLE;
+
+    vma_delete(allocator, m_pMetadata);
+    m_pMetadata = VMA_NULL;
+}
+
+bool VmaDeviceMemoryBlock::Validate() const
+{
+    VMA_VALIDATE((m_hMemory != VK_NULL_HANDLE) &&
+        (m_pMetadata->GetSize() != 0));
+
+    return m_pMetadata->Validate();
+}
+
+VkResult VmaDeviceMemoryBlock::CheckCorruption(VmaAllocator hAllocator)
+{
+    void* pData = nullptr;
+    VkResult res = Map(hAllocator, 1, &pData);
+    if(res != VK_SUCCESS)
+    {
+        return res;
+    }
+
+    res = m_pMetadata->CheckCorruption(pData);
+
+    Unmap(hAllocator, 1);
+
+    return res;
+}
+
+VkResult VmaDeviceMemoryBlock::Map(VmaAllocator hAllocator, uint32_t count, void** ppData)
+{
+    if(count == 0)
+    {
+        return VK_SUCCESS;
+    }
+
+    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
+    if(m_MapCount != 0)
+    {
+        m_MapCount += count;
+        VMA_ASSERT(m_pMappedData != VMA_NULL);
+        if(ppData != VMA_NULL)
+        {
+            *ppData = m_pMappedData;
+        }
+        return VK_SUCCESS;
+    }
+    else
+    {
+        VkResult result = (*hAllocator->GetVulkanFunctions().vkMapMemory)(
+            hAllocator->m_hDevice,
+            m_hMemory,
+            0, // offset
+            VK_WHOLE_SIZE,
+            0, // flags
+            &m_pMappedData);
+        if(result == VK_SUCCESS)
+        {
+            if(ppData != VMA_NULL)
+            {
+                *ppData = m_pMappedData;
+            }
+            m_MapCount = count;
+        }
+        return result;
+    }
+}
+
+void VmaDeviceMemoryBlock::Unmap(VmaAllocator hAllocator, uint32_t count)
+{
+    if(count == 0)
+    {
+        return;
+    }
+
+    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
+    if(m_MapCount >= count)
+    {
+        m_MapCount -= count;
+        if(m_MapCount == 0)
+        {
+            m_pMappedData = VMA_NULL;
+            (*hAllocator->GetVulkanFunctions().vkUnmapMemory)(hAllocator->m_hDevice, m_hMemory);
+        }
+    }
+    else
+    {
+        VMA_ASSERT(0 && "VkDeviceMemory block is being unmapped while it was not previously mapped.");
+    }
+}
+
+VkResult VmaDeviceMemoryBlock::WriteMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize)
+{
+    VMA_ASSERT(VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_MARGIN % 4 == 0 && VMA_DEBUG_DETECT_CORRUPTION);
+    VMA_ASSERT(allocOffset >= VMA_DEBUG_MARGIN);
+
+    void* pData;
+    VkResult res = Map(hAllocator, 1, &pData);
+    if(res != VK_SUCCESS)
+    {
+        return res;
+    }
+
+    VmaWriteMagicValue(pData, allocOffset - VMA_DEBUG_MARGIN);
+    VmaWriteMagicValue(pData, allocOffset + allocSize);
+
+    Unmap(hAllocator, 1);
+
+    return VK_SUCCESS;
+}
+
+VkResult VmaDeviceMemoryBlock::ValidateMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize)
+{
+    VMA_ASSERT(VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_MARGIN % 4 == 0 && VMA_DEBUG_DETECT_CORRUPTION);
+    VMA_ASSERT(allocOffset >= VMA_DEBUG_MARGIN);
+
+    void* pData;
+    VkResult res = Map(hAllocator, 1, &pData);
+    if(res != VK_SUCCESS)
+    {
+        return res;
+    }
+
+    if(!VmaValidateMagicValue(pData, allocOffset - VMA_DEBUG_MARGIN))
+    {
+        VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE FREED ALLOCATION!");
+    }
+    else if(!VmaValidateMagicValue(pData, allocOffset + allocSize))
+    {
+        VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER FREED ALLOCATION!");
+    }
+
+    Unmap(hAllocator, 1);
+
+    return VK_SUCCESS;
+}
+
+VkResult VmaDeviceMemoryBlock::BindBufferMemory(
+    const VmaAllocator hAllocator,
+    const VmaAllocation hAllocation,
+    VkDeviceSize allocationLocalOffset,
+    VkBuffer hBuffer,
+    const void* pNext)
+{
+    VMA_ASSERT(hAllocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_BLOCK &&
+        hAllocation->GetBlock() == this);
+    VMA_ASSERT(allocationLocalOffset < hAllocation->GetSize() &&
+        "Invalid allocationLocalOffset. Did you forget that this offset is relative to the beginning of the allocation, not the whole memory block?");
+    const VkDeviceSize memoryOffset = hAllocation->GetOffset() + allocationLocalOffset;
+    // This lock is important so that we don't call vkBind... and/or vkMap... simultaneously on the same VkDeviceMemory from multiple threads.
+    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
+    return hAllocator->BindVulkanBuffer(m_hMemory, memoryOffset, hBuffer, pNext);
+}
+
+VkResult VmaDeviceMemoryBlock::BindImageMemory(
+    const VmaAllocator hAllocator,
+    const VmaAllocation hAllocation,
+    VkDeviceSize allocationLocalOffset,
+    VkImage hImage,
+    const void* pNext)
+{
+    VMA_ASSERT(hAllocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_BLOCK &&
+        hAllocation->GetBlock() == this);
+    VMA_ASSERT(allocationLocalOffset < hAllocation->GetSize() &&
+        "Invalid allocationLocalOffset. Did you forget that this offset is relative to the beginning of the allocation, not the whole memory block?");
+    const VkDeviceSize memoryOffset = hAllocation->GetOffset() + allocationLocalOffset;
+    // This lock is important so that we don't call vkBind... and/or vkMap... simultaneously on the same VkDeviceMemory from multiple threads.
+    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
+    return hAllocator->BindVulkanImage(m_hMemory, memoryOffset, hImage, pNext);
+}
+
+static void InitStatInfo(VmaStatInfo& outInfo)
+{
+    memset(&outInfo, 0, sizeof(outInfo));
+    outInfo.allocationSizeMin = UINT64_MAX;
+    outInfo.unusedRangeSizeMin = UINT64_MAX;
+}
+
+// Adds statistics srcInfo into inoutInfo, like: inoutInfo += srcInfo.
+static void VmaAddStatInfo(VmaStatInfo& inoutInfo, const VmaStatInfo& srcInfo)
+{
+    inoutInfo.blockCount += srcInfo.blockCount;
+    inoutInfo.allocationCount += srcInfo.allocationCount;
+    inoutInfo.unusedRangeCount += srcInfo.unusedRangeCount;
+    inoutInfo.usedBytes += srcInfo.usedBytes;
+    inoutInfo.unusedBytes += srcInfo.unusedBytes;
+    inoutInfo.allocationSizeMin = VMA_MIN(inoutInfo.allocationSizeMin, srcInfo.allocationSizeMin);
+    inoutInfo.allocationSizeMax = VMA_MAX(inoutInfo.allocationSizeMax, srcInfo.allocationSizeMax);
+    inoutInfo.unusedRangeSizeMin = VMA_MIN(inoutInfo.unusedRangeSizeMin, srcInfo.unusedRangeSizeMin);
+    inoutInfo.unusedRangeSizeMax = VMA_MAX(inoutInfo.unusedRangeSizeMax, srcInfo.unusedRangeSizeMax);
+}
+
+static void VmaPostprocessCalcStatInfo(VmaStatInfo& inoutInfo)
+{
+    inoutInfo.allocationSizeAvg = (inoutInfo.allocationCount > 0) ?
+        VmaRoundDiv<VkDeviceSize>(inoutInfo.usedBytes, inoutInfo.allocationCount) : 0;
+    inoutInfo.unusedRangeSizeAvg = (inoutInfo.unusedRangeCount > 0) ?
+        VmaRoundDiv<VkDeviceSize>(inoutInfo.unusedBytes, inoutInfo.unusedRangeCount) : 0;
+}
+
+VmaPool_T::VmaPool_T(
+    VmaAllocator hAllocator,
+    const VmaPoolCreateInfo& createInfo,
+    VkDeviceSize preferredBlockSize) :
+    m_BlockVector(
+        hAllocator,
+        this, // hParentPool
+        createInfo.memoryTypeIndex,
+        createInfo.blockSize != 0 ? createInfo.blockSize : preferredBlockSize,
+        createInfo.minBlockCount,
+        createInfo.maxBlockCount,
+        (createInfo.flags & VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT) != 0 ? 1 : hAllocator->GetBufferImageGranularity(),
+        createInfo.frameInUseCount,
+        createInfo.blockSize != 0, // explicitBlockSize
+        createInfo.flags & VMA_POOL_CREATE_ALGORITHM_MASK, // algorithm
+        (createInfo.flags & VMA_POOL_CREATE_EXPORTABLE_BIT) != 0), // exportable
+    m_Id(0),
+    m_Name(VMA_NULL)
+{
+}
+
+VmaPool_T::~VmaPool_T()
+{
+}
+
+void VmaPool_T::SetName(const char* pName)
+{
+    const VkAllocationCallbacks* allocs = m_BlockVector.GetAllocator()->GetAllocationCallbacks();
+    VmaFreeString(allocs, m_Name);
+
+    if(pName != VMA_NULL)
+    {
+        m_Name = VmaCreateStringCopy(allocs, pName);
+    }
+    else
+    {
+        m_Name = VMA_NULL;
+    }
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+VmaBlockVector::VmaBlockVector(
+    VmaAllocator hAllocator,
+    VmaPool hParentPool,
+    uint32_t memoryTypeIndex,
+    VkDeviceSize preferredBlockSize,
+    size_t minBlockCount,
+    size_t maxBlockCount,
+    VkDeviceSize bufferImageGranularity,
+    uint32_t frameInUseCount,
+    bool explicitBlockSize,
+    uint32_t algorithm,
+    bool exportable) :
+    m_hAllocator(hAllocator),
+    m_hParentPool(hParentPool),
+    m_MemoryTypeIndex(memoryTypeIndex),
+    m_PreferredBlockSize(preferredBlockSize),
+    m_MinBlockCount(minBlockCount),
+    m_MaxBlockCount(maxBlockCount),
+    m_BufferImageGranularity(bufferImageGranularity),
+    m_FrameInUseCount(frameInUseCount),
+    m_ExplicitBlockSize(explicitBlockSize),
+    m_Algorithm(algorithm),
+    m_Exportable(exportable),
+    m_HasEmptyBlock(false),
+    m_Blocks(VmaStlAllocator<VmaDeviceMemoryBlock*>(hAllocator->GetAllocationCallbacks())),
+    m_NextBlockId(0)
+{
+}
+
+VmaBlockVector::~VmaBlockVector()
+{
+    for(size_t i = m_Blocks.size(); i--; )
+    {
+        m_Blocks[i]->Destroy(m_hAllocator);
+        vma_delete(m_hAllocator, m_Blocks[i]);
+    }
+}
+
+VkResult VmaBlockVector::CreateMinBlocks()
+{
+    for(size_t i = 0; i < m_MinBlockCount; ++i)
+    {
+        VkResult res = CreateBlock(m_PreferredBlockSize, VMA_NULL);
+        if(res != VK_SUCCESS)
+        {
+            return res;
+        }
+    }
+    return VK_SUCCESS;
+}
+
+void VmaBlockVector::GetPoolStats(VmaPoolStats* pStats)
+{
+    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);
+
+    const size_t blockCount = m_Blocks.size();
+
+    pStats->size = 0;
+    pStats->unusedSize = 0;
+    pStats->allocationCount = 0;
+    pStats->unusedRangeCount = 0;
+    pStats->unusedRangeSizeMax = 0;
+    pStats->blockCount = blockCount;
+
+    for(uint32_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
+    {
+        const VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
+        VMA_ASSERT(pBlock);
+        VMA_HEAVY_ASSERT(pBlock->Validate());
+        pBlock->m_pMetadata->AddPoolStats(*pStats);
+    }
+}
+
+bool VmaBlockVector::IsEmpty()
+{
+    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);
+    return m_Blocks.empty();
+}
+
+bool VmaBlockVector::IsCorruptionDetectionEnabled() const
+{
+    const uint32_t requiredMemFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
+    return (VMA_DEBUG_DETECT_CORRUPTION != 0) &&
+        (VMA_DEBUG_MARGIN > 0) &&
+        (m_Algorithm == 0 || m_Algorithm == VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT) &&
+        (m_hAllocator->m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags & requiredMemFlags) == requiredMemFlags;
+}
+
+static const uint32_t VMA_ALLOCATION_TRY_COUNT = 32;
+
+VkResult VmaBlockVector::Allocate(
+    uint32_t currentFrameIndex,
+    VkDeviceSize size,
+    VkDeviceSize alignment,
+    const VmaAllocationCreateInfo& createInfo,
+    VmaSuballocationType suballocType,
+    size_t allocationCount,
+    VmaAllocation* pAllocations)
+{
+    size_t allocIndex;
+    VkResult res = VK_SUCCESS;
+
+    if(IsCorruptionDetectionEnabled())
+    {
+        size = VmaAlignUp<VkDeviceSize>(size, sizeof(VMA_CORRUPTION_DETECTION_MAGIC_VALUE));
+        alignment = VmaAlignUp<VkDeviceSize>(alignment, sizeof(VMA_CORRUPTION_DETECTION_MAGIC_VALUE));
+    }
+
+    {
+        VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);
+        for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
+        {
+            res = AllocatePage(
+                currentFrameIndex,
+                size,
+                alignment,
+                createInfo,
+                suballocType,
+                pAllocations + allocIndex);
+            if(res != VK_SUCCESS)
+            {
+                break;
+            }
+        }
+    }
+
+    if(res != VK_SUCCESS)
+    {
+        // Free all already created allocations.
+        while(allocIndex--)
+        {
+            Free(pAllocations[allocIndex]);
+        }
+        memset(pAllocations, 0, sizeof(VmaAllocation) * allocationCount);
+    }
+
+    return res;
+}
+
+VkResult VmaBlockVector::AllocatePage(
+    uint32_t currentFrameIndex,
+    VkDeviceSize size,
+    VkDeviceSize alignment,
+    const VmaAllocationCreateInfo& createInfo,
+    VmaSuballocationType suballocType,
+    VmaAllocation* pAllocation)
+{
+    const bool isUpperAddress = (createInfo.flags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0;
+    bool canMakeOtherLost = (createInfo.flags & VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT) != 0;
+    const bool mapped = (createInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0;
+    const bool isUserDataString = (createInfo.flags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0;
+
+    VkDeviceSize freeMemory;
+    {
+        const uint32_t heapIndex = m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex);
+        VmaBudget heapBudget = {};
+        m_hAllocator->GetBudget(&heapBudget, heapIndex, 1);
+        freeMemory = (heapBudget.usage < heapBudget.budget) ? (heapBudget.budget - heapBudget.usage) : 0;
+    }
+
+    const bool canFallbackToDedicated = !IsCustomPool();
+    const bool canCreateNewBlock =
+        ((createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) == 0) &&
+        (m_Blocks.size() < m_MaxBlockCount) &&
+        (freeMemory >= size || !canFallbackToDedicated);
+    uint32_t strategy = createInfo.flags & VMA_ALLOCATION_CREATE_STRATEGY_MASK;
+
+    // If linearAlgorithm is used, canMakeOtherLost is available only when used as ring buffer.
+    // Which in turn is available only when maxBlockCount = 1.
+    if(m_Algorithm == VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT && m_MaxBlockCount > 1)
+    {
+        canMakeOtherLost = false;
+    }
+
+    // Upper address can only be used with linear allocator and within single memory block.
+    if(isUpperAddress &&
+        (m_Algorithm != VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT || m_MaxBlockCount > 1))
+    {
+        return VK_ERROR_FEATURE_NOT_PRESENT;
+    }
+
+    // Validate strategy.
+    switch(strategy)
+    {
+    case 0:
+        strategy = VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT;
+        break;
+    case VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT:
+    case VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT:
+    case VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT:
+        break;
+    default:
+        return VK_ERROR_FEATURE_NOT_PRESENT;
+    }
+
+    // Early reject: requested allocation size is larger that maximum block size for this block vector.
+    if(size + 2 * VMA_DEBUG_MARGIN > m_PreferredBlockSize)
+    {
+        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+    }
+
+    /*
+    Under certain condition, this whole section can be skipped for optimization, so
+    we move on directly to trying to allocate with canMakeOtherLost. That's the case
+    e.g. for custom pools with linear algorithm.
+    */
+    if(!canMakeOtherLost || canCreateNewBlock)
+    {
+        // 1. Search existing allocations. Try to allocate without making other allocations lost.
+        VmaAllocationCreateFlags allocFlagsCopy = createInfo.flags;
+        allocFlagsCopy &= ~VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT;
+
+        if(m_Algorithm == VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT)
+        {
+            // Use only last block.
+            if(!m_Blocks.empty())
+            {
+                VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks.back();
+                VMA_ASSERT(pCurrBlock);
+                VkResult res = AllocateFromBlock(
+                    pCurrBlock,
+                    currentFrameIndex,
+                    size,
+                    alignment,
+                    allocFlagsCopy,
+                    createInfo.pUserData,
+                    suballocType,
+                    strategy,
+                    pAllocation);
+                if(res == VK_SUCCESS)
+                {
+                    VMA_DEBUG_LOG("    Returned from last block #%u", pCurrBlock->GetId());
+                    return VK_SUCCESS;
+                }
+            }
+        }
+        else
+        {
+            if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT)
+            {
+                // Forward order in m_Blocks - prefer blocks with smallest amount of free space.
+                for(size_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex )
+                {
+                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
+                    VMA_ASSERT(pCurrBlock);
+                    VkResult res = AllocateFromBlock(
+                        pCurrBlock,
+                        currentFrameIndex,
+                        size,
+                        alignment,
+                        allocFlagsCopy,
+                        createInfo.pUserData,
+                        suballocType,
+                        strategy,
+                        pAllocation);
+                    if(res == VK_SUCCESS)
+                    {
+                        VMA_DEBUG_LOG("    Returned from existing block #%u", pCurrBlock->GetId());
+                        return VK_SUCCESS;
+                    }
+                }
+            }
+            else // WORST_FIT, FIRST_FIT
+            {
+                // Backward order in m_Blocks - prefer blocks with largest amount of free space.
+                for(size_t blockIndex = m_Blocks.size(); blockIndex--; )
+                {
+                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
+                    VMA_ASSERT(pCurrBlock);
+                    VkResult res = AllocateFromBlock(
+                        pCurrBlock,
+                        currentFrameIndex,
+                        size,
+                        alignment,
+                        allocFlagsCopy,
+                        createInfo.pUserData,
+                        suballocType,
+                        strategy,
+                        pAllocation);
+                    if(res == VK_SUCCESS)
+                    {
+                        VMA_DEBUG_LOG("    Returned from existing block #%u", pCurrBlock->GetId());
+                        return VK_SUCCESS;
+                    }
+                }
+            }
+        }
+
+        // 2. Try to create new block.
+        if(canCreateNewBlock)
+        {
+            // Calculate optimal size for new block.
+            VkDeviceSize newBlockSize = m_PreferredBlockSize;
+            uint32_t newBlockSizeShift = 0;
+            const uint32_t NEW_BLOCK_SIZE_SHIFT_MAX = 3;
+
+            if(!m_ExplicitBlockSize)
+            {
+                // Allocate 1/8, 1/4, 1/2 as first blocks.
+                const VkDeviceSize maxExistingBlockSize = CalcMaxBlockSize();
+                for(uint32_t i = 0; i < NEW_BLOCK_SIZE_SHIFT_MAX; ++i)
+                {
+                    const VkDeviceSize smallerNewBlockSize = newBlockSize / 2;
+                    if(smallerNewBlockSize > maxExistingBlockSize && smallerNewBlockSize >= size * 2)
+                    {
+                        newBlockSize = smallerNewBlockSize;
+                        ++newBlockSizeShift;
+                    }
+                    else
+                    {
+                        break;
+                    }
+                }
+            }
+
+            size_t newBlockIndex = 0;
+            VkResult res = (newBlockSize <= freeMemory || !canFallbackToDedicated) ?
+                CreateBlock(newBlockSize, &newBlockIndex) : VK_ERROR_OUT_OF_DEVICE_MEMORY;
+            // Allocation of this size failed? Try 1/2, 1/4, 1/8 of m_PreferredBlockSize.
+            if(!m_ExplicitBlockSize)
+            {
+                while(res < 0 && newBlockSizeShift < NEW_BLOCK_SIZE_SHIFT_MAX)
+                {
+                    const VkDeviceSize smallerNewBlockSize = newBlockSize / 2;
+                    if(smallerNewBlockSize >= size)
+                    {
+                        newBlockSize = smallerNewBlockSize;
+                        ++newBlockSizeShift;
+                        res = (newBlockSize <= freeMemory || !canFallbackToDedicated) ?
+                            CreateBlock(newBlockSize, &newBlockIndex) : VK_ERROR_OUT_OF_DEVICE_MEMORY;
+                    }
+                    else
+                    {
+                        break;
+                    }
+                }
+            }
+
+            if(res == VK_SUCCESS)
+            {
+                VmaDeviceMemoryBlock* const pBlock = m_Blocks[newBlockIndex];
+                VMA_ASSERT(pBlock->m_pMetadata->GetSize() >= size);
+
+                res = AllocateFromBlock(
+                    pBlock,
+                    currentFrameIndex,
+                    size,
+                    alignment,
+                    allocFlagsCopy,
+                    createInfo.pUserData,
+                    suballocType,
+                    strategy,
+                    pAllocation);
+                if(res == VK_SUCCESS)
+                {
+                    VMA_DEBUG_LOG("    Created new block #%u Size=%llu", pBlock->GetId(), newBlockSize);
+                    return VK_SUCCESS;
+                }
+                else
+                {
+                    // Allocation from new block failed, possibly due to VMA_DEBUG_MARGIN or alignment.
+                    return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+                }
+            }
+        }
+    }
+
+    // 3. Try to allocate from existing blocks with making other allocations lost.
+    if(canMakeOtherLost)
+    {
+        uint32_t tryIndex = 0;
+        for(; tryIndex < VMA_ALLOCATION_TRY_COUNT; ++tryIndex)
+        {
+            VmaDeviceMemoryBlock* pBestRequestBlock = VMA_NULL;
+            VmaAllocationRequest bestRequest = {};
+            VkDeviceSize bestRequestCost = VK_WHOLE_SIZE;
+
+            // 1. Search existing allocations.
+            if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT)
+            {
+                // Forward order in m_Blocks - prefer blocks with smallest amount of free space.
+                for(size_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex )
+                {
+                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
+                    VMA_ASSERT(pCurrBlock);
+                    VmaAllocationRequest currRequest = {};
+                    if(pCurrBlock->m_pMetadata->CreateAllocationRequest(
+                        currentFrameIndex,
+                        m_FrameInUseCount,
+                        m_BufferImageGranularity,
+                        size,
+                        alignment,
+                        (createInfo.flags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0,
+                        suballocType,
+                        canMakeOtherLost,
+                        strategy,
+                        &currRequest))
+                    {
+                        const VkDeviceSize currRequestCost = currRequest.CalcCost();
+                        if(pBestRequestBlock == VMA_NULL ||
+                            currRequestCost < bestRequestCost)
+                        {
+                            pBestRequestBlock = pCurrBlock;
+                            bestRequest = currRequest;
+                            bestRequestCost = currRequestCost;
+
+                            if(bestRequestCost == 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            else // WORST_FIT, FIRST_FIT
+            {
+                // Backward order in m_Blocks - prefer blocks with largest amount of free space.
+                for(size_t blockIndex = m_Blocks.size(); blockIndex--; )
+                {
+                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
+                    VMA_ASSERT(pCurrBlock);
+                    VmaAllocationRequest currRequest = {};
+                    if(pCurrBlock->m_pMetadata->CreateAllocationRequest(
+                        currentFrameIndex,
+                        m_FrameInUseCount,
+                        m_BufferImageGranularity,
+                        size,
+                        alignment,
+                        (createInfo.flags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0,
+                        suballocType,
+                        canMakeOtherLost,
+                        strategy,
+                        &currRequest))
+                    {
+                        const VkDeviceSize currRequestCost = currRequest.CalcCost();
+                        if(pBestRequestBlock == VMA_NULL ||
+                            currRequestCost < bestRequestCost ||
+                            strategy == VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT)
+                        {
+                            pBestRequestBlock = pCurrBlock;
+                            bestRequest = currRequest;
+                            bestRequestCost = currRequestCost;
+
+                            if(bestRequestCost == 0 ||
+                                strategy == VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if(pBestRequestBlock != VMA_NULL)
+            {
+                if(mapped)
+                {
+                    VkResult res = pBestRequestBlock->Map(m_hAllocator, 1, VMA_NULL);
+                    if(res != VK_SUCCESS)
+                    {
+                        return res;
+                    }
+                }
+
+                if(pBestRequestBlock->m_pMetadata->MakeRequestedAllocationsLost(
+                    currentFrameIndex,
+                    m_FrameInUseCount,
+                    &bestRequest))
+                {
+                    // Allocate from this pBlock.
+                    *pAllocation = m_hAllocator->m_AllocationObjectAllocator.Allocate(currentFrameIndex, isUserDataString);
+                    pBestRequestBlock->m_pMetadata->Alloc(bestRequest, suballocType, size, *pAllocation);
+                    UpdateHasEmptyBlock();
+                    (*pAllocation)->InitBlockAllocation(
+                        pBestRequestBlock,
+                        bestRequest.offset,
+                        alignment,
+                        size,
+                        m_MemoryTypeIndex,
+                        suballocType,
+                        mapped,
+                        (createInfo.flags & VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT) != 0);
+                    VMA_HEAVY_ASSERT(pBestRequestBlock->Validate());
+                    VMA_DEBUG_LOG("    Returned from existing block");
+                    (*pAllocation)->SetUserData(m_hAllocator, createInfo.pUserData);
+                    m_hAllocator->m_Budget.AddAllocation(m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex), size);
+                    if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
+                    {
+                        m_hAllocator->FillAllocation(*pAllocation, VMA_ALLOCATION_FILL_PATTERN_CREATED);
+                    }
+                    if(IsCorruptionDetectionEnabled())
+                    {
+                        VkResult res = pBestRequestBlock->WriteMagicValueAroundAllocation(m_hAllocator, bestRequest.offset, size);
+                        VMA_ASSERT(res == VK_SUCCESS && "Couldn't map block memory to write magic value.");
+                    }
+                    return VK_SUCCESS;
+                }
+                // else: Some allocations must have been touched while we are here. Next try.
+            }
+            else
+            {
+                // Could not find place in any of the blocks - break outer loop.
+                break;
+            }
+        }
+        /* Maximum number of tries exceeded - a very unlike event when many other
+        threads are simultaneously touching allocations making it impossible to make
+        lost at the same time as we try to allocate. */
+        if(tryIndex == VMA_ALLOCATION_TRY_COUNT)
+        {
+            return VK_ERROR_TOO_MANY_OBJECTS;
+        }
+    }
+
+    return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+}
+
+void VmaBlockVector::Free(
+    const VmaAllocation hAllocation)
+{
+    VmaDeviceMemoryBlock* pBlockToDelete = VMA_NULL;
+
+    bool budgetExceeded = false;
+    {
+        const uint32_t heapIndex = m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex);
+        VmaBudget heapBudget = {};
+        m_hAllocator->GetBudget(&heapBudget, heapIndex, 1);
+        budgetExceeded = heapBudget.usage >= heapBudget.budget;
+    }
+
+    // Scope for lock.
+    {
+        VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);
+
+        VmaDeviceMemoryBlock* pBlock = hAllocation->GetBlock();
+
+        if(IsCorruptionDetectionEnabled())
+        {
+            VkResult res = pBlock->ValidateMagicValueAroundAllocation(m_hAllocator, hAllocation->GetOffset(), hAllocation->GetSize());
+            VMA_ASSERT(res == VK_SUCCESS && "Couldn't map block memory to validate magic value.");
+        }
+
+        if(hAllocation->IsPersistentMap())
+        {
+            pBlock->Unmap(m_hAllocator, 1);
+        }
+
+        pBlock->m_pMetadata->Free(hAllocation);
+        VMA_HEAVY_ASSERT(pBlock->Validate());
+
+        VMA_DEBUG_LOG("  Freed from MemoryTypeIndex=%u", m_MemoryTypeIndex);
+
+        const bool canDeleteBlock = m_Blocks.size() > m_MinBlockCount;
+        // pBlock became empty after this deallocation.
+        if(pBlock->m_pMetadata->IsEmpty())
+        {
+            // Already has empty block. We don't want to have two, so delete this one.
+            if((m_HasEmptyBlock || budgetExceeded) && canDeleteBlock)
+            {
+                pBlockToDelete = pBlock;
+                Remove(pBlock);
+            }
+            // else: We now have an empty block - leave it.
+        }
+        // pBlock didn't become empty, but we have another empty block - find and free that one.
+        // (This is optional, heuristics.)
+        else if(m_HasEmptyBlock && canDeleteBlock)
+        {
+            VmaDeviceMemoryBlock* pLastBlock = m_Blocks.back();
+            if(pLastBlock->m_pMetadata->IsEmpty())
+            {
+                pBlockToDelete = pLastBlock;
+                m_Blocks.pop_back();
+            }
+        }
+
+        UpdateHasEmptyBlock();
+        IncrementallySortBlocks();
+    }
+
+    // Destruction of a free block. Deferred until this point, outside of mutex
+    // lock, for performance reason.
+    if(pBlockToDelete != VMA_NULL)
+    {
+        VMA_DEBUG_LOG("    Deleted empty block");
+        pBlockToDelete->Destroy(m_hAllocator);
+        vma_delete(m_hAllocator, pBlockToDelete);
+    }
+}
+
+VkDeviceSize VmaBlockVector::CalcMaxBlockSize() const
+{
+    VkDeviceSize result = 0;
+    for(size_t i = m_Blocks.size(); i--; )
+    {
+        result = VMA_MAX(result, m_Blocks[i]->m_pMetadata->GetSize());
+        if(result >= m_PreferredBlockSize)
+        {
+            break;
+        }
+    }
+    return result;
+}
+
+void VmaBlockVector::Remove(VmaDeviceMemoryBlock* pBlock)
+{
+    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
+    {
+        if(m_Blocks[blockIndex] == pBlock)
+        {
+            VmaVectorRemove(m_Blocks, blockIndex);
+            return;
+        }
+    }
+    VMA_ASSERT(0);
+}
+
+void VmaBlockVector::IncrementallySortBlocks()
+{
+    if(m_Algorithm != VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT)
+    {
+        // Bubble sort only until first swap.
+        for(size_t i = 1; i < m_Blocks.size(); ++i)
+        {
+            if(m_Blocks[i - 1]->m_pMetadata->GetSumFreeSize() > m_Blocks[i]->m_pMetadata->GetSumFreeSize())
+            {
+                VMA_SWAP(m_Blocks[i - 1], m_Blocks[i]);
+                return;
+            }
+        }
+    }
+}
+
+VkResult VmaBlockVector::AllocateFromBlock(
+    VmaDeviceMemoryBlock* pBlock,
+    uint32_t currentFrameIndex,
+    VkDeviceSize size,
+    VkDeviceSize alignment,
+    VmaAllocationCreateFlags allocFlags,
+    void* pUserData,
+    VmaSuballocationType suballocType,
+    uint32_t strategy,
+    VmaAllocation* pAllocation)
+{
+    VMA_ASSERT((allocFlags & VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT) == 0);
+    const bool isUpperAddress = (allocFlags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0;
+    const bool mapped = (allocFlags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0;
+    const bool isUserDataString = (allocFlags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0;
+
+    VmaAllocationRequest currRequest = {};
+    if(pBlock->m_pMetadata->CreateAllocationRequest(
+        currentFrameIndex,
+        m_FrameInUseCount,
+        m_BufferImageGranularity,
+        size,
+        alignment,
+        isUpperAddress,
+        suballocType,
+        false, // canMakeOtherLost
+        strategy,
+        &currRequest))
+    {
+        // Allocate from pCurrBlock.
+        VMA_ASSERT(currRequest.itemsToMakeLostCount == 0);
+
+        if(mapped)
+        {
+            VkResult res = pBlock->Map(m_hAllocator, 1, VMA_NULL);
+            if(res != VK_SUCCESS)
+            {
+                return res;
+            }
+        }
+
+        *pAllocation = m_hAllocator->m_AllocationObjectAllocator.Allocate(currentFrameIndex, isUserDataString);
+        pBlock->m_pMetadata->Alloc(currRequest, suballocType, size, *pAllocation);
+        UpdateHasEmptyBlock();
+        (*pAllocation)->InitBlockAllocation(
+            pBlock,
+            currRequest.offset,
+            alignment,
+            size,
+            m_MemoryTypeIndex,
+            suballocType,
+            mapped,
+            (allocFlags & VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT) != 0);
+        VMA_HEAVY_ASSERT(pBlock->Validate());
+        (*pAllocation)->SetUserData(m_hAllocator, pUserData);
+        m_hAllocator->m_Budget.AddAllocation(m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex), size);
+        if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
+        {
+            m_hAllocator->FillAllocation(*pAllocation, VMA_ALLOCATION_FILL_PATTERN_CREATED);
+        }
+        if(IsCorruptionDetectionEnabled())
+        {
+            VkResult res = pBlock->WriteMagicValueAroundAllocation(m_hAllocator, currRequest.offset, size);
+            VMA_ASSERT(res == VK_SUCCESS && "Couldn't map block memory to write magic value.");
+        }
+        return VK_SUCCESS;
+    }
+    return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+}
+
+VkResult VmaBlockVector::CreateBlock(VkDeviceSize blockSize, size_t* pNewBlockIndex)
+{
+    VkMemoryAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
+    allocInfo.memoryTypeIndex = m_MemoryTypeIndex;
+    allocInfo.allocationSize = blockSize;
+
+#if VMA_BUFFER_DEVICE_ADDRESS
+    // Every standalone block can potentially contain a buffer with VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT - always enable the feature.
+    VkMemoryAllocateFlagsInfoKHR allocFlagsInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR };
+    if(m_hAllocator->m_UseKhrBufferDeviceAddress)
+    {
+        allocFlagsInfo.flags = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;
+        VmaPnextChainPushFront(&allocInfo, &allocFlagsInfo);
+    }
+#endif // #if VMA_BUFFER_DEVICE_ADDRESS
+
+    VkExportMemoryAllocateInfo exportInfo = { VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO };
+    if(m_Exportable) {
+        exportInfo.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        VmaPnextChainPushFront(&allocInfo, &exportInfo);
+    }
+
+    VkDeviceMemory mem = VK_NULL_HANDLE;
+    VkResult res = m_hAllocator->AllocateVulkanMemory(&allocInfo, &mem);
+    if(res < 0)
+    {
+        return res;
+    }
+
+    // New VkDeviceMemory successfully created.
+
+    // Create new Allocation for it.
+    VmaDeviceMemoryBlock* const pBlock = vma_new(m_hAllocator, VmaDeviceMemoryBlock)(m_hAllocator);
+    pBlock->Init(
+        m_hAllocator,
+        m_hParentPool,
+        m_MemoryTypeIndex,
+        mem,
+        allocInfo.allocationSize,
+        m_NextBlockId++,
+        m_Algorithm);
+
+    m_Blocks.push_back(pBlock);
+    if(pNewBlockIndex != VMA_NULL)
+    {
+        *pNewBlockIndex = m_Blocks.size() - 1;
+    }
+
+    return VK_SUCCESS;
+}
+
+void VmaBlockVector::ApplyDefragmentationMovesCpu(
+    class VmaBlockVectorDefragmentationContext* pDefragCtx,
+    const VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves)
+{
+    const size_t blockCount = m_Blocks.size();
+    const bool isNonCoherent = m_hAllocator->IsMemoryTypeNonCoherent(m_MemoryTypeIndex);
+
+    enum BLOCK_FLAG
+    {
+        BLOCK_FLAG_USED = 0x00000001,
+        BLOCK_FLAG_MAPPED_FOR_DEFRAGMENTATION = 0x00000002,
+    };
+
+    struct BlockInfo
+    {
+        uint32_t flags;
+        void* pMappedData;
+    };
+    VmaVector< BlockInfo, VmaStlAllocator<BlockInfo> >
+        blockInfo(blockCount, BlockInfo(), VmaStlAllocator<BlockInfo>(m_hAllocator->GetAllocationCallbacks()));
+    memset(blockInfo.data(), 0, blockCount * sizeof(BlockInfo));
+
+    // Go over all moves. Mark blocks that are used with BLOCK_FLAG_USED.
+    const size_t moveCount = moves.size();
+    for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
+    {
+        const VmaDefragmentationMove& move = moves[moveIndex];
+        blockInfo[move.srcBlockIndex].flags |= BLOCK_FLAG_USED;
+        blockInfo[move.dstBlockIndex].flags |= BLOCK_FLAG_USED;
+    }
+
+    VMA_ASSERT(pDefragCtx->res == VK_SUCCESS);
+
+    // Go over all blocks. Get mapped pointer or map if necessary.
+    for(size_t blockIndex = 0; pDefragCtx->res == VK_SUCCESS && blockIndex < blockCount; ++blockIndex)
+    {
+        BlockInfo& currBlockInfo = blockInfo[blockIndex];
+        VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
+        if((currBlockInfo.flags & BLOCK_FLAG_USED) != 0)
+        {
+            currBlockInfo.pMappedData = pBlock->GetMappedData();
+            // It is not originally mapped - map it.
+            if(currBlockInfo.pMappedData == VMA_NULL)
+            {
+                pDefragCtx->res = pBlock->Map(m_hAllocator, 1, &currBlockInfo.pMappedData);
+                if(pDefragCtx->res == VK_SUCCESS)
+                {
+                    currBlockInfo.flags |= BLOCK_FLAG_MAPPED_FOR_DEFRAGMENTATION;
+                }
+            }
+        }
+    }
+
+    // Go over all moves. Do actual data transfer.
+    if(pDefragCtx->res == VK_SUCCESS)
+    {
+        const VkDeviceSize nonCoherentAtomSize = m_hAllocator->m_PhysicalDeviceProperties.limits.nonCoherentAtomSize;
+        VkMappedMemoryRange memRange = { VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE };
+
+        for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
+        {
+            const VmaDefragmentationMove& move = moves[moveIndex];
+
+            const BlockInfo& srcBlockInfo = blockInfo[move.srcBlockIndex];
+            const BlockInfo& dstBlockInfo = blockInfo[move.dstBlockIndex];
+
+            VMA_ASSERT(srcBlockInfo.pMappedData && dstBlockInfo.pMappedData);
+
+            // Invalidate source.
+            if(isNonCoherent)
+            {
+                VmaDeviceMemoryBlock* const pSrcBlock = m_Blocks[move.srcBlockIndex];
+                memRange.memory = pSrcBlock->GetDeviceMemory();
+                memRange.offset = VmaAlignDown(move.srcOffset, nonCoherentAtomSize);
+                memRange.size = VMA_MIN(
+                    VmaAlignUp(move.size + (move.srcOffset - memRange.offset), nonCoherentAtomSize),
+                    pSrcBlock->m_pMetadata->GetSize() - memRange.offset);
+                (*m_hAllocator->GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hAllocator->m_hDevice, 1, &memRange);
+            }
+
+            // THE PLACE WHERE ACTUAL DATA COPY HAPPENS.
+            memmove(
+                reinterpret_cast<char*>(dstBlockInfo.pMappedData) + move.dstOffset,
+                reinterpret_cast<char*>(srcBlockInfo.pMappedData) + move.srcOffset,
+                static_cast<size_t>(move.size));
+
+            if(IsCorruptionDetectionEnabled())
+            {
+                VmaWriteMagicValue(dstBlockInfo.pMappedData, move.dstOffset - VMA_DEBUG_MARGIN);
+                VmaWriteMagicValue(dstBlockInfo.pMappedData, move.dstOffset + move.size);
+            }
+
+            // Flush destination.
+            if(isNonCoherent)
+            {
+                VmaDeviceMemoryBlock* const pDstBlock = m_Blocks[move.dstBlockIndex];
+                memRange.memory = pDstBlock->GetDeviceMemory();
+                memRange.offset = VmaAlignDown(move.dstOffset, nonCoherentAtomSize);
+                memRange.size = VMA_MIN(
+                    VmaAlignUp(move.size + (move.dstOffset - memRange.offset), nonCoherentAtomSize),
+                    pDstBlock->m_pMetadata->GetSize() - memRange.offset);
+                (*m_hAllocator->GetVulkanFunctions().vkFlushMappedMemoryRanges)(m_hAllocator->m_hDevice, 1, &memRange);
+            }
+        }
+    }
+
+    // Go over all blocks in reverse order. Unmap those that were mapped just for defragmentation.
+    // Regardless of pCtx->res == VK_SUCCESS.
+    for(size_t blockIndex = blockCount; blockIndex--; )
+    {
+        const BlockInfo& currBlockInfo = blockInfo[blockIndex];
+        if((currBlockInfo.flags & BLOCK_FLAG_MAPPED_FOR_DEFRAGMENTATION) != 0)
+        {
+            VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
+            pBlock->Unmap(m_hAllocator, 1);
+        }
+    }
+}
+
+void VmaBlockVector::ApplyDefragmentationMovesGpu(
+    class VmaBlockVectorDefragmentationContext* pDefragCtx,
+    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+    VkCommandBuffer commandBuffer)
+{
+    const size_t blockCount = m_Blocks.size();
+
+    pDefragCtx->blockContexts.resize(blockCount);
+    memset(pDefragCtx->blockContexts.data(), 0, blockCount * sizeof(VmaBlockDefragmentationContext));
+
+    // Go over all moves. Mark blocks that are used with BLOCK_FLAG_USED.
+    const size_t moveCount = moves.size();
+    for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
+    {
+        const VmaDefragmentationMove& move = moves[moveIndex];
+
+        //if(move.type == VMA_ALLOCATION_TYPE_UNKNOWN)
+        {
+            // Old school move still require us to map the whole block
+            pDefragCtx->blockContexts[move.srcBlockIndex].flags |= VmaBlockDefragmentationContext::BLOCK_FLAG_USED;
+            pDefragCtx->blockContexts[move.dstBlockIndex].flags |= VmaBlockDefragmentationContext::BLOCK_FLAG_USED;
+        }
+    }
+
+    VMA_ASSERT(pDefragCtx->res == VK_SUCCESS);
+
+    // Go over all blocks. Create and bind buffer for whole block if necessary.
+    {
+        VkBufferCreateInfo bufCreateInfo;
+        VmaFillGpuDefragmentationBufferCreateInfo(bufCreateInfo);
+
+        for(size_t blockIndex = 0; pDefragCtx->res == VK_SUCCESS && blockIndex < blockCount; ++blockIndex)
+        {
+            VmaBlockDefragmentationContext& currBlockCtx = pDefragCtx->blockContexts[blockIndex];
+            VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
+            if((currBlockCtx.flags & VmaBlockDefragmentationContext::BLOCK_FLAG_USED) != 0)
+            {
+                bufCreateInfo.size = pBlock->m_pMetadata->GetSize();
+                pDefragCtx->res = (*m_hAllocator->GetVulkanFunctions().vkCreateBuffer)(
+                    m_hAllocator->m_hDevice, &bufCreateInfo, m_hAllocator->GetAllocationCallbacks(), &currBlockCtx.hBuffer);
+                if(pDefragCtx->res == VK_SUCCESS)
+                {
+                    pDefragCtx->res = (*m_hAllocator->GetVulkanFunctions().vkBindBufferMemory)(
+                        m_hAllocator->m_hDevice, currBlockCtx.hBuffer, pBlock->GetDeviceMemory(), 0);
+                }
+            }
+        }
+    }
+
+    // Go over all moves. Post data transfer commands to command buffer.
+    if(pDefragCtx->res == VK_SUCCESS)
+    {
+        for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
+        {
+            const VmaDefragmentationMove& move = moves[moveIndex];
+
+            const VmaBlockDefragmentationContext& srcBlockCtx = pDefragCtx->blockContexts[move.srcBlockIndex];
+            const VmaBlockDefragmentationContext& dstBlockCtx = pDefragCtx->blockContexts[move.dstBlockIndex];
+
+            VMA_ASSERT(srcBlockCtx.hBuffer && dstBlockCtx.hBuffer);
+
+            VkBufferCopy region = {
+                move.srcOffset,
+                move.dstOffset,
+                move.size };
+            (*m_hAllocator->GetVulkanFunctions().vkCmdCopyBuffer)(
+                commandBuffer, srcBlockCtx.hBuffer, dstBlockCtx.hBuffer, 1, &region);
+        }
+    }
+
+    // Save buffers to defrag context for later destruction.
+    if(pDefragCtx->res == VK_SUCCESS && moveCount > 0)
+    {
+        pDefragCtx->res = VK_NOT_READY;
+    }
+}
+
+void VmaBlockVector::FreeEmptyBlocks(VmaDefragmentationStats* pDefragmentationStats)
+{
+    for(size_t blockIndex = m_Blocks.size(); blockIndex--; )
+    {
+        VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
+        if(pBlock->m_pMetadata->IsEmpty())
+        {
+            if(m_Blocks.size() > m_MinBlockCount)
+            {
+                if(pDefragmentationStats != VMA_NULL)
+                {
+                    ++pDefragmentationStats->deviceMemoryBlocksFreed;
+                    pDefragmentationStats->bytesFreed += pBlock->m_pMetadata->GetSize();
+                }
+
+                VmaVectorRemove(m_Blocks, blockIndex);
+                pBlock->Destroy(m_hAllocator);
+                vma_delete(m_hAllocator, pBlock);
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+    UpdateHasEmptyBlock();
+}
+
+void VmaBlockVector::UpdateHasEmptyBlock()
+{
+    m_HasEmptyBlock = false;
+    for(size_t index = 0, count = m_Blocks.size(); index < count; ++index)
+    {
+        VmaDeviceMemoryBlock* const pBlock = m_Blocks[index];
+        if(pBlock->m_pMetadata->IsEmpty())
+        {
+            m_HasEmptyBlock = true;
+            break;
+        }
+    }
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+void VmaBlockVector::PrintDetailedMap(class VmaJsonWriter& json)
+{
+    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);
+
+    json.BeginObject();
+
+    if(IsCustomPool())
+    {
+        const char* poolName = m_hParentPool->GetName();
+        if(poolName != VMA_NULL && poolName[0] != '\0')
+        {
+            json.WriteString("Name");
+            json.WriteString(poolName);
+        }
+
+        json.WriteString("MemoryTypeIndex");
+        json.WriteNumber(m_MemoryTypeIndex);
+
+        json.WriteString("BlockSize");
+        json.WriteNumber(m_PreferredBlockSize);
+
+        json.WriteString("BlockCount");
+        json.BeginObject(true);
+        if(m_MinBlockCount > 0)
+        {
+            json.WriteString("Min");
+            json.WriteNumber((uint64_t)m_MinBlockCount);
+        }
+        if(m_MaxBlockCount < SIZE_MAX)
+        {
+            json.WriteString("Max");
+            json.WriteNumber((uint64_t)m_MaxBlockCount);
+        }
+        json.WriteString("Cur");
+        json.WriteNumber((uint64_t)m_Blocks.size());
+        json.EndObject();
+
+        if(m_FrameInUseCount > 0)
+        {
+            json.WriteString("FrameInUseCount");
+            json.WriteNumber(m_FrameInUseCount);
+        }
+
+        if(m_Algorithm != 0)
+        {
+            json.WriteString("Algorithm");
+            json.WriteString(VmaAlgorithmToStr(m_Algorithm));
+        }
+    }
+    else
+    {
+        json.WriteString("PreferredBlockSize");
+        json.WriteNumber(m_PreferredBlockSize);
+    }
+
+    json.WriteString("Blocks");
+    json.BeginObject();
+    for(size_t i = 0; i < m_Blocks.size(); ++i)
+    {
+        json.BeginString();
+        json.ContinueString(m_Blocks[i]->GetId());
+        json.EndString();
+
+        m_Blocks[i]->m_pMetadata->PrintDetailedMap(json);
+    }
+    json.EndObject();
+
+    json.EndObject();
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+void VmaBlockVector::Defragment(
+    class VmaBlockVectorDefragmentationContext* pCtx,
+    VmaDefragmentationStats* pStats, VmaDefragmentationFlags flags,
+    VkDeviceSize& maxCpuBytesToMove, uint32_t& maxCpuAllocationsToMove,
+    VkDeviceSize& maxGpuBytesToMove, uint32_t& maxGpuAllocationsToMove,
+    VkCommandBuffer commandBuffer)
+{
+    pCtx->res = VK_SUCCESS;
+
+    const VkMemoryPropertyFlags memPropFlags =
+        m_hAllocator->m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags;
+    const bool isHostVisible = (memPropFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0;
+
+    const bool canDefragmentOnCpu = maxCpuBytesToMove > 0 && maxCpuAllocationsToMove > 0 &&
+        isHostVisible;
+    const bool canDefragmentOnGpu = maxGpuBytesToMove > 0 && maxGpuAllocationsToMove > 0 &&
+        !IsCorruptionDetectionEnabled() &&
+        ((1u << m_MemoryTypeIndex) & m_hAllocator->GetGpuDefragmentationMemoryTypeBits()) != 0;
+
+    // There are options to defragment this memory type.
+    if(canDefragmentOnCpu || canDefragmentOnGpu)
+    {
+        bool defragmentOnGpu;
+        // There is only one option to defragment this memory type.
+        if(canDefragmentOnGpu != canDefragmentOnCpu)
+        {
+            defragmentOnGpu = canDefragmentOnGpu;
+        }
+        // Both options are available: Heuristics to choose the best one.
+        else
+        {
+            defragmentOnGpu = (memPropFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) != 0 ||
+                m_hAllocator->IsIntegratedGpu();
+        }
+
+        bool overlappingMoveSupported = !defragmentOnGpu;
+
+        if(m_hAllocator->m_UseMutex)
+        {
+            if(flags & VMA_DEFRAGMENTATION_FLAG_INCREMENTAL)
+            {
+                if(!m_Mutex.TryLockWrite())
+                {
+                    pCtx->res = VK_ERROR_INITIALIZATION_FAILED;
+                    return;
+                }
+            }
+            else
+            {
+                m_Mutex.LockWrite();
+                pCtx->mutexLocked = true;
+            }
+        }
+
+        pCtx->Begin(overlappingMoveSupported, flags);
+
+        // Defragment.
+
+        const VkDeviceSize maxBytesToMove = defragmentOnGpu ? maxGpuBytesToMove : maxCpuBytesToMove;
+        const uint32_t maxAllocationsToMove = defragmentOnGpu ? maxGpuAllocationsToMove : maxCpuAllocationsToMove;
+        pCtx->res = pCtx->GetAlgorithm()->Defragment(pCtx->defragmentationMoves, maxBytesToMove, maxAllocationsToMove, flags);
+
+        // Accumulate statistics.
+        if(pStats != VMA_NULL)
+        {
+            const VkDeviceSize bytesMoved = pCtx->GetAlgorithm()->GetBytesMoved();
+            const uint32_t allocationsMoved = pCtx->GetAlgorithm()->GetAllocationsMoved();
+            pStats->bytesMoved += bytesMoved;
+            pStats->allocationsMoved += allocationsMoved;
+            VMA_ASSERT(bytesMoved <= maxBytesToMove);
+            VMA_ASSERT(allocationsMoved <= maxAllocationsToMove);
+            if(defragmentOnGpu)
+            {
+                maxGpuBytesToMove -= bytesMoved;
+                maxGpuAllocationsToMove -= allocationsMoved;
+            }
+            else
+            {
+                maxCpuBytesToMove -= bytesMoved;
+                maxCpuAllocationsToMove -= allocationsMoved;
+            }
+        }
+
+        if(flags & VMA_DEFRAGMENTATION_FLAG_INCREMENTAL)
+        {
+            if(m_hAllocator->m_UseMutex)
+                m_Mutex.UnlockWrite();
+
+            if(pCtx->res >= VK_SUCCESS && !pCtx->defragmentationMoves.empty())
+                pCtx->res = VK_NOT_READY;
+
+            return;
+        }
+
+        if(pCtx->res >= VK_SUCCESS)
+        {
+            if(defragmentOnGpu)
+            {
+                ApplyDefragmentationMovesGpu(pCtx, pCtx->defragmentationMoves, commandBuffer);
+            }
+            else
+            {
+                ApplyDefragmentationMovesCpu(pCtx, pCtx->defragmentationMoves);
+            }
+        }
+    }
+}
+
+void VmaBlockVector::DefragmentationEnd(
+    class VmaBlockVectorDefragmentationContext* pCtx,
+    uint32_t flags,
+    VmaDefragmentationStats* pStats)
+{
+    if(flags & VMA_DEFRAGMENTATION_FLAG_INCREMENTAL && m_hAllocator->m_UseMutex)
+    {
+        VMA_ASSERT(pCtx->mutexLocked == false);
+
+        // Incremental defragmentation doesn't hold the lock, so when we enter here we don't actually have any
+        // lock protecting us. Since we mutate state here, we have to take the lock out now
+        m_Mutex.LockWrite();
+        pCtx->mutexLocked = true;
+    }
+
+    // If the mutex isn't locked we didn't do any work and there is nothing to delete.
+    if(pCtx->mutexLocked || !m_hAllocator->m_UseMutex)
+    {
+        // Destroy buffers.
+        for(size_t blockIndex = pCtx->blockContexts.size(); blockIndex--;)
+        {
+            VmaBlockDefragmentationContext &blockCtx = pCtx->blockContexts[blockIndex];
+            if(blockCtx.hBuffer)
+            {
+                (*m_hAllocator->GetVulkanFunctions().vkDestroyBuffer)(m_hAllocator->m_hDevice, blockCtx.hBuffer, m_hAllocator->GetAllocationCallbacks());
+            }
+        }
+
+        if(pCtx->res >= VK_SUCCESS)
+        {
+            FreeEmptyBlocks(pStats);
+        }
+    }
+
+    if(pCtx->mutexLocked)
+    {
+        VMA_ASSERT(m_hAllocator->m_UseMutex);
+        m_Mutex.UnlockWrite();
+    }
+}
+
+uint32_t VmaBlockVector::ProcessDefragmentations(
+    class VmaBlockVectorDefragmentationContext *pCtx,
+    VmaDefragmentationPassMoveInfo* pMove, uint32_t maxMoves)
+{
+    VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);
+
+    const uint32_t moveCount = VMA_MIN(uint32_t(pCtx->defragmentationMoves.size()) - pCtx->defragmentationMovesProcessed, maxMoves);
+
+    for(uint32_t i = 0; i < moveCount; ++ i)
+    {
+        VmaDefragmentationMove& move = pCtx->defragmentationMoves[pCtx->defragmentationMovesProcessed + i];
+
+        pMove->allocation = move.hAllocation;
+        pMove->memory = move.pDstBlock->GetDeviceMemory();
+        pMove->offset = move.dstOffset;
+
+        ++ pMove;
+    }
+
+    pCtx->defragmentationMovesProcessed += moveCount;
+
+    return moveCount;
+}
+
+void VmaBlockVector::CommitDefragmentations(
+    class VmaBlockVectorDefragmentationContext *pCtx,
+    VmaDefragmentationStats* pStats)
+{
+    VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);
+
+    for(uint32_t i = pCtx->defragmentationMovesCommitted; i < pCtx->defragmentationMovesProcessed; ++ i)
+    {
+        const VmaDefragmentationMove &move = pCtx->defragmentationMoves[i];
+
+        move.pSrcBlock->m_pMetadata->FreeAtOffset(move.srcOffset);
+        move.hAllocation->ChangeBlockAllocation(m_hAllocator, move.pDstBlock, move.dstOffset);
+    }
+
+    pCtx->defragmentationMovesCommitted = pCtx->defragmentationMovesProcessed;
+    FreeEmptyBlocks(pStats);
+}
+
+size_t VmaBlockVector::CalcAllocationCount() const
+{
+    size_t result = 0;
+    for(size_t i = 0; i < m_Blocks.size(); ++i)
+    {
+        result += m_Blocks[i]->m_pMetadata->GetAllocationCount();
+    }
+    return result;
+}
+
+bool VmaBlockVector::IsBufferImageGranularityConflictPossible() const
+{
+    if(m_BufferImageGranularity == 1)
+    {
+        return false;
+    }
+    VmaSuballocationType lastSuballocType = VMA_SUBALLOCATION_TYPE_FREE;
+    for(size_t i = 0, count = m_Blocks.size(); i < count; ++i)
+    {
+        VmaDeviceMemoryBlock* const pBlock = m_Blocks[i];
+        VMA_ASSERT(m_Algorithm == 0);
+        VmaBlockMetadata_Generic* const pMetadata = (VmaBlockMetadata_Generic*)pBlock->m_pMetadata;
+        if(pMetadata->IsBufferImageGranularityConflictPossible(m_BufferImageGranularity, lastSuballocType))
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+void VmaBlockVector::MakePoolAllocationsLost(
+    uint32_t currentFrameIndex,
+    size_t* pLostAllocationCount)
+{
+    VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);
+    size_t lostAllocationCount = 0;
+    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
+    {
+        VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
+        VMA_ASSERT(pBlock);
+        lostAllocationCount += pBlock->m_pMetadata->MakeAllocationsLost(currentFrameIndex, m_FrameInUseCount);
+    }
+    if(pLostAllocationCount != VMA_NULL)
+    {
+        *pLostAllocationCount = lostAllocationCount;
+    }
+}
+
+VkResult VmaBlockVector::CheckCorruption()
+{
+    if(!IsCorruptionDetectionEnabled())
+    {
+        return VK_ERROR_FEATURE_NOT_PRESENT;
+    }
+
+    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);
+    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
+    {
+        VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
+        VMA_ASSERT(pBlock);
+        VkResult res = pBlock->CheckCorruption(m_hAllocator);
+        if(res != VK_SUCCESS)
+        {
+            return res;
+        }
+    }
+    return VK_SUCCESS;
+}
+
+void VmaBlockVector::AddStats(VmaStats* pStats)
+{
+    const uint32_t memTypeIndex = m_MemoryTypeIndex;
+    const uint32_t memHeapIndex = m_hAllocator->MemoryTypeIndexToHeapIndex(memTypeIndex);
+
+    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);
+
+    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
+    {
+        const VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
+        VMA_ASSERT(pBlock);
+        VMA_HEAVY_ASSERT(pBlock->Validate());
+        VmaStatInfo allocationStatInfo;
+        pBlock->m_pMetadata->CalcAllocationStatInfo(allocationStatInfo);
+        VmaAddStatInfo(pStats->total, allocationStatInfo);
+        VmaAddStatInfo(pStats->memoryType[memTypeIndex], allocationStatInfo);
+        VmaAddStatInfo(pStats->memoryHeap[memHeapIndex], allocationStatInfo);
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaDefragmentationAlgorithm_Generic members definition
+
+VmaDefragmentationAlgorithm_Generic::VmaDefragmentationAlgorithm_Generic(
+    VmaAllocator hAllocator,
+    VmaBlockVector* pBlockVector,
+    uint32_t currentFrameIndex,
+    bool overlappingMoveSupported) :
+    VmaDefragmentationAlgorithm(hAllocator, pBlockVector, currentFrameIndex),
+    m_AllocationCount(0),
+    m_AllAllocations(false),
+    m_BytesMoved(0),
+    m_AllocationsMoved(0),
+    m_Blocks(VmaStlAllocator<BlockInfo*>(hAllocator->GetAllocationCallbacks()))
+{
+    // Create block info for each block.
+    const size_t blockCount = m_pBlockVector->m_Blocks.size();
+    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
+    {
+        BlockInfo* pBlockInfo = vma_new(m_hAllocator, BlockInfo)(m_hAllocator->GetAllocationCallbacks());
+        pBlockInfo->m_OriginalBlockIndex = blockIndex;
+        pBlockInfo->m_pBlock = m_pBlockVector->m_Blocks[blockIndex];
+        m_Blocks.push_back(pBlockInfo);
+    }
+
+    // Sort them by m_pBlock pointer value.
+    VMA_SORT(m_Blocks.begin(), m_Blocks.end(), BlockPointerLess());
+}
+
+VmaDefragmentationAlgorithm_Generic::~VmaDefragmentationAlgorithm_Generic()
+{
+    for(size_t i = m_Blocks.size(); i--; )
+    {
+        vma_delete(m_hAllocator, m_Blocks[i]);
+    }
+}
+
+void VmaDefragmentationAlgorithm_Generic::AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged)
+{
+    // Now as we are inside VmaBlockVector::m_Mutex, we can make final check if this allocation was not lost.
+    if(hAlloc->GetLastUseFrameIndex() != VMA_FRAME_INDEX_LOST)
+    {
+        VmaDeviceMemoryBlock* pBlock = hAlloc->GetBlock();
+        BlockInfoVector::iterator it = VmaBinaryFindFirstNotLess(m_Blocks.begin(), m_Blocks.end(), pBlock, BlockPointerLess());
+        if(it != m_Blocks.end() && (*it)->m_pBlock == pBlock)
+        {
+            AllocationInfo allocInfo = AllocationInfo(hAlloc, pChanged);
+            (*it)->m_Allocations.push_back(allocInfo);
+        }
+        else
+        {
+            VMA_ASSERT(0);
+        }
+
+        ++m_AllocationCount;
+    }
+}
+
+VkResult VmaDefragmentationAlgorithm_Generic::DefragmentRound(
+    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+    VkDeviceSize maxBytesToMove,
+    uint32_t maxAllocationsToMove,
+    bool freeOldAllocations)
+{
+    if(m_Blocks.empty())
+    {
+        return VK_SUCCESS;
+    }
+
+    // This is a choice based on research.
+    // Option 1:
+    uint32_t strategy = VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT;
+    // Option 2:
+    //uint32_t strategy = VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT;
+    // Option 3:
+    //uint32_t strategy = VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT;
+
+    size_t srcBlockMinIndex = 0;
+    // When FAST_ALGORITHM, move allocations from only last out of blocks that contain non-movable allocations.
+    /*
+    if(m_AlgorithmFlags & VMA_DEFRAGMENTATION_FAST_ALGORITHM_BIT)
+    {
+        const size_t blocksWithNonMovableCount = CalcBlocksWithNonMovableCount();
+        if(blocksWithNonMovableCount > 0)
+        {
+            srcBlockMinIndex = blocksWithNonMovableCount - 1;
+        }
+    }
+    */
+
+    size_t srcBlockIndex = m_Blocks.size() - 1;
+    size_t srcAllocIndex = SIZE_MAX;
+    for(;;)
+    {
+        // 1. Find next allocation to move.
+        // 1.1. Start from last to first m_Blocks - they are sorted from most "destination" to most "source".
+        // 1.2. Then start from last to first m_Allocations.
+        while(srcAllocIndex >= m_Blocks[srcBlockIndex]->m_Allocations.size())
+        {
+            if(m_Blocks[srcBlockIndex]->m_Allocations.empty())
+            {
+                // Finished: no more allocations to process.
+                if(srcBlockIndex == srcBlockMinIndex)
+                {
+                    return VK_SUCCESS;
+                }
+                else
+                {
+                    --srcBlockIndex;
+                    srcAllocIndex = SIZE_MAX;
+                }
+            }
+            else
+            {
+                srcAllocIndex = m_Blocks[srcBlockIndex]->m_Allocations.size() - 1;
+            }
+        }
+
+        BlockInfo* pSrcBlockInfo = m_Blocks[srcBlockIndex];
+        AllocationInfo& allocInfo = pSrcBlockInfo->m_Allocations[srcAllocIndex];
+
+        const VkDeviceSize size = allocInfo.m_hAllocation->GetSize();
+        const VkDeviceSize srcOffset = allocInfo.m_hAllocation->GetOffset();
+        const VkDeviceSize alignment = allocInfo.m_hAllocation->GetAlignment();
+        const VmaSuballocationType suballocType = allocInfo.m_hAllocation->GetSuballocationType();
+
+        // 2. Try to find new place for this allocation in preceding or current block.
+        for(size_t dstBlockIndex = 0; dstBlockIndex <= srcBlockIndex; ++dstBlockIndex)
+        {
+            BlockInfo* pDstBlockInfo = m_Blocks[dstBlockIndex];
+            VmaAllocationRequest dstAllocRequest;
+            if(pDstBlockInfo->m_pBlock->m_pMetadata->CreateAllocationRequest(
+                m_CurrentFrameIndex,
+                m_pBlockVector->GetFrameInUseCount(),
+                m_pBlockVector->GetBufferImageGranularity(),
+                size,
+                alignment,
+                false, // upperAddress
+                suballocType,
+                false, // canMakeOtherLost
+                strategy,
+                &dstAllocRequest) &&
+            MoveMakesSense(
+                dstBlockIndex, dstAllocRequest.offset, srcBlockIndex, srcOffset))
+            {
+                VMA_ASSERT(dstAllocRequest.itemsToMakeLostCount == 0);
+
+                // Reached limit on number of allocations or bytes to move.
+                if((m_AllocationsMoved + 1 > maxAllocationsToMove) ||
+                    (m_BytesMoved + size > maxBytesToMove))
+                {
+                    return VK_SUCCESS;
+                }
+
+                VmaDefragmentationMove move = {};
+                move.srcBlockIndex = pSrcBlockInfo->m_OriginalBlockIndex;
+                move.dstBlockIndex = pDstBlockInfo->m_OriginalBlockIndex;
+                move.srcOffset = srcOffset;
+                move.dstOffset = dstAllocRequest.offset;
+                move.size = size;
+                move.hAllocation = allocInfo.m_hAllocation;
+                move.pSrcBlock = pSrcBlockInfo->m_pBlock;
+                move.pDstBlock = pDstBlockInfo->m_pBlock;
+
+                moves.push_back(move);
+
+                pDstBlockInfo->m_pBlock->m_pMetadata->Alloc(
+                    dstAllocRequest,
+                    suballocType,
+                    size,
+                    allocInfo.m_hAllocation);
+
+                if(freeOldAllocations)
+                {
+                    pSrcBlockInfo->m_pBlock->m_pMetadata->FreeAtOffset(srcOffset);
+                    allocInfo.m_hAllocation->ChangeBlockAllocation(m_hAllocator, pDstBlockInfo->m_pBlock, dstAllocRequest.offset);
+                }
+
+                if(allocInfo.m_pChanged != VMA_NULL)
+                {
+                    *allocInfo.m_pChanged = VK_TRUE;
+                }
+
+                ++m_AllocationsMoved;
+                m_BytesMoved += size;
+
+                VmaVectorRemove(pSrcBlockInfo->m_Allocations, srcAllocIndex);
+
+                break;
+            }
+        }
+
+        // If not processed, this allocInfo remains in pBlockInfo->m_Allocations for next round.
+
+        if(srcAllocIndex > 0)
+        {
+            --srcAllocIndex;
+        }
+        else
+        {
+            if(srcBlockIndex > 0)
+            {
+                --srcBlockIndex;
+                srcAllocIndex = SIZE_MAX;
+            }
+            else
+            {
+                return VK_SUCCESS;
+            }
+        }
+    }
+}
+
+size_t VmaDefragmentationAlgorithm_Generic::CalcBlocksWithNonMovableCount() const
+{
+    size_t result = 0;
+    for(size_t i = 0; i < m_Blocks.size(); ++i)
+    {
+        if(m_Blocks[i]->m_HasNonMovableAllocations)
+        {
+            ++result;
+        }
+    }
+    return result;
+}
+
+VkResult VmaDefragmentationAlgorithm_Generic::Defragment(
+    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+    VkDeviceSize maxBytesToMove,
+    uint32_t maxAllocationsToMove,
+    VmaDefragmentationFlags flags)
+{
+    if(!m_AllAllocations && m_AllocationCount == 0)
+    {
+        return VK_SUCCESS;
+    }
+
+    const size_t blockCount = m_Blocks.size();
+    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
+    {
+        BlockInfo* pBlockInfo = m_Blocks[blockIndex];
+
+        if(m_AllAllocations)
+        {
+            VmaBlockMetadata_Generic* pMetadata = (VmaBlockMetadata_Generic*)pBlockInfo->m_pBlock->m_pMetadata;
+            for(VmaSuballocationList::const_iterator it = pMetadata->m_Suballocations.begin();
+                it != pMetadata->m_Suballocations.end();
+                ++it)
+            {
+                if(it->type != VMA_SUBALLOCATION_TYPE_FREE)
+                {
+                    AllocationInfo allocInfo = AllocationInfo(it->hAllocation, VMA_NULL);
+                    pBlockInfo->m_Allocations.push_back(allocInfo);
+                }
+            }
+        }
+
+        pBlockInfo->CalcHasNonMovableAllocations();
+
+        // This is a choice based on research.
+        // Option 1:
+        pBlockInfo->SortAllocationsByOffsetDescending();
+        // Option 2:
+        //pBlockInfo->SortAllocationsBySizeDescending();
+    }
+
+    // Sort m_Blocks this time by the main criterium, from most "destination" to most "source" blocks.
+    VMA_SORT(m_Blocks.begin(), m_Blocks.end(), BlockInfoCompareMoveDestination());
+
+    // This is a choice based on research.
+    const uint32_t roundCount = 2;
+
+    // Execute defragmentation rounds (the main part).
+    VkResult result = VK_SUCCESS;
+    for(uint32_t round = 0; (round < roundCount) && (result == VK_SUCCESS); ++round)
+    {
+        result = DefragmentRound(moves, maxBytesToMove, maxAllocationsToMove, !(flags & VMA_DEFRAGMENTATION_FLAG_INCREMENTAL));
+    }
+
+    return result;
+}
+
+bool VmaDefragmentationAlgorithm_Generic::MoveMakesSense(
+        size_t dstBlockIndex, VkDeviceSize dstOffset,
+        size_t srcBlockIndex, VkDeviceSize srcOffset)
+{
+    if(dstBlockIndex < srcBlockIndex)
+    {
+        return true;
+    }
+    if(dstBlockIndex > srcBlockIndex)
+    {
+        return false;
+    }
+    if(dstOffset < srcOffset)
+    {
+        return true;
+    }
+    return false;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaDefragmentationAlgorithm_Fast
+
+VmaDefragmentationAlgorithm_Fast::VmaDefragmentationAlgorithm_Fast(
+    VmaAllocator hAllocator,
+    VmaBlockVector* pBlockVector,
+    uint32_t currentFrameIndex,
+    bool overlappingMoveSupported) :
+    VmaDefragmentationAlgorithm(hAllocator, pBlockVector, currentFrameIndex),
+    m_OverlappingMoveSupported(overlappingMoveSupported),
+    m_AllocationCount(0),
+    m_AllAllocations(false),
+    m_BytesMoved(0),
+    m_AllocationsMoved(0),
+    m_BlockInfos(VmaStlAllocator<BlockInfo>(hAllocator->GetAllocationCallbacks()))
+{
+    VMA_ASSERT(VMA_DEBUG_MARGIN == 0);
+
+}
+
+VmaDefragmentationAlgorithm_Fast::~VmaDefragmentationAlgorithm_Fast()
+{
+}
+
+VkResult VmaDefragmentationAlgorithm_Fast::Defragment(
+    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
+    VkDeviceSize maxBytesToMove,
+    uint32_t maxAllocationsToMove,
+    VmaDefragmentationFlags flags)
+{
+    VMA_ASSERT(m_AllAllocations || m_pBlockVector->CalcAllocationCount() == m_AllocationCount);
+
+    const size_t blockCount = m_pBlockVector->GetBlockCount();
+    if(blockCount == 0 || maxBytesToMove == 0 || maxAllocationsToMove == 0)
+    {
+        return VK_SUCCESS;
+    }
+
+    PreprocessMetadata();
+
+    // Sort blocks in order from most destination.
+
+    m_BlockInfos.resize(blockCount);
+    for(size_t i = 0; i < blockCount; ++i)
+    {
+        m_BlockInfos[i].origBlockIndex = i;
+    }
+
+    VMA_SORT(m_BlockInfos.begin(), m_BlockInfos.end(), [this](const BlockInfo& lhs, const BlockInfo& rhs) -> bool {
+        return m_pBlockVector->GetBlock(lhs.origBlockIndex)->m_pMetadata->GetSumFreeSize() <
+            m_pBlockVector->GetBlock(rhs.origBlockIndex)->m_pMetadata->GetSumFreeSize();
+    });
+
+    // THE MAIN ALGORITHM
+
+    FreeSpaceDatabase freeSpaceDb;
+
+    size_t dstBlockInfoIndex = 0;
+    size_t dstOrigBlockIndex = m_BlockInfos[dstBlockInfoIndex].origBlockIndex;
+    VmaDeviceMemoryBlock* pDstBlock = m_pBlockVector->GetBlock(dstOrigBlockIndex);
+    VmaBlockMetadata_Generic* pDstMetadata = (VmaBlockMetadata_Generic*)pDstBlock->m_pMetadata;
+    VkDeviceSize dstBlockSize = pDstMetadata->GetSize();
+    VkDeviceSize dstOffset = 0;
+
+    bool end = false;
+    for(size_t srcBlockInfoIndex = 0; !end && srcBlockInfoIndex < blockCount; ++srcBlockInfoIndex)
+    {
+        const size_t srcOrigBlockIndex = m_BlockInfos[srcBlockInfoIndex].origBlockIndex;
+        VmaDeviceMemoryBlock* const pSrcBlock = m_pBlockVector->GetBlock(srcOrigBlockIndex);
+        VmaBlockMetadata_Generic* const pSrcMetadata = (VmaBlockMetadata_Generic*)pSrcBlock->m_pMetadata;
+        for(VmaSuballocationList::iterator srcSuballocIt = pSrcMetadata->m_Suballocations.begin();
+            !end && srcSuballocIt != pSrcMetadata->m_Suballocations.end(); )
+        {
+            VmaAllocation_T* const pAlloc = srcSuballocIt->hAllocation;
+            const VkDeviceSize srcAllocAlignment = pAlloc->GetAlignment();
+            const VkDeviceSize srcAllocSize = srcSuballocIt->size;
+            if(m_AllocationsMoved == maxAllocationsToMove ||
+                m_BytesMoved + srcAllocSize > maxBytesToMove)
+            {
+                end = true;
+                break;
+            }
+            const VkDeviceSize srcAllocOffset = srcSuballocIt->offset;
+
+            VmaDefragmentationMove move = {};
+            // Try to place it in one of free spaces from the database.
+            size_t freeSpaceInfoIndex;
+            VkDeviceSize dstAllocOffset;
+            if(freeSpaceDb.Fetch(srcAllocAlignment, srcAllocSize,
+                freeSpaceInfoIndex, dstAllocOffset))
+            {
+                size_t freeSpaceOrigBlockIndex = m_BlockInfos[freeSpaceInfoIndex].origBlockIndex;
+                VmaDeviceMemoryBlock* pFreeSpaceBlock = m_pBlockVector->GetBlock(freeSpaceOrigBlockIndex);
+                VmaBlockMetadata_Generic* pFreeSpaceMetadata = (VmaBlockMetadata_Generic*)pFreeSpaceBlock->m_pMetadata;
+
+                // Same block
+                if(freeSpaceInfoIndex == srcBlockInfoIndex)
+                {
+                    VMA_ASSERT(dstAllocOffset <= srcAllocOffset);
+
+                    // MOVE OPTION 1: Move the allocation inside the same block by decreasing offset.
+
+                    VmaSuballocation suballoc = *srcSuballocIt;
+                    suballoc.offset = dstAllocOffset;
+                    suballoc.hAllocation->ChangeOffset(dstAllocOffset);
+                    m_BytesMoved += srcAllocSize;
+                    ++m_AllocationsMoved;
+
+                    VmaSuballocationList::iterator nextSuballocIt = srcSuballocIt;
+                    ++nextSuballocIt;
+                    pSrcMetadata->m_Suballocations.erase(srcSuballocIt);
+                    srcSuballocIt = nextSuballocIt;
+
+                    InsertSuballoc(pFreeSpaceMetadata, suballoc);
+
+                    move.srcBlockIndex = srcOrigBlockIndex;
+                    move.dstBlockIndex = freeSpaceOrigBlockIndex;
+                    move.srcOffset = srcAllocOffset;
+                    move.dstOffset = dstAllocOffset;
+                    move.size = srcAllocSize;
+
+                    moves.push_back(move);
+                }
+                // Different block
+                else
+                {
+                    // MOVE OPTION 2: Move the allocation to a different block.
+
+                    VMA_ASSERT(freeSpaceInfoIndex < srcBlockInfoIndex);
+
+                    VmaSuballocation suballoc = *srcSuballocIt;
+                    suballoc.offset = dstAllocOffset;
+                    suballoc.hAllocation->ChangeBlockAllocation(m_hAllocator, pFreeSpaceBlock, dstAllocOffset);
+                    m_BytesMoved += srcAllocSize;
+                    ++m_AllocationsMoved;
+
+                    VmaSuballocationList::iterator nextSuballocIt = srcSuballocIt;
+                    ++nextSuballocIt;
+                    pSrcMetadata->m_Suballocations.erase(srcSuballocIt);
+                    srcSuballocIt = nextSuballocIt;
+
+                    InsertSuballoc(pFreeSpaceMetadata, suballoc);
+
+                    move.srcBlockIndex = srcOrigBlockIndex;
+                    move.dstBlockIndex = freeSpaceOrigBlockIndex;
+                    move.srcOffset = srcAllocOffset;
+                    move.dstOffset = dstAllocOffset;
+                    move.size = srcAllocSize;
+
+                    moves.push_back(move);
+                }
+            }
+            else
+            {
+                dstAllocOffset = VmaAlignUp(dstOffset, srcAllocAlignment);
+
+                // If the allocation doesn't fit before the end of dstBlock, forward to next block.
+                while(dstBlockInfoIndex < srcBlockInfoIndex &&
+                    dstAllocOffset + srcAllocSize > dstBlockSize)
+                {
+                    // But before that, register remaining free space at the end of dst block.
+                    freeSpaceDb.Register(dstBlockInfoIndex, dstOffset, dstBlockSize - dstOffset);
+
+                    ++dstBlockInfoIndex;
+                    dstOrigBlockIndex = m_BlockInfos[dstBlockInfoIndex].origBlockIndex;
+                    pDstBlock = m_pBlockVector->GetBlock(dstOrigBlockIndex);
+                    pDstMetadata = (VmaBlockMetadata_Generic*)pDstBlock->m_pMetadata;
+                    dstBlockSize = pDstMetadata->GetSize();
+                    dstOffset = 0;
+                    dstAllocOffset = 0;
+                }
+
+                // Same block
+                if(dstBlockInfoIndex == srcBlockInfoIndex)
+                {
+                    VMA_ASSERT(dstAllocOffset <= srcAllocOffset);
+
+                    const bool overlap = dstAllocOffset + srcAllocSize > srcAllocOffset;
+
+                    bool skipOver = overlap;
+                    if(overlap && m_OverlappingMoveSupported && dstAllocOffset < srcAllocOffset)
+                    {
+                        // If destination and source place overlap, skip if it would move it
+                        // by only < 1/64 of its size.
+                        skipOver = (srcAllocOffset - dstAllocOffset) * 64 < srcAllocSize;
+                    }
+
+                    if(skipOver)
+                    {
+                        freeSpaceDb.Register(dstBlockInfoIndex, dstOffset, srcAllocOffset - dstOffset);
+
+                        dstOffset = srcAllocOffset + srcAllocSize;
+                        ++srcSuballocIt;
+                    }
+                    // MOVE OPTION 1: Move the allocation inside the same block by decreasing offset.
+                    else
+                    {
+                        srcSuballocIt->offset = dstAllocOffset;
+                        srcSuballocIt->hAllocation->ChangeOffset(dstAllocOffset);
+                        dstOffset = dstAllocOffset + srcAllocSize;
+                        m_BytesMoved += srcAllocSize;
+                        ++m_AllocationsMoved;
+                        ++srcSuballocIt;
+
+                        move.srcBlockIndex = srcOrigBlockIndex;
+                        move.dstBlockIndex = dstOrigBlockIndex;
+                        move.srcOffset = srcAllocOffset;
+                        move.dstOffset = dstAllocOffset;
+                        move.size = srcAllocSize;
+
+                        moves.push_back(move);
+                    }
+                }
+                // Different block
+                else
+                {
+                    // MOVE OPTION 2: Move the allocation to a different block.
+
+                    VMA_ASSERT(dstBlockInfoIndex < srcBlockInfoIndex);
+                    VMA_ASSERT(dstAllocOffset + srcAllocSize <= dstBlockSize);
+
+                    VmaSuballocation suballoc = *srcSuballocIt;
+                    suballoc.offset = dstAllocOffset;
+                    suballoc.hAllocation->ChangeBlockAllocation(m_hAllocator, pDstBlock, dstAllocOffset);
+                    dstOffset = dstAllocOffset + srcAllocSize;
+                    m_BytesMoved += srcAllocSize;
+                    ++m_AllocationsMoved;
+
+                    VmaSuballocationList::iterator nextSuballocIt = srcSuballocIt;
+                    ++nextSuballocIt;
+                    pSrcMetadata->m_Suballocations.erase(srcSuballocIt);
+                    srcSuballocIt = nextSuballocIt;
+
+                    pDstMetadata->m_Suballocations.push_back(suballoc);
+
+                    move.srcBlockIndex = srcOrigBlockIndex;
+                    move.dstBlockIndex = dstOrigBlockIndex;
+                    move.srcOffset = srcAllocOffset;
+                    move.dstOffset = dstAllocOffset;
+                    move.size = srcAllocSize;
+
+                    moves.push_back(move);
+                }
+            }
+        }
+    }
+
+    m_BlockInfos.clear();
+
+    PostprocessMetadata();
+
+    return VK_SUCCESS;
+}
+
+void VmaDefragmentationAlgorithm_Fast::PreprocessMetadata()
+{
+    const size_t blockCount = m_pBlockVector->GetBlockCount();
+    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
+    {
+        VmaBlockMetadata_Generic* const pMetadata =
+            (VmaBlockMetadata_Generic*)m_pBlockVector->GetBlock(blockIndex)->m_pMetadata;
+        pMetadata->m_FreeCount = 0;
+        pMetadata->m_SumFreeSize = pMetadata->GetSize();
+        pMetadata->m_FreeSuballocationsBySize.clear();
+        for(VmaSuballocationList::iterator it = pMetadata->m_Suballocations.begin();
+            it != pMetadata->m_Suballocations.end(); )
+        {
+            if(it->type == VMA_SUBALLOCATION_TYPE_FREE)
+            {
+                VmaSuballocationList::iterator nextIt = it;
+                ++nextIt;
+                pMetadata->m_Suballocations.erase(it);
+                it = nextIt;
+            }
+            else
+            {
+                ++it;
+            }
+        }
+    }
+}
+
+void VmaDefragmentationAlgorithm_Fast::PostprocessMetadata()
+{
+    const size_t blockCount = m_pBlockVector->GetBlockCount();
+    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
+    {
+        VmaBlockMetadata_Generic* const pMetadata =
+            (VmaBlockMetadata_Generic*)m_pBlockVector->GetBlock(blockIndex)->m_pMetadata;
+        const VkDeviceSize blockSize = pMetadata->GetSize();
+
+        // No allocations in this block - entire area is free.
+        if(pMetadata->m_Suballocations.empty())
+        {
+            pMetadata->m_FreeCount = 1;
+            //pMetadata->m_SumFreeSize is already set to blockSize.
+            VmaSuballocation suballoc = {
+                0, // offset
+                blockSize, // size
+                VMA_NULL, // hAllocation
+                VMA_SUBALLOCATION_TYPE_FREE };
+            pMetadata->m_Suballocations.push_back(suballoc);
+            pMetadata->RegisterFreeSuballocation(pMetadata->m_Suballocations.begin());
+        }
+        // There are some allocations in this block.
+        else
+        {
+            VkDeviceSize offset = 0;
+            VmaSuballocationList::iterator it;
+            for(it = pMetadata->m_Suballocations.begin();
+                it != pMetadata->m_Suballocations.end();
+                ++it)
+            {
+                VMA_ASSERT(it->type != VMA_SUBALLOCATION_TYPE_FREE);
+                VMA_ASSERT(it->offset >= offset);
+
+                // Need to insert preceding free space.
+                if(it->offset > offset)
+                {
+                    ++pMetadata->m_FreeCount;
+                    const VkDeviceSize freeSize = it->offset - offset;
+                    VmaSuballocation suballoc = {
+                        offset, // offset
+                        freeSize, // size
+                        VMA_NULL, // hAllocation
+                        VMA_SUBALLOCATION_TYPE_FREE };
+                    VmaSuballocationList::iterator precedingFreeIt = pMetadata->m_Suballocations.insert(it, suballoc);
+                    if(freeSize >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
+                    {
+                        pMetadata->m_FreeSuballocationsBySize.push_back(precedingFreeIt);
+                    }
+                }
+
+                pMetadata->m_SumFreeSize -= it->size;
+                offset = it->offset + it->size;
+            }
+
+            // Need to insert trailing free space.
+            if(offset < blockSize)
+            {
+                ++pMetadata->m_FreeCount;
+                const VkDeviceSize freeSize = blockSize - offset;
+                VmaSuballocation suballoc = {
+                    offset, // offset
+                    freeSize, // size
+                    VMA_NULL, // hAllocation
+                    VMA_SUBALLOCATION_TYPE_FREE };
+                VMA_ASSERT(it == pMetadata->m_Suballocations.end());
+                VmaSuballocationList::iterator trailingFreeIt = pMetadata->m_Suballocations.insert(it, suballoc);
+                if(freeSize > VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
+                {
+                    pMetadata->m_FreeSuballocationsBySize.push_back(trailingFreeIt);
+                }
+            }
+
+            VMA_SORT(
+                pMetadata->m_FreeSuballocationsBySize.begin(),
+                pMetadata->m_FreeSuballocationsBySize.end(),
+                VmaSuballocationItemSizeLess());
+        }
+
+        VMA_HEAVY_ASSERT(pMetadata->Validate());
+    }
+}
+
+void VmaDefragmentationAlgorithm_Fast::InsertSuballoc(VmaBlockMetadata_Generic* pMetadata, const VmaSuballocation& suballoc)
+{
+    // TODO: Optimize somehow. Remember iterator instead of searching for it linearly.
+    VmaSuballocationList::iterator it = pMetadata->m_Suballocations.begin();
+    while(it != pMetadata->m_Suballocations.end())
+    {
+        if(it->offset < suballoc.offset)
+        {
+            ++it;
+        }
+    }
+    pMetadata->m_Suballocations.insert(it, suballoc);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaBlockVectorDefragmentationContext
+
+VmaBlockVectorDefragmentationContext::VmaBlockVectorDefragmentationContext(
+    VmaAllocator hAllocator,
+    VmaPool hCustomPool,
+    VmaBlockVector* pBlockVector,
+    uint32_t currFrameIndex) :
+    res(VK_SUCCESS),
+    mutexLocked(false),
+    blockContexts(VmaStlAllocator<VmaBlockDefragmentationContext>(hAllocator->GetAllocationCallbacks())),
+    defragmentationMoves(VmaStlAllocator<VmaDefragmentationMove>(hAllocator->GetAllocationCallbacks())),
+    defragmentationMovesProcessed(0),
+    defragmentationMovesCommitted(0),
+    hasDefragmentationPlan(0),
+    m_hAllocator(hAllocator),
+    m_hCustomPool(hCustomPool),
+    m_pBlockVector(pBlockVector),
+    m_CurrFrameIndex(currFrameIndex),
+    m_pAlgorithm(VMA_NULL),
+    m_Allocations(VmaStlAllocator<AllocInfo>(hAllocator->GetAllocationCallbacks())),
+    m_AllAllocations(false)
+{
+}
+
+VmaBlockVectorDefragmentationContext::~VmaBlockVectorDefragmentationContext()
+{
+    vma_delete(m_hAllocator, m_pAlgorithm);
+}
+
+void VmaBlockVectorDefragmentationContext::AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged)
+{
+    AllocInfo info = { hAlloc, pChanged };
+    m_Allocations.push_back(info);
+}
+
+void VmaBlockVectorDefragmentationContext::Begin(bool overlappingMoveSupported, VmaDefragmentationFlags flags)
+{
+    const bool allAllocations = m_AllAllocations ||
+        m_Allocations.size() == m_pBlockVector->CalcAllocationCount();
+
+    /********************************
+    HERE IS THE CHOICE OF DEFRAGMENTATION ALGORITHM.
+    ********************************/
+
+    /*
+    Fast algorithm is supported only when certain criteria are met:
+    - VMA_DEBUG_MARGIN is 0.
+    - All allocations in this block vector are moveable.
+    - There is no possibility of image/buffer granularity conflict.
+    - The defragmentation is not incremental
+    */
+    if(VMA_DEBUG_MARGIN == 0 &&
+        allAllocations &&
+        !m_pBlockVector->IsBufferImageGranularityConflictPossible() &&
+        !(flags & VMA_DEFRAGMENTATION_FLAG_INCREMENTAL))
+    {
+        m_pAlgorithm = vma_new(m_hAllocator, VmaDefragmentationAlgorithm_Fast)(
+            m_hAllocator, m_pBlockVector, m_CurrFrameIndex, overlappingMoveSupported);
+    }
+    else
+    {
+        m_pAlgorithm = vma_new(m_hAllocator, VmaDefragmentationAlgorithm_Generic)(
+            m_hAllocator, m_pBlockVector, m_CurrFrameIndex, overlappingMoveSupported);
+    }
+
+    if(allAllocations)
+    {
+        m_pAlgorithm->AddAll();
+    }
+    else
+    {
+        for(size_t i = 0, count = m_Allocations.size(); i < count; ++i)
+        {
+            m_pAlgorithm->AddAllocation(m_Allocations[i].hAlloc, m_Allocations[i].pChanged);
+        }
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaDefragmentationContext
+
+VmaDefragmentationContext_T::VmaDefragmentationContext_T(
+    VmaAllocator hAllocator,
+    uint32_t currFrameIndex,
+    uint32_t flags,
+    VmaDefragmentationStats* pStats) :
+    m_hAllocator(hAllocator),
+    m_CurrFrameIndex(currFrameIndex),
+    m_Flags(flags),
+    m_pStats(pStats),
+    m_CustomPoolContexts(VmaStlAllocator<VmaBlockVectorDefragmentationContext*>(hAllocator->GetAllocationCallbacks()))
+{
+    memset(m_DefaultPoolContexts, 0, sizeof(m_DefaultPoolContexts));
+}
+
+VmaDefragmentationContext_T::~VmaDefragmentationContext_T()
+{
+    for(size_t i = m_CustomPoolContexts.size(); i--; )
+    {
+        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_CustomPoolContexts[i];
+        pBlockVectorCtx->GetBlockVector()->DefragmentationEnd(pBlockVectorCtx, m_Flags, m_pStats);
+        vma_delete(m_hAllocator, pBlockVectorCtx);
+    }
+    for(size_t i = m_hAllocator->m_MemProps.memoryTypeCount; i--; )
+    {
+        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_DefaultPoolContexts[i];
+        if(pBlockVectorCtx)
+        {
+            pBlockVectorCtx->GetBlockVector()->DefragmentationEnd(pBlockVectorCtx, m_Flags, m_pStats);
+            vma_delete(m_hAllocator, pBlockVectorCtx);
+        }
+    }
+}
+
+void VmaDefragmentationContext_T::AddPools(uint32_t poolCount, const VmaPool* pPools)
+{
+    for(uint32_t poolIndex = 0; poolIndex < poolCount; ++poolIndex)
+    {
+        VmaPool pool = pPools[poolIndex];
+        VMA_ASSERT(pool);
+        // Pools with algorithm other than default are not defragmented.
+        if(pool->m_BlockVector.GetAlgorithm() == 0)
+        {
+            VmaBlockVectorDefragmentationContext* pBlockVectorDefragCtx = VMA_NULL;
+
+            for(size_t i = m_CustomPoolContexts.size(); i--; )
+            {
+                if(m_CustomPoolContexts[i]->GetCustomPool() == pool)
+                {
+                    pBlockVectorDefragCtx = m_CustomPoolContexts[i];
+                    break;
+                }
+            }
+
+            if(!pBlockVectorDefragCtx)
+            {
+                pBlockVectorDefragCtx = vma_new(m_hAllocator, VmaBlockVectorDefragmentationContext)(
+                    m_hAllocator,
+                    pool,
+                    &pool->m_BlockVector,
+                    m_CurrFrameIndex);
+                m_CustomPoolContexts.push_back(pBlockVectorDefragCtx);
+            }
+
+            pBlockVectorDefragCtx->AddAll();
+        }
+    }
+}
+
+void VmaDefragmentationContext_T::AddAllocations(
+    uint32_t allocationCount,
+    const VmaAllocation* pAllocations,
+    VkBool32* pAllocationsChanged)
+{
+    // Dispatch pAllocations among defragmentators. Create them when necessary.
+    for(uint32_t allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
+    {
+        const VmaAllocation hAlloc = pAllocations[allocIndex];
+        VMA_ASSERT(hAlloc);
+        // DedicatedAlloc cannot be defragmented.
+        if((hAlloc->GetType() == VmaAllocation_T::ALLOCATION_TYPE_BLOCK) &&
+            // Lost allocation cannot be defragmented.
+            (hAlloc->GetLastUseFrameIndex() != VMA_FRAME_INDEX_LOST))
+        {
+            VmaBlockVectorDefragmentationContext* pBlockVectorDefragCtx = VMA_NULL;
+
+            const VmaPool hAllocPool = hAlloc->GetBlock()->GetParentPool();
+            // This allocation belongs to custom pool.
+            if(hAllocPool != VK_NULL_HANDLE)
+            {
+                // Pools with algorithm other than default are not defragmented.
+                if(hAllocPool->m_BlockVector.GetAlgorithm() == 0)
+                {
+                    for(size_t i = m_CustomPoolContexts.size(); i--; )
+                    {
+                        if(m_CustomPoolContexts[i]->GetCustomPool() == hAllocPool)
+                        {
+                            pBlockVectorDefragCtx = m_CustomPoolContexts[i];
+                            break;
+                        }
+                    }
+                    if(!pBlockVectorDefragCtx)
+                    {
+                        pBlockVectorDefragCtx = vma_new(m_hAllocator, VmaBlockVectorDefragmentationContext)(
+                            m_hAllocator,
+                            hAllocPool,
+                            &hAllocPool->m_BlockVector,
+                            m_CurrFrameIndex);
+                        m_CustomPoolContexts.push_back(pBlockVectorDefragCtx);
+                    }
+                }
+            }
+            // This allocation belongs to default pool.
+            else
+            {
+                const uint32_t memTypeIndex = hAlloc->GetMemoryTypeIndex();
+                pBlockVectorDefragCtx = m_DefaultPoolContexts[memTypeIndex];
+                if(!pBlockVectorDefragCtx)
+                {
+                    pBlockVectorDefragCtx = vma_new(m_hAllocator, VmaBlockVectorDefragmentationContext)(
+                        m_hAllocator,
+                        VMA_NULL, // hCustomPool
+                        m_hAllocator->m_pBlockVectors[memTypeIndex],
+                        m_CurrFrameIndex);
+                    m_DefaultPoolContexts[memTypeIndex] = pBlockVectorDefragCtx;
+                }
+            }
+
+            if(pBlockVectorDefragCtx)
+            {
+                VkBool32* const pChanged = (pAllocationsChanged != VMA_NULL) ?
+                    &pAllocationsChanged[allocIndex] : VMA_NULL;
+                pBlockVectorDefragCtx->AddAllocation(hAlloc, pChanged);
+            }
+        }
+    }
+}
+
+VkResult VmaDefragmentationContext_T::Defragment(
+    VkDeviceSize maxCpuBytesToMove, uint32_t maxCpuAllocationsToMove,
+    VkDeviceSize maxGpuBytesToMove, uint32_t maxGpuAllocationsToMove,
+    VkCommandBuffer commandBuffer, VmaDefragmentationStats* pStats, VmaDefragmentationFlags flags)
+{
+    if(pStats)
+    {
+        memset(pStats, 0, sizeof(VmaDefragmentationStats));
+    }
+
+    if(flags & VMA_DEFRAGMENTATION_FLAG_INCREMENTAL)
+    {
+        // For incremental defragmetnations, we just earmark how much we can move
+        // The real meat is in the defragmentation steps
+        m_MaxCpuBytesToMove = maxCpuBytesToMove;
+        m_MaxCpuAllocationsToMove = maxCpuAllocationsToMove;
+
+        m_MaxGpuBytesToMove = maxGpuBytesToMove;
+        m_MaxGpuAllocationsToMove = maxGpuAllocationsToMove;
+
+        if(m_MaxCpuBytesToMove == 0 && m_MaxCpuAllocationsToMove == 0 &&
+            m_MaxGpuBytesToMove == 0 && m_MaxGpuAllocationsToMove == 0)
+            return VK_SUCCESS;
+
+        return VK_NOT_READY;
+    }
+
+    if(commandBuffer == VK_NULL_HANDLE)
+    {
+        maxGpuBytesToMove = 0;
+        maxGpuAllocationsToMove = 0;
+    }
+
+    VkResult res = VK_SUCCESS;
+
+    // Process default pools.
+    for(uint32_t memTypeIndex = 0;
+        memTypeIndex < m_hAllocator->GetMemoryTypeCount() && res >= VK_SUCCESS;
+        ++memTypeIndex)
+    {
+        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_DefaultPoolContexts[memTypeIndex];
+        if(pBlockVectorCtx)
+        {
+            VMA_ASSERT(pBlockVectorCtx->GetBlockVector());
+            pBlockVectorCtx->GetBlockVector()->Defragment(
+                pBlockVectorCtx,
+                pStats, flags,
+                maxCpuBytesToMove, maxCpuAllocationsToMove,
+                maxGpuBytesToMove, maxGpuAllocationsToMove,
+                commandBuffer);
+            if(pBlockVectorCtx->res != VK_SUCCESS)
+            {
+                res = pBlockVectorCtx->res;
+            }
+        }
+    }
+
+    // Process custom pools.
+    for(size_t customCtxIndex = 0, customCtxCount = m_CustomPoolContexts.size();
+        customCtxIndex < customCtxCount && res >= VK_SUCCESS;
+        ++customCtxIndex)
+    {
+        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_CustomPoolContexts[customCtxIndex];
+        VMA_ASSERT(pBlockVectorCtx && pBlockVectorCtx->GetBlockVector());
+        pBlockVectorCtx->GetBlockVector()->Defragment(
+            pBlockVectorCtx,
+            pStats, flags,
+            maxCpuBytesToMove, maxCpuAllocationsToMove,
+            maxGpuBytesToMove, maxGpuAllocationsToMove,
+            commandBuffer);
+        if(pBlockVectorCtx->res != VK_SUCCESS)
+        {
+            res = pBlockVectorCtx->res;
+        }
+    }
+
+    return res;
+}
+
+VkResult VmaDefragmentationContext_T::DefragmentPassBegin(VmaDefragmentationPassInfo* pInfo)
+{
+    VmaDefragmentationPassMoveInfo* pCurrentMove = pInfo->pMoves;
+    uint32_t movesLeft = pInfo->moveCount;
+
+    // Process default pools.
+    for(uint32_t memTypeIndex = 0;
+        memTypeIndex < m_hAllocator->GetMemoryTypeCount();
+        ++memTypeIndex)
+    {
+        VmaBlockVectorDefragmentationContext *pBlockVectorCtx = m_DefaultPoolContexts[memTypeIndex];
+        if(pBlockVectorCtx)
+        {
+            VMA_ASSERT(pBlockVectorCtx->GetBlockVector());
+
+            if(!pBlockVectorCtx->hasDefragmentationPlan)
+            {
+                pBlockVectorCtx->GetBlockVector()->Defragment(
+                    pBlockVectorCtx,
+                    m_pStats, m_Flags,
+                    m_MaxCpuBytesToMove, m_MaxCpuAllocationsToMove,
+                    m_MaxGpuBytesToMove, m_MaxGpuAllocationsToMove,
+                    VK_NULL_HANDLE);
+
+                if(pBlockVectorCtx->res < VK_SUCCESS)
+                    continue;
+
+                pBlockVectorCtx->hasDefragmentationPlan = true;
+            }
+
+            const uint32_t processed = pBlockVectorCtx->GetBlockVector()->ProcessDefragmentations(
+                pBlockVectorCtx,
+                pCurrentMove, movesLeft);
+
+            movesLeft -= processed;
+            pCurrentMove += processed;
+        }
+    }
+
+    // Process custom pools.
+    for(size_t customCtxIndex = 0, customCtxCount = m_CustomPoolContexts.size();
+        customCtxIndex < customCtxCount;
+        ++customCtxIndex)
+    {
+        VmaBlockVectorDefragmentationContext *pBlockVectorCtx = m_CustomPoolContexts[customCtxIndex];
+        VMA_ASSERT(pBlockVectorCtx && pBlockVectorCtx->GetBlockVector());
+
+        if(!pBlockVectorCtx->hasDefragmentationPlan)
+        {
+            pBlockVectorCtx->GetBlockVector()->Defragment(
+                pBlockVectorCtx,
+                m_pStats, m_Flags,
+                m_MaxCpuBytesToMove, m_MaxCpuAllocationsToMove,
+                m_MaxGpuBytesToMove, m_MaxGpuAllocationsToMove,
+                VK_NULL_HANDLE);
+
+            if(pBlockVectorCtx->res < VK_SUCCESS)
+                continue;
+
+            pBlockVectorCtx->hasDefragmentationPlan = true;
+        }
+
+        const uint32_t processed = pBlockVectorCtx->GetBlockVector()->ProcessDefragmentations(
+            pBlockVectorCtx,
+            pCurrentMove, movesLeft);
+
+        movesLeft -= processed;
+        pCurrentMove += processed;
+    }
+
+    pInfo->moveCount = pInfo->moveCount - movesLeft;
+
+    return VK_SUCCESS;
+}
+VkResult VmaDefragmentationContext_T::DefragmentPassEnd()
+{
+    VkResult res = VK_SUCCESS;
+
+    // Process default pools.
+    for(uint32_t memTypeIndex = 0;
+        memTypeIndex < m_hAllocator->GetMemoryTypeCount();
+        ++memTypeIndex)
+    {
+        VmaBlockVectorDefragmentationContext *pBlockVectorCtx = m_DefaultPoolContexts[memTypeIndex];
+        if(pBlockVectorCtx)
+        {
+            VMA_ASSERT(pBlockVectorCtx->GetBlockVector());
+
+            if(!pBlockVectorCtx->hasDefragmentationPlan)
+            {
+                res = VK_NOT_READY;
+                continue;
+            }
+
+            pBlockVectorCtx->GetBlockVector()->CommitDefragmentations(
+                pBlockVectorCtx, m_pStats);
+
+            if(pBlockVectorCtx->defragmentationMoves.size() != pBlockVectorCtx->defragmentationMovesCommitted)
+                res = VK_NOT_READY;
+        }
+    }
+
+    // Process custom pools.
+    for(size_t customCtxIndex = 0, customCtxCount = m_CustomPoolContexts.size();
+        customCtxIndex < customCtxCount;
+        ++customCtxIndex)
+    {
+        VmaBlockVectorDefragmentationContext *pBlockVectorCtx = m_CustomPoolContexts[customCtxIndex];
+        VMA_ASSERT(pBlockVectorCtx && pBlockVectorCtx->GetBlockVector());
+
+        if(!pBlockVectorCtx->hasDefragmentationPlan)
+        {
+            res = VK_NOT_READY;
+            continue;
+        }
+
+        pBlockVectorCtx->GetBlockVector()->CommitDefragmentations(
+            pBlockVectorCtx, m_pStats);
+
+        if(pBlockVectorCtx->defragmentationMoves.size() != pBlockVectorCtx->defragmentationMovesCommitted)
+            res = VK_NOT_READY;
+    }
+
+    return res;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaRecorder
+
+#if VMA_RECORDING_ENABLED
+
+VmaRecorder::VmaRecorder() :
+    m_UseMutex(true),
+    m_Flags(0),
+    m_File(VMA_NULL),
+    m_RecordingStartTime(std::chrono::high_resolution_clock::now())
+{
+}
+
+VkResult VmaRecorder::Init(const VmaRecordSettings& settings, bool useMutex)
+{
+    m_UseMutex = useMutex;
+    m_Flags = settings.flags;
+
+#if defined(_WIN32)
+    // Open file for writing.
+    errno_t err = fopen_s(&m_File, settings.pFilePath, "wb");
+
+    if(err != 0)
+    {
+        return VK_ERROR_INITIALIZATION_FAILED;
+    }
+#else
+    // Open file for writing.
+    m_File = fopen(settings.pFilePath, "wb");
+
+    if(m_File == 0)
+    {
+        return VK_ERROR_INITIALIZATION_FAILED;
+    }
+#endif
+
+    // Write header.
+    fprintf(m_File, "%s\n", "Vulkan Memory Allocator,Calls recording");
+    fprintf(m_File, "%s\n", "1,8");
+
+    return VK_SUCCESS;
+}
+
+VmaRecorder::~VmaRecorder()
+{
+    if(m_File != VMA_NULL)
+    {
+        fclose(m_File);
+    }
+}
+
+void VmaRecorder::RecordCreateAllocator(uint32_t frameIndex)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaCreateAllocator\n", callParams.threadId, callParams.time, frameIndex);
+    Flush();
+}
+
+void VmaRecorder::RecordDestroyAllocator(uint32_t frameIndex)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaDestroyAllocator\n", callParams.threadId, callParams.time, frameIndex);
+    Flush();
+}
+
+void VmaRecorder::RecordCreatePool(uint32_t frameIndex, const VmaPoolCreateInfo& createInfo, VmaPool pool)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaCreatePool,%u,%u,%llu,%llu,%llu,%u,%p\n", callParams.threadId, callParams.time, frameIndex,
+        createInfo.memoryTypeIndex,
+        createInfo.flags,
+        createInfo.blockSize,
+        (uint64_t)createInfo.minBlockCount,
+        (uint64_t)createInfo.maxBlockCount,
+        createInfo.frameInUseCount,
+        pool);
+    Flush();
+}
+
+void VmaRecorder::RecordDestroyPool(uint32_t frameIndex, VmaPool pool)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaDestroyPool,%p\n", callParams.threadId, callParams.time, frameIndex,
+        pool);
+    Flush();
+}
+
+void VmaRecorder::RecordAllocateMemory(uint32_t frameIndex,
+        const VkMemoryRequirements& vkMemReq,
+        const VmaAllocationCreateInfo& createInfo,
+        VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
+    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemory,%llu,%llu,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
+        vkMemReq.size,
+        vkMemReq.alignment,
+        vkMemReq.memoryTypeBits,
+        createInfo.flags,
+        createInfo.usage,
+        createInfo.requiredFlags,
+        createInfo.preferredFlags,
+        createInfo.memoryTypeBits,
+        createInfo.pool,
+        allocation,
+        userDataStr.GetString());
+    Flush();
+}
+
+void VmaRecorder::RecordAllocateMemoryPages(uint32_t frameIndex,
+    const VkMemoryRequirements& vkMemReq,
+    const VmaAllocationCreateInfo& createInfo,
+    uint64_t allocationCount,
+    const VmaAllocation* pAllocations)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
+    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemoryPages,%llu,%llu,%u,%u,%u,%u,%u,%u,%p,", callParams.threadId, callParams.time, frameIndex,
+        vkMemReq.size,
+        vkMemReq.alignment,
+        vkMemReq.memoryTypeBits,
+        createInfo.flags,
+        createInfo.usage,
+        createInfo.requiredFlags,
+        createInfo.preferredFlags,
+        createInfo.memoryTypeBits,
+        createInfo.pool);
+    PrintPointerList(allocationCount, pAllocations);
+    fprintf(m_File, ",%s\n", userDataStr.GetString());
+    Flush();
+}
+
+void VmaRecorder::RecordAllocateMemoryForBuffer(uint32_t frameIndex,
+    const VkMemoryRequirements& vkMemReq,
+    bool requiresDedicatedAllocation,
+    bool prefersDedicatedAllocation,
+    const VmaAllocationCreateInfo& createInfo,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
+    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemoryForBuffer,%llu,%llu,%u,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
+        vkMemReq.size,
+        vkMemReq.alignment,
+        vkMemReq.memoryTypeBits,
+        requiresDedicatedAllocation ? 1 : 0,
+        prefersDedicatedAllocation ? 1 : 0,
+        createInfo.flags,
+        createInfo.usage,
+        createInfo.requiredFlags,
+        createInfo.preferredFlags,
+        createInfo.memoryTypeBits,
+        createInfo.pool,
+        allocation,
+        userDataStr.GetString());
+    Flush();
+}
+
+void VmaRecorder::RecordAllocateMemoryForImage(uint32_t frameIndex,
+    const VkMemoryRequirements& vkMemReq,
+    bool requiresDedicatedAllocation,
+    bool prefersDedicatedAllocation,
+    const VmaAllocationCreateInfo& createInfo,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
+    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemoryForImage,%llu,%llu,%u,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
+        vkMemReq.size,
+        vkMemReq.alignment,
+        vkMemReq.memoryTypeBits,
+        requiresDedicatedAllocation ? 1 : 0,
+        prefersDedicatedAllocation ? 1 : 0,
+        createInfo.flags,
+        createInfo.usage,
+        createInfo.requiredFlags,
+        createInfo.preferredFlags,
+        createInfo.memoryTypeBits,
+        createInfo.pool,
+        allocation,
+        userDataStr.GetString());
+    Flush();
+}
+
+void VmaRecorder::RecordFreeMemory(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaFreeMemory,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordFreeMemoryPages(uint32_t frameIndex,
+    uint64_t allocationCount,
+    const VmaAllocation* pAllocations)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaFreeMemoryPages,", callParams.threadId, callParams.time, frameIndex);
+    PrintPointerList(allocationCount, pAllocations);
+    fprintf(m_File, "\n");
+    Flush();
+}
+
+void VmaRecorder::RecordSetAllocationUserData(uint32_t frameIndex,
+    VmaAllocation allocation,
+    const void* pUserData)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    UserDataString userDataStr(
+        allocation->IsUserDataString() ? VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT : 0,
+        pUserData);
+    fprintf(m_File, "%u,%.3f,%u,vmaSetAllocationUserData,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
+        allocation,
+        userDataStr.GetString());
+    Flush();
+}
+
+void VmaRecorder::RecordCreateLostAllocation(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaCreateLostAllocation,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordMapMemory(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaMapMemory,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordUnmapMemory(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaUnmapMemory,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordFlushAllocation(uint32_t frameIndex,
+    VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaFlushAllocation,%p,%llu,%llu\n", callParams.threadId, callParams.time, frameIndex,
+        allocation,
+        offset,
+        size);
+    Flush();
+}
+
+void VmaRecorder::RecordInvalidateAllocation(uint32_t frameIndex,
+    VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaInvalidateAllocation,%p,%llu,%llu\n", callParams.threadId, callParams.time, frameIndex,
+        allocation,
+        offset,
+        size);
+    Flush();
+}
+
+void VmaRecorder::RecordCreateBuffer(uint32_t frameIndex,
+    const VkBufferCreateInfo& bufCreateInfo,
+    const VmaAllocationCreateInfo& allocCreateInfo,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    UserDataString userDataStr(allocCreateInfo.flags, allocCreateInfo.pUserData);
+    fprintf(m_File, "%u,%.3f,%u,vmaCreateBuffer,%u,%llu,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
+        bufCreateInfo.flags,
+        bufCreateInfo.size,
+        bufCreateInfo.usage,
+        bufCreateInfo.sharingMode,
+        allocCreateInfo.flags,
+        allocCreateInfo.usage,
+        allocCreateInfo.requiredFlags,
+        allocCreateInfo.preferredFlags,
+        allocCreateInfo.memoryTypeBits,
+        allocCreateInfo.pool,
+        allocation,
+        userDataStr.GetString());
+    Flush();
+}
+
+void VmaRecorder::RecordCreateImage(uint32_t frameIndex,
+    const VkImageCreateInfo& imageCreateInfo,
+    const VmaAllocationCreateInfo& allocCreateInfo,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    UserDataString userDataStr(allocCreateInfo.flags, allocCreateInfo.pUserData);
+    fprintf(m_File, "%u,%.3f,%u,vmaCreateImage,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
+        imageCreateInfo.flags,
+        imageCreateInfo.imageType,
+        imageCreateInfo.format,
+        imageCreateInfo.extent.width,
+        imageCreateInfo.extent.height,
+        imageCreateInfo.extent.depth,
+        imageCreateInfo.mipLevels,
+        imageCreateInfo.arrayLayers,
+        imageCreateInfo.samples,
+        imageCreateInfo.tiling,
+        imageCreateInfo.usage,
+        imageCreateInfo.sharingMode,
+        imageCreateInfo.initialLayout,
+        allocCreateInfo.flags,
+        allocCreateInfo.usage,
+        allocCreateInfo.requiredFlags,
+        allocCreateInfo.preferredFlags,
+        allocCreateInfo.memoryTypeBits,
+        allocCreateInfo.pool,
+        allocation,
+        userDataStr.GetString());
+    Flush();
+}
+
+void VmaRecorder::RecordDestroyBuffer(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaDestroyBuffer,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordDestroyImage(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaDestroyImage,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordTouchAllocation(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaTouchAllocation,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordGetAllocationInfo(uint32_t frameIndex,
+    VmaAllocation allocation)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaGetAllocationInfo,%p\n", callParams.threadId, callParams.time, frameIndex,
+        allocation);
+    Flush();
+}
+
+void VmaRecorder::RecordMakePoolAllocationsLost(uint32_t frameIndex,
+    VmaPool pool)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaMakePoolAllocationsLost,%p\n", callParams.threadId, callParams.time, frameIndex,
+        pool);
+    Flush();
+}
+
+void VmaRecorder::RecordDefragmentationBegin(uint32_t frameIndex,
+    const VmaDefragmentationInfo2& info,
+    VmaDefragmentationContext ctx)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaDefragmentationBegin,%u,", callParams.threadId, callParams.time, frameIndex,
+        info.flags);
+    PrintPointerList(info.allocationCount, info.pAllocations);
+    fprintf(m_File, ",");
+    PrintPointerList(info.poolCount, info.pPools);
+    fprintf(m_File, ",%llu,%u,%llu,%u,%p,%p\n",
+        info.maxCpuBytesToMove,
+        info.maxCpuAllocationsToMove,
+        info.maxGpuBytesToMove,
+        info.maxGpuAllocationsToMove,
+        info.commandBuffer,
+        ctx);
+    Flush();
+}
+
+void VmaRecorder::RecordDefragmentationEnd(uint32_t frameIndex,
+    VmaDefragmentationContext ctx)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaDefragmentationEnd,%p\n", callParams.threadId, callParams.time, frameIndex,
+        ctx);
+    Flush();
+}
+
+void VmaRecorder::RecordSetPoolName(uint32_t frameIndex,
+    VmaPool pool,
+    const char* name)
+{
+    CallParams callParams;
+    GetBasicParams(callParams);
+
+    VmaMutexLock lock(m_FileMutex, m_UseMutex);
+    fprintf(m_File, "%u,%.3f,%u,vmaSetPoolName,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
+        pool, name != VMA_NULL ? name : "");
+    Flush();
+}
+
+VmaRecorder::UserDataString::UserDataString(VmaAllocationCreateFlags allocFlags, const void* pUserData)
+{
+    if(pUserData != VMA_NULL)
+    {
+        if((allocFlags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0)
+        {
+            m_Str = (const char*)pUserData;
+        }
+        else
+        {
+            // If VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is not specified, convert the string's memory address to a string and store it.
+            snprintf(m_PtrStr, 17, "%p", pUserData);
+            m_Str = m_PtrStr;
+        }
+    }
+    else
+    {
+        m_Str = "";
+    }
+}
+
+void VmaRecorder::WriteConfiguration(
+    const VkPhysicalDeviceProperties& devProps,
+    const VkPhysicalDeviceMemoryProperties& memProps,
+    uint32_t vulkanApiVersion,
+    bool dedicatedAllocationExtensionEnabled,
+    bool bindMemory2ExtensionEnabled,
+    bool memoryBudgetExtensionEnabled,
+    bool deviceCoherentMemoryExtensionEnabled)
+{
+    fprintf(m_File, "Config,Begin\n");
+
+    fprintf(m_File, "VulkanApiVersion,%u,%u\n", VK_VERSION_MAJOR(vulkanApiVersion), VK_VERSION_MINOR(vulkanApiVersion));
+
+    fprintf(m_File, "PhysicalDevice,apiVersion,%u\n", devProps.apiVersion);
+    fprintf(m_File, "PhysicalDevice,driverVersion,%u\n", devProps.driverVersion);
+    fprintf(m_File, "PhysicalDevice,vendorID,%u\n", devProps.vendorID);
+    fprintf(m_File, "PhysicalDevice,deviceID,%u\n", devProps.deviceID);
+    fprintf(m_File, "PhysicalDevice,deviceType,%u\n", devProps.deviceType);
+    fprintf(m_File, "PhysicalDevice,deviceName,%s\n", devProps.deviceName);
+
+    fprintf(m_File, "PhysicalDeviceLimits,maxMemoryAllocationCount,%u\n", devProps.limits.maxMemoryAllocationCount);
+    fprintf(m_File, "PhysicalDeviceLimits,bufferImageGranularity,%llu\n", devProps.limits.bufferImageGranularity);
+    fprintf(m_File, "PhysicalDeviceLimits,nonCoherentAtomSize,%llu\n", devProps.limits.nonCoherentAtomSize);
+
+    fprintf(m_File, "PhysicalDeviceMemory,HeapCount,%u\n", memProps.memoryHeapCount);
+    for(uint32_t i = 0; i < memProps.memoryHeapCount; ++i)
+    {
+        fprintf(m_File, "PhysicalDeviceMemory,Heap,%u,size,%llu\n", i, memProps.memoryHeaps[i].size);
+        fprintf(m_File, "PhysicalDeviceMemory,Heap,%u,flags,%u\n", i, memProps.memoryHeaps[i].flags);
+    }
+    fprintf(m_File, "PhysicalDeviceMemory,TypeCount,%u\n", memProps.memoryTypeCount);
+    for(uint32_t i = 0; i < memProps.memoryTypeCount; ++i)
+    {
+        fprintf(m_File, "PhysicalDeviceMemory,Type,%u,heapIndex,%u\n", i, memProps.memoryTypes[i].heapIndex);
+        fprintf(m_File, "PhysicalDeviceMemory,Type,%u,propertyFlags,%u\n", i, memProps.memoryTypes[i].propertyFlags);
+    }
+
+    fprintf(m_File, "Extension,VK_KHR_dedicated_allocation,%u\n", dedicatedAllocationExtensionEnabled ? 1 : 0);
+    fprintf(m_File, "Extension,VK_KHR_bind_memory2,%u\n", bindMemory2ExtensionEnabled ? 1 : 0);
+    fprintf(m_File, "Extension,VK_EXT_memory_budget,%u\n", memoryBudgetExtensionEnabled ? 1 : 0);
+    fprintf(m_File, "Extension,VK_AMD_device_coherent_memory,%u\n", deviceCoherentMemoryExtensionEnabled ? 1 : 0);
+
+    fprintf(m_File, "Macro,VMA_DEBUG_ALWAYS_DEDICATED_MEMORY,%u\n", VMA_DEBUG_ALWAYS_DEDICATED_MEMORY ? 1 : 0);
+    fprintf(m_File, "Macro,VMA_DEBUG_ALIGNMENT,%llu\n", (VkDeviceSize)VMA_DEBUG_ALIGNMENT);
+    fprintf(m_File, "Macro,VMA_DEBUG_MARGIN,%llu\n", (VkDeviceSize)VMA_DEBUG_MARGIN);
+    fprintf(m_File, "Macro,VMA_DEBUG_INITIALIZE_ALLOCATIONS,%u\n", VMA_DEBUG_INITIALIZE_ALLOCATIONS ? 1 : 0);
+    fprintf(m_File, "Macro,VMA_DEBUG_DETECT_CORRUPTION,%u\n", VMA_DEBUG_DETECT_CORRUPTION ? 1 : 0);
+    fprintf(m_File, "Macro,VMA_DEBUG_GLOBAL_MUTEX,%u\n", VMA_DEBUG_GLOBAL_MUTEX ? 1 : 0);
+    fprintf(m_File, "Macro,VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY,%llu\n", (VkDeviceSize)VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY);
+    fprintf(m_File, "Macro,VMA_SMALL_HEAP_MAX_SIZE,%llu\n", (VkDeviceSize)VMA_SMALL_HEAP_MAX_SIZE);
+    fprintf(m_File, "Macro,VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE,%llu\n", (VkDeviceSize)VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE);
+
+    fprintf(m_File, "Config,End\n");
+}
+
+void VmaRecorder::GetBasicParams(CallParams& outParams)
+{
+    #if defined(_WIN32)
+        outParams.threadId = GetCurrentThreadId();
+    #else
+        // Use C++11 features to get thread id and convert it to uint32_t.
+        // There is room for optimization since sstream is quite slow.
+        // Is there a better way to convert std::this_thread::get_id() to uint32_t?
+        std::thread::id thread_id = std::this_thread::get_id();
+        std::stringstream thread_id_to_string_converter;
+        thread_id_to_string_converter << thread_id;
+        std::string thread_id_as_string = thread_id_to_string_converter.str();
+        outParams.threadId = static_cast<uint32_t>(std::stoi(thread_id_as_string.c_str()));
+    #endif
+
+    auto current_time = std::chrono::high_resolution_clock::now();
+
+    outParams.time = std::chrono::duration<double, std::chrono::seconds::period>(current_time - m_RecordingStartTime).count();
+}
+
+void VmaRecorder::PrintPointerList(uint64_t count, const VmaAllocation* pItems)
+{
+    if(count)
+    {
+        fprintf(m_File, "%p", pItems[0]);
+        for(uint64_t i = 1; i < count; ++i)
+        {
+            fprintf(m_File, " %p", pItems[i]);
+        }
+    }
+}
+
+void VmaRecorder::Flush()
+{
+    if((m_Flags & VMA_RECORD_FLUSH_AFTER_CALL_BIT) != 0)
+    {
+        fflush(m_File);
+    }
+}
+
+#endif // #if VMA_RECORDING_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaAllocationObjectAllocator
+
+VmaAllocationObjectAllocator::VmaAllocationObjectAllocator(const VkAllocationCallbacks* pAllocationCallbacks) :
+    m_Allocator(pAllocationCallbacks, 1024)
+{
+}
+
+template<typename... Types> VmaAllocation VmaAllocationObjectAllocator::Allocate(Types... args)
+{
+    VmaMutexLock mutexLock(m_Mutex);
+    return m_Allocator.Alloc<Types...>(std::forward<Types>(args)...);
+}
+
+void VmaAllocationObjectAllocator::Free(VmaAllocation hAlloc)
+{
+    VmaMutexLock mutexLock(m_Mutex);
+    m_Allocator.Free(hAlloc);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// VmaAllocator_T
+
+VmaAllocator_T::VmaAllocator_T(const VmaAllocatorCreateInfo* pCreateInfo) :
+    m_UseMutex((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT) == 0),
+    m_VulkanApiVersion(pCreateInfo->vulkanApiVersion != 0 ? pCreateInfo->vulkanApiVersion : VK_API_VERSION_1_0),
+    m_UseKhrDedicatedAllocation((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT) != 0),
+    m_UseKhrBindMemory2((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0),
+    m_UseExtMemoryBudget((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0),
+    m_UseAmdDeviceCoherentMemory((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT) != 0),
+    m_UseKhrBufferDeviceAddress((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT) != 0),
+    m_hDevice(pCreateInfo->device),
+    m_hInstance(pCreateInfo->instance),
+    m_AllocationCallbacksSpecified(pCreateInfo->pAllocationCallbacks != VMA_NULL),
+    m_AllocationCallbacks(pCreateInfo->pAllocationCallbacks ?
+        *pCreateInfo->pAllocationCallbacks : VmaEmptyAllocationCallbacks),
+    m_AllocationObjectAllocator(&m_AllocationCallbacks),
+    m_HeapSizeLimitMask(0),
+    m_PreferredLargeHeapBlockSize(0),
+    m_PhysicalDevice(pCreateInfo->physicalDevice),
+    m_CurrentFrameIndex(0),
+    m_GpuDefragmentationMemoryTypeBits(UINT32_MAX),
+    m_Pools(VmaStlAllocator<VmaPool>(GetAllocationCallbacks())),
+    m_NextPoolId(0),
+    m_GlobalMemoryTypeBits(UINT32_MAX)
+#if VMA_RECORDING_ENABLED
+    ,m_pRecorder(VMA_NULL)
+#endif
+{
+    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        m_UseKhrDedicatedAllocation = false;
+        m_UseKhrBindMemory2 = false;
+    }
+
+    if(VMA_DEBUG_DETECT_CORRUPTION)
+    {
+        // Needs to be multiply of uint32_t size because we are going to write VMA_CORRUPTION_DETECTION_MAGIC_VALUE to it.
+        VMA_ASSERT(VMA_DEBUG_MARGIN % sizeof(uint32_t) == 0);
+    }
+
+    VMA_ASSERT(pCreateInfo->physicalDevice && pCreateInfo->device && pCreateInfo->instance);
+
+    if(m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0))
+    {
+#if !(VMA_DEDICATED_ALLOCATION)
+        if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT) != 0)
+        {
+            VMA_ASSERT(0 && "VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT set but required extensions are disabled by preprocessor macros.");
+        }
+#endif
+#if !(VMA_BIND_MEMORY2)
+        if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0)
+        {
+            VMA_ASSERT(0 && "VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT set but required extension is disabled by preprocessor macros.");
+        }
+#endif
+    }
+#if !(VMA_MEMORY_BUDGET)
+    if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0)
+    {
+        VMA_ASSERT(0 && "VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT set but required extension is disabled by preprocessor macros.");
+    }
+#endif
+#if !(VMA_BUFFER_DEVICE_ADDRESS)
+    if(m_UseKhrBufferDeviceAddress)
+    {
+        VMA_ASSERT(0 && "VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT is set but required extension or Vulkan 1.2 is not available in your Vulkan header or its support in VMA has been disabled by a preprocessor macro.");
+    }
+#endif
+#if VMA_VULKAN_VERSION < 1002000
+    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 2, 0))
+    {
+        VMA_ASSERT(0 && "vulkanApiVersion >= VK_API_VERSION_1_2 but required Vulkan version is disabled by preprocessor macros.");
+    }
+#endif
+#if VMA_VULKAN_VERSION < 1001000
+    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        VMA_ASSERT(0 && "vulkanApiVersion >= VK_API_VERSION_1_1 but required Vulkan version is disabled by preprocessor macros.");
+    }
+#endif
+
+    memset(&m_DeviceMemoryCallbacks, 0 ,sizeof(m_DeviceMemoryCallbacks));
+    memset(&m_PhysicalDeviceProperties, 0, sizeof(m_PhysicalDeviceProperties));
+    memset(&m_MemProps, 0, sizeof(m_MemProps));
+
+    memset(&m_pBlockVectors, 0, sizeof(m_pBlockVectors));
+    memset(&m_pDedicatedAllocations, 0, sizeof(m_pDedicatedAllocations));
+    memset(&m_VulkanFunctions, 0, sizeof(m_VulkanFunctions));
+
+    if(pCreateInfo->pDeviceMemoryCallbacks != VMA_NULL)
+    {
+        m_DeviceMemoryCallbacks.pUserData = pCreateInfo->pDeviceMemoryCallbacks->pUserData;
+        m_DeviceMemoryCallbacks.pfnAllocate = pCreateInfo->pDeviceMemoryCallbacks->pfnAllocate;
+        m_DeviceMemoryCallbacks.pfnFree = pCreateInfo->pDeviceMemoryCallbacks->pfnFree;
+    }
+
+    ImportVulkanFunctions(pCreateInfo->pVulkanFunctions);
+
+    (*m_VulkanFunctions.vkGetPhysicalDeviceProperties)(m_PhysicalDevice, &m_PhysicalDeviceProperties);
+    (*m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties)(m_PhysicalDevice, &m_MemProps);
+
+    VMA_ASSERT(VmaIsPow2(VMA_DEBUG_ALIGNMENT));
+    VMA_ASSERT(VmaIsPow2(VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY));
+    VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.bufferImageGranularity));
+    VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.nonCoherentAtomSize));
+
+    m_PreferredLargeHeapBlockSize = (pCreateInfo->preferredLargeHeapBlockSize != 0) ?
+        pCreateInfo->preferredLargeHeapBlockSize : static_cast<VkDeviceSize>(VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE);
+
+    m_GlobalMemoryTypeBits = CalculateGlobalMemoryTypeBits();
+
+    if(pCreateInfo->pHeapSizeLimit != VMA_NULL)
+    {
+        for(uint32_t heapIndex = 0; heapIndex < GetMemoryHeapCount(); ++heapIndex)
+        {
+            const VkDeviceSize limit = pCreateInfo->pHeapSizeLimit[heapIndex];
+            if(limit != VK_WHOLE_SIZE)
+            {
+                m_HeapSizeLimitMask |= 1u << heapIndex;
+                if(limit < m_MemProps.memoryHeaps[heapIndex].size)
+                {
+                    m_MemProps.memoryHeaps[heapIndex].size = limit;
+                }
+            }
+        }
+    }
+
+    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
+    {
+        const VkDeviceSize preferredBlockSize = CalcPreferredBlockSize(memTypeIndex);
+
+        m_pBlockVectors[memTypeIndex] = vma_new(this, VmaBlockVector)(
+            this,
+            VK_NULL_HANDLE, // hParentPool
+            memTypeIndex,
+            preferredBlockSize,
+            0,
+            SIZE_MAX,
+            GetBufferImageGranularity(),
+            pCreateInfo->frameInUseCount,
+            false, // explicitBlockSize
+            false, // linearAlgorithm
+            false); // exportable
+        // No need to call m_pBlockVectors[memTypeIndex][blockVectorTypeIndex]->CreateMinBlocks here,
+        // becase minBlockCount is 0.
+        m_pDedicatedAllocations[memTypeIndex] = vma_new(this, AllocationVectorType)(VmaStlAllocator<VmaAllocation>(GetAllocationCallbacks()));
+
+    }
+}
+
+VkResult VmaAllocator_T::Init(const VmaAllocatorCreateInfo* pCreateInfo)
+{
+    VkResult res = VK_SUCCESS;
+
+    if(pCreateInfo->pRecordSettings != VMA_NULL &&
+        !VmaStrIsEmpty(pCreateInfo->pRecordSettings->pFilePath))
+    {
+#if VMA_RECORDING_ENABLED
+        m_pRecorder = vma_new(this, VmaRecorder)();
+        res = m_pRecorder->Init(*pCreateInfo->pRecordSettings, m_UseMutex);
+        if(res != VK_SUCCESS)
+        {
+            return res;
+        }
+        m_pRecorder->WriteConfiguration(
+            m_PhysicalDeviceProperties,
+            m_MemProps,
+            m_VulkanApiVersion,
+            m_UseKhrDedicatedAllocation,
+            m_UseKhrBindMemory2,
+            m_UseExtMemoryBudget,
+            m_UseAmdDeviceCoherentMemory);
+        m_pRecorder->RecordCreateAllocator(GetCurrentFrameIndex());
+#else
+        VMA_ASSERT(0 && "VmaAllocatorCreateInfo::pRecordSettings used, but not supported due to VMA_RECORDING_ENABLED not defined to 1.");
+        return VK_ERROR_FEATURE_NOT_PRESENT;
+#endif
+    }
+
+#if VMA_MEMORY_BUDGET
+    if(m_UseExtMemoryBudget)
+    {
+        UpdateVulkanBudget();
+    }
+#endif // #if VMA_MEMORY_BUDGET
+
+    return res;
+}
+
+VmaAllocator_T::~VmaAllocator_T()
+{
+#if VMA_RECORDING_ENABLED
+    if(m_pRecorder != VMA_NULL)
+    {
+        m_pRecorder->RecordDestroyAllocator(GetCurrentFrameIndex());
+        vma_delete(this, m_pRecorder);
+    }
+#endif
+
+    VMA_ASSERT(m_Pools.empty());
+
+    for(size_t i = GetMemoryTypeCount(); i--; )
+    {
+        if(m_pDedicatedAllocations[i] != VMA_NULL && !m_pDedicatedAllocations[i]->empty())
+        {
+            VMA_ASSERT(0 && "Unfreed dedicated allocations found.");
+        }
+
+        vma_delete(this, m_pDedicatedAllocations[i]);
+        vma_delete(this, m_pBlockVectors[i]);
+    }
+}
+
+void VmaAllocator_T::ImportVulkanFunctions(const VmaVulkanFunctions* pVulkanFunctions)
+{
+#if VMA_STATIC_VULKAN_FUNCTIONS == 1
+    ImportVulkanFunctions_Static();
+#endif
+
+    if(pVulkanFunctions != VMA_NULL)
+    {
+        ImportVulkanFunctions_Custom(pVulkanFunctions);
+    }
+
+#if VMA_DYNAMIC_VULKAN_FUNCTIONS == 1
+    ImportVulkanFunctions_Dynamic();
+#endif
+
+    ValidateVulkanFunctions();
+}
+
+#if VMA_STATIC_VULKAN_FUNCTIONS == 1
+
+void VmaAllocator_T::ImportVulkanFunctions_Static()
+{
+    // Vulkan 1.0
+    m_VulkanFunctions.vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)vkGetPhysicalDeviceProperties;
+    m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)vkGetPhysicalDeviceMemoryProperties;
+    m_VulkanFunctions.vkAllocateMemory = (PFN_vkAllocateMemory)vkAllocateMemory;
+    m_VulkanFunctions.vkFreeMemory = (PFN_vkFreeMemory)vkFreeMemory;
+    m_VulkanFunctions.vkMapMemory = (PFN_vkMapMemory)vkMapMemory;
+    m_VulkanFunctions.vkUnmapMemory = (PFN_vkUnmapMemory)vkUnmapMemory;
+    m_VulkanFunctions.vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)vkFlushMappedMemoryRanges;
+    m_VulkanFunctions.vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)vkInvalidateMappedMemoryRanges;
+    m_VulkanFunctions.vkBindBufferMemory = (PFN_vkBindBufferMemory)vkBindBufferMemory;
+    m_VulkanFunctions.vkBindImageMemory = (PFN_vkBindImageMemory)vkBindImageMemory;
+    m_VulkanFunctions.vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)vkGetBufferMemoryRequirements;
+    m_VulkanFunctions.vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)vkGetImageMemoryRequirements;
+    m_VulkanFunctions.vkCreateBuffer = (PFN_vkCreateBuffer)vkCreateBuffer;
+    m_VulkanFunctions.vkDestroyBuffer = (PFN_vkDestroyBuffer)vkDestroyBuffer;
+    m_VulkanFunctions.vkCreateImage = (PFN_vkCreateImage)vkCreateImage;
+    m_VulkanFunctions.vkDestroyImage = (PFN_vkDestroyImage)vkDestroyImage;
+    m_VulkanFunctions.vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)vkCmdCopyBuffer;
+
+    // Vulkan 1.1
+#if VMA_VULKAN_VERSION >= 1001000
+    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2)vkGetBufferMemoryRequirements2;
+        m_VulkanFunctions.vkGetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2)vkGetImageMemoryRequirements2;
+        m_VulkanFunctions.vkBindBufferMemory2KHR = (PFN_vkBindBufferMemory2)vkBindBufferMemory2;
+        m_VulkanFunctions.vkBindImageMemory2KHR = (PFN_vkBindImageMemory2)vkBindImageMemory2;
+        m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR = (PFN_vkGetPhysicalDeviceMemoryProperties2)vkGetPhysicalDeviceMemoryProperties2;
+    }
+#endif
+}
+
+#endif // #if VMA_STATIC_VULKAN_FUNCTIONS == 1
+
+void VmaAllocator_T::ImportVulkanFunctions_Custom(const VmaVulkanFunctions* pVulkanFunctions)
+{
+    VMA_ASSERT(pVulkanFunctions != VMA_NULL);
+
+#define VMA_COPY_IF_NOT_NULL(funcName) \
+    if(pVulkanFunctions->funcName != VMA_NULL) m_VulkanFunctions.funcName = pVulkanFunctions->funcName;
+
+    VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceProperties);
+    VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties);
+    VMA_COPY_IF_NOT_NULL(vkAllocateMemory);
+    VMA_COPY_IF_NOT_NULL(vkFreeMemory);
+    VMA_COPY_IF_NOT_NULL(vkMapMemory);
+    VMA_COPY_IF_NOT_NULL(vkUnmapMemory);
+    VMA_COPY_IF_NOT_NULL(vkFlushMappedMemoryRanges);
+    VMA_COPY_IF_NOT_NULL(vkInvalidateMappedMemoryRanges);
+    VMA_COPY_IF_NOT_NULL(vkBindBufferMemory);
+    VMA_COPY_IF_NOT_NULL(vkBindImageMemory);
+    VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements);
+    VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements);
+    VMA_COPY_IF_NOT_NULL(vkCreateBuffer);
+    VMA_COPY_IF_NOT_NULL(vkDestroyBuffer);
+    VMA_COPY_IF_NOT_NULL(vkCreateImage);
+    VMA_COPY_IF_NOT_NULL(vkDestroyImage);
+    VMA_COPY_IF_NOT_NULL(vkCmdCopyBuffer);
+
+#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements2KHR);
+    VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements2KHR);
+#endif
+
+#if VMA_BIND_MEMORY2 || VMA_VULKAN_VERSION >= 1001000
+    VMA_COPY_IF_NOT_NULL(vkBindBufferMemory2KHR);
+    VMA_COPY_IF_NOT_NULL(vkBindImageMemory2KHR);
+#endif
+
+#if VMA_MEMORY_BUDGET
+    VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties2KHR);
+#endif
+
+#undef VMA_COPY_IF_NOT_NULL
+}
+
+#if VMA_DYNAMIC_VULKAN_FUNCTIONS == 1
+
+void VmaAllocator_T::ImportVulkanFunctions_Dynamic()
+{
+#define VMA_FETCH_INSTANCE_FUNC(memberName, functionPointerType, functionNameString) \
+    if(m_VulkanFunctions.memberName == VMA_NULL) \
+        m_VulkanFunctions.memberName = \
+            (functionPointerType)vkGetInstanceProcAddr(m_hInstance, functionNameString);
+#define VMA_FETCH_DEVICE_FUNC(memberName, functionPointerType, functionNameString) \
+    if(m_VulkanFunctions.memberName == VMA_NULL) \
+        m_VulkanFunctions.memberName = \
+            (functionPointerType)vkGetDeviceProcAddr(m_hDevice, functionNameString);
+
+    VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceProperties, PFN_vkGetPhysicalDeviceProperties, "vkGetPhysicalDeviceProperties");
+    VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties, PFN_vkGetPhysicalDeviceMemoryProperties, "vkGetPhysicalDeviceMemoryProperties");
+    VMA_FETCH_DEVICE_FUNC(vkAllocateMemory, PFN_vkAllocateMemory, "vkAllocateMemory");
+    VMA_FETCH_DEVICE_FUNC(vkFreeMemory, PFN_vkFreeMemory, "vkFreeMemory");
+    VMA_FETCH_DEVICE_FUNC(vkMapMemory, PFN_vkMapMemory, "vkMapMemory");
+    VMA_FETCH_DEVICE_FUNC(vkUnmapMemory, PFN_vkUnmapMemory, "vkUnmapMemory");
+    VMA_FETCH_DEVICE_FUNC(vkFlushMappedMemoryRanges, PFN_vkFlushMappedMemoryRanges, "vkFlushMappedMemoryRanges");
+    VMA_FETCH_DEVICE_FUNC(vkInvalidateMappedMemoryRanges, PFN_vkInvalidateMappedMemoryRanges, "vkInvalidateMappedMemoryRanges");
+    VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory, PFN_vkBindBufferMemory, "vkBindBufferMemory");
+    VMA_FETCH_DEVICE_FUNC(vkBindImageMemory, PFN_vkBindImageMemory, "vkBindImageMemory");
+    VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements, PFN_vkGetBufferMemoryRequirements, "vkGetBufferMemoryRequirements");
+    VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements, PFN_vkGetImageMemoryRequirements, "vkGetImageMemoryRequirements");
+    VMA_FETCH_DEVICE_FUNC(vkCreateBuffer, PFN_vkCreateBuffer, "vkCreateBuffer");
+    VMA_FETCH_DEVICE_FUNC(vkDestroyBuffer, PFN_vkDestroyBuffer, "vkDestroyBuffer");
+    VMA_FETCH_DEVICE_FUNC(vkCreateImage, PFN_vkCreateImage, "vkCreateImage");
+    VMA_FETCH_DEVICE_FUNC(vkDestroyImage, PFN_vkDestroyImage, "vkDestroyImage");
+    VMA_FETCH_DEVICE_FUNC(vkCmdCopyBuffer, PFN_vkCmdCopyBuffer, "vkCmdCopyBuffer");
+
+#if VMA_VULKAN_VERSION >= 1001000
+    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements2KHR, PFN_vkGetBufferMemoryRequirements2, "vkGetBufferMemoryRequirements2");
+        VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements2KHR, PFN_vkGetImageMemoryRequirements2, "vkGetImageMemoryRequirements2");
+        VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory2KHR, PFN_vkBindBufferMemory2, "vkBindBufferMemory2");
+        VMA_FETCH_DEVICE_FUNC(vkBindImageMemory2KHR, PFN_vkBindImageMemory2, "vkBindImageMemory2");
+        VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties2KHR, PFN_vkGetPhysicalDeviceMemoryProperties2, "vkGetPhysicalDeviceMemoryProperties2");
+    }
+#endif
+
+#if VMA_DEDICATED_ALLOCATION
+    if(m_UseKhrDedicatedAllocation)
+    {
+        VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements2KHR, PFN_vkGetBufferMemoryRequirements2KHR, "vkGetBufferMemoryRequirements2KHR");
+        VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements2KHR, PFN_vkGetImageMemoryRequirements2KHR, "vkGetImageMemoryRequirements2KHR");
+    }
+#endif
+
+#if VMA_BIND_MEMORY2
+    if(m_UseKhrBindMemory2)
+    {
+        VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory2KHR, PFN_vkBindBufferMemory2KHR, "vkBindBufferMemory2KHR");
+        VMA_FETCH_DEVICE_FUNC(vkBindImageMemory2KHR, PFN_vkBindImageMemory2KHR, "vkBindImageMemory2KHR");
+    }
+#endif // #if VMA_BIND_MEMORY2
+
+#if VMA_MEMORY_BUDGET
+    if(m_UseExtMemoryBudget)
+    {
+        VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties2KHR, PFN_vkGetPhysicalDeviceMemoryProperties2KHR, "vkGetPhysicalDeviceMemoryProperties2KHR");
+    }
+#endif // #if VMA_MEMORY_BUDGET
+
+#undef VMA_FETCH_DEVICE_FUNC
+#undef VMA_FETCH_INSTANCE_FUNC
+}
+
+#endif // #if VMA_DYNAMIC_VULKAN_FUNCTIONS == 1
+
+void VmaAllocator_T::ValidateVulkanFunctions()
+{
+    VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceProperties != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkAllocateMemory != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkFreeMemory != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkMapMemory != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkUnmapMemory != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkFlushMappedMemoryRanges != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkInvalidateMappedMemoryRanges != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkCreateBuffer != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkDestroyBuffer != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkCreateImage != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkDestroyImage != VMA_NULL);
+    VMA_ASSERT(m_VulkanFunctions.vkCmdCopyBuffer != VMA_NULL);
+
+#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0) || m_UseKhrDedicatedAllocation)
+    {
+        VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR != VMA_NULL);
+        VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements2KHR != VMA_NULL);
+    }
+#endif
+
+#if VMA_BIND_MEMORY2 || VMA_VULKAN_VERSION >= 1001000
+    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0) || m_UseKhrBindMemory2)
+    {
+        VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory2KHR != VMA_NULL);
+        VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory2KHR != VMA_NULL);
+    }
+#endif
+
+#if VMA_MEMORY_BUDGET || VMA_VULKAN_VERSION >= 1001000
+    if(m_UseExtMemoryBudget || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR != VMA_NULL);
+    }
+#endif
+}
+
+VkDeviceSize VmaAllocator_T::CalcPreferredBlockSize(uint32_t memTypeIndex)
+{
+    const uint32_t heapIndex = MemoryTypeIndexToHeapIndex(memTypeIndex);
+    const VkDeviceSize heapSize = m_MemProps.memoryHeaps[heapIndex].size;
+    const bool isSmallHeap = heapSize <= VMA_SMALL_HEAP_MAX_SIZE;
+    return VmaAlignUp(isSmallHeap ? (heapSize / 8) : m_PreferredLargeHeapBlockSize, (VkDeviceSize)32);
+}
+
+VkResult VmaAllocator_T::AllocateMemoryOfType(
+    VkDeviceSize size,
+    VkDeviceSize alignment,
+    bool dedicatedAllocation,
+    VkBuffer dedicatedBuffer,
+    VkBufferUsageFlags dedicatedBufferUsage,
+    VkImage dedicatedImage,
+    const VmaAllocationCreateInfo& createInfo,
+    uint32_t memTypeIndex,
+    VmaSuballocationType suballocType,
+    size_t allocationCount,
+    VmaAllocation* pAllocations)
+{
+    VMA_ASSERT(pAllocations != VMA_NULL);
+    VMA_DEBUG_LOG("  AllocateMemory: MemoryTypeIndex=%u, AllocationCount=%zu, Size=%llu", memTypeIndex, allocationCount, size);
+
+    VmaAllocationCreateInfo finalCreateInfo = createInfo;
+
+    // If memory type is not HOST_VISIBLE, disable MAPPED.
+    if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0 &&
+        (m_MemProps.memoryTypes[memTypeIndex].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
+    {
+        finalCreateInfo.flags &= ~VMA_ALLOCATION_CREATE_MAPPED_BIT;
+    }
+    // If memory is lazily allocated, it should be always dedicated.
+    if(finalCreateInfo.usage == VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED)
+    {
+        finalCreateInfo.flags |= VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
+    }
+
+    VmaBlockVector* const blockVector = m_pBlockVectors[memTypeIndex];
+    VMA_ASSERT(blockVector);
+
+    const VkDeviceSize preferredBlockSize = blockVector->GetPreferredBlockSize();
+    bool preferDedicatedMemory =
+        VMA_DEBUG_ALWAYS_DEDICATED_MEMORY ||
+        dedicatedAllocation ||
+        // Heuristics: Allocate dedicated memory if requested size if greater than half of preferred block size.
+        size > preferredBlockSize / 2;
+
+    if(preferDedicatedMemory &&
+        (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) == 0 &&
+        finalCreateInfo.pool == VK_NULL_HANDLE)
+    {
+        finalCreateInfo.flags |= VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
+    }
+
+    if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT) != 0)
+    {
+        if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
+        {
+            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+        }
+        else
+        {
+            return AllocateDedicatedMemory(
+                size,
+                suballocType,
+                memTypeIndex,
+                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT) != 0,
+                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0,
+                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0,
+                finalCreateInfo.pUserData,
+                dedicatedBuffer,
+                dedicatedBufferUsage,
+                dedicatedImage,
+                allocationCount,
+                pAllocations);
+        }
+    }
+    else
+    {
+        VkResult res = blockVector->Allocate(
+            m_CurrentFrameIndex.load(),
+            size,
+            alignment,
+            finalCreateInfo,
+            suballocType,
+            allocationCount,
+            pAllocations);
+        if(res == VK_SUCCESS)
+        {
+            return res;
+        }
+
+        // 5. Try dedicated memory.
+        if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
+        {
+            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+        }
+        else
+        {
+            res = AllocateDedicatedMemory(
+                size,
+                suballocType,
+                memTypeIndex,
+                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT) != 0,
+                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0,
+                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0,
+                finalCreateInfo.pUserData,
+                dedicatedBuffer,
+                dedicatedBufferUsage,
+                dedicatedImage,
+                allocationCount,
+                pAllocations);
+            if(res == VK_SUCCESS)
+            {
+                // Succeeded: AllocateDedicatedMemory function already filld pMemory, nothing more to do here.
+                VMA_DEBUG_LOG("    Allocated as DedicatedMemory");
+                return VK_SUCCESS;
+            }
+            else
+            {
+                // Everything failed: Return error code.
+                VMA_DEBUG_LOG("    vkAllocateMemory FAILED");
+                return res;
+            }
+        }
+    }
+}
+
+VkResult VmaAllocator_T::AllocateDedicatedMemory(
+    VkDeviceSize size,
+    VmaSuballocationType suballocType,
+    uint32_t memTypeIndex,
+    bool withinBudget,
+    bool map,
+    bool isUserDataString,
+    void* pUserData,
+    VkBuffer dedicatedBuffer,
+    VkBufferUsageFlags dedicatedBufferUsage,
+    VkImage dedicatedImage,
+    size_t allocationCount,
+    VmaAllocation* pAllocations)
+{
+    VMA_ASSERT(allocationCount > 0 && pAllocations);
+
+    if(withinBudget)
+    {
+        const uint32_t heapIndex = MemoryTypeIndexToHeapIndex(memTypeIndex);
+        VmaBudget heapBudget = {};
+        GetBudget(&heapBudget, heapIndex, 1);
+        if(heapBudget.usage + size * allocationCount > heapBudget.budget)
+        {
+            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+        }
+    }
+
+    VkMemoryAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
+    allocInfo.memoryTypeIndex = memTypeIndex;
+    allocInfo.allocationSize = size;
+
+#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    VkMemoryDedicatedAllocateInfoKHR dedicatedAllocInfo = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR };
+    if(m_UseKhrDedicatedAllocation || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        if(dedicatedBuffer != VK_NULL_HANDLE)
+        {
+            VMA_ASSERT(dedicatedImage == VK_NULL_HANDLE);
+            dedicatedAllocInfo.buffer = dedicatedBuffer;
+            VmaPnextChainPushFront(&allocInfo, &dedicatedAllocInfo);
+        }
+        else if(dedicatedImage != VK_NULL_HANDLE)
+        {
+            dedicatedAllocInfo.image = dedicatedImage;
+            VmaPnextChainPushFront(&allocInfo, &dedicatedAllocInfo);
+        }
+    }
+#endif // #if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+
+#if VMA_BUFFER_DEVICE_ADDRESS
+    VkMemoryAllocateFlagsInfoKHR allocFlagsInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR };
+    if(m_UseKhrBufferDeviceAddress)
+    {
+        bool canContainBufferWithDeviceAddress = true;
+        if(dedicatedBuffer != VK_NULL_HANDLE)
+        {
+            canContainBufferWithDeviceAddress = dedicatedBufferUsage == UINT32_MAX || // Usage flags unknown
+                (dedicatedBufferUsage & VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT) != 0;
+        }
+        else if(dedicatedImage != VK_NULL_HANDLE)
+        {
+            canContainBufferWithDeviceAddress = false;
+        }
+        if(canContainBufferWithDeviceAddress)
+        {
+            allocFlagsInfo.flags = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;
+            VmaPnextChainPushFront(&allocInfo, &allocFlagsInfo);
+        }
+    }
+#endif // #if VMA_BUFFER_DEVICE_ADDRESS
+
+    size_t allocIndex;
+    VkResult res = VK_SUCCESS;
+    for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
+    {
+        res = AllocateDedicatedMemoryPage(
+            size,
+            suballocType,
+            memTypeIndex,
+            allocInfo,
+            map,
+            isUserDataString,
+            pUserData,
+            pAllocations + allocIndex);
+        if(res != VK_SUCCESS)
+        {
+            break;
+        }
+    }
+
+    if(res == VK_SUCCESS)
+    {
+        // Register them in m_pDedicatedAllocations.
+        {
+            VmaMutexLockWrite lock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
+            AllocationVectorType* pDedicatedAllocations = m_pDedicatedAllocations[memTypeIndex];
+            VMA_ASSERT(pDedicatedAllocations);
+            for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
+            {
+                VmaVectorInsertSorted<VmaPointerLess>(*pDedicatedAllocations, pAllocations[allocIndex]);
+            }
+        }
+
+        VMA_DEBUG_LOG("    Allocated DedicatedMemory Count=%zu, MemoryTypeIndex=#%u", allocationCount, memTypeIndex);
+    }
+    else
+    {
+        // Free all already created allocations.
+        while(allocIndex--)
+        {
+            VmaAllocation currAlloc = pAllocations[allocIndex];
+            VkDeviceMemory hMemory = currAlloc->GetMemory();
+
+            /*
+            There is no need to call this, because Vulkan spec allows to skip vkUnmapMemory
+            before vkFreeMemory.
+
+            if(currAlloc->GetMappedData() != VMA_NULL)
+            {
+                (*m_VulkanFunctions.vkUnmapMemory)(m_hDevice, hMemory);
+            }
+            */
+
+            FreeVulkanMemory(memTypeIndex, currAlloc->GetSize(), hMemory);
+            m_Budget.RemoveAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex), currAlloc->GetSize());
+            currAlloc->SetUserData(this, VMA_NULL);
+            m_AllocationObjectAllocator.Free(currAlloc);
+        }
+
+        memset(pAllocations, 0, sizeof(VmaAllocation) * allocationCount);
+    }
+
+    return res;
+}
+
+VkResult VmaAllocator_T::AllocateDedicatedMemoryPage(
+    VkDeviceSize size,
+    VmaSuballocationType suballocType,
+    uint32_t memTypeIndex,
+    const VkMemoryAllocateInfo& allocInfo,
+    bool map,
+    bool isUserDataString,
+    void* pUserData,
+    VmaAllocation* pAllocation)
+{
+    VkDeviceMemory hMemory = VK_NULL_HANDLE;
+    VkResult res = AllocateVulkanMemory(&allocInfo, &hMemory);
+    if(res < 0)
+    {
+        VMA_DEBUG_LOG("    vkAllocateMemory FAILED");
+        return res;
+    }
+
+    void* pMappedData = VMA_NULL;
+    if(map)
+    {
+        res = (*m_VulkanFunctions.vkMapMemory)(
+            m_hDevice,
+            hMemory,
+            0,
+            VK_WHOLE_SIZE,
+            0,
+            &pMappedData);
+        if(res < 0)
+        {
+            VMA_DEBUG_LOG("    vkMapMemory FAILED");
+            FreeVulkanMemory(memTypeIndex, size, hMemory);
+            return res;
+        }
+    }
+
+    *pAllocation = m_AllocationObjectAllocator.Allocate(m_CurrentFrameIndex.load(), isUserDataString);
+    (*pAllocation)->InitDedicatedAllocation(memTypeIndex, hMemory, suballocType, pMappedData, size);
+    (*pAllocation)->SetUserData(this, pUserData);
+    m_Budget.AddAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex), size);
+    if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
+    {
+        FillAllocation(*pAllocation, VMA_ALLOCATION_FILL_PATTERN_CREATED);
+    }
+
+    return VK_SUCCESS;
+}
+
+void VmaAllocator_T::GetBufferMemoryRequirements(
+    VkBuffer hBuffer,
+    VkMemoryRequirements& memReq,
+    bool& requiresDedicatedAllocation,
+    bool& prefersDedicatedAllocation) const
+{
+#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    if(m_UseKhrDedicatedAllocation || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        VkBufferMemoryRequirementsInfo2KHR memReqInfo = { VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR };
+        memReqInfo.buffer = hBuffer;
+
+        VkMemoryDedicatedRequirementsKHR memDedicatedReq = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR };
+
+        VkMemoryRequirements2KHR memReq2 = { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR };
+        VmaPnextChainPushFront(&memReq2, &memDedicatedReq);
+
+        (*m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR)(m_hDevice, &memReqInfo, &memReq2);
+
+        memReq = memReq2.memoryRequirements;
+        requiresDedicatedAllocation = (memDedicatedReq.requiresDedicatedAllocation != VK_FALSE);
+        prefersDedicatedAllocation  = (memDedicatedReq.prefersDedicatedAllocation  != VK_FALSE);
+    }
+    else
+#endif // #if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    {
+        (*m_VulkanFunctions.vkGetBufferMemoryRequirements)(m_hDevice, hBuffer, &memReq);
+        requiresDedicatedAllocation = false;
+        prefersDedicatedAllocation  = false;
+    }
+}
+
+void VmaAllocator_T::GetImageMemoryRequirements(
+    VkImage hImage,
+    VkMemoryRequirements& memReq,
+    bool& requiresDedicatedAllocation,
+    bool& prefersDedicatedAllocation) const
+{
+#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    if(m_UseKhrDedicatedAllocation || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
+    {
+        VkImageMemoryRequirementsInfo2KHR memReqInfo = { VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR };
+        memReqInfo.image = hImage;
+
+        VkMemoryDedicatedRequirementsKHR memDedicatedReq = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR };
+
+        VkMemoryRequirements2KHR memReq2 = { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR };
+        VmaPnextChainPushFront(&memReq2, &memDedicatedReq);
+
+        (*m_VulkanFunctions.vkGetImageMemoryRequirements2KHR)(m_hDevice, &memReqInfo, &memReq2);
+
+        memReq = memReq2.memoryRequirements;
+        requiresDedicatedAllocation = (memDedicatedReq.requiresDedicatedAllocation != VK_FALSE);
+        prefersDedicatedAllocation  = (memDedicatedReq.prefersDedicatedAllocation  != VK_FALSE);
+    }
+    else
+#endif // #if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
+    {
+        (*m_VulkanFunctions.vkGetImageMemoryRequirements)(m_hDevice, hImage, &memReq);
+        requiresDedicatedAllocation = false;
+        prefersDedicatedAllocation  = false;
+    }
+}
+
+VkResult VmaAllocator_T::AllocateMemory(
+    const VkMemoryRequirements& vkMemReq,
+    bool requiresDedicatedAllocation,
+    bool prefersDedicatedAllocation,
+    VkBuffer dedicatedBuffer,
+    VkBufferUsageFlags dedicatedBufferUsage,
+    VkImage dedicatedImage,
+    const VmaAllocationCreateInfo& createInfo,
+    VmaSuballocationType suballocType,
+    size_t allocationCount,
+    VmaAllocation* pAllocations)
+{
+    memset(pAllocations, 0, sizeof(VmaAllocation) * allocationCount);
+
+    VMA_ASSERT(VmaIsPow2(vkMemReq.alignment));
+
+    if(vkMemReq.size == 0)
+    {
+        return VK_ERROR_VALIDATION_FAILED_EXT;
+    }
+    if((createInfo.flags & VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT) != 0 &&
+        (createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
+    {
+        VMA_ASSERT(0 && "Specifying VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT together with VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT makes no sense.");
+        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+    }
+    if((createInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0 &&
+        (createInfo.flags & VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT) != 0)
+    {
+        VMA_ASSERT(0 && "Specifying VMA_ALLOCATION_CREATE_MAPPED_BIT together with VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT is invalid.");
+        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+    }
+    if(requiresDedicatedAllocation)
+    {
+        if((createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
+        {
+            VMA_ASSERT(0 && "VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT specified while dedicated allocation is required.");
+            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+        }
+        if(createInfo.pool != VK_NULL_HANDLE)
+        {
+            VMA_ASSERT(0 && "Pool specified while dedicated allocation is required.");
+            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+        }
+    }
+    if((createInfo.pool != VK_NULL_HANDLE) &&
+        ((createInfo.flags & (VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT)) != 0))
+    {
+        VMA_ASSERT(0 && "Specifying VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT when pool != null is invalid.");
+        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+    }
+
+    if(createInfo.pool != VK_NULL_HANDLE)
+    {
+        const VkDeviceSize alignmentForPool = VMA_MAX(
+            vkMemReq.alignment,
+            GetMemoryTypeMinAlignment(createInfo.pool->m_BlockVector.GetMemoryTypeIndex()));
+
+        VmaAllocationCreateInfo createInfoForPool = createInfo;
+        // If memory type is not HOST_VISIBLE, disable MAPPED.
+        if((createInfoForPool.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0 &&
+            (m_MemProps.memoryTypes[createInfo.pool->m_BlockVector.GetMemoryTypeIndex()].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
+        {
+            createInfoForPool.flags &= ~VMA_ALLOCATION_CREATE_MAPPED_BIT;
+        }
+
+        return createInfo.pool->m_BlockVector.Allocate(
+            m_CurrentFrameIndex.load(),
+            vkMemReq.size,
+            alignmentForPool,
+            createInfoForPool,
+            suballocType,
+            allocationCount,
+            pAllocations);
+    }
+    else
+    {
+        // Bit mask of memory Vulkan types acceptable for this allocation.
+        uint32_t memoryTypeBits = vkMemReq.memoryTypeBits;
+        uint32_t memTypeIndex = UINT32_MAX;
+        VkResult res = vmaFindMemoryTypeIndex(this, memoryTypeBits, &createInfo, &memTypeIndex);
+        if(res == VK_SUCCESS)
+        {
+            VkDeviceSize alignmentForMemType = VMA_MAX(
+                vkMemReq.alignment,
+                GetMemoryTypeMinAlignment(memTypeIndex));
+
+            res = AllocateMemoryOfType(
+                vkMemReq.size,
+                alignmentForMemType,
+                requiresDedicatedAllocation || prefersDedicatedAllocation,
+                dedicatedBuffer,
+                dedicatedBufferUsage,
+                dedicatedImage,
+                createInfo,
+                memTypeIndex,
+                suballocType,
+                allocationCount,
+                pAllocations);
+            // Succeeded on first try.
+            if(res == VK_SUCCESS)
+            {
+                return res;
+            }
+            // Allocation from this memory type failed. Try other compatible memory types.
+            else
+            {
+                for(;;)
+                {
+                    // Remove old memTypeIndex from list of possibilities.
+                    memoryTypeBits &= ~(1u << memTypeIndex);
+                    // Find alternative memTypeIndex.
+                    res = vmaFindMemoryTypeIndex(this, memoryTypeBits, &createInfo, &memTypeIndex);
+                    if(res == VK_SUCCESS)
+                    {
+                        alignmentForMemType = VMA_MAX(
+                            vkMemReq.alignment,
+                            GetMemoryTypeMinAlignment(memTypeIndex));
+
+                        res = AllocateMemoryOfType(
+                            vkMemReq.size,
+                            alignmentForMemType,
+                            requiresDedicatedAllocation || prefersDedicatedAllocation,
+                            dedicatedBuffer,
+                            dedicatedBufferUsage,
+                            dedicatedImage,
+                            createInfo,
+                            memTypeIndex,
+                            suballocType,
+                            allocationCount,
+                            pAllocations);
+                        // Allocation from this alternative memory type succeeded.
+                        if(res == VK_SUCCESS)
+                        {
+                            return res;
+                        }
+                        // else: Allocation from this memory type failed. Try next one - next loop iteration.
+                    }
+                    // No other matching memory type index could be found.
+                    else
+                    {
+                        // Not returning res, which is VK_ERROR_FEATURE_NOT_PRESENT, because we already failed to allocate once.
+                        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+                    }
+                }
+            }
+        }
+        // Can't find any single memory type maching requirements. res is VK_ERROR_FEATURE_NOT_PRESENT.
+        else
+            return res;
+    }
+}
+
+void VmaAllocator_T::FreeMemory(
+    size_t allocationCount,
+    const VmaAllocation* pAllocations)
+{
+    VMA_ASSERT(pAllocations);
+
+    for(size_t allocIndex = allocationCount; allocIndex--; )
+    {
+        VmaAllocation allocation = pAllocations[allocIndex];
+
+        if(allocation != VK_NULL_HANDLE)
+        {
+            if(TouchAllocation(allocation))
+            {
+                if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
+                {
+                    FillAllocation(allocation, VMA_ALLOCATION_FILL_PATTERN_DESTROYED);
+                }
+
+                switch(allocation->GetType())
+                {
+                case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
+                    {
+                        VmaBlockVector* pBlockVector = VMA_NULL;
+                        VmaPool hPool = allocation->GetBlock()->GetParentPool();
+                        if(hPool != VK_NULL_HANDLE)
+                        {
+                            pBlockVector = &hPool->m_BlockVector;
+                        }
+                        else
+                        {
+                            const uint32_t memTypeIndex = allocation->GetMemoryTypeIndex();
+                            pBlockVector = m_pBlockVectors[memTypeIndex];
+                        }
+                        pBlockVector->Free(allocation);
+                    }
+                    break;
+                case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
+                    FreeDedicatedMemory(allocation);
+                    break;
+                default:
+                    VMA_ASSERT(0);
+                }
+            }
+
+            // Do this regardless of whether the allocation is lost. Lost allocations still account to Budget.AllocationBytes.
+            m_Budget.RemoveAllocation(MemoryTypeIndexToHeapIndex(allocation->GetMemoryTypeIndex()), allocation->GetSize());
+            allocation->SetUserData(this, VMA_NULL);
+            m_AllocationObjectAllocator.Free(allocation);
+        }
+    }
+}
+
+VkResult VmaAllocator_T::ResizeAllocation(
+    const VmaAllocation alloc,
+    VkDeviceSize newSize)
+{
+    // This function is deprecated and so it does nothing. It's left for backward compatibility.
+    if(newSize == 0 || alloc->GetLastUseFrameIndex() == VMA_FRAME_INDEX_LOST)
+    {
+        return VK_ERROR_VALIDATION_FAILED_EXT;
+    }
+    if(newSize == alloc->GetSize())
+    {
+        return VK_SUCCESS;
+    }
+    return VK_ERROR_OUT_OF_POOL_MEMORY;
+}
+
+void VmaAllocator_T::CalculateStats(VmaStats* pStats)
+{
+    // Initialize.
+    InitStatInfo(pStats->total);
+    for(size_t i = 0; i < VK_MAX_MEMORY_TYPES; ++i)
+        InitStatInfo(pStats->memoryType[i]);
+    for(size_t i = 0; i < VK_MAX_MEMORY_HEAPS; ++i)
+        InitStatInfo(pStats->memoryHeap[i]);
+
+    // Process default pools.
+    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
+    {
+        VmaBlockVector* const pBlockVector = m_pBlockVectors[memTypeIndex];
+        VMA_ASSERT(pBlockVector);
+        pBlockVector->AddStats(pStats);
+    }
+
+    // Process custom pools.
+    {
+        VmaMutexLockRead lock(m_PoolsMutex, m_UseMutex);
+        for(size_t poolIndex = 0, poolCount = m_Pools.size(); poolIndex < poolCount; ++poolIndex)
+        {
+            m_Pools[poolIndex]->m_BlockVector.AddStats(pStats);
+        }
+    }
+
+    // Process dedicated allocations.
+    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
+    {
+        const uint32_t memHeapIndex = MemoryTypeIndexToHeapIndex(memTypeIndex);
+        VmaMutexLockRead dedicatedAllocationsLock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
+        AllocationVectorType* const pDedicatedAllocVector = m_pDedicatedAllocations[memTypeIndex];
+        VMA_ASSERT(pDedicatedAllocVector);
+        for(size_t allocIndex = 0, allocCount = pDedicatedAllocVector->size(); allocIndex < allocCount; ++allocIndex)
+        {
+            VmaStatInfo allocationStatInfo;
+            (*pDedicatedAllocVector)[allocIndex]->DedicatedAllocCalcStatsInfo(allocationStatInfo);
+            VmaAddStatInfo(pStats->total, allocationStatInfo);
+            VmaAddStatInfo(pStats->memoryType[memTypeIndex], allocationStatInfo);
+            VmaAddStatInfo(pStats->memoryHeap[memHeapIndex], allocationStatInfo);
+        }
+    }
+
+    // Postprocess.
+    VmaPostprocessCalcStatInfo(pStats->total);
+    for(size_t i = 0; i < GetMemoryTypeCount(); ++i)
+        VmaPostprocessCalcStatInfo(pStats->memoryType[i]);
+    for(size_t i = 0; i < GetMemoryHeapCount(); ++i)
+        VmaPostprocessCalcStatInfo(pStats->memoryHeap[i]);
+}
+
+void VmaAllocator_T::GetBudget(VmaBudget* outBudget, uint32_t firstHeap, uint32_t heapCount)
+{
+#if VMA_MEMORY_BUDGET
+    if(m_UseExtMemoryBudget)
+    {
+        if(m_Budget.m_OperationsSinceBudgetFetch < 30)
+        {
+            VmaMutexLockRead lockRead(m_Budget.m_BudgetMutex, m_UseMutex);
+            for(uint32_t i = 0; i < heapCount; ++i, ++outBudget)
+            {
+                const uint32_t heapIndex = firstHeap + i;
+
+                outBudget->blockBytes = m_Budget.m_BlockBytes[heapIndex];
+                outBudget->allocationBytes = m_Budget.m_AllocationBytes[heapIndex];
+
+                if(m_Budget.m_VulkanUsage[heapIndex] + outBudget->blockBytes > m_Budget.m_BlockBytesAtBudgetFetch[heapIndex])
+                {
+                    outBudget->usage = m_Budget.m_VulkanUsage[heapIndex] +
+                        outBudget->blockBytes - m_Budget.m_BlockBytesAtBudgetFetch[heapIndex];
+                }
+                else
+                {
+                    outBudget->usage = 0;
+                }
+
+                // Have to take MIN with heap size because explicit HeapSizeLimit is included in it.
+                outBudget->budget = VMA_MIN(
+                    m_Budget.m_VulkanBudget[heapIndex], m_MemProps.memoryHeaps[heapIndex].size);
+            }
+        }
+        else
+        {
+            UpdateVulkanBudget(); // Outside of mutex lock
+            GetBudget(outBudget, firstHeap, heapCount); // Recursion
+        }
+    }
+    else
+#endif
+    {
+        for(uint32_t i = 0; i < heapCount; ++i, ++outBudget)
+        {
+            const uint32_t heapIndex = firstHeap + i;
+
+            outBudget->blockBytes = m_Budget.m_BlockBytes[heapIndex];
+            outBudget->allocationBytes = m_Budget.m_AllocationBytes[heapIndex];
+
+            outBudget->usage = outBudget->blockBytes;
+            outBudget->budget = m_MemProps.memoryHeaps[heapIndex].size * 8 / 10; // 80% heuristics.
+        }
+    }
+}
+
+static const uint32_t VMA_VENDOR_ID_AMD = 4098;
+
+VkResult VmaAllocator_T::DefragmentationBegin(
+    const VmaDefragmentationInfo2& info,
+    VmaDefragmentationStats* pStats,
+    VmaDefragmentationContext* pContext)
+{
+    if(info.pAllocationsChanged != VMA_NULL)
+    {
+        memset(info.pAllocationsChanged, 0, info.allocationCount * sizeof(VkBool32));
+    }
+
+    *pContext = vma_new(this, VmaDefragmentationContext_T)(
+        this, m_CurrentFrameIndex.load(), info.flags, pStats);
+
+    (*pContext)->AddPools(info.poolCount, info.pPools);
+    (*pContext)->AddAllocations(
+        info.allocationCount, info.pAllocations, info.pAllocationsChanged);
+
+    VkResult res = (*pContext)->Defragment(
+        info.maxCpuBytesToMove, info.maxCpuAllocationsToMove,
+        info.maxGpuBytesToMove, info.maxGpuAllocationsToMove,
+        info.commandBuffer, pStats, info.flags);
+
+    if(res != VK_NOT_READY)
+    {
+        vma_delete(this, *pContext);
+        *pContext = VMA_NULL;
+    }
+
+    return res;
+}
+
+VkResult VmaAllocator_T::DefragmentationEnd(
+    VmaDefragmentationContext context)
+{
+    vma_delete(this, context);
+    return VK_SUCCESS;
+}
+
+VkResult VmaAllocator_T::DefragmentationPassBegin(
+    VmaDefragmentationPassInfo* pInfo,
+    VmaDefragmentationContext context)
+{
+    return context->DefragmentPassBegin(pInfo);
+}
+VkResult VmaAllocator_T::DefragmentationPassEnd(
+    VmaDefragmentationContext context)
+{
+    return context->DefragmentPassEnd();
+
+}
+
+void VmaAllocator_T::GetAllocationInfo(VmaAllocation hAllocation, VmaAllocationInfo* pAllocationInfo)
+{
+    if(hAllocation->CanBecomeLost())
+    {
+        /*
+        Warning: This is a carefully designed algorithm.
+        Do not modify unless you really know what you're doing :)
+        */
+        const uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
+        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
+        for(;;)
+        {
+            if(localLastUseFrameIndex == VMA_FRAME_INDEX_LOST)
+            {
+                pAllocationInfo->memoryType = UINT32_MAX;
+                pAllocationInfo->deviceMemory = VK_NULL_HANDLE;
+                pAllocationInfo->offset = 0;
+                pAllocationInfo->size = hAllocation->GetSize();
+                pAllocationInfo->pMappedData = VMA_NULL;
+                pAllocationInfo->pUserData = hAllocation->GetUserData();
+                return;
+            }
+            else if(localLastUseFrameIndex == localCurrFrameIndex)
+            {
+                pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();
+                pAllocationInfo->deviceMemory = hAllocation->GetMemory();
+                pAllocationInfo->offset = hAllocation->GetOffset();
+                pAllocationInfo->size = hAllocation->GetSize();
+                pAllocationInfo->pMappedData = VMA_NULL;
+                pAllocationInfo->pUserData = hAllocation->GetUserData();
+                return;
+            }
+            else // Last use time earlier than current time.
+            {
+                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
+                {
+                    localLastUseFrameIndex = localCurrFrameIndex;
+                }
+            }
+        }
+    }
+    else
+    {
+#if VMA_STATS_STRING_ENABLED
+        uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
+        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
+        for(;;)
+        {
+            VMA_ASSERT(localLastUseFrameIndex != VMA_FRAME_INDEX_LOST);
+            if(localLastUseFrameIndex == localCurrFrameIndex)
+            {
+                break;
+            }
+            else // Last use time earlier than current time.
+            {
+                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
+                {
+                    localLastUseFrameIndex = localCurrFrameIndex;
+                }
+            }
+        }
+#endif
+
+        pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();
+        pAllocationInfo->deviceMemory = hAllocation->GetMemory();
+        pAllocationInfo->offset = hAllocation->GetOffset();
+        pAllocationInfo->size = hAllocation->GetSize();
+        pAllocationInfo->pMappedData = hAllocation->GetMappedData();
+        pAllocationInfo->pUserData = hAllocation->GetUserData();
+    }
+}
+
+bool VmaAllocator_T::TouchAllocation(VmaAllocation hAllocation)
+{
+    // This is a stripped-down version of VmaAllocator_T::GetAllocationInfo.
+    if(hAllocation->CanBecomeLost())
+    {
+        uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
+        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
+        for(;;)
+        {
+            if(localLastUseFrameIndex == VMA_FRAME_INDEX_LOST)
+            {
+                return false;
+            }
+            else if(localLastUseFrameIndex == localCurrFrameIndex)
+            {
+                return true;
+            }
+            else // Last use time earlier than current time.
+            {
+                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
+                {
+                    localLastUseFrameIndex = localCurrFrameIndex;
+                }
+            }
+        }
+    }
+    else
+    {
+#if VMA_STATS_STRING_ENABLED
+        uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
+        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
+        for(;;)
+        {
+            VMA_ASSERT(localLastUseFrameIndex != VMA_FRAME_INDEX_LOST);
+            if(localLastUseFrameIndex == localCurrFrameIndex)
+            {
+                break;
+            }
+            else // Last use time earlier than current time.
+            {
+                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
+                {
+                    localLastUseFrameIndex = localCurrFrameIndex;
+                }
+            }
+        }
+#endif
+
+        return true;
+    }
+}
+
+VkResult VmaAllocator_T::CreatePool(const VmaPoolCreateInfo* pCreateInfo, VmaPool* pPool)
+{
+    VMA_DEBUG_LOG("  CreatePool: MemoryTypeIndex=%u, flags=%u", pCreateInfo->memoryTypeIndex, pCreateInfo->flags);
+
+    VmaPoolCreateInfo newCreateInfo = *pCreateInfo;
+
+    if(newCreateInfo.maxBlockCount == 0)
+    {
+        newCreateInfo.maxBlockCount = SIZE_MAX;
+    }
+    if(newCreateInfo.minBlockCount > newCreateInfo.maxBlockCount)
+    {
+        return VK_ERROR_INITIALIZATION_FAILED;
+    }
+    // Memory type index out of range or forbidden.
+    if(pCreateInfo->memoryTypeIndex >= GetMemoryTypeCount() ||
+        ((1u << pCreateInfo->memoryTypeIndex) & m_GlobalMemoryTypeBits) == 0)
+    {
+        return VK_ERROR_FEATURE_NOT_PRESENT;
+    }
+
+    const VkDeviceSize preferredBlockSize = CalcPreferredBlockSize(newCreateInfo.memoryTypeIndex);
+
+    *pPool = vma_new(this, VmaPool_T)(this, newCreateInfo, preferredBlockSize);
+
+    VkResult res = (*pPool)->m_BlockVector.CreateMinBlocks();
+    if(res != VK_SUCCESS)
+    {
+        vma_delete(this, *pPool);
+        *pPool = VMA_NULL;
+        return res;
+    }
+
+    // Add to m_Pools.
+    {
+        VmaMutexLockWrite lock(m_PoolsMutex, m_UseMutex);
+        (*pPool)->SetId(m_NextPoolId++);
+        VmaVectorInsertSorted<VmaPointerLess>(m_Pools, *pPool);
+    }
+
+    return VK_SUCCESS;
+}
+
+void VmaAllocator_T::DestroyPool(VmaPool pool)
+{
+    // Remove from m_Pools.
+    {
+        VmaMutexLockWrite lock(m_PoolsMutex, m_UseMutex);
+        bool success = VmaVectorRemoveSorted<VmaPointerLess>(m_Pools, pool);
+        VMA_ASSERT(success && "Pool not found in Allocator.");
+    }
+
+    vma_delete(this, pool);
+}
+
+void VmaAllocator_T::GetPoolStats(VmaPool pool, VmaPoolStats* pPoolStats)
+{
+    pool->m_BlockVector.GetPoolStats(pPoolStats);
+}
+
+void VmaAllocator_T::SetCurrentFrameIndex(uint32_t frameIndex)
+{
+    m_CurrentFrameIndex.store(frameIndex);
+
+#if VMA_MEMORY_BUDGET
+    if(m_UseExtMemoryBudget)
+    {
+        UpdateVulkanBudget();
+    }
+#endif // #if VMA_MEMORY_BUDGET
+}
+
+void VmaAllocator_T::MakePoolAllocationsLost(
+    VmaPool hPool,
+    size_t* pLostAllocationCount)
+{
+    hPool->m_BlockVector.MakePoolAllocationsLost(
+        m_CurrentFrameIndex.load(),
+        pLostAllocationCount);
+}
+
+VkResult VmaAllocator_T::CheckPoolCorruption(VmaPool hPool)
+{
+    return hPool->m_BlockVector.CheckCorruption();
+}
+
+VkResult VmaAllocator_T::CheckCorruption(uint32_t memoryTypeBits)
+{
+    VkResult finalRes = VK_ERROR_FEATURE_NOT_PRESENT;
+
+    // Process default pools.
+    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
+    {
+        if(((1u << memTypeIndex) & memoryTypeBits) != 0)
+        {
+            VmaBlockVector* const pBlockVector = m_pBlockVectors[memTypeIndex];
+            VMA_ASSERT(pBlockVector);
+            VkResult localRes = pBlockVector->CheckCorruption();
+            switch(localRes)
+            {
+            case VK_ERROR_FEATURE_NOT_PRESENT:
+                break;
+            case VK_SUCCESS:
+                finalRes = VK_SUCCESS;
+                break;
+            default:
+                return localRes;
+            }
+        }
+    }
+
+    // Process custom pools.
+    {
+        VmaMutexLockRead lock(m_PoolsMutex, m_UseMutex);
+        for(size_t poolIndex = 0, poolCount = m_Pools.size(); poolIndex < poolCount; ++poolIndex)
+        {
+            if(((1u << m_Pools[poolIndex]->m_BlockVector.GetMemoryTypeIndex()) & memoryTypeBits) != 0)
+            {
+                VkResult localRes = m_Pools[poolIndex]->m_BlockVector.CheckCorruption();
+                switch(localRes)
+                {
+                case VK_ERROR_FEATURE_NOT_PRESENT:
+                    break;
+                case VK_SUCCESS:
+                    finalRes = VK_SUCCESS;
+                    break;
+                default:
+                    return localRes;
+                }
+            }
+        }
+    }
+
+    return finalRes;
+}
+
+void VmaAllocator_T::CreateLostAllocation(VmaAllocation* pAllocation)
+{
+    *pAllocation = m_AllocationObjectAllocator.Allocate(VMA_FRAME_INDEX_LOST, false);
+    (*pAllocation)->InitLost();
+}
+
+VkResult VmaAllocator_T::AllocateVulkanMemory(const VkMemoryAllocateInfo* pAllocateInfo, VkDeviceMemory* pMemory)
+{
+    const uint32_t heapIndex = MemoryTypeIndexToHeapIndex(pAllocateInfo->memoryTypeIndex);
+
+    // HeapSizeLimit is in effect for this heap.
+    if((m_HeapSizeLimitMask & (1u << heapIndex)) != 0)
+    {
+        const VkDeviceSize heapSize = m_MemProps.memoryHeaps[heapIndex].size;
+        VkDeviceSize blockBytes = m_Budget.m_BlockBytes[heapIndex];
+        for(;;)
+        {
+            const VkDeviceSize blockBytesAfterAllocation = blockBytes + pAllocateInfo->allocationSize;
+            if(blockBytesAfterAllocation > heapSize)
+            {
+                return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+            }
+            if(m_Budget.m_BlockBytes[heapIndex].compare_exchange_strong(blockBytes, blockBytesAfterAllocation))
+            {
+                break;
+            }
+        }
+    }
+    else
+    {
+        m_Budget.m_BlockBytes[heapIndex] += pAllocateInfo->allocationSize;
+    }
+
+    // VULKAN CALL vkAllocateMemory.
+    VkResult res = (*m_VulkanFunctions.vkAllocateMemory)(m_hDevice, pAllocateInfo, GetAllocationCallbacks(), pMemory);
+
+    if(res == VK_SUCCESS)
+    {
+#if VMA_MEMORY_BUDGET
+        ++m_Budget.m_OperationsSinceBudgetFetch;
+#endif
+
+        // Informative callback.
+        if(m_DeviceMemoryCallbacks.pfnAllocate != VMA_NULL)
+        {
+            (*m_DeviceMemoryCallbacks.pfnAllocate)(this, pAllocateInfo->memoryTypeIndex, *pMemory, pAllocateInfo->allocationSize, m_DeviceMemoryCallbacks.pUserData);
+        }
+    }
+    else
+    {
+        m_Budget.m_BlockBytes[heapIndex] -= pAllocateInfo->allocationSize;
+    }
+
+    return res;
+}
+
+void VmaAllocator_T::FreeVulkanMemory(uint32_t memoryType, VkDeviceSize size, VkDeviceMemory hMemory)
+{
+    // Informative callback.
+    if(m_DeviceMemoryCallbacks.pfnFree != VMA_NULL)
+    {
+        (*m_DeviceMemoryCallbacks.pfnFree)(this, memoryType, hMemory, size, m_DeviceMemoryCallbacks.pUserData);
+    }
+
+    // VULKAN CALL vkFreeMemory.
+    (*m_VulkanFunctions.vkFreeMemory)(m_hDevice, hMemory, GetAllocationCallbacks());
+
+    m_Budget.m_BlockBytes[MemoryTypeIndexToHeapIndex(memoryType)] -= size;
+}
+
+VkResult VmaAllocator_T::BindVulkanBuffer(
+    VkDeviceMemory memory,
+    VkDeviceSize memoryOffset,
+    VkBuffer buffer,
+    const void* pNext)
+{
+    if(pNext != VMA_NULL)
+    {
+#if VMA_VULKAN_VERSION >= 1001000 || VMA_BIND_MEMORY2
+        if((m_UseKhrBindMemory2 || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0)) &&
+            m_VulkanFunctions.vkBindBufferMemory2KHR != VMA_NULL)
+        {
+            VkBindBufferMemoryInfoKHR bindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR };
+            bindBufferMemoryInfo.pNext = pNext;
+            bindBufferMemoryInfo.buffer = buffer;
+            bindBufferMemoryInfo.memory = memory;
+            bindBufferMemoryInfo.memoryOffset = memoryOffset;
+            return (*m_VulkanFunctions.vkBindBufferMemory2KHR)(m_hDevice, 1, &bindBufferMemoryInfo);
+        }
+        else
+#endif // #if VMA_VULKAN_VERSION >= 1001000 || VMA_BIND_MEMORY2
+        {
+            return VK_ERROR_EXTENSION_NOT_PRESENT;
+        }
+    }
+    else
+    {
+        return (*m_VulkanFunctions.vkBindBufferMemory)(m_hDevice, buffer, memory, memoryOffset);
+    }
+}
+
+VkResult VmaAllocator_T::BindVulkanImage(
+    VkDeviceMemory memory,
+    VkDeviceSize memoryOffset,
+    VkImage image,
+    const void* pNext)
+{
+    if(pNext != VMA_NULL)
+    {
+#if VMA_VULKAN_VERSION >= 1001000 || VMA_BIND_MEMORY2
+        if((m_UseKhrBindMemory2 || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0)) &&
+            m_VulkanFunctions.vkBindImageMemory2KHR != VMA_NULL)
+        {
+            VkBindImageMemoryInfoKHR bindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR };
+            bindBufferMemoryInfo.pNext = pNext;
+            bindBufferMemoryInfo.image = image;
+            bindBufferMemoryInfo.memory = memory;
+            bindBufferMemoryInfo.memoryOffset = memoryOffset;
+            return (*m_VulkanFunctions.vkBindImageMemory2KHR)(m_hDevice, 1, &bindBufferMemoryInfo);
+        }
+        else
+#endif // #if VMA_BIND_MEMORY2
+        {
+            return VK_ERROR_EXTENSION_NOT_PRESENT;
+        }
+    }
+    else
+    {
+        return (*m_VulkanFunctions.vkBindImageMemory)(m_hDevice, image, memory, memoryOffset);
+    }
+}
+
+VkResult VmaAllocator_T::Map(VmaAllocation hAllocation, void** ppData)
+{
+    if(hAllocation->CanBecomeLost())
+    {
+        return VK_ERROR_MEMORY_MAP_FAILED;
+    }
+
+    switch(hAllocation->GetType())
+    {
+    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
+        {
+            VmaDeviceMemoryBlock* const pBlock = hAllocation->GetBlock();
+            char *pBytes = VMA_NULL;
+            VkResult res = pBlock->Map(this, 1, (void**)&pBytes);
+            if(res == VK_SUCCESS)
+            {
+                *ppData = pBytes + (ptrdiff_t)hAllocation->GetOffset();
+                hAllocation->BlockAllocMap();
+            }
+            return res;
+        }
+    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
+        return hAllocation->DedicatedAllocMap(this, ppData);
+    default:
+        VMA_ASSERT(0);
+        return VK_ERROR_MEMORY_MAP_FAILED;
+    }
+}
+
+void VmaAllocator_T::Unmap(VmaAllocation hAllocation)
+{
+    switch(hAllocation->GetType())
+    {
+    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
+        {
+            VmaDeviceMemoryBlock* const pBlock = hAllocation->GetBlock();
+            hAllocation->BlockAllocUnmap();
+            pBlock->Unmap(this, 1);
+        }
+        break;
+    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
+        hAllocation->DedicatedAllocUnmap(this);
+        break;
+    default:
+        VMA_ASSERT(0);
+    }
+}
+
+VkResult VmaAllocator_T::BindBufferMemory(
+    VmaAllocation hAllocation,
+    VkDeviceSize allocationLocalOffset,
+    VkBuffer hBuffer,
+    const void* pNext)
+{
+    VkResult res = VK_SUCCESS;
+    switch(hAllocation->GetType())
+    {
+    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
+        res = BindVulkanBuffer(hAllocation->GetMemory(), allocationLocalOffset, hBuffer, pNext);
+        break;
+    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
+    {
+        VmaDeviceMemoryBlock* const pBlock = hAllocation->GetBlock();
+        VMA_ASSERT(pBlock && "Binding buffer to allocation that doesn't belong to any block. Is the allocation lost?");
+        res = pBlock->BindBufferMemory(this, hAllocation, allocationLocalOffset, hBuffer, pNext);
+        break;
+    }
+    default:
+        VMA_ASSERT(0);
+    }
+    return res;
+}
+
+VkResult VmaAllocator_T::BindImageMemory(
+    VmaAllocation hAllocation,
+    VkDeviceSize allocationLocalOffset,
+    VkImage hImage,
+    const void* pNext)
+{
+    VkResult res = VK_SUCCESS;
+    switch(hAllocation->GetType())
+    {
+    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
+        res = BindVulkanImage(hAllocation->GetMemory(), allocationLocalOffset, hImage, pNext);
+        break;
+    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
+    {
+        VmaDeviceMemoryBlock* pBlock = hAllocation->GetBlock();
+        VMA_ASSERT(pBlock && "Binding image to allocation that doesn't belong to any block. Is the allocation lost?");
+        res = pBlock->BindImageMemory(this, hAllocation, allocationLocalOffset, hImage, pNext);
+        break;
+    }
+    default:
+        VMA_ASSERT(0);
+    }
+    return res;
+}
+
+VkResult VmaAllocator_T::FlushOrInvalidateAllocation(
+    VmaAllocation hAllocation,
+    VkDeviceSize offset, VkDeviceSize size,
+    VMA_CACHE_OPERATION op)
+{
+    VkResult res = VK_SUCCESS;
+
+    VkMappedMemoryRange memRange = {};
+    if(GetFlushOrInvalidateRange(hAllocation, offset, size, memRange))
+    {
+        switch(op)
+        {
+        case VMA_CACHE_FLUSH:
+            res = (*GetVulkanFunctions().vkFlushMappedMemoryRanges)(m_hDevice, 1, &memRange);
+            break;
+        case VMA_CACHE_INVALIDATE:
+            res = (*GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hDevice, 1, &memRange);
+            break;
+        default:
+            VMA_ASSERT(0);
+        }
+    }
+    // else: Just ignore this call.
+    return res;
+}
+
+VkResult VmaAllocator_T::FlushOrInvalidateAllocations(
+    uint32_t allocationCount,
+    const VmaAllocation* allocations,
+    const VkDeviceSize* offsets, const VkDeviceSize* sizes,
+    VMA_CACHE_OPERATION op)
+{
+    typedef VmaStlAllocator<VkMappedMemoryRange> RangeAllocator;
+    typedef VmaSmallVector<VkMappedMemoryRange, RangeAllocator, 16> RangeVector;
+    RangeVector ranges = RangeVector(RangeAllocator(GetAllocationCallbacks()));
+
+    for(uint32_t allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
+    {
+        const VmaAllocation alloc = allocations[allocIndex];
+        const VkDeviceSize offset = offsets != VMA_NULL ? offsets[allocIndex] : 0;
+        const VkDeviceSize size = sizes != VMA_NULL ? sizes[allocIndex] : VK_WHOLE_SIZE;
+        VkMappedMemoryRange newRange;
+        if(GetFlushOrInvalidateRange(alloc, offset, size, newRange))
+        {
+            ranges.push_back(newRange);
+        }
+    }
+
+    VkResult res = VK_SUCCESS;
+    if(!ranges.empty())
+    {
+        switch(op)
+        {
+        case VMA_CACHE_FLUSH:
+            res = (*GetVulkanFunctions().vkFlushMappedMemoryRanges)(m_hDevice, (uint32_t)ranges.size(), ranges.data());
+            break;
+        case VMA_CACHE_INVALIDATE:
+            res = (*GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hDevice, (uint32_t)ranges.size(), ranges.data());
+            break;
+        default:
+            VMA_ASSERT(0);
+        }
+    }
+    // else: Just ignore this call.
+    return res;
+}
+
+void VmaAllocator_T::FreeDedicatedMemory(const VmaAllocation allocation)
+{
+    VMA_ASSERT(allocation && allocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_DEDICATED);
+
+    const uint32_t memTypeIndex = allocation->GetMemoryTypeIndex();
+    {
+        VmaMutexLockWrite lock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
+        AllocationVectorType* const pDedicatedAllocations = m_pDedicatedAllocations[memTypeIndex];
+        VMA_ASSERT(pDedicatedAllocations);
+        bool success = VmaVectorRemoveSorted<VmaPointerLess>(*pDedicatedAllocations, allocation);
+        VMA_ASSERT(success);
+    }
+
+    VkDeviceMemory hMemory = allocation->GetMemory();
+
+    /*
+    There is no need to call this, because Vulkan spec allows to skip vkUnmapMemory
+    before vkFreeMemory.
+
+    if(allocation->GetMappedData() != VMA_NULL)
+    {
+        (*m_VulkanFunctions.vkUnmapMemory)(m_hDevice, hMemory);
+    }
+    */
+
+    FreeVulkanMemory(memTypeIndex, allocation->GetSize(), hMemory);
+
+    VMA_DEBUG_LOG("    Freed DedicatedMemory MemoryTypeIndex=%u", memTypeIndex);
+}
+
+uint32_t VmaAllocator_T::CalculateGpuDefragmentationMemoryTypeBits() const
+{
+    VkBufferCreateInfo dummyBufCreateInfo;
+    VmaFillGpuDefragmentationBufferCreateInfo(dummyBufCreateInfo);
+
+    uint32_t memoryTypeBits = 0;
+
+    // Create buffer.
+    VkBuffer buf = VK_NULL_HANDLE;
+    VkResult res = (*GetVulkanFunctions().vkCreateBuffer)(
+        m_hDevice, &dummyBufCreateInfo, GetAllocationCallbacks(), &buf);
+    if(res == VK_SUCCESS)
+    {
+        // Query for supported memory types.
+        VkMemoryRequirements memReq;
+        (*GetVulkanFunctions().vkGetBufferMemoryRequirements)(m_hDevice, buf, &memReq);
+        memoryTypeBits = memReq.memoryTypeBits;
+
+        // Destroy buffer.
+        (*GetVulkanFunctions().vkDestroyBuffer)(m_hDevice, buf, GetAllocationCallbacks());
+    }
+
+    return memoryTypeBits;
+}
+
+uint32_t VmaAllocator_T::CalculateGlobalMemoryTypeBits() const
+{
+    // Make sure memory information is already fetched.
+    VMA_ASSERT(GetMemoryTypeCount() > 0);
+
+    uint32_t memoryTypeBits = UINT32_MAX;
+
+    if(!m_UseAmdDeviceCoherentMemory)
+    {
+        // Exclude memory types that have VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD.
+        for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
+        {
+            if((m_MemProps.memoryTypes[memTypeIndex].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY) != 0)
+            {
+                memoryTypeBits &= ~(1u << memTypeIndex);
+            }
+        }
+    }
+
+    return memoryTypeBits;
+}
+
+bool VmaAllocator_T::GetFlushOrInvalidateRange(
+    VmaAllocation allocation,
+    VkDeviceSize offset, VkDeviceSize size,
+    VkMappedMemoryRange& outRange) const
+{
+    const uint32_t memTypeIndex = allocation->GetMemoryTypeIndex();
+    if(size > 0 && IsMemoryTypeNonCoherent(memTypeIndex))
+    {
+        const VkDeviceSize nonCoherentAtomSize = m_PhysicalDeviceProperties.limits.nonCoherentAtomSize;
+        const VkDeviceSize allocationSize = allocation->GetSize();
+        VMA_ASSERT(offset <= allocationSize);
+
+        outRange.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
+        outRange.pNext = VMA_NULL;
+        outRange.memory = allocation->GetMemory();
+
+        switch(allocation->GetType())
+        {
+        case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
+            outRange.offset = VmaAlignDown(offset, nonCoherentAtomSize);
+            if(size == VK_WHOLE_SIZE)
+            {
+                outRange.size = allocationSize - outRange.offset;
+            }
+            else
+            {
+                VMA_ASSERT(offset + size <= allocationSize);
+                outRange.size = VMA_MIN(
+                    VmaAlignUp(size + (offset - outRange.offset), nonCoherentAtomSize),
+                    allocationSize - outRange.offset);
+            }
+            break;
+        case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
+        {
+            // 1. Still within this allocation.
+            outRange.offset = VmaAlignDown(offset, nonCoherentAtomSize);
+            if(size == VK_WHOLE_SIZE)
+            {
+                size = allocationSize - offset;
+            }
+            else
+            {
+                VMA_ASSERT(offset + size <= allocationSize);
+            }
+            outRange.size = VmaAlignUp(size + (offset - outRange.offset), nonCoherentAtomSize);
+
+            // 2. Adjust to whole block.
+            const VkDeviceSize allocationOffset = allocation->GetOffset();
+            VMA_ASSERT(allocationOffset % nonCoherentAtomSize == 0);
+            const VkDeviceSize blockSize = allocation->GetBlock()->m_pMetadata->GetSize();
+            outRange.offset += allocationOffset;
+            outRange.size = VMA_MIN(outRange.size, blockSize - outRange.offset);
+
+            break;
+        }
+        default:
+            VMA_ASSERT(0);
+        }
+        return true;
+    }
+    return false;
+}
+
+#if VMA_MEMORY_BUDGET
+
+void VmaAllocator_T::UpdateVulkanBudget()
+{
+    VMA_ASSERT(m_UseExtMemoryBudget);
+
+    VkPhysicalDeviceMemoryProperties2KHR memProps = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR };
+
+    VkPhysicalDeviceMemoryBudgetPropertiesEXT budgetProps = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT };
+    VmaPnextChainPushFront(&memProps, &budgetProps);
+
+    GetVulkanFunctions().vkGetPhysicalDeviceMemoryProperties2KHR(m_PhysicalDevice, &memProps);
+
+    {
+        VmaMutexLockWrite lockWrite(m_Budget.m_BudgetMutex, m_UseMutex);
+
+        for(uint32_t heapIndex = 0; heapIndex < GetMemoryHeapCount(); ++heapIndex)
+        {
+            m_Budget.m_VulkanUsage[heapIndex] = budgetProps.heapUsage[heapIndex];
+            m_Budget.m_VulkanBudget[heapIndex] = budgetProps.heapBudget[heapIndex];
+            m_Budget.m_BlockBytesAtBudgetFetch[heapIndex] = m_Budget.m_BlockBytes[heapIndex].load();
+
+            // Some bugged drivers return the budget incorrectly, e.g. 0 or much bigger than heap size.
+            if(m_Budget.m_VulkanBudget[heapIndex] == 0)
+            {
+                m_Budget.m_VulkanBudget[heapIndex] = m_MemProps.memoryHeaps[heapIndex].size * 8 / 10; // 80% heuristics.
+            }
+            else if(m_Budget.m_VulkanBudget[heapIndex] > m_MemProps.memoryHeaps[heapIndex].size)
+            {
+                m_Budget.m_VulkanBudget[heapIndex] = m_MemProps.memoryHeaps[heapIndex].size;
+            }
+            if(m_Budget.m_VulkanUsage[heapIndex] == 0 && m_Budget.m_BlockBytesAtBudgetFetch[heapIndex] > 0)
+            {
+                m_Budget.m_VulkanUsage[heapIndex] = m_Budget.m_BlockBytesAtBudgetFetch[heapIndex];
+            }
+        }
+        m_Budget.m_OperationsSinceBudgetFetch = 0;
+    }
+}
+
+#endif // #if VMA_MEMORY_BUDGET
+
+void VmaAllocator_T::FillAllocation(const VmaAllocation hAllocation, uint8_t pattern)
+{
+    if(VMA_DEBUG_INITIALIZE_ALLOCATIONS &&
+        !hAllocation->CanBecomeLost() &&
+        (m_MemProps.memoryTypes[hAllocation->GetMemoryTypeIndex()].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0)
+    {
+        void* pData = VMA_NULL;
+        VkResult res = Map(hAllocation, &pData);
+        if(res == VK_SUCCESS)
+        {
+            memset(pData, (int)pattern, (size_t)hAllocation->GetSize());
+            FlushOrInvalidateAllocation(hAllocation, 0, VK_WHOLE_SIZE, VMA_CACHE_FLUSH);
+            Unmap(hAllocation);
+        }
+        else
+        {
+            VMA_ASSERT(0 && "VMA_DEBUG_INITIALIZE_ALLOCATIONS is enabled, but couldn't map memory to fill allocation.");
+        }
+    }
+}
+
+uint32_t VmaAllocator_T::GetGpuDefragmentationMemoryTypeBits()
+{
+    uint32_t memoryTypeBits = m_GpuDefragmentationMemoryTypeBits.load();
+    if(memoryTypeBits == UINT32_MAX)
+    {
+        memoryTypeBits = CalculateGpuDefragmentationMemoryTypeBits();
+        m_GpuDefragmentationMemoryTypeBits.store(memoryTypeBits);
+    }
+    return memoryTypeBits;
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+void VmaAllocator_T::PrintDetailedMap(VmaJsonWriter& json)
+{
+    bool dedicatedAllocationsStarted = false;
+    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
+    {
+        VmaMutexLockRead dedicatedAllocationsLock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
+        AllocationVectorType* const pDedicatedAllocVector = m_pDedicatedAllocations[memTypeIndex];
+        VMA_ASSERT(pDedicatedAllocVector);
+        if(pDedicatedAllocVector->empty() == false)
+        {
+            if(dedicatedAllocationsStarted == false)
+            {
+                dedicatedAllocationsStarted = true;
+                json.WriteString("DedicatedAllocations");
+                json.BeginObject();
+            }
+
+            json.BeginString("Type ");
+            json.ContinueString(memTypeIndex);
+            json.EndString();
+
+            json.BeginArray();
+
+            for(size_t i = 0; i < pDedicatedAllocVector->size(); ++i)
+            {
+                json.BeginObject(true);
+                const VmaAllocation hAlloc = (*pDedicatedAllocVector)[i];
+                hAlloc->PrintParameters(json);
+                json.EndObject();
+            }
+
+            json.EndArray();
+        }
+    }
+    if(dedicatedAllocationsStarted)
+    {
+        json.EndObject();
+    }
+
+    {
+        bool allocationsStarted = false;
+        for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
+        {
+            if(m_pBlockVectors[memTypeIndex]->IsEmpty() == false)
+            {
+                if(allocationsStarted == false)
+                {
+                    allocationsStarted = true;
+                    json.WriteString("DefaultPools");
+                    json.BeginObject();
+                }
+
+                json.BeginString("Type ");
+                json.ContinueString(memTypeIndex);
+                json.EndString();
+
+                m_pBlockVectors[memTypeIndex]->PrintDetailedMap(json);
+            }
+        }
+        if(allocationsStarted)
+        {
+            json.EndObject();
+        }
+    }
+
+    // Custom pools
+    {
+        VmaMutexLockRead lock(m_PoolsMutex, m_UseMutex);
+        const size_t poolCount = m_Pools.size();
+        if(poolCount > 0)
+        {
+            json.WriteString("Pools");
+            json.BeginObject();
+            for(size_t poolIndex = 0; poolIndex < poolCount; ++poolIndex)
+            {
+                json.BeginString();
+                json.ContinueString(m_Pools[poolIndex]->GetId());
+                json.EndString();
+
+                m_Pools[poolIndex]->m_BlockVector.PrintDetailedMap(json);
+            }
+            json.EndObject();
+        }
+    }
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////
+// Public interface
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAllocator(
+    const VmaAllocatorCreateInfo* pCreateInfo,
+    VmaAllocator* pAllocator)
+{
+    VMA_ASSERT(pCreateInfo && pAllocator);
+    VMA_ASSERT(pCreateInfo->vulkanApiVersion == 0 ||
+        (VK_VERSION_MAJOR(pCreateInfo->vulkanApiVersion) == 1 && VK_VERSION_MINOR(pCreateInfo->vulkanApiVersion) <= 2));
+    VMA_DEBUG_LOG("vmaCreateAllocator");
+    *pAllocator = vma_new(pCreateInfo->pAllocationCallbacks, VmaAllocator_T)(pCreateInfo);
+    return (*pAllocator)->Init(pCreateInfo);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyAllocator(
+    VmaAllocator allocator)
+{
+    if(allocator != VK_NULL_HANDLE)
+    {
+        VMA_DEBUG_LOG("vmaDestroyAllocator");
+        VkAllocationCallbacks allocationCallbacks = allocator->m_AllocationCallbacks;
+        vma_delete(&allocationCallbacks, allocator);
+    }
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocatorInfo(VmaAllocator allocator, VmaAllocatorInfo* pAllocatorInfo)
+{
+    VMA_ASSERT(allocator && pAllocatorInfo);
+    pAllocatorInfo->instance = allocator->m_hInstance;
+    pAllocatorInfo->physicalDevice = allocator->GetPhysicalDevice();
+    pAllocatorInfo->device = allocator->m_hDevice;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetPhysicalDeviceProperties(
+    VmaAllocator allocator,
+    const VkPhysicalDeviceProperties **ppPhysicalDeviceProperties)
+{
+    VMA_ASSERT(allocator && ppPhysicalDeviceProperties);
+    *ppPhysicalDeviceProperties = &allocator->m_PhysicalDeviceProperties;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryProperties(
+    VmaAllocator allocator,
+    const VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties)
+{
+    VMA_ASSERT(allocator && ppPhysicalDeviceMemoryProperties);
+    *ppPhysicalDeviceMemoryProperties = &allocator->m_MemProps;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryTypeProperties(
+    VmaAllocator allocator,
+    uint32_t memoryTypeIndex,
+    VkMemoryPropertyFlags* pFlags)
+{
+    VMA_ASSERT(allocator && pFlags);
+    VMA_ASSERT(memoryTypeIndex < allocator->GetMemoryTypeCount());
+    *pFlags = allocator->m_MemProps.memoryTypes[memoryTypeIndex].propertyFlags;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaSetCurrentFrameIndex(
+    VmaAllocator allocator,
+    uint32_t frameIndex)
+{
+    VMA_ASSERT(allocator);
+    VMA_ASSERT(frameIndex != VMA_FRAME_INDEX_LOST);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    allocator->SetCurrentFrameIndex(frameIndex);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaCalculateStats(
+    VmaAllocator allocator,
+    VmaStats* pStats)
+{
+    VMA_ASSERT(allocator && pStats);
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+    allocator->CalculateStats(pStats);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetBudget(
+    VmaAllocator allocator,
+    VmaBudget* pBudget)
+{
+    VMA_ASSERT(allocator && pBudget);
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+    allocator->GetBudget(pBudget, 0, allocator->GetMemoryHeapCount());
+}
+
+#if VMA_STATS_STRING_ENABLED
+
+VMA_CALL_PRE void VMA_CALL_POST vmaBuildStatsString(
+    VmaAllocator allocator,
+    char** ppStatsString,
+    VkBool32 detailedMap)
+{
+    VMA_ASSERT(allocator && ppStatsString);
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VmaStringBuilder sb(allocator);
+    {
+        VmaJsonWriter json(allocator->GetAllocationCallbacks(), sb);
+        json.BeginObject();
+
+        VmaBudget budget[VK_MAX_MEMORY_HEAPS];
+        allocator->GetBudget(budget, 0, allocator->GetMemoryHeapCount());
+
+        VmaStats stats;
+        allocator->CalculateStats(&stats);
+
+        json.WriteString("Total");
+        VmaPrintStatInfo(json, stats.total);
+
+        for(uint32_t heapIndex = 0; heapIndex < allocator->GetMemoryHeapCount(); ++heapIndex)
+        {
+            json.BeginString("Heap ");
+            json.ContinueString(heapIndex);
+            json.EndString();
+            json.BeginObject();
+
+            json.WriteString("Size");
+            json.WriteNumber(allocator->m_MemProps.memoryHeaps[heapIndex].size);
+
+            json.WriteString("Flags");
+            json.BeginArray(true);
+            if((allocator->m_MemProps.memoryHeaps[heapIndex].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) != 0)
+            {
+                json.WriteString("DEVICE_LOCAL");
+            }
+            json.EndArray();
+
+            json.WriteString("Budget");
+            json.BeginObject();
+            {
+                json.WriteString("BlockBytes");
+                json.WriteNumber(budget[heapIndex].blockBytes);
+                json.WriteString("AllocationBytes");
+                json.WriteNumber(budget[heapIndex].allocationBytes);
+                json.WriteString("Usage");
+                json.WriteNumber(budget[heapIndex].usage);
+                json.WriteString("Budget");
+                json.WriteNumber(budget[heapIndex].budget);
+            }
+            json.EndObject();
+
+            if(stats.memoryHeap[heapIndex].blockCount > 0)
+            {
+                json.WriteString("Stats");
+                VmaPrintStatInfo(json, stats.memoryHeap[heapIndex]);
+            }
+
+            for(uint32_t typeIndex = 0; typeIndex < allocator->GetMemoryTypeCount(); ++typeIndex)
+            {
+                if(allocator->MemoryTypeIndexToHeapIndex(typeIndex) == heapIndex)
+                {
+                    json.BeginString("Type ");
+                    json.ContinueString(typeIndex);
+                    json.EndString();
+
+                    json.BeginObject();
+
+                    json.WriteString("Flags");
+                    json.BeginArray(true);
+                    VkMemoryPropertyFlags flags = allocator->m_MemProps.memoryTypes[typeIndex].propertyFlags;
+                    if((flags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) != 0)
+                    {
+                        json.WriteString("DEVICE_LOCAL");
+                    }
+                    if((flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0)
+                    {
+                        json.WriteString("HOST_VISIBLE");
+                    }
+                    if((flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) != 0)
+                    {
+                        json.WriteString("HOST_COHERENT");
+                    }
+                    if((flags & VK_MEMORY_PROPERTY_HOST_CACHED_BIT) != 0)
+                    {
+                        json.WriteString("HOST_CACHED");
+                    }
+                    if((flags & VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT) != 0)
+                    {
+                        json.WriteString("LAZILY_ALLOCATED");
+                    }
+                    if((flags & VK_MEMORY_PROPERTY_PROTECTED_BIT) != 0)
+                    {
+                        json.WriteString(" PROTECTED");
+                    }
+                    if((flags & VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY) != 0)
+                    {
+                        json.WriteString(" DEVICE_COHERENT");
+                    }
+                    if((flags & VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY) != 0)
+                    {
+                        json.WriteString(" DEVICE_UNCACHED");
+                    }
+                    json.EndArray();
+
+                    if(stats.memoryType[typeIndex].blockCount > 0)
+                    {
+                        json.WriteString("Stats");
+                        VmaPrintStatInfo(json, stats.memoryType[typeIndex]);
+                    }
+
+                    json.EndObject();
+                }
+            }
+
+            json.EndObject();
+        }
+        if(detailedMap == VK_TRUE)
+        {
+            allocator->PrintDetailedMap(json);
+        }
+
+        json.EndObject();
+    }
+
+    const size_t len = sb.GetLength();
+    char* const pChars = vma_new_array(allocator, char, len + 1);
+    if(len > 0)
+    {
+        memcpy(pChars, sb.GetData(), len);
+    }
+    pChars[len] = '\0';
+    *ppStatsString = pChars;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaFreeStatsString(
+    VmaAllocator allocator,
+    char* pStatsString)
+{
+    if(pStatsString != VMA_NULL)
+    {
+        VMA_ASSERT(allocator);
+        size_t len = strlen(pStatsString);
+        vma_delete_array(allocator, pStatsString, len + 1);
+    }
+}
+
+#endif // #if VMA_STATS_STRING_ENABLED
+
+/*
+This function is not protected by any mutex because it just reads immutable data.
+*/
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndex(
+    VmaAllocator allocator,
+    uint32_t memoryTypeBits,
+    const VmaAllocationCreateInfo* pAllocationCreateInfo,
+    uint32_t* pMemoryTypeIndex)
+{
+    VMA_ASSERT(allocator != VK_NULL_HANDLE);
+    VMA_ASSERT(pAllocationCreateInfo != VMA_NULL);
+    VMA_ASSERT(pMemoryTypeIndex != VMA_NULL);
+
+    memoryTypeBits &= allocator->GetGlobalMemoryTypeBits();
+
+    if(pAllocationCreateInfo->memoryTypeBits != 0)
+    {
+        memoryTypeBits &= pAllocationCreateInfo->memoryTypeBits;
+    }
+
+    uint32_t requiredFlags = pAllocationCreateInfo->requiredFlags;
+    uint32_t preferredFlags = pAllocationCreateInfo->preferredFlags;
+    uint32_t notPreferredFlags = 0;
+
+    // Convert usage to requiredFlags and preferredFlags.
+    switch(pAllocationCreateInfo->usage)
+    {
+    case VMA_MEMORY_USAGE_UNKNOWN:
+        break;
+    case VMA_MEMORY_USAGE_GPU_ONLY:
+        if(!allocator->IsIntegratedGpu() || (preferredFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
+        {
+            preferredFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
+        }
+        break;
+    case VMA_MEMORY_USAGE_CPU_ONLY:
+        requiredFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
+        break;
+    case VMA_MEMORY_USAGE_CPU_TO_GPU:
+        requiredFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
+        if(!allocator->IsIntegratedGpu() || (preferredFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
+        {
+            preferredFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
+        }
+        break;
+    case VMA_MEMORY_USAGE_GPU_TO_CPU:
+        requiredFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
+        preferredFlags |= VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
+        break;
+    case VMA_MEMORY_USAGE_CPU_COPY:
+        notPreferredFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
+        break;
+    case VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED:
+        requiredFlags |= VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
+        break;
+    default:
+        VMA_ASSERT(0);
+        break;
+    }
+
+    // Avoid DEVICE_COHERENT unless explicitly requested.
+    if(((pAllocationCreateInfo->requiredFlags | pAllocationCreateInfo->preferredFlags) &
+        (VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY | VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY)) == 0)
+    {
+        notPreferredFlags |= VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY;
+    }
+
+    *pMemoryTypeIndex = UINT32_MAX;
+    uint32_t minCost = UINT32_MAX;
+    for(uint32_t memTypeIndex = 0, memTypeBit = 1;
+        memTypeIndex < allocator->GetMemoryTypeCount();
+        ++memTypeIndex, memTypeBit <<= 1)
+    {
+        // This memory type is acceptable according to memoryTypeBits bitmask.
+        if((memTypeBit & memoryTypeBits) != 0)
+        {
+            const VkMemoryPropertyFlags currFlags =
+                allocator->m_MemProps.memoryTypes[memTypeIndex].propertyFlags;
+            // This memory type contains requiredFlags.
+            if((requiredFlags & ~currFlags) == 0)
+            {
+                // Calculate cost as number of bits from preferredFlags not present in this memory type.
+                uint32_t currCost = VmaCountBitsSet(preferredFlags & ~currFlags) +
+                    VmaCountBitsSet(currFlags & notPreferredFlags);
+                // Remember memory type with lowest cost.
+                if(currCost < minCost)
+                {
+                    *pMemoryTypeIndex = memTypeIndex;
+                    if(currCost == 0)
+                    {
+                        return VK_SUCCESS;
+                    }
+                    minCost = currCost;
+                }
+            }
+        }
+    }
+    return (*pMemoryTypeIndex != UINT32_MAX) ? VK_SUCCESS : VK_ERROR_FEATURE_NOT_PRESENT;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForBufferInfo(
+    VmaAllocator allocator,
+    const VkBufferCreateInfo* pBufferCreateInfo,
+    const VmaAllocationCreateInfo* pAllocationCreateInfo,
+    uint32_t* pMemoryTypeIndex)
+{
+    VMA_ASSERT(allocator != VK_NULL_HANDLE);
+    VMA_ASSERT(pBufferCreateInfo != VMA_NULL);
+    VMA_ASSERT(pAllocationCreateInfo != VMA_NULL);
+    VMA_ASSERT(pMemoryTypeIndex != VMA_NULL);
+
+    const VkDevice hDev = allocator->m_hDevice;
+    VkBuffer hBuffer = VK_NULL_HANDLE;
+    VkResult res = allocator->GetVulkanFunctions().vkCreateBuffer(
+        hDev, pBufferCreateInfo, allocator->GetAllocationCallbacks(), &hBuffer);
+    if(res == VK_SUCCESS)
+    {
+        VkMemoryRequirements memReq = {};
+        allocator->GetVulkanFunctions().vkGetBufferMemoryRequirements(
+            hDev, hBuffer, &memReq);
+
+        res = vmaFindMemoryTypeIndex(
+            allocator,
+            memReq.memoryTypeBits,
+            pAllocationCreateInfo,
+            pMemoryTypeIndex);
+
+        allocator->GetVulkanFunctions().vkDestroyBuffer(
+            hDev, hBuffer, allocator->GetAllocationCallbacks());
+    }
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForImageInfo(
+    VmaAllocator allocator,
+    const VkImageCreateInfo* pImageCreateInfo,
+    const VmaAllocationCreateInfo* pAllocationCreateInfo,
+    uint32_t* pMemoryTypeIndex)
+{
+    VMA_ASSERT(allocator != VK_NULL_HANDLE);
+    VMA_ASSERT(pImageCreateInfo != VMA_NULL);
+    VMA_ASSERT(pAllocationCreateInfo != VMA_NULL);
+    VMA_ASSERT(pMemoryTypeIndex != VMA_NULL);
+
+    const VkDevice hDev = allocator->m_hDevice;
+    VkImage hImage = VK_NULL_HANDLE;
+    VkResult res = allocator->GetVulkanFunctions().vkCreateImage(
+        hDev, pImageCreateInfo, allocator->GetAllocationCallbacks(), &hImage);
+    if(res == VK_SUCCESS)
+    {
+        VkMemoryRequirements memReq = {};
+        allocator->GetVulkanFunctions().vkGetImageMemoryRequirements(
+            hDev, hImage, &memReq);
+
+        res = vmaFindMemoryTypeIndex(
+            allocator,
+            memReq.memoryTypeBits,
+            pAllocationCreateInfo,
+            pMemoryTypeIndex);
+
+        allocator->GetVulkanFunctions().vkDestroyImage(
+            hDev, hImage, allocator->GetAllocationCallbacks());
+    }
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreatePool(
+    VmaAllocator allocator,
+    const VmaPoolCreateInfo* pCreateInfo,
+    VmaPool* pPool)
+{
+    VMA_ASSERT(allocator && pCreateInfo && pPool);
+
+    VMA_DEBUG_LOG("vmaCreatePool");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VkResult res = allocator->CreatePool(pCreateInfo, pPool);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordCreatePool(allocator->GetCurrentFrameIndex(), *pCreateInfo, *pPool);
+    }
+#endif
+
+    return res;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool(
+    VmaAllocator allocator,
+    VmaPool pool)
+{
+    VMA_ASSERT(allocator);
+
+    if(pool == VK_NULL_HANDLE)
+    {
+        return;
+    }
+
+    VMA_DEBUG_LOG("vmaDestroyPool");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordDestroyPool(allocator->GetCurrentFrameIndex(), pool);
+    }
+#endif
+
+    allocator->DestroyPool(pool);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolStats(
+    VmaAllocator allocator,
+    VmaPool pool,
+    VmaPoolStats* pPoolStats)
+{
+    VMA_ASSERT(allocator && pool && pPoolStats);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    allocator->GetPoolStats(pool, pPoolStats);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaMakePoolAllocationsLost(
+    VmaAllocator allocator,
+    VmaPool pool,
+    size_t* pLostAllocationCount)
+{
+    VMA_ASSERT(allocator && pool);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordMakePoolAllocationsLost(allocator->GetCurrentFrameIndex(), pool);
+    }
+#endif
+
+    allocator->MakePoolAllocationsLost(pool, pLostAllocationCount);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckPoolCorruption(VmaAllocator allocator, VmaPool pool)
+{
+    VMA_ASSERT(allocator && pool);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VMA_DEBUG_LOG("vmaCheckPoolCorruption");
+
+    return allocator->CheckPoolCorruption(pool);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolName(
+    VmaAllocator allocator,
+    VmaPool pool,
+    const char** ppName)
+{
+    VMA_ASSERT(allocator && pool && ppName);
+
+    VMA_DEBUG_LOG("vmaGetPoolName");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    *ppName = pool->GetName();
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaSetPoolName(
+    VmaAllocator allocator,
+    VmaPool pool,
+    const char* pName)
+{
+    VMA_ASSERT(allocator && pool);
+
+    VMA_DEBUG_LOG("vmaSetPoolName");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    pool->SetName(pName);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordSetPoolName(allocator->GetCurrentFrameIndex(), pool, pName);
+    }
+#endif
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemory(
+    VmaAllocator allocator,
+    const VkMemoryRequirements* pVkMemoryRequirements,
+    const VmaAllocationCreateInfo* pCreateInfo,
+    VmaAllocation* pAllocation,
+    VmaAllocationInfo* pAllocationInfo)
+{
+    VMA_ASSERT(allocator && pVkMemoryRequirements && pCreateInfo && pAllocation);
+
+    VMA_DEBUG_LOG("vmaAllocateMemory");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VkResult result = allocator->AllocateMemory(
+        *pVkMemoryRequirements,
+        false, // requiresDedicatedAllocation
+        false, // prefersDedicatedAllocation
+        VK_NULL_HANDLE, // dedicatedBuffer
+        UINT32_MAX, // dedicatedBufferUsage
+        VK_NULL_HANDLE, // dedicatedImage
+        *pCreateInfo,
+        VMA_SUBALLOCATION_TYPE_UNKNOWN,
+        1, // allocationCount
+        pAllocation);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordAllocateMemory(
+            allocator->GetCurrentFrameIndex(),
+            *pVkMemoryRequirements,
+            *pCreateInfo,
+            *pAllocation);
+    }
+#endif
+
+    if(pAllocationInfo != VMA_NULL && result == VK_SUCCESS)
+    {
+        allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
+    }
+
+    return result;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryPages(
+    VmaAllocator allocator,
+    const VkMemoryRequirements* pVkMemoryRequirements,
+    const VmaAllocationCreateInfo* pCreateInfo,
+    size_t allocationCount,
+    VmaAllocation* pAllocations,
+    VmaAllocationInfo* pAllocationInfo)
+{
+    if(allocationCount == 0)
+    {
+        return VK_SUCCESS;
+    }
+
+    VMA_ASSERT(allocator && pVkMemoryRequirements && pCreateInfo && pAllocations);
+
+    VMA_DEBUG_LOG("vmaAllocateMemoryPages");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VkResult result = allocator->AllocateMemory(
+        *pVkMemoryRequirements,
+        false, // requiresDedicatedAllocation
+        false, // prefersDedicatedAllocation
+        VK_NULL_HANDLE, // dedicatedBuffer
+        UINT32_MAX, // dedicatedBufferUsage
+        VK_NULL_HANDLE, // dedicatedImage
+        *pCreateInfo,
+        VMA_SUBALLOCATION_TYPE_UNKNOWN,
+        allocationCount,
+        pAllocations);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordAllocateMemoryPages(
+            allocator->GetCurrentFrameIndex(),
+            *pVkMemoryRequirements,
+            *pCreateInfo,
+            (uint64_t)allocationCount,
+            pAllocations);
+    }
+#endif
+
+    if(pAllocationInfo != VMA_NULL && result == VK_SUCCESS)
+    {
+        for(size_t i = 0; i < allocationCount; ++i)
+        {
+            allocator->GetAllocationInfo(pAllocations[i], pAllocationInfo + i);
+        }
+    }
+
+    return result;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForBuffer(
+    VmaAllocator allocator,
+    VkBuffer buffer,
+    const VmaAllocationCreateInfo* pCreateInfo,
+    VmaAllocation* pAllocation,
+    VmaAllocationInfo* pAllocationInfo)
+{
+    VMA_ASSERT(allocator && buffer != VK_NULL_HANDLE && pCreateInfo && pAllocation);
+
+    VMA_DEBUG_LOG("vmaAllocateMemoryForBuffer");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VkMemoryRequirements vkMemReq = {};
+    bool requiresDedicatedAllocation = false;
+    bool prefersDedicatedAllocation = false;
+    allocator->GetBufferMemoryRequirements(buffer, vkMemReq,
+        requiresDedicatedAllocation,
+        prefersDedicatedAllocation);
+
+    VkResult result = allocator->AllocateMemory(
+        vkMemReq,
+        requiresDedicatedAllocation,
+        prefersDedicatedAllocation,
+        buffer, // dedicatedBuffer
+        UINT32_MAX, // dedicatedBufferUsage
+        VK_NULL_HANDLE, // dedicatedImage
+        *pCreateInfo,
+        VMA_SUBALLOCATION_TYPE_BUFFER,
+        1, // allocationCount
+        pAllocation);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordAllocateMemoryForBuffer(
+            allocator->GetCurrentFrameIndex(),
+            vkMemReq,
+            requiresDedicatedAllocation,
+            prefersDedicatedAllocation,
+            *pCreateInfo,
+            *pAllocation);
+    }
+#endif
+
+    if(pAllocationInfo && result == VK_SUCCESS)
+    {
+        allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
+    }
+
+    return result;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForImage(
+    VmaAllocator allocator,
+    VkImage image,
+    const VmaAllocationCreateInfo* pCreateInfo,
+    VmaAllocation* pAllocation,
+    VmaAllocationInfo* pAllocationInfo)
+{
+    VMA_ASSERT(allocator && image != VK_NULL_HANDLE && pCreateInfo && pAllocation);
+
+    VMA_DEBUG_LOG("vmaAllocateMemoryForImage");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VkMemoryRequirements vkMemReq = {};
+    bool requiresDedicatedAllocation = false;
+    bool prefersDedicatedAllocation  = false;
+    allocator->GetImageMemoryRequirements(image, vkMemReq,
+        requiresDedicatedAllocation, prefersDedicatedAllocation);
+
+    VkResult result = allocator->AllocateMemory(
+        vkMemReq,
+        requiresDedicatedAllocation,
+        prefersDedicatedAllocation,
+        VK_NULL_HANDLE, // dedicatedBuffer
+        UINT32_MAX, // dedicatedBufferUsage
+        image, // dedicatedImage
+        *pCreateInfo,
+        VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN,
+        1, // allocationCount
+        pAllocation);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordAllocateMemoryForImage(
+            allocator->GetCurrentFrameIndex(),
+            vkMemReq,
+            requiresDedicatedAllocation,
+            prefersDedicatedAllocation,
+            *pCreateInfo,
+            *pAllocation);
+    }
+#endif
+
+    if(pAllocationInfo && result == VK_SUCCESS)
+    {
+        allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
+    }
+
+    return result;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory(
+    VmaAllocator allocator,
+    VmaAllocation allocation)
+{
+    VMA_ASSERT(allocator);
+
+    if(allocation == VK_NULL_HANDLE)
+    {
+        return;
+    }
+
+    VMA_DEBUG_LOG("vmaFreeMemory");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordFreeMemory(
+            allocator->GetCurrentFrameIndex(),
+            allocation);
+    }
+#endif
+
+    allocator->FreeMemory(
+        1, // allocationCount
+        &allocation);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemoryPages(
+    VmaAllocator allocator,
+    size_t allocationCount,
+    const VmaAllocation* pAllocations)
+{
+    if(allocationCount == 0)
+    {
+        return;
+    }
+
+    VMA_ASSERT(allocator);
+
+    VMA_DEBUG_LOG("vmaFreeMemoryPages");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordFreeMemoryPages(
+            allocator->GetCurrentFrameIndex(),
+            (uint64_t)allocationCount,
+            pAllocations);
+    }
+#endif
+
+    allocator->FreeMemory(allocationCount, pAllocations);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaResizeAllocation(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    VkDeviceSize newSize)
+{
+    VMA_ASSERT(allocator && allocation);
+
+    VMA_DEBUG_LOG("vmaResizeAllocation");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    return allocator->ResizeAllocation(allocation, newSize);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    VmaAllocationInfo* pAllocationInfo)
+{
+    VMA_ASSERT(allocator && allocation && pAllocationInfo);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordGetAllocationInfo(
+            allocator->GetCurrentFrameIndex(),
+            allocation);
+    }
+#endif
+
+    allocator->GetAllocationInfo(allocation, pAllocationInfo);
+}
+
+VMA_CALL_PRE VkBool32 VMA_CALL_POST vmaTouchAllocation(
+    VmaAllocator allocator,
+    VmaAllocation allocation)
+{
+    VMA_ASSERT(allocator && allocation);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordTouchAllocation(
+            allocator->GetCurrentFrameIndex(),
+            allocation);
+    }
+#endif
+
+    return allocator->TouchAllocation(allocation);
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationUserData(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    void* pUserData)
+{
+    VMA_ASSERT(allocator && allocation);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    allocation->SetUserData(allocator, pUserData);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordSetAllocationUserData(
+            allocator->GetCurrentFrameIndex(),
+            allocation,
+            pUserData);
+    }
+#endif
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaCreateLostAllocation(
+    VmaAllocator allocator,
+    VmaAllocation* pAllocation)
+{
+    VMA_ASSERT(allocator && pAllocation);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK;
+
+    allocator->CreateLostAllocation(pAllocation);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordCreateLostAllocation(
+            allocator->GetCurrentFrameIndex(),
+            *pAllocation);
+    }
+#endif
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaMapMemory(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    void** ppData)
+{
+    VMA_ASSERT(allocator && allocation && ppData);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VkResult res = allocator->Map(allocation, ppData);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordMapMemory(
+            allocator->GetCurrentFrameIndex(),
+            allocation);
+    }
+#endif
+
+    return res;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaUnmapMemory(
+    VmaAllocator allocator,
+    VmaAllocation allocation)
+{
+    VMA_ASSERT(allocator && allocation);
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordUnmapMemory(
+            allocator->GetCurrentFrameIndex(),
+            allocation);
+    }
+#endif
+
+    allocator->Unmap(allocation);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
+{
+    VMA_ASSERT(allocator && allocation);
+
+    VMA_DEBUG_LOG("vmaFlushAllocation");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    const VkResult res = allocator->FlushOrInvalidateAllocation(allocation, offset, size, VMA_CACHE_FLUSH);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordFlushAllocation(
+            allocator->GetCurrentFrameIndex(),
+            allocation, offset, size);
+    }
+#endif
+
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
+{
+    VMA_ASSERT(allocator && allocation);
+
+    VMA_DEBUG_LOG("vmaInvalidateAllocation");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    const VkResult res = allocator->FlushOrInvalidateAllocation(allocation, offset, size, VMA_CACHE_INVALIDATE);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordInvalidateAllocation(
+            allocator->GetCurrentFrameIndex(),
+            allocation, offset, size);
+    }
+#endif
+
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocations(
+    VmaAllocator allocator,
+    uint32_t allocationCount,
+    const VmaAllocation* allocations,
+    const VkDeviceSize* offsets,
+    const VkDeviceSize* sizes)
+{
+    VMA_ASSERT(allocator);
+
+    if(allocationCount == 0)
+    {
+        return VK_SUCCESS;
+    }
+
+    VMA_ASSERT(allocations);
+
+    VMA_DEBUG_LOG("vmaFlushAllocations");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    const VkResult res = allocator->FlushOrInvalidateAllocations(allocationCount, allocations, offsets, sizes, VMA_CACHE_FLUSH);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        //TODO
+    }
+#endif
+
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocations(
+    VmaAllocator allocator,
+    uint32_t allocationCount,
+    const VmaAllocation* allocations,
+    const VkDeviceSize* offsets,
+    const VkDeviceSize* sizes)
+{
+    VMA_ASSERT(allocator);
+
+    if(allocationCount == 0)
+    {
+        return VK_SUCCESS;
+    }
+
+    VMA_ASSERT(allocations);
+
+    VMA_DEBUG_LOG("vmaInvalidateAllocations");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    const VkResult res = allocator->FlushOrInvalidateAllocations(allocationCount, allocations, offsets, sizes, VMA_CACHE_INVALIDATE);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        //TODO
+    }
+#endif
+
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckCorruption(VmaAllocator allocator, uint32_t memoryTypeBits)
+{
+    VMA_ASSERT(allocator);
+
+    VMA_DEBUG_LOG("vmaCheckCorruption");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    return allocator->CheckCorruption(memoryTypeBits);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragment(
+    VmaAllocator allocator,
+    const VmaAllocation* pAllocations,
+    size_t allocationCount,
+    VkBool32* pAllocationsChanged,
+    const VmaDefragmentationInfo *pDefragmentationInfo,
+    VmaDefragmentationStats* pDefragmentationStats)
+{
+    // Deprecated interface, reimplemented using new one.
+
+    VmaDefragmentationInfo2 info2 = {};
+    info2.allocationCount = (uint32_t)allocationCount;
+    info2.pAllocations = pAllocations;
+    info2.pAllocationsChanged = pAllocationsChanged;
+    if(pDefragmentationInfo != VMA_NULL)
+    {
+        info2.maxCpuAllocationsToMove = pDefragmentationInfo->maxAllocationsToMove;
+        info2.maxCpuBytesToMove = pDefragmentationInfo->maxBytesToMove;
+    }
+    else
+    {
+        info2.maxCpuAllocationsToMove = UINT32_MAX;
+        info2.maxCpuBytesToMove = VK_WHOLE_SIZE;
+    }
+    // info2.flags, maxGpuAllocationsToMove, maxGpuBytesToMove, commandBuffer deliberately left zero.
+
+    VmaDefragmentationContext ctx;
+    VkResult res = vmaDefragmentationBegin(allocator, &info2, pDefragmentationStats, &ctx);
+    if(res == VK_NOT_READY)
+    {
+        res = vmaDefragmentationEnd( allocator, ctx);
+    }
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationBegin(
+    VmaAllocator allocator,
+    const VmaDefragmentationInfo2* pInfo,
+    VmaDefragmentationStats* pStats,
+    VmaDefragmentationContext *pContext)
+{
+    VMA_ASSERT(allocator && pInfo && pContext);
+
+    // Degenerate case: Nothing to defragment.
+    if(pInfo->allocationCount == 0 && pInfo->poolCount == 0)
+    {
+        return VK_SUCCESS;
+    }
+
+    VMA_ASSERT(pInfo->allocationCount == 0 || pInfo->pAllocations != VMA_NULL);
+    VMA_ASSERT(pInfo->poolCount == 0 || pInfo->pPools != VMA_NULL);
+    VMA_HEAVY_ASSERT(VmaValidatePointerArray(pInfo->allocationCount, pInfo->pAllocations));
+    VMA_HEAVY_ASSERT(VmaValidatePointerArray(pInfo->poolCount, pInfo->pPools));
+
+    VMA_DEBUG_LOG("vmaDefragmentationBegin");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    VkResult res = allocator->DefragmentationBegin(*pInfo, pStats, pContext);
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordDefragmentationBegin(
+            allocator->GetCurrentFrameIndex(), *pInfo, *pContext);
+    }
+#endif
+
+    return res;
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationEnd(
+    VmaAllocator allocator,
+    VmaDefragmentationContext context)
+{
+    VMA_ASSERT(allocator);
+
+    VMA_DEBUG_LOG("vmaDefragmentationEnd");
+
+    if(context != VK_NULL_HANDLE)
+    {
+        VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+        if(allocator->GetRecorder() != VMA_NULL)
+        {
+            allocator->GetRecorder()->RecordDefragmentationEnd(
+                allocator->GetCurrentFrameIndex(), context);
+        }
+#endif
+
+        return allocator->DefragmentationEnd(context);
+    }
+    else
+    {
+        return VK_SUCCESS;
+    }
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentationPass(
+    VmaAllocator allocator,
+    VmaDefragmentationContext context,
+    VmaDefragmentationPassInfo* pInfo
+    )
+{
+    VMA_ASSERT(allocator);
+    VMA_ASSERT(pInfo);
+
+    VMA_DEBUG_LOG("vmaBeginDefragmentationPass");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    if(context == VK_NULL_HANDLE)
+    {
+        pInfo->moveCount = 0;
+        return VK_SUCCESS;
+    }
+
+    return allocator->DefragmentationPassBegin(pInfo, context);
+}
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaEndDefragmentationPass(
+    VmaAllocator allocator,
+    VmaDefragmentationContext context)
+{
+    VMA_ASSERT(allocator);
+
+    VMA_DEBUG_LOG("vmaEndDefragmentationPass");
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    if(context == VK_NULL_HANDLE)
+        return VK_SUCCESS;
+
+    return allocator->DefragmentationPassEnd(context);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    VkBuffer buffer)
+{
+    VMA_ASSERT(allocator && allocation && buffer);
+
+    VMA_DEBUG_LOG("vmaBindBufferMemory");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    return allocator->BindBufferMemory(allocation, 0, buffer, VMA_NULL);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory2(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    VkDeviceSize allocationLocalOffset,
+    VkBuffer buffer,
+    const void* pNext)
+{
+    VMA_ASSERT(allocator && allocation && buffer);
+
+    VMA_DEBUG_LOG("vmaBindBufferMemory2");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    return allocator->BindBufferMemory(allocation, allocationLocalOffset, buffer, pNext);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    VkImage image)
+{
+    VMA_ASSERT(allocator && allocation && image);
+
+    VMA_DEBUG_LOG("vmaBindImageMemory");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    return allocator->BindImageMemory(allocation, 0, image, VMA_NULL);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory2(
+    VmaAllocator allocator,
+    VmaAllocation allocation,
+    VkDeviceSize allocationLocalOffset,
+    VkImage image,
+    const void* pNext)
+{
+    VMA_ASSERT(allocator && allocation && image);
+
+    VMA_DEBUG_LOG("vmaBindImageMemory2");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+        return allocator->BindImageMemory(allocation, allocationLocalOffset, image, pNext);
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer(
+    VmaAllocator allocator,
+    const VkBufferCreateInfo* pBufferCreateInfo,
+    const VmaAllocationCreateInfo* pAllocationCreateInfo,
+    VkBuffer* pBuffer,
+    VmaAllocation* pAllocation,
+    VmaAllocationInfo* pAllocationInfo)
+{
+    VMA_ASSERT(allocator && pBufferCreateInfo && pAllocationCreateInfo && pBuffer && pAllocation);
+
+    if(pBufferCreateInfo->size == 0)
+    {
+        return VK_ERROR_VALIDATION_FAILED_EXT;
+    }
+    if((pBufferCreateInfo->usage & VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_COPY) != 0 &&
+        !allocator->m_UseKhrBufferDeviceAddress)
+    {
+        VMA_ASSERT(0 && "Creating a buffer with VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT is not valid if VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT was not used.");
+        return VK_ERROR_VALIDATION_FAILED_EXT;
+    }
+
+    VMA_DEBUG_LOG("vmaCreateBuffer");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    *pBuffer = VK_NULL_HANDLE;
+    *pAllocation = VK_NULL_HANDLE;
+
+    // 1. Create VkBuffer.
+    VkResult res = (*allocator->GetVulkanFunctions().vkCreateBuffer)(
+        allocator->m_hDevice,
+        pBufferCreateInfo,
+        allocator->GetAllocationCallbacks(),
+        pBuffer);
+    if(res >= 0)
+    {
+        // 2. vkGetBufferMemoryRequirements.
+        VkMemoryRequirements vkMemReq = {};
+        bool requiresDedicatedAllocation = false;
+        bool prefersDedicatedAllocation  = false;
+        allocator->GetBufferMemoryRequirements(*pBuffer, vkMemReq,
+            requiresDedicatedAllocation, prefersDedicatedAllocation);
+
+        // 3. Allocate memory using allocator.
+        res = allocator->AllocateMemory(
+            vkMemReq,
+            requiresDedicatedAllocation,
+            prefersDedicatedAllocation,
+            *pBuffer, // dedicatedBuffer
+            pBufferCreateInfo->usage, // dedicatedBufferUsage
+            VK_NULL_HANDLE, // dedicatedImage
+            *pAllocationCreateInfo,
+            VMA_SUBALLOCATION_TYPE_BUFFER,
+            1, // allocationCount
+            pAllocation);
+
+#if VMA_RECORDING_ENABLED
+        if(allocator->GetRecorder() != VMA_NULL)
+        {
+            allocator->GetRecorder()->RecordCreateBuffer(
+                allocator->GetCurrentFrameIndex(),
+                *pBufferCreateInfo,
+                *pAllocationCreateInfo,
+                *pAllocation);
+        }
+#endif
+
+        if(res >= 0)
+        {
+            // 3. Bind buffer with memory.
+            if((pAllocationCreateInfo->flags & VMA_ALLOCATION_CREATE_DONT_BIND_BIT) == 0)
+            {
+                res = allocator->BindBufferMemory(*pAllocation, 0, *pBuffer, VMA_NULL);
+            }
+            if(res >= 0)
+            {
+                // All steps succeeded.
+                #if VMA_STATS_STRING_ENABLED
+                    (*pAllocation)->InitBufferImageUsage(pBufferCreateInfo->usage);
+                #endif
+                if(pAllocationInfo != VMA_NULL)
+                {
+                    allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
+                }
+
+                return VK_SUCCESS;
+            }
+            allocator->FreeMemory(
+                1, // allocationCount
+                pAllocation);
+            *pAllocation = VK_NULL_HANDLE;
+            (*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, *pBuffer, allocator->GetAllocationCallbacks());
+            *pBuffer = VK_NULL_HANDLE;
+            return res;
+        }
+        (*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, *pBuffer, allocator->GetAllocationCallbacks());
+        *pBuffer = VK_NULL_HANDLE;
+        return res;
+    }
+    return res;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer(
+    VmaAllocator allocator,
+    VkBuffer buffer,
+    VmaAllocation allocation)
+{
+    VMA_ASSERT(allocator);
+
+    if(buffer == VK_NULL_HANDLE && allocation == VK_NULL_HANDLE)
+    {
+        return;
+    }
+
+    VMA_DEBUG_LOG("vmaDestroyBuffer");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordDestroyBuffer(
+            allocator->GetCurrentFrameIndex(),
+            allocation);
+    }
+#endif
+
+    if(buffer != VK_NULL_HANDLE)
+    {
+        (*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, buffer, allocator->GetAllocationCallbacks());
+    }
+
+    if(allocation != VK_NULL_HANDLE)
+    {
+        allocator->FreeMemory(
+            1, // allocationCount
+            &allocation);
+    }
+}
+
+VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateImage(
+    VmaAllocator allocator,
+    const VkImageCreateInfo* pImageCreateInfo,
+    const VmaAllocationCreateInfo* pAllocationCreateInfo,
+    VkImage* pImage,
+    VmaAllocation* pAllocation,
+    VmaAllocationInfo* pAllocationInfo)
+{
+    VMA_ASSERT(allocator && pImageCreateInfo && pAllocationCreateInfo && pImage && pAllocation);
+
+    if(pImageCreateInfo->extent.width == 0 ||
+        pImageCreateInfo->extent.height == 0 ||
+        pImageCreateInfo->extent.depth == 0 ||
+        pImageCreateInfo->mipLevels == 0 ||
+        pImageCreateInfo->arrayLayers == 0)
+    {
+        return VK_ERROR_VALIDATION_FAILED_EXT;
+    }
+
+    VMA_DEBUG_LOG("vmaCreateImage");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+    *pImage = VK_NULL_HANDLE;
+    *pAllocation = VK_NULL_HANDLE;
+
+    // 1. Create VkImage.
+    VkResult res = (*allocator->GetVulkanFunctions().vkCreateImage)(
+        allocator->m_hDevice,
+        pImageCreateInfo,
+        allocator->GetAllocationCallbacks(),
+        pImage);
+    if(res >= 0)
+    {
+        VmaSuballocationType suballocType = pImageCreateInfo->tiling == VK_IMAGE_TILING_OPTIMAL ?
+            VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL :
+            VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR;
+
+        // 2. Allocate memory using allocator.
+        VkMemoryRequirements vkMemReq = {};
+        bool requiresDedicatedAllocation = false;
+        bool prefersDedicatedAllocation  = false;
+        allocator->GetImageMemoryRequirements(*pImage, vkMemReq,
+            requiresDedicatedAllocation, prefersDedicatedAllocation);
+
+        res = allocator->AllocateMemory(
+            vkMemReq,
+            requiresDedicatedAllocation,
+            prefersDedicatedAllocation,
+            VK_NULL_HANDLE, // dedicatedBuffer
+            UINT32_MAX, // dedicatedBufferUsage
+            *pImage, // dedicatedImage
+            *pAllocationCreateInfo,
+            suballocType,
+            1, // allocationCount
+            pAllocation);
+
+#if VMA_RECORDING_ENABLED
+        if(allocator->GetRecorder() != VMA_NULL)
+        {
+            allocator->GetRecorder()->RecordCreateImage(
+                allocator->GetCurrentFrameIndex(),
+                *pImageCreateInfo,
+                *pAllocationCreateInfo,
+                *pAllocation);
+        }
+#endif
+
+        if(res >= 0)
+        {
+            // 3. Bind image with memory.
+            if((pAllocationCreateInfo->flags & VMA_ALLOCATION_CREATE_DONT_BIND_BIT) == 0)
+            {
+                res = allocator->BindImageMemory(*pAllocation, 0, *pImage, VMA_NULL);
+            }
+            if(res >= 0)
+            {
+                // All steps succeeded.
+                #if VMA_STATS_STRING_ENABLED
+                    (*pAllocation)->InitBufferImageUsage(pImageCreateInfo->usage);
+                #endif
+                if(pAllocationInfo != VMA_NULL)
+                {
+                    allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
+                }
+
+                return VK_SUCCESS;
+            }
+            allocator->FreeMemory(
+                1, // allocationCount
+                pAllocation);
+            *pAllocation = VK_NULL_HANDLE;
+            (*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, *pImage, allocator->GetAllocationCallbacks());
+            *pImage = VK_NULL_HANDLE;
+            return res;
+        }
+        (*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, *pImage, allocator->GetAllocationCallbacks());
+        *pImage = VK_NULL_HANDLE;
+        return res;
+    }
+    return res;
+}
+
+VMA_CALL_PRE void VMA_CALL_POST vmaDestroyImage(
+    VmaAllocator allocator,
+    VkImage image,
+    VmaAllocation allocation)
+{
+    VMA_ASSERT(allocator);
+
+    if(image == VK_NULL_HANDLE && allocation == VK_NULL_HANDLE)
+    {
+        return;
+    }
+
+    VMA_DEBUG_LOG("vmaDestroyImage");
+
+    VMA_DEBUG_GLOBAL_MUTEX_LOCK
+
+#if VMA_RECORDING_ENABLED
+    if(allocator->GetRecorder() != VMA_NULL)
+    {
+        allocator->GetRecorder()->RecordDestroyImage(
+            allocator->GetCurrentFrameIndex(),
+            allocation);
+    }
+#endif
+
+    if(image != VK_NULL_HANDLE)
+    {
+        (*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, image, allocator->GetAllocationCallbacks());
+    }
+    if(allocation != VK_NULL_HANDLE)
+    {
+        allocator->FreeMemory(
+            1, // allocationCount
+            &allocation);
+    }
+}
+
+#endif // #ifdef VMA_IMPLEMENTATION
diff -Naur ./ThirdParty/bcrypt/CMakeLists.txt ../omniscidb-master/ThirdParty/bcrypt/CMakeLists.txt
--- ./ThirdParty/bcrypt/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/bcrypt/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -1,5 +1,9 @@
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -W -Wall -Wbad-function-cast -Wcast-align -Wcast-qual -Wmissing-prototypes -Wstrict-prototypes -Wshadow -Wundef -Wpointer-arith -O2 -fomit-frame-pointer -funroll-loops")
 
+if(MSVC)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /permissive /D WIN32_LEAN_AND_MEAN")
+endif()
+
 set(bcrypt_src
   crypt_blowfish/crypt_blowfish.c
   crypt_blowfish/crypt_gensalt.c
@@ -9,7 +13,7 @@
 )
 
 set(bcrypt_hdr
-    bcrypt.h
+    include/bcrypt.h
 )
 
 add_library(bcrypt ${bcrypt_src} ${bcrypt_hdr})
diff -Naur ./ThirdParty/bcrypt/bcrypt.c ../omniscidb-master/ThirdParty/bcrypt/bcrypt.c
--- ./ThirdParty/bcrypt/bcrypt.c	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/bcrypt/bcrypt.c	2021-04-21 00:02:57.000000000 +0300
@@ -15,11 +15,27 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#ifdef _WIN32
+#elif _WIN64
+#else
 #include <unistd.h>
+#endif
 #include <errno.h>
 
+#if defined(_WIN32) || defined(_WIN64)
+// On windows we need to generate random bytes differently.
+typedef __int64 ssize_t;
+#define BCRYPT_HASHSIZE 64
+
+#include <windows.h>
+#include <wincrypt.h> /* CryptAcquireContext, CryptGenRandom */
+
 #include "bcrypt.h"
+
+#else
+#include "include/bcrypt.h"
 #include "crypt_blowfish/ow-crypt.h"
+#endif
 
 #define RANDBYTES (16)
 
@@ -101,6 +117,25 @@
 	int workf;
 	char *aux;
 
+	// Note: Windows does not have /dev/urandom sadly.
+#if defined(_WIN32) || defined(_WIN64)
+	HCRYPTPROV p;
+	ULONG     i;
+
+	// Acquire a crypt context for generating random bytes.
+	if (CryptAcquireContext(&p, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) == FALSE) {
+		return 1;
+	}
+
+	if (CryptGenRandom(p, RANDBYTES, (BYTE*)input) == FALSE) {
+		return 2;
+	}
+
+	if (CryptReleaseContext(p, 0) == FALSE) {
+		return 3;
+	}
+#else
+	// Get random bytes on Unix/Linux.
 	fd = open("/dev/urandom", O_RDONLY);
 	if (fd == -1)
 		return 1;
@@ -113,6 +148,7 @@
 
 	if (try_close(fd) != 0)
 		return 3;
+#endif
 
 	/* Generate salt. */
 	workf = (factor < 4 || factor > 31)?12:factor;
@@ -192,4 +228,4 @@
 
 	return 0;
 }
-#endif
+#endif
\ No newline at end of file
diff -Naur ./ThirdParty/bcrypt/bcrypt.h ../omniscidb-master/ThirdParty/bcrypt/bcrypt.h
--- ./ThirdParty/bcrypt/bcrypt.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/bcrypt/bcrypt.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,97 +0,0 @@
-#ifndef BCRYPT_H_
-#define BCRYPT_H_
-/*
- * bcrypt wrapper library
- *
- * Written in 2011, 2013, 2014, 2015 by Ricardo Garcia <r@rg3.name>
- *
- * To the extent possible under law, the author(s) have dedicated all copyright
- * and related and neighboring rights to this software to the public domain
- * worldwide. This software is distributed without any warranty.
- *
- * You should have received a copy of the CC0 Public Domain Dedication along
- * with this software. If not, see
- * <http://creativecommons.org/publicdomain/zero/1.0/>.
- */
-
-#define BCRYPT_HASHSIZE	(64)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * This function expects a work factor between 4 and 31 and a char array to
- * store the resulting generated salt. The char array should typically have
- * BCRYPT_HASHSIZE bytes at least. If the provided work factor is not in the
- * previous range, it will default to 12.
- *
- * The return value is zero if the salt could be correctly generated and
- * nonzero otherwise.
- *
- */
-int bcrypt_gensalt(int workfactor, char salt[BCRYPT_HASHSIZE]);
-
-/*
- * This function expects a password to be hashed, a salt to hash the password
- * with and a char array to leave the result. Both the salt and the hash
- * parameters should have room for BCRYPT_HASHSIZE characters at least.
- *
- * It can also be used to verify a hashed password. In that case, provide the
- * expected hash in the salt parameter and verify the output hash is the same
- * as the input hash. However, to avoid timing attacks, it's better to use
- * bcrypt_checkpw when verifying a password.
- *
- * The return value is zero if the password could be hashed and nonzero
- * otherwise.
- */
-int bcrypt_hashpw(const char *passwd, const char salt[BCRYPT_HASHSIZE],
-		  char hash[BCRYPT_HASHSIZE]);
-
-/*
- * This function expects a password and a hash to verify the password against.
- * The internal implementation is tuned to avoid timing attacks.
- *
- * The return value will be -1 in case of errors, zero if the provided password
- * matches the given hash and greater than zero if no errors are found and the
- * passwords don't match.
- *
- */
-int bcrypt_checkpw(const char *passwd, const char hash[BCRYPT_HASHSIZE]);
-
-/*
- * Brief Example
- * -------------
- *
- * Hashing a password:
- *
- *	char salt[BCRYPT_HASHSIZE];
- *	char hash[BCRYPT_HASHSIZE];
- *	int ret;
- *
- *	ret = bcrypt_gensalt(12, salt);
- *	assert(ret == 0);
- *	ret = bcrypt_hashpw("thepassword", salt, hash);
- *	assert(ret == 0);
- *
- *
- * Verifying a password:
- *
- *	int ret;
- *
- *      ret = bcrypt_checkpw("thepassword", "expectedhash");
- *      assert(ret != -1);
- *
- *	if (ret == 0) {
- *		printf("The password matches\n");
- *	} else {
- *		printf("The password does NOT match\n");
- *	}
- *
- */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -Naur ./ThirdParty/bcrypt/include/bcrypt.h ../omniscidb-master/ThirdParty/bcrypt/include/bcrypt.h
--- ./ThirdParty/bcrypt/include/bcrypt.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/bcrypt/include/bcrypt.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,97 @@
+#ifndef BCRYPT_H_
+#define BCRYPT_H_
+/*
+ * bcrypt wrapper library
+ *
+ * Written in 2011, 2013, 2014, 2015 by Ricardo Garcia <r@rg3.name>
+ *
+ * To the extent possible under law, the author(s) have dedicated all copyright
+ * and related and neighboring rights to this software to the public domain
+ * worldwide. This software is distributed without any warranty.
+ *
+ * You should have received a copy of the CC0 Public Domain Dedication along
+ * with this software. If not, see
+ * <http://creativecommons.org/publicdomain/zero/1.0/>.
+ */
+
+#define BCRYPT_HASHSIZE	(64)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * This function expects a work factor between 4 and 31 and a char array to
+ * store the resulting generated salt. The char array should typically have
+ * BCRYPT_HASHSIZE bytes at least. If the provided work factor is not in the
+ * previous range, it will default to 12.
+ *
+ * The return value is zero if the salt could be correctly generated and
+ * nonzero otherwise.
+ *
+ */
+int bcrypt_gensalt(int workfactor, char salt[BCRYPT_HASHSIZE]);
+
+/*
+ * This function expects a password to be hashed, a salt to hash the password
+ * with and a char array to leave the result. Both the salt and the hash
+ * parameters should have room for BCRYPT_HASHSIZE characters at least.
+ *
+ * It can also be used to verify a hashed password. In that case, provide the
+ * expected hash in the salt parameter and verify the output hash is the same
+ * as the input hash. However, to avoid timing attacks, it's better to use
+ * bcrypt_checkpw when verifying a password.
+ *
+ * The return value is zero if the password could be hashed and nonzero
+ * otherwise.
+ */
+int bcrypt_hashpw(const char *passwd, const char salt[BCRYPT_HASHSIZE],
+		  char hash[BCRYPT_HASHSIZE]);
+
+/*
+ * This function expects a password and a hash to verify the password against.
+ * The internal implementation is tuned to avoid timing attacks.
+ *
+ * The return value will be -1 in case of errors, zero if the provided password
+ * matches the given hash and greater than zero if no errors are found and the
+ * passwords don't match.
+ *
+ */
+int bcrypt_checkpw(const char *passwd, const char hash[BCRYPT_HASHSIZE]);
+
+/*
+ * Brief Example
+ * -------------
+ *
+ * Hashing a password:
+ *
+ *	char salt[BCRYPT_HASHSIZE];
+ *	char hash[BCRYPT_HASHSIZE];
+ *	int ret;
+ *
+ *	ret = bcrypt_gensalt(12, salt);
+ *	assert(ret == 0);
+ *	ret = bcrypt_hashpw("thepassword", salt, hash);
+ *	assert(ret == 0);
+ *
+ *
+ * Verifying a password:
+ *
+ *	int ret;
+ *
+ *      ret = bcrypt_checkpw("thepassword", "expectedhash");
+ *      assert(ret != -1);
+ *
+ *	if (ret == 0) {
+ *		printf("The password matches\n");
+ *	} else {
+ *		printf("The password does NOT match\n");
+ *	}
+ *
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur ./ThirdParty/googletest/gtest/gtest.h ../omniscidb-master/ThirdParty/googletest/gtest/gtest.h
--- ./ThirdParty/googletest/gtest/gtest.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/googletest/gtest/gtest.h	2021-04-21 00:02:57.000000000 +0300
@@ -2260,7 +2260,7 @@
 // StrError() aren't needed on Windows CE at this time and thus not
 // defined there.
 
-#if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT
+#if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT && !defined(_MSC_VER)
 inline int ChDir(const char* dir) { return chdir(dir); }
 #endif
 inline FILE* FOpen(const char* path, const char* mode) {
diff -Naur ./ThirdParty/licenses/VulkanMemoryAllocator.txt ../omniscidb-master/ThirdParty/licenses/VulkanMemoryAllocator.txt
--- ./ThirdParty/licenses/VulkanMemoryAllocator.txt	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/licenses/VulkanMemoryAllocator.txt	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,19 @@
+Copyright (c) 2017-2020 Advanced Micro Devices, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff -Naur ./ThirdParty/licenses/index.md ../omniscidb-master/ThirdParty/licenses/index.md
--- ./ThirdParty/licenses/index.md	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/licenses/index.md	2021-04-21 00:02:57.000000000 +0300
@@ -34,6 +34,7 @@
 glslang | [BSD BSD-like MIT](https://github.com/KhronosGroup/glslang/blob/master/LICENSE.txt) | Rendering support
 spirv-tools | [Apache-2.0](https://github.com/KhronosGroup/SPIRV-Tools/blob/master/LICENSE) | Rendering support
 spirv-cross | [Apache-2.0](https://github.com/KhronosGroup/SPIRV-Cross/blob/master/LICENSE) | Rendering support
+Vulkan Memory Allocator | [MIT](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator/blob/master/LICENSE.txt) | Rendering support
 --- | --- | --- |
 gdal | [MIT](<http://svn.osgeo.org/gdal/trunk/gdal/LICENSE.TXT>) | GDAL, Geospatial import |
 libexpat | [MIT](<https://github.com/LuaDist/libexpat/blob/master/COPYING>) | GDAL, KML import |
diff -Naur ./ThirdParty/licenses/index.txt ../omniscidb-master/ThirdParty/licenses/index.txt
--- ./ThirdParty/licenses/index.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/licenses/index.txt	2021-04-21 00:02:57.000000000 +0300
@@ -1,149 +1,150 @@
-  Name                                      License                                                                                       Use
-  ----------------------------------------- --------------------------------------------------------------------------------------------- -----------------------------------------------
-  Apache Arrow                              [Apache](https://github.com/apache/arrow/blob/master/LICENSE.txt)                             Data exchange layer
-  Apache Calcite                            [Apache](https://github.com/apache/calcite/blob/master/LICENSE)                               SQL parser
-  Apache Thrift                             [Apache](https://github.com/apache/thrift/blob/master/LICENSE)                                RPC
-  Bcrypt                                    [CC0](https://github.com/rg3/bcrypt/blob/master/COPYING)                                      Password hashing
-  Boost                                     [Boost](http://www.boost.org/LICENSE_1_0.txt)                                                 Multiple
-  cpr                                       [MIT](https://github.com/whoshuu/cpr/blob/master/LICENSE)                                     License verification
-  crypto++                                  [Boost](http://www.cryptopp.com/License.txt)                                                  Signature verification
-  CUDA                                      [NVIDIA EULA](http://docs.nvidia.com/cuda/eula/index.html#redistribution-rights)              GPU access
-  double-conversion                         [BSD-like](https://github.com/google/double-conversion/blob/master/COPYING)                   Folly
-  EGL, KHR                                  [MIT]()                                                                                       Rendering Support
-  fmt                                       [MIT](https://github.com/fmtlib/fmt/blob/master/LICENSE.rst)                                  Folly
-  Folly                                     [Apache](https://github.com/facebook/folly/blob/master/LICENSE)                               Multiple
-  glbinding                                 [MIT](https://github.com/cginternals/glbinding/blob/master/LICENSE)                           OpenGL management
-  gflags                                    [BSD-like](https://github.com/gflags/gflags/blob/master/COPYING.txt)                          Folly
-  glog                                      [BSD-like](https://github.com/google/glog/blob/master/COPYING)                                C++ logging
-  cpp-jwt                                   [MIT](https://github.com/arun11299/cpp-jwt/blob/master/LICENSE)                               Elliptical Curve Digital Signature
-  libcurl                                   [MIT](https://curl.haxx.se/docs/copyright.html)                                               AWS metadata download
-  libldap                                   varies, [OpenLDAP](http://www.openldap.org/software/release/license.html)                     LDAP support; provided by OS (dynamic linked)
-  libpng                                    [libpng](http://libpng.org/pub/png/src/libpng-LICENSE.txt)                                    Render encoding / transport
-  linenoise                                 [BSD](https://github.com/antirez/linenoise/blob/master/LICENSE)                               CLI
-  LLVM                                      [LLVM](http://llvm.org/releases/3.9.1/LICENSE.TXT)                                            JIT
-  muparserx                                 [BSD](https://github.com/beltoforion/muparserx/blob/master/License.txt)                       Expression string parsing
-  ncurses                                   [X11](http://invisible-island.net/ncurses/ncurses.faq.html#who_owns_it)                       CLI/password entry
-  PicoSHA2                                  [MIT](https://github.com/okdshin/PicoSHA2/blob/master/LICENSE)                                SHA256 Library
-  rapidjson                                 [MIT](https://github.com/miloyip/rapidjson/blob/master/license.txt)                           JSON parsing
-  SQLite                                    [Public Domain](https://www.sqlite.org/copyright.html)                                        Catalog management
-  TBB                                       [Apache-2.0](https://raw.githubusercontent.com/oneapi-src/oneTBB/tbb_2020/LICENSE)            Threadpool support
-  TimeGM                                    [BSD](https://cdn.netbsd.org/pub/pkgsrc/current/pkgsrc/pkgtools/libnbcompat/files/timegm.c)   Date/time support
-  Xorg                                      [MIT](https://www.x.org/releases/X11R7.7/doc/xorg-docs/License.html)                          OpenGL rendering
-  zlib                                      [zlib](http://zlib.net/zlib_license.html)                                                     PNG support
-  ---                                       ---                                                                                           ---
-  glslang                                   [BSD BSD-like MIT](https://github.com/KhronosGroup/glslang/blob/master/LICENSE.txt)           Rendering support
-  spirv-tools                               [Apache-2.0](https://github.com/KhronosGroup/SPIRV-Tools/blob/master/LICENSE)                 Rendering support
-  spirv-cross                               [Apache-2.0](https://github.com/KhronosGroup/SPIRV-Cross/blob/master/LICENSE)                 Rendering support
-  ---                                       ---                                                                                           ---
-  gdal                                      [MIT](http://svn.osgeo.org/gdal/trunk/gdal/LICENSE.TXT)                                       GDAL, Geospatial import
-  libexpat                                  [MIT](https://github.com/LuaDist/libexpat/blob/master/COPYING)                                GDAL, KML import
-  libkml                                    [BSD](https://github.com/google/libkml/blob/master/LICENSE)                                   GDAL, KML import
-  minizip                                   [zlib](http://zlib.net/zlib_license.html)                                                     GDAL, zip support
-  pcre                                      [BSD](http://www.pcre.org/licence.txt)                                                        GDAL, KML import
-  proj4                                     [MIT](http://proj4.org/license.html)                                                          GDAL, Geospatial reprojection
-  shapelib                                  [MIT](http://shapelib.maptools.org/license.html)                                              GDAL, Shapefile import
-  uriparser                                 [BSD](https://sourceforge.net/p/uriparser/git/ci/master/tree/COPYING)                         GDAL, KML import
-  ---                                       ---                                                                                           ---
-  generate\_cert (Go)                       [BSD](https://github.com/golang/go/blob/master/LICENSE)                                       HTTPS certificate generator
-  gorilla/context                           [BSD](https://github.com/gorilla/context/blob/master/LICENSE)                                 HTTP session handlers
-  gorilla/handlers                          [BSD](https://github.com/gorilla/handlers/blob/master/LICENSE)                                HTTP service handlers
-  gorilla/securecookie                      [BSD](https://github.com/gorilla/securecookie/blob/master/LICENSE)                            HTTP session handlers
-  gorilla/sessions                          [BSD](https://github.com/gorilla/sessions/blob/master/LICENSE)                                HTTP session handlers
-  pelletier/go-toml                         [MIT](https://github.com/pelletier/go-toml/blob/master/LICENSE)                               Config file parser
-  Jeffail/gabs                              [MIT](https://github.com/Jeffail/gabs/blob/master/LICENSE)                                    JSON Parsing
-  rs/cors                                   [MIT](https://github.com/rs/cors/blob/master/LICENSE)                                         CORS handler
-  Sirupsen/logrus                           [MIT](https://github.com/Sirupsen/logrus/blob/master/LICENSE)                                 Go logging
-  spf13/afero                               [BSD](https://github.com/spf13/afero/blob/master/LICENSE.txt)                                 CLI flags handler
-  spf13/pflag                               [BSD](https://github.com/spf13/pflag/blob/master/LICENSE)                                     CLI flags handler
-  spf13/viper                               [MIT](https://github.com/spf13/viper/blob/master/LICENSE)                                     Config file management
-  andrewseidl/viper                         [MIT](https://github.com/andrewseidl/viper/blob/master/LICENSE)                               Config file management
-  tylerb/graceful                           [MIT](https://github.com/tylerb/graceful/blob/master/LICENSE)                                 Graceful server shutdown and restart
-  dgrijalva/jwt-go                          [MIT](https://github.com/dgrijalva/jwt-go/blob/master/LICENSE)                                Licensing
-  ---                                       ---                                                                                           ---
-  Apache commons-cli                        [Apache](https://github.com/apache/commons-cli/blob/trunk/LICENSE.txt)                        CLI flags handler
-  Apache commons-math3                      [Apache](https://github.com/apache/commons-math/blob/master/LICENSE.txt)                      Math functions
-  Apache commons-text                       [Apache](https://github.com/apache/commons-text/blob/master/LICENSE.txt)                      String parsing functions
-  slf4j-log4j12                             [MIT](http://www.slf4j.org/license.html)                                                      Java logging
-  Google Gson                               [Apache](https://github.com/google/gson/blob/master/LICENSE)                                  Java JSON parsing
-  Xerial sqlite-jdbc                        [Apache](https://github.com/xerial/sqlite-jdbc/blob/master/LICENSE)                           Catalog connector/reader
-  ---                                       ---                                                                                           ---
-  bitshuffle                                [MIT](https://github.com/Blosc/c-blosc/blob/master/LICENSES/BITSHUFFLE.txt)                   Compression support
-  blosc                                     [BSD](https://github.com/Blosc/c-blosc/blob/master/LICENSES/BLOSC.txt)                        Compression support
-  fastlz                                    [MIT](https://github.com/Blosc/c-blosc/blob/master/LICENSES/FASTLZ.txt)                       Compression support
-  lz4                                       [BSD 2-Clause](https://github.com/Blosc/c-blosc/blob/master/LICENSES/LZ4.txt)                 Compression support
-  snappy                                    [BSD](https://github.com/Blosc/c-blosc/blob/master/LICENSES/SNAPPY.txt)                       Compression support
-  stdint                                    [BSD](https://github.com/Blosc/c-blosc/blob/master/LICENSES/STDINT.txt)                       Compression support
-  zlib                                      [zlib](http://zlib.net/zlib_license.html)                                                     Compression support
-  zstd                                      [BSD](https://github.com/facebook/zstd/blob/dev/LICENSE)                                      Compression support
-  libarchive                                [BSD](https://raw.githubusercontent.com/libarchive/libarchive/master/COPYING)                 Compression support
-  liblzma                                   [Public Domain](https://git.tukaani.org/?p=xz.git;a=blob;f=COPYING)                           Compression support
-  libbz2                                    [BSD](http://bzip.org/1.0.5/bzip2-manual-1.0.5.html)                                          Compression support
-  ---                                       ---                                                                                           ---
-  librdkafka                                [BSD](https://github.com/edenhill/librdkafka/blob/master/LICENSE)                             HA, Kafka support
-  pycrc                                     [MIT](https://github.com/tpircher/pycrc/blob/master/COPYING)                                  HA, Kafka support
-  queue.h                                   [BSD](https://github.com/edenhill/librdkafka/blob/master/LICENSE.queue)                       HA, Kafka support
-  regexp                                    [Public domain](https://github.com/ccxvii/minilibs/blob/master/README.md)                     HA, Kafka support
-  tinycthread                               [zlib](https://github.com/tinycthread/tinycthread/blob/master/README.txt)                     HA, Kafka support
-  wingetopt                                 [BSD](https://github.com/alex85k/wingetopt/blob/master/LICENSE)                               HA, Kafka support
-  ---                                       ---                                                                                           ---
-  opensaml                                  [Apache](https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=blob;f=doc/LICENSE.txt)        SAML support
-  xerces-c                                  [Apache](https://github.com/apache/xerces-c/blob/trunk/LICENSE)                               SAML support
-  xml-security-c                            [Apache](https://github.com/apache/santuario-cpp/blob/trunk/LICENSE.txt)                      SAML support
-  xmltooling                                [Apache](https://git.shibboleth.net/view/?p=cpp-xmltooling.git;a=blob;f=doc/LICENSE.txt)      SAML support
-  ---                                       ---                                                                                           ---
-  beorn7/perks                              [MIT](https://github.com/beorn7/perks/blob/master/LICENSE)                                    Distributed consensus
-  coreos/go-semver                          [Apache-2.0](https://github.com/coreos/go-semver/blob/master/LICENSE)                         Distributed consensus
-  coreos/go-systemd                         [Apache-2.0](https://github.com/coreos/go-systemd/blob/master/LICENSE)                        Distributed consensus
-  coreos/pkg                                [Apache-2.0](https://github.com/coreos/pkg/blob/master/LICENSE)                               Distributed consensus
-  dustin/go-humanize                        [MIT](https://github.com/dustin/go-humanize/blob/master/LICENSE)                              Distributed consensus
-  ghodss/yaml                               [MIT](https://github.com/ghodss/yaml/blob/master/LICENSE)                                     Distributed consensus
-  gogo/protobuf                             [BSD-3-Clause](https://github.com/gogo/protobuf/blob/master/LICENSE)                          Distributed consensus
-  golang/protobuf                           [BSD-3-Clause](https://github.com/golang/protobuf/blob/master/LICENSE)                        Distributed consensus
-  google/btree                              [Apache-2.0](https://github.com/google/btree/blob/master/LICENSE)                             Distributed consensus
-  google/uuid                               [BSD-3-Clause](https://github.com/google/uuid/blob/master/LICENSE)                            Distributed consensus
-  gorilla/websocket                         [BSD-2-Clause](https://github.com/gorilla/websocket/blob/master/LICENSE)                      Distributed consensus
-  grpc-ecosystem/go-grpc-middleware         [Apache-2.0](https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/LICENSE)        Distributed consensus
-  grpc-ecosystem/go-grpc-prometheus         [Apache-2.0](https://github.com/grpc-ecosystem/go-grpc-prometheus/blob/master/LICENSE)        Distributed consensus
-  grpc-ecosystem/grpc-gateway               [BSD-3-Clause](https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt)        Distributed consensus
-  Jeffail/gabs                              [MIT](https://github.com/Jeffail/gabs/blob/master/LICENSE)                                    Distributed consensus
-  jonboulle/clockwork                       [Apache-2.0](https://github.com/jonboulle/clockwork/blob/master/LICENSE)                      Distributed consensus
-  kr/pretty                                 [MIT](https://github.com/kr/pretty/blob/master/License)                                       Distributed consensus
-  kr/text                                   [MIT](https://github.com/kr/text/blob/master/License)                                         Distributed consensus
-  magiconair/properties                     [BSD-2-Clause](https://github.com/magiconair/properties/blob/master/LICENSE)                  Distributed consensus
-  matttproud/golang\_protobuf\_extensions   [Apache-2.0](https://github.com/matttproud/golang_protobuf_extensions/blob/master/LICENSE)    Distributed consensus
-  mitchellh/mapstructure                    [MIT](https://github.com/mitchellh/mapstructure/blob/master/LICENSE)                          Distributed consensus
-  pelletier/go-toml                         [MIT](https://github.com/pelletier/go-toml/blob/master/LICENSE)                               Distributed consensus
-  prometheus/client\_golang                 [Apache-2.0](https://github.com/prometheus/client_golang/blob/master/LICENSE)                 Distributed consensus
-  prometheus/client\_model                  [Apache-2.0](https://github.com/prometheus/client_model/blob/master/LICENSE)                  Distributed consensus
-  prometheus/common                         [Apache-2.0](https://github.com/prometheus/common/blob/master/LICENSE)                        Distributed consensus
-  prometheus/procfs                         [Apache-2.0](https://github.com/prometheus/procfs/blob/master/LICENSE)                        Distributed consensus
-  rcrowley/go-metrics                       [BSD-2-Clause](https://github.com/rcrowley/go-metrics/blob/master/LICENSE)                    Distributed consensus
-  rs/xhandler                               [MIT](https://github.com/rs/xhandler/blob/master/LICENSE)                                     Distributed consensus
-  soheilhy/cmux                             [Apache-2.0](https://github.com/soheilhy/cmux/blob/master/LICENSE)                            Distributed consensus
-  spf13/jwalterweatherman                   [MIT](https://github.com/spf13/jwalterweatherman/blob/master/LICENSE)                         Distributed consensus
-  tmc/grpc-websocket-proxy                  [MIT](https://github.com/tmc/grpc-websocket-proxy/blob/master/LICENSE)                        Distributed consensus
-  ugorji/go                                 [MIT](https://github.com/ugorji/go/blob/master/LICENSE)                                       Distributed consensus
-  xeipuuv/gojsonpointer                     [Apache-2.0](https://github.com/xeipuuv/gojsonpointer/blob/master/LICENSE-APACHE-2.0.txt)     Distributed consensus
-  xeipuuv/gojsonreference                   [Apache-2.0](https://github.com/xeipuuv/gojsonreference/blob/master/LICENSE-APACHE-2.0.txt)   Distributed consensus
-  xeipuuv/gojsonschema                      [Apache-2.0](https://github.com/xeipuuv/gojsonschema/blob/master/LICENSE-APACHE-2.0.txt)      Distributed consensus
-  xiang90/probing                           [MIT](https://github.com/xiang90/probing/blob/master/LICENSE)                                 Distributed consensus
-  etcd-io/bbolt                             [MIT](https://github.com/etcd-io/bbolt/blob/master/LICENSE)                                   Distributed consensus
-  etcd-io/etcd                              [Apache-2.0](https://github.com/etcd-io/etcd/blob/master/LICENSE)                             Distributed consensus
-  google/go-genproto                        [Apache-2.0](https://github.com/google/go-genproto/blob/master/LICENSE)                       Distributed consensus
-  golang/crypto                             [BSD-3-Clause](https://github.com/golang/crypto/blob/master/LICENSE)                          Distributed consensus
-  golang/net                                [BSD-3-Clause](https://github.com/golang/net/blob/master/LICENSE)                             Distributed consensus
-  golang/sys                                [BSD-3-Clause](https://github.com/golang/sys/blob/master/LICENSE)                             Distributed consensus
-  golang/text                               [BSD-3-Clause](https://github.com/golang/text/blob/master/LICENSE)                            Distributed consensus
-  golang/time                               [BSD-3-Clause](https://github.com/golang/time/blob/master/LICENSE)                            Distributed consensus
-  grpc/grpc-go                              [Apache-2.0](https://github.com/grpc/grpc-go/blob/master/LICENSE)                             Distributed consensus
-  fsnotify/fsnotify                         [BSD-3-Clause](https://github.com/fsnotify/fsnotify/blob/master/LICENSE)                      Distributed consensus
-  go-yaml/yaml                              [Apache-2.0](https://github.com/go-yaml/yaml/blob/v2/LICENSE)                                 Distributed consensus
-  go-yaml/yaml                              [MIT](https://github.com/go-yaml/yaml/blob/v2/LICENSE.libyaml)                                Distributed consensus
-  uber-go/atomic                            [MIT](https://github.com/uber-go/atomic/blob/master/LICENSE.txt)                              Distributed consensus
-  uber-go/multierr                          [MIT](https://github.com/uber-go/multierr/blob/master/LICENSE.txt)                            Distributed consensus
-  uber-go/zap                               [MIT](https://github.com/uber-go/zap/blob/master/LICENSE.txt)                                 Distributed consensus
-  ---                                       ---                                                                                           ---
-  geos                                      [LGPLv2.1](https://github.com/libgeos/geos/blob/master/COPYING)                               Geo support, dynamic linked
-  ---                                       ---                                                                                           ---
-  Canonical Raft                            [LGPLv3](https://github.com/canonical/raft/blob/master/LICENSE)                               Distributed consensus
-  libuv                                     [MIT](https://github.com/libuv/libuv/blob/v1.x/LICENSE)                                       Distributed consensus
+  Name                                      License                                                                                            Use
+  ----------------------------------------- -------------------------------------------------------------------------------------------------- -----------------------------------------------
+  Apache Arrow                              [Apache](https://github.com/apache/arrow/blob/master/LICENSE.txt)                                  Data exchange layer
+  Apache Calcite                            [Apache](https://github.com/apache/calcite/blob/master/LICENSE)                                    SQL parser
+  Apache Thrift                             [Apache](https://github.com/apache/thrift/blob/master/LICENSE)                                     RPC
+  Bcrypt                                    [CC0](https://github.com/rg3/bcrypt/blob/master/COPYING)                                           Password hashing
+  Boost                                     [Boost](http://www.boost.org/LICENSE_1_0.txt)                                                      Multiple
+  cpr                                       [MIT](https://github.com/whoshuu/cpr/blob/master/LICENSE)                                          License verification
+  crypto++                                  [Boost](http://www.cryptopp.com/License.txt)                                                       Signature verification
+  CUDA                                      [NVIDIA EULA](http://docs.nvidia.com/cuda/eula/index.html#redistribution-rights)                   GPU access
+  double-conversion                         [BSD-like](https://github.com/google/double-conversion/blob/master/COPYING)                        Folly
+  EGL, KHR                                  [MIT]()                                                                                            Rendering Support
+  fmt                                       [MIT](https://github.com/fmtlib/fmt/blob/master/LICENSE.rst)                                       Folly
+  Folly                                     [Apache](https://github.com/facebook/folly/blob/master/LICENSE)                                    Multiple
+  glbinding                                 [MIT](https://github.com/cginternals/glbinding/blob/master/LICENSE)                                OpenGL management
+  gflags                                    [BSD-like](https://github.com/gflags/gflags/blob/master/COPYING.txt)                               Folly
+  glog                                      [BSD-like](https://github.com/google/glog/blob/master/COPYING)                                     C++ logging
+  cpp-jwt                                   [MIT](https://github.com/arun11299/cpp-jwt/blob/master/LICENSE)                                    Elliptical Curve Digital Signature
+  libcurl                                   [MIT](https://curl.haxx.se/docs/copyright.html)                                                    AWS metadata download
+  libldap                                   varies, [OpenLDAP](http://www.openldap.org/software/release/license.html)                          LDAP support; provided by OS (dynamic linked)
+  libpng                                    [libpng](http://libpng.org/pub/png/src/libpng-LICENSE.txt)                                         Render encoding / transport
+  linenoise                                 [BSD](https://github.com/antirez/linenoise/blob/master/LICENSE)                                    CLI
+  LLVM                                      [LLVM](http://llvm.org/releases/3.9.1/LICENSE.TXT)                                                 JIT
+  muparserx                                 [BSD](https://github.com/beltoforion/muparserx/blob/master/License.txt)                            Expression string parsing
+  ncurses                                   [X11](http://invisible-island.net/ncurses/ncurses.faq.html#who_owns_it)                            CLI/password entry
+  PicoSHA2                                  [MIT](https://github.com/okdshin/PicoSHA2/blob/master/LICENSE)                                     SHA256 Library
+  rapidjson                                 [MIT](https://github.com/miloyip/rapidjson/blob/master/license.txt)                                JSON parsing
+  SQLite                                    [Public Domain](https://www.sqlite.org/copyright.html)                                             Catalog management
+  TBB                                       [Apache-2.0](https://raw.githubusercontent.com/oneapi-src/oneTBB/tbb_2020/LICENSE)                 Threadpool support
+  TimeGM                                    [BSD](https://cdn.netbsd.org/pub/pkgsrc/current/pkgsrc/pkgtools/libnbcompat/files/timegm.c)        Date/time support
+  Xorg                                      [MIT](https://www.x.org/releases/X11R7.7/doc/xorg-docs/License.html)                               OpenGL rendering
+  zlib                                      [zlib](http://zlib.net/zlib_license.html)                                                          PNG support
+  ---                                       ---                                                                                                ---
+  glslang                                   [BSD BSD-like MIT](https://github.com/KhronosGroup/glslang/blob/master/LICENSE.txt)                Rendering support
+  spirv-tools                               [Apache-2.0](https://github.com/KhronosGroup/SPIRV-Tools/blob/master/LICENSE)                      Rendering support
+  spirv-cross                               [Apache-2.0](https://github.com/KhronosGroup/SPIRV-Cross/blob/master/LICENSE)                      Rendering support
+  Vulkan Memory Allocator                   [MIT](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator/blob/master/LICENSE.txt)   Rendering support
+  ---                                       ---                                                                                                ---
+  gdal                                      [MIT](http://svn.osgeo.org/gdal/trunk/gdal/LICENSE.TXT)                                            GDAL, Geospatial import
+  libexpat                                  [MIT](https://github.com/LuaDist/libexpat/blob/master/COPYING)                                     GDAL, KML import
+  libkml                                    [BSD](https://github.com/google/libkml/blob/master/LICENSE)                                        GDAL, KML import
+  minizip                                   [zlib](http://zlib.net/zlib_license.html)                                                          GDAL, zip support
+  pcre                                      [BSD](http://www.pcre.org/licence.txt)                                                             GDAL, KML import
+  proj4                                     [MIT](http://proj4.org/license.html)                                                               GDAL, Geospatial reprojection
+  shapelib                                  [MIT](http://shapelib.maptools.org/license.html)                                                   GDAL, Shapefile import
+  uriparser                                 [BSD](https://sourceforge.net/p/uriparser/git/ci/master/tree/COPYING)                              GDAL, KML import
+  ---                                       ---                                                                                                ---
+  generate\_cert (Go)                       [BSD](https://github.com/golang/go/blob/master/LICENSE)                                            HTTPS certificate generator
+  gorilla/context                           [BSD](https://github.com/gorilla/context/blob/master/LICENSE)                                      HTTP session handlers
+  gorilla/handlers                          [BSD](https://github.com/gorilla/handlers/blob/master/LICENSE)                                     HTTP service handlers
+  gorilla/securecookie                      [BSD](https://github.com/gorilla/securecookie/blob/master/LICENSE)                                 HTTP session handlers
+  gorilla/sessions                          [BSD](https://github.com/gorilla/sessions/blob/master/LICENSE)                                     HTTP session handlers
+  pelletier/go-toml                         [MIT](https://github.com/pelletier/go-toml/blob/master/LICENSE)                                    Config file parser
+  Jeffail/gabs                              [MIT](https://github.com/Jeffail/gabs/blob/master/LICENSE)                                         JSON Parsing
+  rs/cors                                   [MIT](https://github.com/rs/cors/blob/master/LICENSE)                                              CORS handler
+  Sirupsen/logrus                           [MIT](https://github.com/Sirupsen/logrus/blob/master/LICENSE)                                      Go logging
+  spf13/afero                               [BSD](https://github.com/spf13/afero/blob/master/LICENSE.txt)                                      CLI flags handler
+  spf13/pflag                               [BSD](https://github.com/spf13/pflag/blob/master/LICENSE)                                          CLI flags handler
+  spf13/viper                               [MIT](https://github.com/spf13/viper/blob/master/LICENSE)                                          Config file management
+  andrewseidl/viper                         [MIT](https://github.com/andrewseidl/viper/blob/master/LICENSE)                                    Config file management
+  tylerb/graceful                           [MIT](https://github.com/tylerb/graceful/blob/master/LICENSE)                                      Graceful server shutdown and restart
+  dgrijalva/jwt-go                          [MIT](https://github.com/dgrijalva/jwt-go/blob/master/LICENSE)                                     Licensing
+  ---                                       ---                                                                                                ---
+  Apache commons-cli                        [Apache](https://github.com/apache/commons-cli/blob/trunk/LICENSE.txt)                             CLI flags handler
+  Apache commons-math3                      [Apache](https://github.com/apache/commons-math/blob/master/LICENSE.txt)                           Math functions
+  Apache commons-text                       [Apache](https://github.com/apache/commons-text/blob/master/LICENSE.txt)                           String parsing functions
+  slf4j-log4j12                             [MIT](http://www.slf4j.org/license.html)                                                           Java logging
+  Google Gson                               [Apache](https://github.com/google/gson/blob/master/LICENSE)                                       Java JSON parsing
+  Xerial sqlite-jdbc                        [Apache](https://github.com/xerial/sqlite-jdbc/blob/master/LICENSE)                                Catalog connector/reader
+  ---                                       ---                                                                                                ---
+  bitshuffle                                [MIT](https://github.com/Blosc/c-blosc/blob/master/LICENSES/BITSHUFFLE.txt)                        Compression support
+  blosc                                     [BSD](https://github.com/Blosc/c-blosc/blob/master/LICENSES/BLOSC.txt)                             Compression support
+  fastlz                                    [MIT](https://github.com/Blosc/c-blosc/blob/master/LICENSES/FASTLZ.txt)                            Compression support
+  lz4                                       [BSD 2-Clause](https://github.com/Blosc/c-blosc/blob/master/LICENSES/LZ4.txt)                      Compression support
+  snappy                                    [BSD](https://github.com/Blosc/c-blosc/blob/master/LICENSES/SNAPPY.txt)                            Compression support
+  stdint                                    [BSD](https://github.com/Blosc/c-blosc/blob/master/LICENSES/STDINT.txt)                            Compression support
+  zlib                                      [zlib](http://zlib.net/zlib_license.html)                                                          Compression support
+  zstd                                      [BSD](https://github.com/facebook/zstd/blob/dev/LICENSE)                                           Compression support
+  libarchive                                [BSD](https://raw.githubusercontent.com/libarchive/libarchive/master/COPYING)                      Compression support
+  liblzma                                   [Public Domain](https://git.tukaani.org/?p=xz.git;a=blob;f=COPYING)                                Compression support
+  libbz2                                    [BSD](http://bzip.org/1.0.5/bzip2-manual-1.0.5.html)                                               Compression support
+  ---                                       ---                                                                                                ---
+  librdkafka                                [BSD](https://github.com/edenhill/librdkafka/blob/master/LICENSE)                                  HA, Kafka support
+  pycrc                                     [MIT](https://github.com/tpircher/pycrc/blob/master/COPYING)                                       HA, Kafka support
+  queue.h                                   [BSD](https://github.com/edenhill/librdkafka/blob/master/LICENSE.queue)                            HA, Kafka support
+  regexp                                    [Public domain](https://github.com/ccxvii/minilibs/blob/master/README.md)                          HA, Kafka support
+  tinycthread                               [zlib](https://github.com/tinycthread/tinycthread/blob/master/README.txt)                          HA, Kafka support
+  wingetopt                                 [BSD](https://github.com/alex85k/wingetopt/blob/master/LICENSE)                                    HA, Kafka support
+  ---                                       ---                                                                                                ---
+  opensaml                                  [Apache](https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=blob;f=doc/LICENSE.txt)             SAML support
+  xerces-c                                  [Apache](https://github.com/apache/xerces-c/blob/trunk/LICENSE)                                    SAML support
+  xml-security-c                            [Apache](https://github.com/apache/santuario-cpp/blob/trunk/LICENSE.txt)                           SAML support
+  xmltooling                                [Apache](https://git.shibboleth.net/view/?p=cpp-xmltooling.git;a=blob;f=doc/LICENSE.txt)           SAML support
+  ---                                       ---                                                                                                ---
+  beorn7/perks                              [MIT](https://github.com/beorn7/perks/blob/master/LICENSE)                                         Distributed consensus
+  coreos/go-semver                          [Apache-2.0](https://github.com/coreos/go-semver/blob/master/LICENSE)                              Distributed consensus
+  coreos/go-systemd                         [Apache-2.0](https://github.com/coreos/go-systemd/blob/master/LICENSE)                             Distributed consensus
+  coreos/pkg                                [Apache-2.0](https://github.com/coreos/pkg/blob/master/LICENSE)                                    Distributed consensus
+  dustin/go-humanize                        [MIT](https://github.com/dustin/go-humanize/blob/master/LICENSE)                                   Distributed consensus
+  ghodss/yaml                               [MIT](https://github.com/ghodss/yaml/blob/master/LICENSE)                                          Distributed consensus
+  gogo/protobuf                             [BSD-3-Clause](https://github.com/gogo/protobuf/blob/master/LICENSE)                               Distributed consensus
+  golang/protobuf                           [BSD-3-Clause](https://github.com/golang/protobuf/blob/master/LICENSE)                             Distributed consensus
+  google/btree                              [Apache-2.0](https://github.com/google/btree/blob/master/LICENSE)                                  Distributed consensus
+  google/uuid                               [BSD-3-Clause](https://github.com/google/uuid/blob/master/LICENSE)                                 Distributed consensus
+  gorilla/websocket                         [BSD-2-Clause](https://github.com/gorilla/websocket/blob/master/LICENSE)                           Distributed consensus
+  grpc-ecosystem/go-grpc-middleware         [Apache-2.0](https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/LICENSE)             Distributed consensus
+  grpc-ecosystem/go-grpc-prometheus         [Apache-2.0](https://github.com/grpc-ecosystem/go-grpc-prometheus/blob/master/LICENSE)             Distributed consensus
+  grpc-ecosystem/grpc-gateway               [BSD-3-Clause](https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt)             Distributed consensus
+  Jeffail/gabs                              [MIT](https://github.com/Jeffail/gabs/blob/master/LICENSE)                                         Distributed consensus
+  jonboulle/clockwork                       [Apache-2.0](https://github.com/jonboulle/clockwork/blob/master/LICENSE)                           Distributed consensus
+  kr/pretty                                 [MIT](https://github.com/kr/pretty/blob/master/License)                                            Distributed consensus
+  kr/text                                   [MIT](https://github.com/kr/text/blob/master/License)                                              Distributed consensus
+  magiconair/properties                     [BSD-2-Clause](https://github.com/magiconair/properties/blob/master/LICENSE)                       Distributed consensus
+  matttproud/golang\_protobuf\_extensions   [Apache-2.0](https://github.com/matttproud/golang_protobuf_extensions/blob/master/LICENSE)         Distributed consensus
+  mitchellh/mapstructure                    [MIT](https://github.com/mitchellh/mapstructure/blob/master/LICENSE)                               Distributed consensus
+  pelletier/go-toml                         [MIT](https://github.com/pelletier/go-toml/blob/master/LICENSE)                                    Distributed consensus
+  prometheus/client\_golang                 [Apache-2.0](https://github.com/prometheus/client_golang/blob/master/LICENSE)                      Distributed consensus
+  prometheus/client\_model                  [Apache-2.0](https://github.com/prometheus/client_model/blob/master/LICENSE)                       Distributed consensus
+  prometheus/common                         [Apache-2.0](https://github.com/prometheus/common/blob/master/LICENSE)                             Distributed consensus
+  prometheus/procfs                         [Apache-2.0](https://github.com/prometheus/procfs/blob/master/LICENSE)                             Distributed consensus
+  rcrowley/go-metrics                       [BSD-2-Clause](https://github.com/rcrowley/go-metrics/blob/master/LICENSE)                         Distributed consensus
+  rs/xhandler                               [MIT](https://github.com/rs/xhandler/blob/master/LICENSE)                                          Distributed consensus
+  soheilhy/cmux                             [Apache-2.0](https://github.com/soheilhy/cmux/blob/master/LICENSE)                                 Distributed consensus
+  spf13/jwalterweatherman                   [MIT](https://github.com/spf13/jwalterweatherman/blob/master/LICENSE)                              Distributed consensus
+  tmc/grpc-websocket-proxy                  [MIT](https://github.com/tmc/grpc-websocket-proxy/blob/master/LICENSE)                             Distributed consensus
+  ugorji/go                                 [MIT](https://github.com/ugorji/go/blob/master/LICENSE)                                            Distributed consensus
+  xeipuuv/gojsonpointer                     [Apache-2.0](https://github.com/xeipuuv/gojsonpointer/blob/master/LICENSE-APACHE-2.0.txt)          Distributed consensus
+  xeipuuv/gojsonreference                   [Apache-2.0](https://github.com/xeipuuv/gojsonreference/blob/master/LICENSE-APACHE-2.0.txt)        Distributed consensus
+  xeipuuv/gojsonschema                      [Apache-2.0](https://github.com/xeipuuv/gojsonschema/blob/master/LICENSE-APACHE-2.0.txt)           Distributed consensus
+  xiang90/probing                           [MIT](https://github.com/xiang90/probing/blob/master/LICENSE)                                      Distributed consensus
+  etcd-io/bbolt                             [MIT](https://github.com/etcd-io/bbolt/blob/master/LICENSE)                                        Distributed consensus
+  etcd-io/etcd                              [Apache-2.0](https://github.com/etcd-io/etcd/blob/master/LICENSE)                                  Distributed consensus
+  google/go-genproto                        [Apache-2.0](https://github.com/google/go-genproto/blob/master/LICENSE)                            Distributed consensus
+  golang/crypto                             [BSD-3-Clause](https://github.com/golang/crypto/blob/master/LICENSE)                               Distributed consensus
+  golang/net                                [BSD-3-Clause](https://github.com/golang/net/blob/master/LICENSE)                                  Distributed consensus
+  golang/sys                                [BSD-3-Clause](https://github.com/golang/sys/blob/master/LICENSE)                                  Distributed consensus
+  golang/text                               [BSD-3-Clause](https://github.com/golang/text/blob/master/LICENSE)                                 Distributed consensus
+  golang/time                               [BSD-3-Clause](https://github.com/golang/time/blob/master/LICENSE)                                 Distributed consensus
+  grpc/grpc-go                              [Apache-2.0](https://github.com/grpc/grpc-go/blob/master/LICENSE)                                  Distributed consensus
+  fsnotify/fsnotify                         [BSD-3-Clause](https://github.com/fsnotify/fsnotify/blob/master/LICENSE)                           Distributed consensus
+  go-yaml/yaml                              [Apache-2.0](https://github.com/go-yaml/yaml/blob/v2/LICENSE)                                      Distributed consensus
+  go-yaml/yaml                              [MIT](https://github.com/go-yaml/yaml/blob/v2/LICENSE.libyaml)                                     Distributed consensus
+  uber-go/atomic                            [MIT](https://github.com/uber-go/atomic/blob/master/LICENSE.txt)                                   Distributed consensus
+  uber-go/multierr                          [MIT](https://github.com/uber-go/multierr/blob/master/LICENSE.txt)                                 Distributed consensus
+  uber-go/zap                               [MIT](https://github.com/uber-go/zap/blob/master/LICENSE.txt)                                      Distributed consensus
+  ---                                       ---                                                                                                ---
+  geos                                      [LGPLv2.1](https://github.com/libgeos/geos/blob/master/COPYING)                                    Geo support, dynamic linked
+  ---                                       ---                                                                                                ---
+  Canonical Raft                            [LGPLv3](https://github.com/canonical/raft/blob/master/LICENSE)                                    Distributed consensus
+  libuv                                     [MIT](https://github.com/libuv/libuv/blob/v1.x/LICENSE)                                            Distributed consensus
diff -Naur ./ThirdParty/linenoise/CMakeLists.txt ../omniscidb-master/ThirdParty/linenoise/CMakeLists.txt
--- ./ThirdParty/linenoise/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -1 +1,84 @@
-add_library(linenoise linenoise.cpp linenoise.h)
+# -*- mode: CMAKE; -*-
+
+cmake_minimum_required(VERSION 3.16)
+
+project(linenoise)
+
+set(CMAKE_BINARY_DIR "${CMAKE_SOURCE_DIR}/build")
+
+if(NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release CACHE string "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel." FORCE)
+endif()
+
+message(STATUS "Build mode: ${CMAKE_BUILD_TYPE}")
+
+# INFO
+set(LINENOISE_VERSION "1.0.0" CACHE PATH "Linenoise version")
+set(LINENOISE_DISPLAY_NAME "Linenoise-NG")
+set(LINENOISE_URL_INFO_ABOUT "https://github.com/arangodb/linenoise-ng")
+set(LINENOISE_CONTACT "hackers@arangodb.org")
+set(LINENOISE_FRIENDLY_STRING "Linenoise NG - Linenoise Next Generation")
+
+# compiler options
+if(CMAKE_COMPILER_IS_GNUCXX)
+  message(STATUS "Compiler type GNU: ${CMAKE_CXX_COMPILER}")
+  set(BASE_COMPILER_OPTIONS "-std=c++11 -Wall -Wextra -Wno-implicit-fallthrough")
+  set(CMAKE_CXX_FLAGS                "${CMAKE_CXX_FLAGS} ${BASE_COMPILER_OPTIONS}")
+  set(CMAKE_CXX_FLAGS_DEBUG          "${CMAKE_CXX_FLAGS_DEBUG} ${BASE_COMPILER_OPTIONS} -O0 -g")
+  set(CMAKE_CXX_FLAGS_MINSIZEREL     "${CMAKE_CXX_FLAGS_MINSIZEREL} ${BASE_COMPILER_OPTIONS} -Os")
+  set(CMAKE_CXX_FLAGS_RELEASE        "${CMAKE_CXX_FLAGS_RELEASE} ${BASE_COMPILER_OPTIONS} -O3 -fomit-frame-pointer")
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} ${BASE_COMPILER_OPTIONS} -O3 -g")
+
+elseif(CMAKE_COMPILER_IS_CLANGCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  # using regular Clang or AppleClang
+  message(STATUS "Compiler type CLANG: ${CMAKE_CXX_COMPILER}")
+  set(BASE_COMPILER_OPTIONS "-std=c++11 -Wall -Wextra")
+  set(CMAKE_CXX_FLAGS                "${CMAKE_CXX_FLAGS} ${BASE_COMPILER_OPTIONS}")
+  set(CMAKE_CXX_FLAGS_DEBUG          "${CMAKE_CXX_FLAGS_DEBUG} ${BASE_COMPILER_OPTIONS} -O0 -g")
+  set(CMAKE_CXX_FLAGS_MINSIZEREL     "${CMAKE_CXX_FLAGS_MINSIZEREL} ${BASE_COMPILER_OPTIONS} -Os")
+  set(CMAKE_CXX_FLAGS_RELEASE        "${CMAKE_CXX_FLAGS_RELEASE} ${BASE_COMPILER_OPTIONS} -O3 -fomit-frame-pointer")
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} ${BASE_COMPILER_OPTIONS} -O3 -g")
+  
+elseif(MSVC) 
+  message(STATUS "Compiler type MSVC: ${CMAKE_CXX_COMPILER}")
+  add_definitions("-D_CRT_SECURE_NO_WARNINGS=1")
+
+  foreach (flag_var
+           CMAKE_CXX_FLAGS
+           CMAKE_CXX_FLAGS_DEBUG
+           CMAKE_CXX_FLAGS_RELEASE
+           CMAKE_CXX_FLAGS_MINSIZEREL
+           CMAKE_CXX_FLAGS_RELWITHDEBINFO)
+    if (flag_var MATCHES "DEBUG")
+      set(${flag_var} "${${flag_var}} /MTd")
+    else ()
+      set(${flag_var} "${${flag_var}} /MT")
+    endif ()
+  endforeach()
+  # https://msdn.microsoft.com/en-us/library/aa267384%28VS.60%29.aspx
+  set(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG} /INCREMENTAL:NO /SUBSYSTEM:CONSOLE /LTCG /ignore:4099")
+  set(CMAKE_EXE_LINKER_FLAGS_MINSIZEREL "${CMAKE_EXE_LINKER_FLAGS_MINSIZEREL} /SUBSYSTEM:CONSOLE /ignore:4099")
+  set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE} /SUBSYSTEM:CONSOLE /ignore:4099")
+  set(CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO "${CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO} /SUBSYSTEM:CONSOLE /ignore:4099")
+else()
+  # unknown compilers
+  message(STATUS "Compiler type UNKNOWN: ${CMAKE_CXX_COMPILER}")
+  set(BASE_COMPILER_OPTIONS "-std=c++11 -Wall -Wextra")
+  set(CMAKE_CXX_FLAGS                "${CMAKE_CXX_FLAGS} ${BASE_COMPILER_OPTIONS}")
+  set(CMAKE_CXX_FLAGS_DEBUG          "${CMAKE_CXX_FLAGS_DEBUG} ${BASE_COMPILER_OPTIONS} -O0 -g")
+  set(CMAKE_CXX_FLAGS_MINSIZEREL     "${CMAKE_CXX_FLAGS_MINSIZEREL} ${BASE_COMPILER_OPTIONS} -Os")
+  set(CMAKE_CXX_FLAGS_RELEASE        "${CMAKE_CXX_FLAGS_RELEASE} ${BASE_COMPILER_OPTIONS} -O3 -fomit-frame-pointer")
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} ${BASE_COMPILER_OPTIONS} -O3 -g")
+
+endif()
+
+include_directories(${PROJECT_SOURCE_DIR}/include ${PROJECT_SOURCE_DIR}/src)
+
+# build liblinenoise
+add_library(
+  linenoise
+  STATIC
+  src/ConvertUTF.cpp
+  src/linenoise.cpp
+  src/wcwidth.cpp
+)
diff -Naur ./ThirdParty/linenoise/include/linenoise.h ../omniscidb-master/ThirdParty/linenoise/include/linenoise.h
--- ./ThirdParty/linenoise/include/linenoise.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/include/linenoise.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,73 @@
+/* linenoise.h -- guerrilla line editing library against the idea that a
+ * line editing lib needs to be 20,000 lines of C code.
+ *
+ * See linenoise.c for more information.
+ *
+ * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LINENOISE_H
+#define __LINENOISE_H
+
+#define LINENOISE_VERSION "1.0.0"
+#define LINENOISE_VERSION_MAJOR 1
+#define LINENOISE_VERSION_MINOR 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct linenoiseCompletions linenoiseCompletions;
+
+typedef void(linenoiseCompletionCallback)(const char*, linenoiseCompletions*);
+void linenoiseSetCompletionCallback(linenoiseCompletionCallback* fn);
+void linenoiseAddCompletion(linenoiseCompletions* lc, const char* str);
+
+char* linenoise(const char* prompt);
+void linenoisePreloadBuffer(const char* preloadText);
+int linenoiseHistoryAdd(const char* line);
+int linenoiseHistorySetMaxLen(int len);
+char* linenoiseHistoryLine(int index);
+int linenoiseHistorySave(const char* filename);
+int linenoiseHistoryLoad(const char* filename);
+void linenoiseHistoryFree(void);
+void linenoiseClearScreen(void);
+void linenoiseSetMultiLine(int ml);
+void linenoisePrintKeyCodes(void);
+/* the following are extensions to the original linenoise API */
+int linenoiseInstallWindowChangeHandler(void);
+/* returns type of key pressed: 1 = CTRL-C, 2 = CTRL-D, 0 = other */ 
+int linenoiseKeyType(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __LINENOISE_H */
diff -Naur ./ThirdParty/linenoise/linenoise.cpp ../omniscidb-master/ThirdParty/linenoise/linenoise.cpp
--- ./ThirdParty/linenoise/linenoise.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/linenoise.cpp	1970-01-01 03:00:00.000000000 +0300
@@ -1,1106 +0,0 @@
-// clang-format off
-/* linenoise.c -- guerrilla line editing library against the idea that a
- * line editing lib needs to be 20,000 lines of C code.
- *
- * You can find the latest source code at:
- *
- *   http://github.com/antirez/linenoise
- *
- * Does a number of crazy assumptions that happen to be true in 99.9999% of
- * the 2010 UNIX computers around.
- *
- * ------------------------------------------------------------------------
- *
- * Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>
- * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  *  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *  *  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * ------------------------------------------------------------------------
- *
- * References:
- * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
- * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
- *
- * Todo list:
- * - Filter bogus Ctrl+<char> combinations.
- * - Win32 support
- *
- * Bloat:
- * - History search like Ctrl+r in readline?
- *
- * List of escape sequences used by this program, we do everything just
- * with three sequences. In order to be so cheap we may have some
- * flickering effect with some slow terminal, but the lesser sequences
- * the more compatible.
- *
- * EL (Erase Line)
- *    Sequence: ESC [ n K
- *    Effect: if n is 0 or missing, clear from cursor to end of line
- *    Effect: if n is 1, clear from beginning of line to cursor
- *    Effect: if n is 2, clear entire line
- *
- * CUF (CUrsor Forward)
- *    Sequence: ESC [ n C
- *    Effect: moves cursor forward n chars
- *
- * CUB (CUrsor Backward)
- *    Sequence: ESC [ n D
- *    Effect: moves cursor backward n chars
- *
- * The following is used to get the terminal width if getting
- * the width with the TIOCGWINSZ ioctl fails
- *
- * DSR (Device Status Report)
- *    Sequence: ESC [ 6 n
- *    Effect: reports the current cusor position as ESC [ n ; m R
- *            where n is the row and m is the column
- *
- * When multi line mode is enabled, we also use an additional escape
- * sequence. However multi line editing is disabled by default.
- *
- * CUU (Cursor Up)
- *    Sequence: ESC [ n A
- *    Effect: moves cursor up of n chars.
- *
- * CUD (Cursor Down)
- *    Sequence: ESC [ n B
- *    Effect: moves cursor down of n chars.
- *
- * When linenoiseClearScreen() is called, two additional escape sequences
- * are used in order to clear the screen and position the cursor at home
- * position.
- *
- * CUP (Cursor position)
- *    Sequence: ESC [ H
- *    Effect: moves the cursor to upper left corner
- *
- * ED (Erase display)
- *    Sequence: ESC [ 2 J
- *    Effect: clear the whole screen
- *
- */
-
-#include <termios.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <errno.h>
-#include <string.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include "linenoise.h"
-
-#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
-#define LINENOISE_MAX_LINE 4096
-static const char *unsupported_term[] = {"dumb","cons25","emacs",NULL};
-static linenoiseCompletionCallback *completionCallback = NULL;
-
-static struct termios orig_termios; /* In order to restore at exit.*/
-static int rawmode = 0; /* For atexit() function to check if restore is needed*/
-static int mlmode = 0;  /* Multi line mode. Default is single line. */
-static int atexit_registered = 0; /* Register atexit just 1 time. */
-static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
-static int history_len = 0;
-static char **history = NULL;
-
-/* The linenoiseState structure represents the state during line editing.
- * We pass this state to functions implementing specific editing
- * functionalities. */
-struct linenoiseState {
-    int ifd;            /* Terminal stdin file descriptor. */
-    int ofd;            /* Terminal stdout file descriptor. */
-    char *buf;          /* Edited line buffer. */
-    size_t buflen;      /* Edited line buffer size. */
-    const char *prompt; /* Prompt to display. */
-    size_t plen;        /* Prompt length. */
-    size_t pos;         /* Current cursor position. */
-    size_t oldpos;      /* Previous refresh cursor position. */
-    size_t len;         /* Current edited line length. */
-    size_t cols;        /* Number of columns in terminal. */
-    size_t maxrows;     /* Maximum num of rows used so far (multiline mode) */
-    int history_index;  /* The history index we are currently editing. */
-};
-
-enum KEY_ACTION{
-	KEY_NULL = 0,	    /* NULL */
-	CTRL_A = 1,         /* Ctrl+a */
-	CTRL_B = 2,         /* Ctrl-b */
-	CTRL_C = 3,         /* Ctrl-c */
-	CTRL_D = 4,         /* Ctrl-d */
-	CTRL_E = 5,         /* Ctrl-e */
-	CTRL_F = 6,         /* Ctrl-f */
-	CTRL_H = 8,         /* Ctrl-h */
-	TAB = 9,            /* Tab */
-	CTRL_K = 11,        /* Ctrl+k */
-	CTRL_L = 12,        /* Ctrl+l */
-	ENTER = 13,         /* Enter */
-	CTRL_N = 14,        /* Ctrl-n */
-	CTRL_P = 16,        /* Ctrl-p */
-	CTRL_T = 20,        /* Ctrl-t */
-	CTRL_U = 21,        /* Ctrl+u */
-	CTRL_W = 23,        /* Ctrl+w */
-	ESC = 27,           /* Escape */
-	BACKSPACE =  127    /* Backspace */
-};
-
-static void linenoiseAtExit(void);
-int linenoiseHistoryAdd(const char *line);
-static void refreshLine(struct linenoiseState *l);
-
-/* Debugging macro. */
-#if 0
-FILE *lndebug_fp = NULL;
-#define lndebug(...) \
-    do { \
-        if (lndebug_fp == NULL) { \
-            lndebug_fp = fopen("/tmp/lndebug.txt","a"); \
-            fprintf(lndebug_fp, \
-            "[%d %d %d] p: %d, rows: %d, rpos: %d, max: %d, oldmax: %d\n", \
-            (int)l->len,(int)l->pos,(int)l->oldpos,plen,rows,rpos, \
-            (int)l->maxrows,old_rows); \
-        } \
-        fprintf(lndebug_fp, ", " __VA_ARGS__); \
-        fflush(lndebug_fp); \
-    } while (0)
-#else
-#define lndebug(fmt, ...)
-#endif
-
-/* ======================= Low level terminal handling ====================== */
-
-/* Set if to use or not the multi line mode. */
-void linenoiseSetMultiLine(int ml) {
-    mlmode = ml;
-}
-
-/* Return true if the terminal name is in the list of terminals we know are
- * not able to understand basic escape sequences. */
-static int isUnsupportedTerm(void) {
-    char *term = getenv("TERM");
-    int j;
-
-    if (term == NULL) return 0;
-    for (j = 0; unsupported_term[j]; j++)
-        if (!strcasecmp(term,unsupported_term[j])) return 1;
-    return 0;
-}
-
-/* Raw mode: 1960 magic shit. */
-static int enableRawMode(int fd) {
-    struct termios raw;
-
-    if (!isatty(STDIN_FILENO)) goto fatal;
-    if (!atexit_registered) {
-        atexit(linenoiseAtExit);
-        atexit_registered = 1;
-    }
-    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;
-
-    raw = orig_termios;  /* modify the original mode */
-    /* input modes: no break, no CR to NL, no parity check, no strip char,
-     * no start/stop output control. */
-    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
-    /* output modes - disable post processing */
-    raw.c_oflag &= ~(OPOST);
-    /* control modes - set 8 bit chars */
-    raw.c_cflag |= (CS8);
-    /* local modes - choing off, canonical off, no extended functions,
-     * no signal chars (^Z,^C) */
-    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
-    /* control chars - set return condition: min number of bytes and timer.
-     * We want read to return every single byte, without timeout. */
-    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
-
-    /* put terminal in raw mode after flushing */
-    if (tcsetattr(fd,TCSADRAIN,&raw) < 0) goto fatal;
-    rawmode = 1;
-    return 0;
-
-fatal:
-    errno = ENOTTY;
-    return -1;
-}
-
-static void disableRawMode(int fd) {
-    /* Don't even check the return value as it's too late. */
-    if (rawmode && tcsetattr(fd,TCSADRAIN,&orig_termios) != -1)
-        rawmode = 0;
-}
-
-/* Use the ESC [6n escape sequence to query the horizontal cursor position
- * and return it. On error -1 is returned, on success the position of the
- * cursor. */
-static int getCursorPosition(int ifd, int ofd) {
-    char buf[32];
-    int cols, rows;
-    unsigned int i = 0;
-
-    /* Report cursor location */
-    if (write(ofd, "\x1b[6n", 4) != 4) return -1;
-
-    /* Read the response: ESC [ rows ; cols R */
-    while (i < sizeof(buf)-1) {
-        if (read(ifd,buf+i,1) != 1) break;
-        if (buf[i] == 'R') break;
-        i++;
-    }
-    buf[i] = '\0';
-
-    /* Parse it. */
-    if (buf[0] != ESC || buf[1] != '[') return -1;
-    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) return -1;
-    return cols;
-}
-
-/* Try to get the number of columns in the current terminal, or assume 80
- * if it fails. */
-static int getColumns(int ifd, int ofd) {
-    struct winsize ws;
-
-    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
-        /* ioctl() failed. Try to query the terminal itself. */
-        int start, cols;
-
-        /* Get the initial position so we can restore it later. */
-        start = getCursorPosition(ifd,ofd);
-        if (start == -1) goto failed;
-
-        /* Go to right margin and get position. */
-        if (write(ofd,"\x1b[999C",6) != 6) goto failed;
-        cols = getCursorPosition(ifd,ofd);
-        if (cols == -1) goto failed;
-
-        /* Restore position. */
-        if (cols > start) {
-            char seq[32];
-            snprintf(seq,32,"\x1b[%dD",cols-start);
-            if (write(ofd,seq,strlen(seq)) == -1) {
-                /* Can't recover... */
-            }
-        }
-        return cols;
-    } else {
-        return ws.ws_col;
-    }
-
-failed:
-    return 80;
-}
-
-/* Clear the screen. Used to handle ctrl+l */
-void linenoiseClearScreen(void) {
-    if (write(STDOUT_FILENO,"\x1b[H\x1b[2J",7) <= 0) {
-        /* nothing to do, just to avoid warning. */
-    }
-}
-
-/* Beep, used for completion when there is nothing to complete or when all
- * the choices were already shown. */
-static void linenoiseBeep(void) {
-    fprintf(stderr, "\x7");
-    fflush(stderr);
-}
-
-/* ============================== Completion ================================ */
-
-/* Free a list of completion option populated by linenoiseAddCompletion(). */
-static void freeCompletions(linenoiseCompletions *lc) {
-    size_t i;
-    for (i = 0; i < lc->len; i++)
-        free(lc->cvec[i]);
-    if (lc->cvec != NULL)
-        free(lc->cvec);
-}
-
-/* This is an helper function for linenoiseEdit() and is called when the
- * user types the <tab> key in order to complete the string currently in the
- * input.
- *
- * The state of the editing is encapsulated into the pointed linenoiseState
- * structure as described in the structure definition. */
-static int completeLine(struct linenoiseState *ls) {
-    linenoiseCompletions lc = { 0, NULL };
-    int nread, nwritten;
-    char c = 0;
-
-    completionCallback(ls->buf,&lc);
-    if (lc.len == 0) {
-        linenoiseBeep();
-    } else {
-        size_t stop = 0, i = 0;
-
-        while(!stop) {
-            /* Show completion or original buffer */
-            if (i < lc.len) {
-                struct linenoiseState saved = *ls;
-
-                ls->len = ls->pos = strlen(lc.cvec[i]);
-                ls->buf = lc.cvec[i];
-                refreshLine(ls);
-                ls->len = saved.len;
-                ls->pos = saved.pos;
-                ls->buf = saved.buf;
-            } else {
-                refreshLine(ls);
-            }
-
-            nread = read(ls->ifd,&c,1);
-            if (nread <= 0) {
-                freeCompletions(&lc);
-                return -1;
-            }
-
-            switch(c) {
-                case 9: /* tab */
-                    i = (i+1) % (lc.len+1);
-                    if (i == lc.len) linenoiseBeep();
-                    break;
-                case 27: /* escape */
-                    /* Re-show original buffer */
-                    if (i < lc.len) refreshLine(ls);
-                    stop = 1;
-                    break;
-                default:
-                    /* Update buffer and return */
-                    if (i < lc.len) {
-                        nwritten = snprintf(ls->buf,ls->buflen,"%s",lc.cvec[i]);
-                        ls->len = ls->pos = nwritten;
-                    }
-                    stop = 1;
-                    break;
-            }
-        }
-    }
-
-    freeCompletions(&lc);
-    return c; /* Return last read character */
-}
-
-/* Register a callback function to be called for tab-completion. */
-void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
-    completionCallback = fn;
-}
-
-/* This function is used by the callback function registered by the user
- * in order to add completion options given the input string when the
- * user typed <tab>. See the example.c source code for a very easy to
- * understand example. */
-void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
-    size_t len = strlen(str);
-    char *copy, **cvec;
-
-    copy = (char*)malloc(len+1);
-    if (copy == NULL) return;
-    memcpy(copy,str,len+1);
-    cvec = (char**)realloc(lc->cvec,sizeof(char*)*(lc->len+1));
-    if (cvec == NULL) {
-        free(copy);
-        return;
-    }
-    lc->cvec = cvec;
-    lc->cvec[lc->len++] = copy;
-}
-
-/* =========================== Line editing ================================= */
-
-/* We define a very simple "append buffer" structure, that is an heap
- * allocated string where we can append to. This is useful in order to
- * write all the escape sequences in a buffer and flush them to the standard
- * output in a single call, to avoid flickering effects. */
-struct abuf {
-    char *b;
-    int len;
-};
-
-static void abInit(struct abuf *ab) {
-    ab->b = NULL;
-    ab->len = 0;
-}
-
-static void abAppend(struct abuf *ab, const char *s, int len) {
-    char *new_s = (char*)realloc(ab->b,ab->len+len);
-
-    if (new_s == NULL) return;
-    memcpy(new_s+ab->len,s,len);
-    ab->b = new_s;
-    ab->len += len;
-}
-
-static void abFree(struct abuf *ab) {
-    free(ab->b);
-}
-
-/* Single line low level line refresh.
- *
- * Rewrite the currently edited line accordingly to the buffer content,
- * cursor position, and number of columns of the terminal. */
-static void refreshSingleLine(struct linenoiseState *l) {
-    char seq[64];
-    size_t plen = strlen(l->prompt);
-    int fd = l->ofd;
-    char *buf = l->buf;
-    size_t len = l->len;
-    size_t pos = l->pos;
-    struct abuf ab;
-
-    while((plen+pos) >= l->cols) {
-        buf++;
-        len--;
-        pos--;
-    }
-    while (plen+len > l->cols) {
-        len--;
-    }
-
-    abInit(&ab);
-    /* Cursor to left edge */
-    snprintf(seq,64,"\r");
-    abAppend(&ab,seq,strlen(seq));
-    /* Write the prompt and the current buffer content */
-    abAppend(&ab,l->prompt,strlen(l->prompt));
-    abAppend(&ab,buf,len);
-    /* Erase to right */
-    snprintf(seq,64,"\x1b[0K");
-    abAppend(&ab,seq,strlen(seq));
-    /* Move cursor to original position. */
-    snprintf(seq,64,"\r\x1b[%dC", (int)(pos+plen));
-    abAppend(&ab,seq,strlen(seq));
-    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
-    abFree(&ab);
-}
-
-/* Multi line low level line refresh.
- *
- * Rewrite the currently edited line accordingly to the buffer content,
- * cursor position, and number of columns of the terminal. */
-static void refreshMultiLine(struct linenoiseState *l) {
-    char seq[64];
-    int plen = strlen(l->prompt);
-    int rows = (plen+l->len+l->cols-1)/l->cols; /* rows used by current buf. */
-    int rpos = (plen+l->oldpos+l->cols)/l->cols; /* cursor relative row. */
-    int rpos2; /* rpos after refresh. */
-    int col; /* colum position, zero-based. */
-    int old_rows = l->maxrows;
-    int fd = l->ofd, j;
-    struct abuf ab;
-
-    /* Update maxrows if needed. */
-    if (rows > (int)l->maxrows) l->maxrows = rows;
-
-    /* First step: clear all the lines used before. To do so start by
-     * going to the last row. */
-    abInit(&ab);
-    if (old_rows-rpos > 0) {
-        lndebug("go down %d", old_rows-rpos);
-        snprintf(seq,64,"\x1b[%dB", old_rows-rpos);
-        abAppend(&ab,seq,strlen(seq));
-    }
-
-    /* Now for every row clear it, go up. */
-    for (j = 0; j < old_rows-1; j++) {
-        lndebug("clear+up");
-        snprintf(seq,64,"\r\x1b[0K\x1b[1A");
-        abAppend(&ab,seq,strlen(seq));
-    }
-
-    /* Clean the top line. */
-    lndebug("clear");
-    snprintf(seq,64,"\r\x1b[0K");
-    abAppend(&ab,seq,strlen(seq));
-
-    /* Write the prompt and the current buffer content */
-    abAppend(&ab,l->prompt,strlen(l->prompt));
-    abAppend(&ab,l->buf,l->len);
-
-    /* If we are at the very end of the screen with our prompt, we need to
-     * emit a newline and move the prompt to the first column. */
-    if (l->pos &&
-        l->pos == l->len &&
-        (l->pos+plen) % l->cols == 0)
-    {
-        lndebug("<newline>");
-        abAppend(&ab,"\n",1);
-        snprintf(seq,64,"\r");
-        abAppend(&ab,seq,strlen(seq));
-        rows++;
-        if (rows > (int)l->maxrows) l->maxrows = rows;
-    }
-
-    /* Move cursor to right position. */
-    rpos2 = (plen+l->pos+l->cols)/l->cols; /* current cursor relative row. */
-    lndebug("rpos2 %d", rpos2);
-
-    /* Go up till we reach the expected positon. */
-    if (rows-rpos2 > 0) {
-        lndebug("go-up %d", rows-rpos2);
-        snprintf(seq,64,"\x1b[%dA", rows-rpos2);
-        abAppend(&ab,seq,strlen(seq));
-    }
-
-    /* Set column. */
-    col = (plen+(int)l->pos) % (int)l->cols;
-    lndebug("set col %d", 1+col);
-    if (col)
-        snprintf(seq,64,"\r\x1b[%dC", col);
-    else
-        snprintf(seq,64,"\r");
-    abAppend(&ab,seq,strlen(seq));
-
-    lndebug("\n");
-    l->oldpos = l->pos;
-
-    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
-    abFree(&ab);
-}
-
-/* Calls the two low level functions refreshSingleLine() or
- * refreshMultiLine() according to the selected mode. */
-static void refreshLine(struct linenoiseState *l) {
-    if (mlmode)
-        refreshMultiLine(l);
-    else
-        refreshSingleLine(l);
-}
-
-/* Insert the character 'c' at cursor current position.
- *
- * On error writing to the terminal -1 is returned, otherwise 0. */
-int linenoiseEditInsert(struct linenoiseState *l, char c) {
-    if (l->len < l->buflen) {
-        if (l->len == l->pos) {
-            l->buf[l->pos] = c;
-            l->pos++;
-            l->len++;
-            l->buf[l->len] = '\0';
-            if ((!mlmode && l->plen+l->len < l->cols) /* || mlmode */) {
-                /* Avoid a full update of the line in the
-                 * trivial case. */
-                if (write(l->ofd,&c,1) == -1) return -1;
-            } else {
-                refreshLine(l);
-            }
-        } else {
-            memmove(l->buf+l->pos+1,l->buf+l->pos,l->len-l->pos);
-            l->buf[l->pos] = c;
-            l->len++;
-            l->pos++;
-            l->buf[l->len] = '\0';
-            refreshLine(l);
-        }
-    }
-    return 0;
-}
-
-/* Move cursor on the left. */
-void linenoiseEditMoveLeft(struct linenoiseState *l) {
-    if (l->pos > 0) {
-        l->pos--;
-        refreshLine(l);
-    }
-}
-
-/* Move cursor on the right. */
-void linenoiseEditMoveRight(struct linenoiseState *l) {
-    if (l->pos != l->len) {
-        l->pos++;
-        refreshLine(l);
-    }
-}
-
-/* Move cursor to the start of the line. */
-void linenoiseEditMoveHome(struct linenoiseState *l) {
-    if (l->pos != 0) {
-        l->pos = 0;
-        refreshLine(l);
-    }
-}
-
-/* Move cursor to the end of the line. */
-void linenoiseEditMoveEnd(struct linenoiseState *l) {
-    if (l->pos != l->len) {
-        l->pos = l->len;
-        refreshLine(l);
-    }
-}
-
-/* Substitute the currently edited line with the next or previous history
- * entry as specified by 'dir'. */
-#define LINENOISE_HISTORY_NEXT 0
-#define LINENOISE_HISTORY_PREV 1
-void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
-    if (history_len > 1) {
-        /* Update the current history entry before to
-         * overwrite it with the next one. */
-        free(history[history_len - 1 - l->history_index]);
-        history[history_len - 1 - l->history_index] = strdup(l->buf);
-        /* Show the new entry */
-        l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;
-        if (l->history_index < 0) {
-            l->history_index = 0;
-            return;
-        } else if (l->history_index >= history_len) {
-            l->history_index = history_len-1;
-            return;
-        }
-        strncpy(l->buf,history[history_len - 1 - l->history_index],l->buflen);
-        l->buf[l->buflen-1] = '\0';
-        l->len = l->pos = strlen(l->buf);
-        refreshLine(l);
-    }
-}
-
-/* Delete the character at the right of the cursor without altering the cursor
- * position. Basically this is what happens with the "Delete" keyboard key. */
-void linenoiseEditDelete(struct linenoiseState *l) {
-    if (l->len > 0 && l->pos < l->len) {
-        memmove(l->buf+l->pos,l->buf+l->pos+1,l->len-l->pos-1);
-        l->len--;
-        l->buf[l->len] = '\0';
-        refreshLine(l);
-    }
-}
-
-/* Backspace implementation. */
-void linenoiseEditBackspace(struct linenoiseState *l) {
-    if (l->pos > 0 && l->len > 0) {
-        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
-        l->pos--;
-        l->len--;
-        l->buf[l->len] = '\0';
-        refreshLine(l);
-    }
-}
-
-/* Delete the previosu word, maintaining the cursor at the start of the
- * current word. */
-void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
-    size_t old_pos = l->pos;
-    size_t diff;
-
-    while (l->pos > 0 && l->buf[l->pos-1] == ' ')
-        l->pos--;
-    while (l->pos > 0 && l->buf[l->pos-1] != ' ')
-        l->pos--;
-    diff = old_pos - l->pos;
-    memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);
-    l->len -= diff;
-    refreshLine(l);
-}
-
-/* This function is the core of the line editing capability of linenoise.
- * It expects 'fd' to be already in "raw mode" so that every key pressed
- * will be returned ASAP to read().
- *
- * The resulting string is put into 'buf' when the user type enter, or
- * when ctrl+d is typed.
- *
- * The function returns the length of the current buffer. */
-static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt)
-{
-    struct linenoiseState l;
-
-    /* Populate the linenoise state that we pass to functions implementing
-     * specific editing functionalities. */
-    l.ifd = stdin_fd;
-    l.ofd = stdout_fd;
-    l.buf = buf;
-    l.buflen = buflen;
-    l.prompt = prompt;
-    l.plen = strlen(prompt);
-    l.oldpos = l.pos = 0;
-    l.len = 0;
-    l.cols = getColumns(stdin_fd, stdout_fd);
-    l.maxrows = 0;
-    l.history_index = 0;
-
-    /* Buffer starts empty. */
-    l.buf[0] = '\0';
-    l.buflen--; /* Make sure there is always space for the nulterm */
-
-    /* The latest history entry is always our current buffer, that
-     * initially is just an empty string. */
-    linenoiseHistoryAdd("");
-
-    if (write(l.ofd,prompt,l.plen) == -1) return -1;
-    while(1) {
-        char c;
-        int nread;
-        char seq[3];
-
-        nread = read(l.ifd,&c,1);
-        if (nread <= 0) return l.len;
-
-        /* Only autocomplete when the callback is set. It returns < 0 when
-         * there was an error reading from fd. Otherwise it will return the
-         * character that should be handled next. */
-        if (c == 9 && completionCallback != NULL) {
-            c = completeLine(&l);
-            /* Return on errors */
-            if (c < 0) return l.len;
-            /* Read next character when 0 */
-            if (c == 0) continue;
-        }
-
-        switch(c) {
-        case ENTER:    /* enter */
-            history_len--;
-            free(history[history_len]);
-            if (mlmode) linenoiseEditMoveEnd(&l);
-            return (int)l.len;
-        case CTRL_C:     /* ctrl-c */
-            errno = EAGAIN;
-            return -1;
-        case BACKSPACE:   /* backspace */
-        case 8:     /* ctrl-h */
-            linenoiseEditBackspace(&l);
-            break;
-        case CTRL_D:     /* ctrl-d, remove char at right of cursor, or if the
-                            line is empty, act as end-of-file. */
-            if (l.len > 0) {
-                linenoiseEditDelete(&l);
-            } else {
-                history_len--;
-                free(history[history_len]);
-                return -1;
-            }
-            break;
-        case CTRL_T:    /* ctrl-t, swaps current character with previous. */
-            if (l.pos > 0 && l.pos < l.len) {
-                int aux = buf[l.pos-1];
-                buf[l.pos-1] = buf[l.pos];
-                buf[l.pos] = aux;
-                if (l.pos != l.len-1) l.pos++;
-                refreshLine(&l);
-            }
-            break;
-        case CTRL_B:     /* ctrl-b */
-            linenoiseEditMoveLeft(&l);
-            break;
-        case CTRL_F:     /* ctrl-f */
-            linenoiseEditMoveRight(&l);
-            break;
-        case CTRL_P:    /* ctrl-p */
-            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
-            break;
-        case CTRL_N:    /* ctrl-n */
-            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
-            break;
-        case ESC:    /* escape sequence */
-            /* Read the next two bytes representing the escape sequence.
-             * Use two calls to handle slow terminals returning the two
-             * chars at different times. */
-            if (read(l.ifd,seq,1) == -1) break;
-            if (read(l.ifd,seq+1,1) == -1) break;
-
-            /* ESC [ sequences. */
-            if (seq[0] == '[') {
-                if (seq[1] >= '0' && seq[1] <= '9') {
-                    /* Extended escape, read additional byte. */
-                    if (read(l.ifd,seq+2,1) == -1) break;
-                    if (seq[2] == '~') {
-                        switch(seq[1]) {
-                        case '3': /* Delete key. */
-                            linenoiseEditDelete(&l);
-                            break;
-                        }
-                    }
-                } else {
-                    switch(seq[1]) {
-                    case 'A': /* Up */
-                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
-                        break;
-                    case 'B': /* Down */
-                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
-                        break;
-                    case 'C': /* Right */
-                        linenoiseEditMoveRight(&l);
-                        break;
-                    case 'D': /* Left */
-                        linenoiseEditMoveLeft(&l);
-                        break;
-                    case 'H': /* Home */
-                        linenoiseEditMoveHome(&l);
-                        break;
-                    case 'F': /* End*/
-                        linenoiseEditMoveEnd(&l);
-                        break;
-                    }
-                }
-            }
-
-            /* ESC O sequences. */
-            else if (seq[0] == 'O') {
-                switch(seq[1]) {
-                case 'H': /* Home */
-                    linenoiseEditMoveHome(&l);
-                    break;
-                case 'F': /* End*/
-                    linenoiseEditMoveEnd(&l);
-                    break;
-                }
-            }
-            break;
-        default:
-            if (linenoiseEditInsert(&l,c)) return -1;
-            break;
-        case CTRL_U: /* Ctrl+u, delete the whole line. */
-            buf[0] = '\0';
-            l.pos = l.len = 0;
-            refreshLine(&l);
-            break;
-        case CTRL_K: /* Ctrl+k, delete from current to end of line. */
-            buf[l.pos] = '\0';
-            l.len = l.pos;
-            refreshLine(&l);
-            break;
-        case CTRL_A: /* Ctrl+a, go to the start of the line */
-            linenoiseEditMoveHome(&l);
-            break;
-        case CTRL_E: /* ctrl+e, go to the end of the line */
-            linenoiseEditMoveEnd(&l);
-            break;
-        case CTRL_L: /* ctrl+l, clear screen */
-            linenoiseClearScreen();
-            refreshLine(&l);
-            break;
-        case CTRL_W: /* ctrl+w, delete previous word */
-            linenoiseEditDeletePrevWord(&l);
-            break;
-        }
-    }
-    return l.len;
-}
-
-/* This special mode is used by linenoise in order to print scan codes
- * on screen for debugging / development purposes. It is implemented
- * by the linenoise_example program using the --keycodes option. */
-void linenoisePrintKeyCodes(void) {
-    char quit[4];
-
-    printf("Linenoise key codes debugging mode.\n"
-            "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
-    if (enableRawMode(STDIN_FILENO) == -1) return;
-    memset(quit,' ',4);
-    while(1) {
-        char c;
-        int nread;
-
-        nread = read(STDIN_FILENO,&c,1);
-        if (nread <= 0) continue;
-        memmove(quit,quit+1,sizeof(quit)-1); /* shift string to left. */
-        quit[sizeof(quit)-1] = c; /* Insert current char on the right. */
-        if (memcmp(quit,"quit",sizeof(quit)) == 0) break;
-
-        printf("'%c' %02x (%d) (type quit to exit)\n",
-            isprint(c) ? c : '?', (int)c, (int)c);
-        printf("\r"); /* Go left edge manually, we are in raw mode. */
-        fflush(stdout);
-    }
-    disableRawMode(STDIN_FILENO);
-}
-
-/* This function calls the line editing function linenoiseEdit() using
- * the STDIN file descriptor set in raw mode. */
-static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
-    int count;
-
-    if (buflen == 0) {
-        errno = EINVAL;
-        return -1;
-    }
-    if (!isatty(STDIN_FILENO)) {
-        /* Not a tty: read from file / pipe. */
-        if (fgets(buf, buflen, stdin) == NULL) return -1;
-        count = strlen(buf);
-        if (count && buf[count-1] == '\n') {
-            count--;
-            buf[count] = '\0';
-        }
-    } else {
-        /* Interactive editing. */
-        if (enableRawMode(STDIN_FILENO) == -1) return -1;
-        count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
-        disableRawMode(STDIN_FILENO);
-        printf("\n");
-    }
-    return count;
-}
-
-/* The high level function that is the main API of the linenoise library.
- * This function checks if the terminal has basic capabilities, just checking
- * for a blacklist of stupid terminals, and later either calls the line
- * editing function or uses dummy fgets() so that you will be able to type
- * something even in the most desperate of the conditions. */
-char *linenoise(const char *prompt) {
-    char buf[LINENOISE_MAX_LINE];
-    int count;
-
-    if (isUnsupportedTerm()) {
-        size_t len;
-
-        printf("%s",prompt);
-        fflush(stdout);
-        if (fgets(buf,LINENOISE_MAX_LINE,stdin) == NULL) return NULL;
-        len = strlen(buf);
-        while(len && (buf[len-1] == '\n' || buf[len-1] == '\r')) {
-            len--;
-            buf[len] = '\0';
-        }
-        return strdup(buf);
-    } else {
-        count = linenoiseRaw(buf,LINENOISE_MAX_LINE,prompt);
-        if (count == -1) return NULL;
-        return strdup(buf);
-    }
-}
-
-/* ================================ History ================================= */
-
-/* Free the history, but does not reset it. Only used when we have to
- * exit() to avoid memory leaks are reported by valgrind & co. */
-static void freeHistory(void) {
-    if (history) {
-        int j;
-
-        for (j = 0; j < history_len; j++)
-            free(history[j]);
-        free(history);
-    }
-}
-
-/* At exit we'll try to fix the terminal to the initial conditions. */
-static void linenoiseAtExit(void) {
-    disableRawMode(STDIN_FILENO);
-    freeHistory();
-}
-
-/* This is the API call to add a new entry in the linenoise history.
- * It uses a fixed array of char pointers that are shifted (memmoved)
- * when the history max length is reached in order to remove the older
- * entry and make room for the new one, so it is not exactly suitable for huge
- * histories, but will work well for a few hundred of entries.
- *
- * Using a circular buffer is smarter, but a bit more complex to handle. */
-int linenoiseHistoryAdd(const char *line) {
-    char *linecopy;
-
-    if (history_max_len == 0) return 0;
-
-    /* Initialization on first call. */
-    if (history == NULL) {
-        history = (char**)malloc(sizeof(char*)*history_max_len);
-        if (history == NULL) return 0;
-        memset(history,0,(sizeof(char*)*history_max_len));
-    }
-
-    /* Don't add duplicated lines. */
-    if (history_len && !strcmp(history[history_len-1], line)) return 0;
-
-    /* Add an heap allocated copy of the line in the history.
-     * If we reached the max length, remove the older line. */
-    linecopy = strdup(line);
-    if (!linecopy) return 0;
-    if (history_len == history_max_len) {
-        free(history[0]);
-        memmove(history,history+1,sizeof(char*)*(history_max_len-1));
-        history_len--;
-    }
-    history[history_len] = linecopy;
-    history_len++;
-    return 1;
-}
-
-/* Set the maximum length for the history. This function can be called even
- * if there is already some history, the function will make sure to retain
- * just the latest 'len' elements if the new history length value is smaller
- * than the amount of items already inside the history. */
-int linenoiseHistorySetMaxLen(int len) {
-    char **new_s;
-
-    if (len < 1) return 0;
-    if (history) {
-        int tocopy = history_len;
-
-        new_s = (char**)malloc(sizeof(char*)*len);
-        if (new_s == NULL) return 0;
-
-        /* If we can't copy everything, free the elements we'll not use. */
-        if (len < tocopy) {
-            int j;
-
-            for (j = 0; j < tocopy-len; j++) free(history[j]);
-            tocopy = len;
-        }
-        memset(new_s,0,sizeof(char*)*len);
-        memcpy(new_s,history+(history_len-tocopy), sizeof(char*)*tocopy);
-        free(history);
-        history = new_s;
-    }
-    history_max_len = len;
-    if (history_len > history_max_len)
-        history_len = history_max_len;
-    return 1;
-}
-
-/* Save the history in the specified file. On success 0 is returned
- * otherwise -1 is returned. */
-int linenoiseHistorySave(const char *filename) {
-    FILE *fp = fopen(filename,"w");
-    int j;
-
-    if (fp == NULL) return -1;
-    for (j = 0; j < history_len; j++)
-        fprintf(fp,"%s\n",history[j]);
-    fclose(fp);
-    return 0;
-}
-
-/* Load the history from the specified file. If the file does not exist
- * zero is returned and no operation is performed.
- *
- * If the file exists and the operation succeeded 0 is returned, otherwise
- * on error -1 is returned. */
-int linenoiseHistoryLoad(const char *filename) {
-    FILE *fp = fopen(filename,"r");
-    char buf[LINENOISE_MAX_LINE];
-
-    if (fp == NULL) return -1;
-
-    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {
-        char *p;
-
-        p = strchr(buf,'\r');
-        if (!p) p = strchr(buf,'\n');
-        if (p) *p = '\0';
-        linenoiseHistoryAdd(buf);
-    }
-    fclose(fp);
-    return 0;
-}
diff -Naur ./ThirdParty/linenoise/linenoise.h ../omniscidb-master/ThirdParty/linenoise/linenoise.h
--- ./ThirdParty/linenoise/linenoise.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/linenoise.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,66 +0,0 @@
-/* linenoise.h -- guerrilla line editing library against the idea that a
- * line editing lib needs to be 20,000 lines of C code.
- *
- * See linenoise.c for more information.
- *
- * ------------------------------------------------------------------------
- *
- * Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>
- * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  *  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *  *  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __LINENOISE_H
-#define __LINENOISE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct linenoiseCompletions {
-  size_t len;
-  char **cvec;
-} linenoiseCompletions;
-
-typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);
-void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);
-void linenoiseAddCompletion(linenoiseCompletions *, const char *);
-
-char *linenoise(const char *prompt);
-int linenoiseHistoryAdd(const char *line);
-int linenoiseHistorySetMaxLen(int len);
-int linenoiseHistorySave(const char *filename);
-int linenoiseHistoryLoad(const char *filename);
-void linenoiseClearScreen(void);
-void linenoiseSetMultiLine(int ml);
-void linenoisePrintKeyCodes(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __LINENOISE_H */
diff -Naur ./ThirdParty/linenoise/src/ConvertUTF.cpp ../omniscidb-master/ThirdParty/linenoise/src/ConvertUTF.cpp
--- ./ThirdParty/linenoise/src/ConvertUTF.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/src/ConvertUTF.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,542 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ * 
+ * Disclaimer
+ * 
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ * 
+ * Limitations on Rights to Redistribute This Code
+ * 
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Conversions between UTF32, UTF-16, and UTF-8. Source code file.
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+    Sept 2001: fixed const & error conditions per
+        mods suggested by S. Parent & A. Lillich.
+    June 2002: Tim Dodd added detection and handling of incomplete
+        source sequences, enhanced error detection, added casts
+        to eliminate compiler warnings.
+    July 2003: slight mods to back out aggressive FFFE detection.
+    Jan 2004: updated switches in from-UTF8 conversions.
+    Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.
+
+    See the header file "ConvertUTF.h" for complete documentation.
+
+------------------------------------------------------------------------ */
+
+#include "ConvertUTF.h"
+#ifdef CVTUTF_DEBUG
+#include <stdio.h>
+#endif
+
+namespace linenoise_ng {
+
+static const int halfShift  = 10; /* used for shifting by 10 bits */
+
+static const UTF32 halfBase = 0x0010000UL;
+static const UTF32 halfMask = 0x3FFUL;
+
+#define UNI_SUR_HIGH_START  (UTF32)0xD800
+#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
+#define UNI_SUR_LOW_START   (UTF32)0xDC00
+#define UNI_SUR_LOW_END     (UTF32)0xDFFF
+#define false      0
+#define true        1
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF16 (
+        const UTF32** sourceStart, const UTF32* sourceEnd, 
+        char16_t** targetStart, char16_t* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF32* source = *sourceStart;
+    char16_t* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch;
+        if (target >= targetEnd) {
+            result = targetExhausted; break;
+        }
+        ch = *source++;
+        if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
+            /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                if (flags == strictConversion) {
+                    --source; /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                } else {
+                    *target++ = UNI_REPLACEMENT_CHAR;
+                }
+            } else {
+                *target++ = (UTF16)ch; /* normal case */
+            }
+        } else if (ch > UNI_MAX_LEGAL_UTF32) {
+            if (flags == strictConversion) {
+                result = sourceIllegal;
+            } else {
+                *target++ = UNI_REPLACEMENT_CHAR;
+            }
+        } else {
+            /* target is a character in range 0xFFFF - 0x10FFFF. */
+            if (target + 1 >= targetEnd) {
+                --source; /* Back up source pointer! */
+                result = targetExhausted; break;
+            }
+            ch -= halfBase;
+            *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+            *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+        }
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF32 (
+        const UTF16** sourceStart, const UTF16* sourceEnd, 
+        UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF16* source = *sourceStart;
+    UTF32* target = *targetStart;
+    UTF32 ch, ch2;
+    while (source < sourceEnd) {
+        const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
+        ch = *source++;
+        /* If we have a surrogate pair, convert to UTF32 first. */
+        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+            /* If the 16 bits following the high surrogate are in the source buffer... */
+            if (source < sourceEnd) {
+                ch2 = *source;
+                /* If it's a low surrogate, convert to UTF32. */
+                if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+                    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+                        + (ch2 - UNI_SUR_LOW_START) + halfBase;
+                    ++source;
+                } else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+                    --source; /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                }
+            } else { /* We don't have the 16 bits following the high surrogate. */
+                --source; /* return to the high surrogate */
+                result = sourceExhausted;
+                break;
+            }
+        } else if (flags == strictConversion) {
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+                --source; /* return to the illegal value itself */
+                result = sourceIllegal;
+                break;
+            }
+        }
+        if (target >= targetEnd) {
+            source = oldSource; /* Back up source pointer! */
+            result = targetExhausted; break;
+        }
+        *target++ = ch;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+#ifdef CVTUTF_DEBUG
+if (result == sourceIllegal) {
+    fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
+    fflush(stderr);
+}
+#endif
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Index into the table below with the first byte of a UTF-8 sequence to
+ * get the number of trailing bytes that are supposed to follow it.
+ * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
+ * left as-is for anyone who may want to do such conversion, which was
+ * allowed in earlier algorithms.
+ */
+static const char trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+/*
+ * Magic values subtracted from a buffer value during UTF8 conversion.
+ * This table contains as many values as there might be trailing bytes
+ * in a UTF-8 sequence.
+ */
+static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, 
+                     0x03C82080UL, 0xFA082080UL, 0x82082080UL };
+
+/*
+ * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
+ * into the first byte, depending on how many bytes follow.  There are
+ * as many entries in this table as there are UTF-8 sequence types.
+ * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
+ * for *legal* UTF-8 will be 4 or fewer bytes total.
+ */
+static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+/* --------------------------------------------------------------------- */
+
+/* The interface converts a whole buffer to avoid function-call overhead.
+ * Constants have been gathered. Loops & conditionals have been removed as
+ * much as possible for efficiency, in favor of drop-through switches.
+ * (See "Note A" at the bottom of the file for equivalent code.)
+ * If your compiler supports it, the "isLegalUTF8" call can be turned
+ * into an inline function.
+ */
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF8 (
+        const UTF16** sourceStart, const UTF16* sourceEnd, 
+        UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF16* source = *sourceStart;
+    UTF8* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch;
+        unsigned short bytesToWrite = 0;
+        const UTF32 byteMask = 0xBF;
+        const UTF32 byteMark = 0x80; 
+        const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
+        ch = *source++;
+        /* If we have a surrogate pair, convert to UTF32 first. */
+        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+            /* If the 16 bits following the high surrogate are in the source buffer... */
+            if (source < sourceEnd) {
+                UTF32 ch2 = *source;
+                /* If it's a low surrogate, convert to UTF32. */
+                if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+                    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+                        + (ch2 - UNI_SUR_LOW_START) + halfBase;
+                    ++source;
+                } else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+                    --source; /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                }
+            } else { /* We don't have the 16 bits following the high surrogate. */
+                --source; /* return to the high surrogate */
+                result = sourceExhausted;
+                break;
+            }
+        } else if (flags == strictConversion) {
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+                --source; /* return to the illegal value itself */
+                result = sourceIllegal;
+                break;
+            }
+        }
+        /* Figure out how many bytes the result will require */
+        if (ch < (UTF32)0x80) {      bytesToWrite = 1;
+        } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+        } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+        } else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
+        } else {                            bytesToWrite = 3;
+                                            ch = UNI_REPLACEMENT_CHAR;
+        }
+
+        target += bytesToWrite;
+        if (target > targetEnd) {
+            source = oldSource; /* Back up source pointer! */
+            target -= bytesToWrite; result = targetExhausted; break;
+        }
+        switch (bytesToWrite) { /* note: everything falls through. */
+            case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
+        }
+        target += bytesToWrite;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Utility routine to tell whether a sequence of bytes is legal UTF-8.
+ * This must be called with the length pre-determined by the first byte.
+ * If not calling this from ConvertUTF8to*, then the length can be set by:
+ *  length = trailingBytesForUTF8[*source]+1;
+ * and the sequence is illegal right away if there aren't that many bytes
+ * available.
+ * If presented with a length > 4, this returns false.  The Unicode
+ * definition of UTF-8 goes up to 4-byte sequences.
+ */
+
+static Boolean isLegalUTF8(const UTF8 *source, int length) {
+    UTF8 a;
+    const UTF8 *srcptr = source+length;
+    switch (length) {
+    default: return false;
+        /* Everything else falls through when "true"... */
+    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+    case 2: if ((a = (*--srcptr)) > 0xBF) return false;
+
+        switch (*source) {
+            /* no fall-through in this inner switch */
+            case 0xE0: if (a < 0xA0) return false; break;
+            case 0xED: if (a > 0x9F) return false; break;
+            case 0xF0: if (a < 0x90) return false; break;
+            case 0xF4: if (a > 0x8F) return false; break;
+            default:   if (a < 0x80) return false;
+        }
+
+    case 1: if (*source >= 0x80 && *source < 0xC2) return false;
+    }
+    if (*source > 0xF4) return false;
+    return true;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Exported function to return whether a UTF-8 sequence is legal or not.
+ * This is not used here; it's just exported.
+ */
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
+    int length = trailingBytesForUTF8[*source]+1;
+    if (source+length > sourceEnd) {
+        return false;
+    }
+    return isLegalUTF8(source, length);
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF16 (
+        const UTF8** sourceStart, const UTF8* sourceEnd, 
+        UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF8* source = *sourceStart;
+    UTF16* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch = 0;
+        unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+        if (source + extraBytesToRead >= sourceEnd) {
+            result = sourceExhausted; break;
+        }
+        /* Do this check whether lenient or strict */
+        if (! isLegalUTF8(source, extraBytesToRead+1)) {
+            result = sourceIllegal;
+            break;
+        }
+        /*
+         * The cases all fall through. See "Note A" below.
+         */
+        switch (extraBytesToRead) {
+            case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+            case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+            case 3: ch += *source++; ch <<= 6;
+            case 2: ch += *source++; ch <<= 6;
+            case 1: ch += *source++; ch <<= 6;
+            case 0: ch += *source++;
+        }
+        ch -= offsetsFromUTF8[extraBytesToRead];
+
+        if (target >= targetEnd) {
+            source -= (extraBytesToRead+1); /* Back up source pointer! */
+            result = targetExhausted; break;
+        }
+        if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                if (flags == strictConversion) {
+                    source -= (extraBytesToRead+1); /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                } else {
+                    *target++ = UNI_REPLACEMENT_CHAR;
+                }
+            } else {
+                *target++ = (UTF16)ch; /* normal case */
+            }
+        } else if (ch > UNI_MAX_UTF16) {
+            if (flags == strictConversion) {
+                result = sourceIllegal;
+                source -= (extraBytesToRead+1); /* return to the start */
+                break; /* Bail out; shouldn't continue */
+            } else {
+                *target++ = UNI_REPLACEMENT_CHAR;
+            }
+        } else {
+            /* target is a character in range 0xFFFF - 0x10FFFF. */
+            if (target + 1 >= targetEnd) {
+                source -= (extraBytesToRead+1); /* Back up source pointer! */
+                result = targetExhausted; break;
+            }
+            ch -= halfBase;
+            *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+            *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+        }
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF8 (
+        const UTF32** sourceStart, const UTF32* sourceEnd, 
+        UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF32* source = *sourceStart;
+    UTF8* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch;
+        unsigned short bytesToWrite = 0;
+        const UTF32 byteMask = 0xBF;
+        const UTF32 byteMark = 0x80; 
+        ch = *source++;
+        if (flags == strictConversion ) {
+            /* UTF-16 surrogate values are illegal in UTF-32 */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                --source; /* return to the illegal value itself */
+                result = sourceIllegal;
+                break;
+            }
+        }
+        /*
+         * Figure out how many bytes the result will require. Turn any
+         * illegally large UTF32 things (> Plane 17) into replacement chars.
+         */
+        if (ch < (UTF32)0x80) {      bytesToWrite = 1;
+        } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+        } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+        } else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
+        } else {                            bytesToWrite = 3;
+                                            ch = UNI_REPLACEMENT_CHAR;
+                                            result = sourceIllegal;
+        }
+        
+        target += bytesToWrite;
+        if (target > targetEnd) {
+            --source; /* Back up source pointer! */
+            target -= bytesToWrite; result = targetExhausted; break;
+        }
+        switch (bytesToWrite) { /* note: everything falls through. */
+            case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+            case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
+        }
+        target += bytesToWrite;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF32 (
+        const UTF8** sourceStart, const UTF8* sourceEnd, 
+        UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF8* source = *sourceStart;
+    UTF32* target = *targetStart;
+    while (source < sourceEnd) {
+        UTF32 ch = 0;
+        unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+        if (source + extraBytesToRead >= sourceEnd) {
+            result = sourceExhausted; break;
+        }
+        /* Do this check whether lenient or strict */
+        if (! isLegalUTF8(source, extraBytesToRead+1)) {
+            result = sourceIllegal;
+            break;
+        }
+        /*
+         * The cases all fall through. See "Note A" below.
+         */
+        switch (extraBytesToRead) {
+            case 5: ch += *source++; ch <<= 6;
+            case 4: ch += *source++; ch <<= 6;
+            case 3: ch += *source++; ch <<= 6;
+            case 2: ch += *source++; ch <<= 6;
+            case 1: ch += *source++; ch <<= 6;
+            case 0: ch += *source++;
+        }
+        ch -= offsetsFromUTF8[extraBytesToRead];
+
+        if (target >= targetEnd) {
+            source -= (extraBytesToRead+1); /* Back up the source pointer! */
+            result = targetExhausted; break;
+        }
+        if (ch <= UNI_MAX_LEGAL_UTF32) {
+            /*
+             * UTF-16 surrogate values are illegal in UTF-32, and anything
+             * over Plane 17 (> 0x10FFFF) is illegal.
+             */
+            if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+                if (flags == strictConversion) {
+                    source -= (extraBytesToRead+1); /* return to the illegal value itself */
+                    result = sourceIllegal;
+                    break;
+                } else {
+                    *target++ = UNI_REPLACEMENT_CHAR;
+                }
+            } else {
+                *target++ = ch;
+            }
+        } else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
+            result = sourceIllegal;
+            *target++ = UNI_REPLACEMENT_CHAR;
+        }
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+}
+
+/* ---------------------------------------------------------------------
+
+    Note A.
+    The fall-through switches in UTF-8 reading code save a
+    temp variable, some decrements & conditionals.  The switches
+    are equivalent to the following loop:
+        {
+            int tmpBytesToRead = extraBytesToRead+1;
+            do {
+                ch += *source++;
+                --tmpBytesToRead;
+                if (tmpBytesToRead) ch <<= 6;
+            } while (tmpBytesToRead > 0);
+        }
+    In UTF-8 writing code, the switches on "bytesToWrite" are
+    similarly unrolled loops.
+
+   --------------------------------------------------------------------- */
diff -Naur ./ThirdParty/linenoise/src/ConvertUTF.h ../omniscidb-master/ThirdParty/linenoise/src/ConvertUTF.h
--- ./ThirdParty/linenoise/src/ConvertUTF.h	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/src/ConvertUTF.h	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ * 
+ * Disclaimer
+ * 
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ * 
+ * Limitations on Rights to Redistribute This Code
+ * 
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Conversions between UTF32, UTF-16, and UTF-8.  Header file.
+
+    Several funtions are included here, forming a complete set of
+    conversions between the three formats.  UTF-7 is not included
+    here, but is handled in a separate source file.
+
+    Each of these routines takes pointers to input buffers and output
+    buffers.  The input buffers are const.
+
+    Each routine converts the text between *sourceStart and sourceEnd,
+    putting the result into the buffer between *targetStart and
+    targetEnd. Note: the end pointers are *after* the last item: e.g. 
+    *(sourceEnd - 1) is the last item.
+
+    The return result indicates whether the conversion was successful,
+    and if not, whether the problem was in the source or target buffers.
+    (Only the first encountered problem is indicated.)
+
+    After the conversion, *sourceStart and *targetStart are both
+    updated to point to the end of last text successfully converted in
+    the respective buffers.
+
+    Input parameters:
+        sourceStart - pointer to a pointer to the source buffer.
+                The contents of this are modified on return so that
+                it points at the next thing to be converted.
+        targetStart - similarly, pointer to pointer to the target buffer.
+        sourceEnd, targetEnd - respectively pointers to the ends of the
+                two buffers, for overflow checking only.
+
+    These conversion functions take a ConversionFlags argument. When this
+    flag is set to strict, both irregular sequences and isolated surrogates
+    will cause an error.  When the flag is set to lenient, both irregular
+    sequences and isolated surrogates are converted.
+
+    Whether the flag is strict or lenient, all illegal sequences will cause
+    an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,
+    or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code
+    must check for illegal sequences.
+
+    When the flag is set to lenient, characters over 0x10FFFF are converted
+    to the replacement character; otherwise (when the flag is set to strict)
+    they constitute an error.
+
+    Output parameters:
+        The value "sourceIllegal" is returned from some routines if the input
+        sequence is malformed.  When "sourceIllegal" is returned, the source
+        value will point to the illegal value that caused the problem. E.g.,
+        in UTF-8 when a sequence is malformed, it points to the start of the
+        malformed sequence.  
+
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+                 Fixes & updates, Sept 2001.
+
+------------------------------------------------------------------------ */
+
+/* ---------------------------------------------------------------------
+    The following 4 definitions are compiler-specific.
+    The C standard does not guarantee that wchar_t has at least
+    16 bits, so wchar_t is no less portable than unsigned short!
+    All should be unsigned values to avoid sign extension during
+    bit mask & shift operations.
+------------------------------------------------------------------------ */
+
+#if 0
+typedef unsigned long  UTF32; /* at least 32 bits */
+typedef unsigned short UTF16; /* at least 16 bits */
+typedef unsigned char  UTF8;  /* typically 8 bits */
+#endif
+
+#include <stdint.h>
+#include <string>
+
+namespace linenoise_ng {
+
+typedef uint32_t         UTF32;
+typedef uint16_t         UTF16;
+typedef uint8_t          UTF8;
+typedef unsigned char    Boolean; /* 0 or 1 */
+
+/* Some fundamental constants */
+#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
+#define UNI_MAX_BMP (UTF32)0x0000FFFF
+#define UNI_MAX_UTF16 (UTF32)0x0010FFFF
+#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF
+#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF
+
+typedef enum {
+        conversionOK,           /* conversion successful */
+        sourceExhausted,        /* partial character in source, but hit end */
+        targetExhausted,        /* insuff. room in target for conversion */
+        sourceIllegal           /* source sequence is illegal/malformed */
+} ConversionResult;
+
+typedef enum {
+        strictConversion = 0,
+        lenientConversion
+} ConversionFlags;
+
+// /* This is for C++ and does no harm in C */
+// #ifdef __cplusplus
+// extern "C" {
+// #endif
+
+ConversionResult ConvertUTF8toUTF16 (
+                const UTF8** sourceStart, const UTF8* sourceEnd, 
+                UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF16toUTF8 (
+                const UTF16** sourceStart, const UTF16* sourceEnd, 
+                UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+                
+ConversionResult ConvertUTF8toUTF32 (
+                const UTF8** sourceStart, const UTF8* sourceEnd, 
+                UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF8 (
+                const UTF32** sourceStart, const UTF32* sourceEnd, 
+                UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+                
+ConversionResult ConvertUTF16toUTF32 (
+                const UTF16** sourceStart, const UTF16* sourceEnd, 
+                UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF16 (
+                const UTF32** sourceStart, const UTF32* sourceEnd, 
+                char16_t** targetStart, char16_t* targetEnd, ConversionFlags flags);
+
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd);
+
+// #ifdef __cplusplus
+// }
+// #endif
+
+}
+
+/* --------------------------------------------------------------------- */
diff -Naur ./ThirdParty/linenoise/src/linenoise.cpp ../omniscidb-master/ThirdParty/linenoise/src/linenoise.cpp
--- ./ThirdParty/linenoise/src/linenoise.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/src/linenoise.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,3457 @@
+/* linenoise.c -- guerrilla line editing library against the idea that a
+ * line editing lib needs to be 20,000 lines of C code.
+ *
+ * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * line editing lib needs to be 20,000 lines of C code.
+ *
+ * You can find the latest source code at:
+ *
+ *   http://github.com/antirez/linenoise
+ *
+ * Does a number of crazy assumptions that happen to be true in 99.9999% of
+ * the 2010 UNIX computers around.
+ *
+ * References:
+ * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
+ * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
+ *
+ * Todo list:
+ * - Switch to gets() if $TERM is something we can't support.
+ * - Filter bogus Ctrl+<char> combinations.
+ * - Win32 support
+ *
+ * Bloat:
+ * - Completion?
+ * - History search like Ctrl+r in readline?
+ *
+ * List of escape sequences used by this program, we do everything just
+ * with three sequences. In order to be so cheap we may have some
+ * flickering effect with some slow terminal, but the lesser sequences
+ * the more compatible.
+ *
+ * CHA (Cursor Horizontal Absolute)
+ *    Sequence: ESC [ n G
+ *    Effect: moves cursor to column n (1 based)
+ *
+ * EL (Erase Line)
+ *    Sequence: ESC [ n K
+ *    Effect: if n is 0 or missing, clear from cursor to end of line
+ *    Effect: if n is 1, clear from beginning of line to cursor
+ *    Effect: if n is 2, clear entire line
+ *
+ * CUF (Cursor Forward)
+ *    Sequence: ESC [ n C
+ *    Effect: moves cursor forward of n chars
+ *
+ * The following are used to clear the screen: ESC [ H ESC [ 2 J
+ * This is actually composed of two sequences:
+ *
+ * cursorhome
+ *    Sequence: ESC [ H
+ *    Effect: moves the cursor to upper left corner
+ *
+ * ED2 (Clear entire screen)
+ *    Sequence: ESC [ 2 J
+ *    Effect: clear the whole screen
+ *
+ */
+
+#ifdef _WIN32
+
+#include <conio.h>
+#include <windows.h>
+#include <io.h>
+
+#if defined(_MSC_VER) && _MSC_VER < 1900
+#define snprintf _snprintf  // Microsoft headers use underscores in some names
+#endif
+
+#if !defined GNUC
+#define strcasecmp _stricmp
+#endif
+
+#define strdup _strdup
+#define isatty _isatty
+#define write _write
+#define STDIN_FILENO 0
+
+#else /* _WIN32 */
+
+#include <signal.h>
+#include <termios.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <cctype>
+#include <wctype.h>
+
+#endif /* _WIN32 */
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include "linenoise.h"
+#include "ConvertUTF.h"
+
+#include <string>
+#include <vector>
+#include <memory>
+
+using std::string;
+using std::vector;
+using std::unique_ptr;
+using namespace linenoise_ng;
+
+typedef unsigned char char8_t;
+
+static ConversionResult copyString8to32(char32_t* dst, size_t dstSize,
+                                        size_t& dstCount, const char* src) {
+  const UTF8* sourceStart = reinterpret_cast<const UTF8*>(src);
+  const UTF8* sourceEnd = sourceStart + strlen(src);
+  UTF32* targetStart = reinterpret_cast<UTF32*>(dst);
+  UTF32* targetEnd = targetStart + dstSize;
+
+  ConversionResult res = ConvertUTF8toUTF32(
+      &sourceStart, sourceEnd, &targetStart, targetEnd, lenientConversion);
+
+  if (res == conversionOK) {
+    dstCount = targetStart - reinterpret_cast<UTF32*>(dst);
+
+    if (dstCount < dstSize) {
+      *targetStart = 0;
+    }
+  }
+
+  return res;
+}
+
+static ConversionResult copyString8to32(char32_t* dst, size_t dstSize,
+                                        size_t& dstCount, const char8_t* src) {
+  return copyString8to32(dst, dstSize, dstCount,
+                         reinterpret_cast<const char*>(src));
+}
+
+static size_t strlen32(const char32_t* str) {
+  const char32_t* ptr = str;
+
+  while (*ptr) {
+    ++ptr;
+  }
+
+  return ptr - str;
+}
+
+static size_t strlen8(const char8_t* str) {
+  return strlen(reinterpret_cast<const char*>(str));
+}
+
+static char8_t* strdup8(const char* src) {
+  return reinterpret_cast<char8_t*>(strdup(src));
+}
+
+#ifdef _WIN32
+static const int FOREGROUND_WHITE =
+    FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+static const int BACKGROUND_WHITE =
+    BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
+static const int INTENSITY = FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
+
+class WinAttributes {
+ public:
+  WinAttributes() {
+    CONSOLE_SCREEN_BUFFER_INFO info;
+    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info);
+    _defaultAttribute = info.wAttributes & INTENSITY;
+    _defaultColor = info.wAttributes & FOREGROUND_WHITE;
+    _defaultBackground = info.wAttributes & BACKGROUND_WHITE;
+
+    _consoleAttribute = _defaultAttribute;
+    _consoleColor = _defaultColor | _defaultBackground;
+  }
+
+ public:
+  int _defaultAttribute;
+  int _defaultColor;
+  int _defaultBackground;
+
+  int _consoleAttribute;
+  int _consoleColor;
+};
+
+static WinAttributes WIN_ATTR;
+
+static void copyString32to16(char16_t* dst, size_t dstSize, size_t* dstCount,
+                             const char32_t* src, size_t srcSize) {
+  const UTF32* sourceStart = reinterpret_cast<const UTF32*>(src);
+  const UTF32* sourceEnd = sourceStart + srcSize;
+  char16_t* targetStart = reinterpret_cast<char16_t*>(dst);
+  char16_t* targetEnd = targetStart + dstSize;
+
+  ConversionResult res = ConvertUTF32toUTF16(
+      &sourceStart, sourceEnd, &targetStart, targetEnd, lenientConversion);
+
+  if (res == conversionOK) {
+    *dstCount = targetStart - reinterpret_cast<char16_t*>(dst);
+
+    if (*dstCount < dstSize) {
+      *targetStart = 0;
+    }
+  }
+}
+#endif
+
+static void copyString32to8(char* dst, size_t dstSize, size_t* dstCount,
+                            const char32_t* src, size_t srcSize) {
+  const UTF32* sourceStart = reinterpret_cast<const UTF32*>(src);
+  const UTF32* sourceEnd = sourceStart + srcSize;
+  UTF8* targetStart = reinterpret_cast<UTF8*>(dst);
+  UTF8* targetEnd = targetStart + dstSize;
+
+  ConversionResult res = ConvertUTF32toUTF8(
+      &sourceStart, sourceEnd, &targetStart, targetEnd, lenientConversion);
+
+  if (res == conversionOK) {
+    *dstCount = targetStart - reinterpret_cast<UTF8*>(dst);
+
+    if (*dstCount < dstSize) {
+      *targetStart = 0;
+    }
+  }
+}
+
+static void copyString32to8(char* dst, size_t dstLen, const char32_t* src) {
+  size_t dstCount = 0;
+  copyString32to8(dst, dstLen, &dstCount, src, strlen32(src));
+}
+
+static void copyString32(char32_t* dst, const char32_t* src, size_t len) {
+  while (0 < len && *src) {
+    *dst++ = *src++;
+    --len;
+  }
+
+  *dst = 0;
+}
+
+static int strncmp32(const char32_t* left, const char32_t* right, size_t len) {
+  while (0 < len && *left) {
+    if (*left != *right) {
+      return *left - *right;
+    }
+
+    ++left;
+    ++right;
+    --len;
+  }
+
+  return 0;
+}
+
+#ifdef _WIN32
+#include <iostream>
+
+static size_t OutputWin(char16_t* text16, char32_t* text32, size_t len32) {
+  size_t count16 = 0;
+
+  copyString32to16(text16, len32, &count16, text32, len32);
+  WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), text16,
+                static_cast<DWORD>(count16), nullptr, nullptr);
+
+  return count16;
+}
+
+static char32_t* HandleEsc(char32_t* p, char32_t* end) {
+  if (*p == '[') {
+    int code = 0;
+
+    for (++p; p < end; ++p) {
+      char32_t c = *p;
+
+      if ('0' <= c && c <= '9') {
+        code = code * 10 + (c - '0');
+      } else if (c == 'm' || c == ';') {
+        switch (code) {
+          case 0:
+            WIN_ATTR._consoleAttribute = WIN_ATTR._defaultAttribute;
+            WIN_ATTR._consoleColor =
+                WIN_ATTR._defaultColor | WIN_ATTR._defaultBackground;
+            break;
+
+          case 1:  // BOLD
+          case 5:  // BLINK
+            WIN_ATTR._consoleAttribute =
+                (WIN_ATTR._defaultAttribute ^ FOREGROUND_INTENSITY) & INTENSITY;
+            break;
+
+          case 30:
+            WIN_ATTR._consoleColor = BACKGROUND_WHITE;
+            break;
+
+          case 31:
+            WIN_ATTR._consoleColor =
+                FOREGROUND_RED | WIN_ATTR._defaultBackground;
+            break;
+
+          case 32:
+            WIN_ATTR._consoleColor =
+                FOREGROUND_GREEN | WIN_ATTR._defaultBackground;
+            break;
+
+          case 33:
+            WIN_ATTR._consoleColor =
+                FOREGROUND_RED | FOREGROUND_GREEN | WIN_ATTR._defaultBackground;
+            break;
+
+          case 34:
+            WIN_ATTR._consoleColor =
+                FOREGROUND_BLUE | WIN_ATTR._defaultBackground;
+            break;
+
+          case 35:
+            WIN_ATTR._consoleColor =
+                FOREGROUND_BLUE | FOREGROUND_RED | WIN_ATTR._defaultBackground;
+            break;
+
+          case 36:
+            WIN_ATTR._consoleColor = FOREGROUND_BLUE | FOREGROUND_GREEN |
+                                     WIN_ATTR._defaultBackground;
+            break;
+
+          case 37:
+            WIN_ATTR._consoleColor = FOREGROUND_GREEN | FOREGROUND_RED |
+                                     FOREGROUND_BLUE |
+                                     WIN_ATTR._defaultBackground;
+            break;
+        }
+
+        code = 0;
+      }
+
+      if (*p == 'm') {
+        ++p;
+        break;
+      }
+    }
+  } else {
+    ++p;
+  }
+
+  auto handle = GetStdHandle(STD_OUTPUT_HANDLE);
+  SetConsoleTextAttribute(handle,
+                          WIN_ATTR._consoleAttribute | WIN_ATTR._consoleColor);
+
+  return p;
+}
+
+static size_t WinWrite32(char16_t* text16, char32_t* text32, size_t len32) {
+  char32_t* p = text32;
+  char32_t* q = p;
+  char32_t* e = text32 + len32;
+  size_t count16 = 0;
+
+  while (p < e) {
+    if (*p == 27) {
+      if (q < p) {
+        count16 += OutputWin(text16, q, p - q);
+      }
+
+      q = p = HandleEsc(p + 1, e);
+    } else {
+      ++p;
+    }
+  }
+
+  if (q < p) {
+    count16 += OutputWin(text16, q, p - q);
+  }
+
+  return count16;
+}
+#endif
+
+static int write32(int fd, char32_t* text32, int len32) {
+#ifdef _WIN32
+  if (isatty(fd)) {
+    size_t len16 = 2 * len32 + 1;
+    unique_ptr<char16_t[]> text16(new char16_t[len16]);
+    size_t count16 = WinWrite32(text16.get(), text32, len32);
+
+    return static_cast<int>(count16);
+  } else {
+    size_t len8 = 4 * len32 + 1;
+    unique_ptr<char[]> text8(new char[len8]);
+    size_t count8 = 0;
+
+    copyString32to8(text8.get(), len8, &count8, text32, len32);
+
+    return write(fd, text8.get(), static_cast<unsigned int>(count8));
+  }
+#else
+  size_t len8 = 4 * len32 + 1;
+  unique_ptr<char[]> text8(new char[len8]);
+  size_t count8 = 0;
+
+  copyString32to8(text8.get(), len8, &count8, text32, len32);
+
+  return write(fd, text8.get(), count8);
+#endif
+}
+
+class Utf32String {
+ public:
+  Utf32String() : _length(0), _data(nullptr) { 
+    // note: parens intentional, _data must be properly initialized
+    _data = new char32_t[1](); 
+  }
+
+  explicit Utf32String(const char* src) : _length(0), _data(nullptr) {
+    size_t len = strlen(src);
+    // note: parens intentional, _data must be properly initialized
+    _data = new char32_t[len + 1]();
+    copyString8to32(_data, len + 1, _length, src);
+  }
+
+  explicit Utf32String(const char8_t* src) : _length(0), _data(nullptr) {
+    size_t len = strlen(reinterpret_cast<const char*>(src));
+    // note: parens intentional, _data must be properly initialized
+    _data = new char32_t[len + 1]();
+    copyString8to32(_data, len + 1, _length, src);
+  }
+
+  explicit Utf32String(const char32_t* src) : _length(0), _data(nullptr) {
+    for (_length = 0; src[_length] != 0; ++_length) {
+    }
+
+    // note: parens intentional, _data must be properly initialized
+    _data = new char32_t[_length + 1]();
+    memcpy(_data, src, _length * sizeof(char32_t));
+  }
+
+  explicit Utf32String(const char32_t* src, int len) : _length(len), _data(nullptr) {
+    // note: parens intentional, _data must be properly initialized
+    _data = new char32_t[len + 1]();
+    memcpy(_data, src, len * sizeof(char32_t));
+  }
+
+  explicit Utf32String(int len) : _length(0), _data(nullptr) { 
+    // note: parens intentional, _data must be properly initialized
+    _data = new char32_t[len](); 
+  }
+
+  explicit Utf32String(const Utf32String& that) : _length(that._length), _data(nullptr) {
+    // note: parens intentional, _data must be properly initialized
+    _data = new char32_t[_length + 1]();
+    memcpy(_data, that._data, sizeof(char32_t) * _length);
+  }
+
+  Utf32String& operator=(const Utf32String& that) {
+    if (this != &that) {
+      delete[] _data;
+      _data = new char32_t[that._length]();
+      _length = that._length;
+      memcpy(_data, that._data, sizeof(char32_t) * _length);
+    }
+
+    return *this;
+  }
+
+  ~Utf32String() { delete[] _data; }
+
+ public:
+  char32_t* get() const { return _data; }
+
+  size_t length() const { return _length; }
+
+  size_t chars() const { return _length; }
+
+  void initFromBuffer() {
+    for (_length = 0; _data[_length] != 0; ++_length) {
+    }
+  }
+
+  const char32_t& operator[](size_t pos) const { return _data[pos]; }
+
+  char32_t& operator[](size_t pos) { return _data[pos]; }
+
+ private:
+  size_t _length;
+  char32_t* _data;
+};
+
+class Utf8String {
+  Utf8String(const Utf8String&) = delete;
+  Utf8String& operator=(const Utf8String&) = delete;
+
+ public:
+  explicit Utf8String(const Utf32String& src) {
+    size_t len = src.length() * 4 + 1;
+    _data = new char[len];
+    copyString32to8(_data, len, src.get());
+  }
+
+  ~Utf8String() { delete[] _data; }
+
+ public:
+  char* get() const { return _data; }
+
+ private:
+  char* _data;
+};
+
+struct linenoiseCompletions {
+  vector<Utf32String> completionStrings;
+};
+
+#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
+#define LINENOISE_MAX_LINE 4096
+
+// make control-characters more readable
+#define ctrlChar(upperCaseASCII) (upperCaseASCII - 0x40)
+
+/**
+ * Recompute widths of all characters in a char32_t buffer
+ * @param text          input buffer of Unicode characters
+ * @param widths        output buffer of character widths
+ * @param charCount     number of characters in buffer
+ */
+namespace linenoise_ng {
+int mk_wcwidth(char32_t ucs);
+}
+
+static void recomputeCharacterWidths(const char32_t* text, char* widths,
+                                     int charCount) {
+  for (int i = 0; i < charCount; ++i) {
+    widths[i] = mk_wcwidth(text[i]);
+  }
+}
+
+/**
+ * Calculate a new screen position given a starting position, screen width and
+ * character count
+ * @param x             initial x position (zero-based)
+ * @param y             initial y position (zero-based)
+ * @param screenColumns screen column count
+ * @param charCount     character positions to advance
+ * @param xOut          returned x position (zero-based)
+ * @param yOut          returned y position (zero-based)
+ */
+static void calculateScreenPosition(int x, int y, int screenColumns,
+                                    int charCount, int& xOut, int& yOut) {
+  xOut = x;
+  yOut = y;
+  int charsRemaining = charCount;
+  while (charsRemaining > 0) {
+    int charsThisRow = (x + charsRemaining < screenColumns) ? charsRemaining
+                                                            : screenColumns - x;
+    xOut = x + charsThisRow;
+    yOut = y;
+    charsRemaining -= charsThisRow;
+    x = 0;
+    ++y;
+  }
+  if (xOut == screenColumns) {  // we have to special-case line wrap
+    xOut = 0;
+    ++yOut;
+  }
+}
+
+/**
+ * Calculate a column width using mk_wcswidth()
+ * @param buf32  text to calculate
+ * @param len    length of text to calculate
+ */
+namespace linenoise_ng {
+int mk_wcswidth(const char32_t* pwcs, size_t n);
+}
+
+static int calculateColumnPosition(char32_t* buf32, int len) {
+  int width = mk_wcswidth(reinterpret_cast<const char32_t*>(buf32), len);
+  if (width == -1)
+    return len;
+  else
+    return width;
+}
+
+static bool isControlChar(char32_t testChar) {
+  return (testChar < ' ') ||                      // C0 controls
+         (testChar >= 0x7F && testChar <= 0x9F);  // DEL and C1 controls
+}
+
+struct PromptBase {            // a convenience struct for grouping prompt info
+  Utf32String promptText;      // our copy of the prompt text, edited
+  char* promptCharWidths;      // character widths from mk_wcwidth()
+  int promptChars;             // chars in promptText
+  int promptBytes;             // bytes in promptText
+  int promptExtraLines;        // extra lines (beyond 1) occupied by prompt
+  int promptIndentation;       // column offset to end of prompt
+  int promptLastLinePosition;  // index into promptText where last line begins
+  int promptPreviousInputLen;  // promptChars of previous input line, for
+                               // clearing
+  int promptCursorRowOffset;   // where the cursor is relative to the start of
+                               // the prompt
+  int promptScreenColumns;     // width of screen in columns
+  int promptPreviousLen;       // help erasing
+  int promptErrorCode;         // error code (invalid UTF-8) or zero
+
+  PromptBase() : promptPreviousInputLen(0) {}
+
+  bool write() {
+    if (write32(1, promptText.get(), promptBytes) == -1) return false;
+
+    return true;
+  }
+};
+
+struct PromptInfo : public PromptBase {
+  PromptInfo(const char* textPtr, int columns) {
+    promptExtraLines = 0;
+    promptLastLinePosition = 0;
+    promptPreviousLen = 0;
+    promptScreenColumns = columns;
+    Utf32String tempUnicode(textPtr);
+
+    // strip control characters from the prompt -- we do allow newline
+    char32_t* pIn = tempUnicode.get();
+    char32_t* pOut = pIn;
+
+    int len = 0;
+    int x = 0;
+
+    bool const strip = (isatty(1) == 0);
+
+    while (*pIn) {
+      char32_t c = *pIn;
+      if ('\n' == c || !isControlChar(c)) {
+        *pOut = c;
+        ++pOut;
+        ++pIn;
+        ++len;
+        if ('\n' == c || ++x >= promptScreenColumns) {
+          x = 0;
+          ++promptExtraLines;
+          promptLastLinePosition = len;
+        }
+      } else if (c == '\x1b') {
+        if (strip) {
+          // jump over control chars
+          ++pIn;
+          if (*pIn == '[') {
+            ++pIn;
+            while (*pIn && ((*pIn == ';') || ((*pIn >= '0' && *pIn <= '9')))) {
+              ++pIn;
+            }
+            if (*pIn == 'm') {
+              ++pIn;
+            }
+          }
+        } else {
+          // copy control chars
+          *pOut = *pIn;
+          ++pOut;
+          ++pIn;
+          if (*pIn == '[') {
+            *pOut = *pIn;
+            ++pOut;
+            ++pIn;
+            while (*pIn && ((*pIn == ';') || ((*pIn >= '0' && *pIn <= '9')))) {
+              *pOut = *pIn;
+              ++pOut;
+              ++pIn;
+            }
+            if (*pIn == 'm') {
+              *pOut = *pIn;
+              ++pOut;
+              ++pIn;
+            }
+          }
+        }
+      } else {
+        ++pIn;
+      }
+    }
+    *pOut = 0;
+    promptChars = len;
+    promptBytes = static_cast<int>(pOut - tempUnicode.get());
+    promptText = tempUnicode;
+
+    promptIndentation = len - promptLastLinePosition;
+    promptCursorRowOffset = promptExtraLines;
+  }
+};
+
+// Used with DynamicPrompt (history search)
+//
+static const Utf32String forwardSearchBasePrompt("(i-search)`");
+static const Utf32String reverseSearchBasePrompt("(reverse-i-search)`");
+static const Utf32String endSearchBasePrompt("': ");
+static Utf32String
+    previousSearchText;  // remembered across invocations of linenoise()
+
+// changing prompt for "(reverse-i-search)`text':" etc.
+//
+struct DynamicPrompt : public PromptBase {
+  Utf32String searchText;  // text we are searching for
+  char* searchCharWidths;  // character widths from mk_wcwidth()
+  int searchTextLen;       // chars in searchText
+  int direction;           // current search direction, 1=forward, -1=reverse
+
+  DynamicPrompt(PromptBase& pi, int initialDirection)
+      : searchTextLen(0), direction(initialDirection) {
+    promptScreenColumns = pi.promptScreenColumns;
+    promptCursorRowOffset = 0;
+    Utf32String emptyString(1);
+    searchText = emptyString;
+    const Utf32String* basePrompt =
+        (direction > 0) ? &forwardSearchBasePrompt : &reverseSearchBasePrompt;
+    size_t promptStartLength = basePrompt->length();
+    promptChars =
+        static_cast<int>(promptStartLength + endSearchBasePrompt.length());
+    promptBytes = promptChars;
+    promptLastLinePosition = promptChars;  // TODO fix this, we are asssuming
+                                           // that the history prompt won't wrap
+                                           // (!)
+    promptPreviousLen = promptChars;
+    Utf32String tempUnicode(promptChars + 1);
+    memcpy(tempUnicode.get(), basePrompt->get(),
+           sizeof(char32_t) * promptStartLength);
+    memcpy(&tempUnicode[promptStartLength], endSearchBasePrompt.get(),
+           sizeof(char32_t) * (endSearchBasePrompt.length() + 1));
+    tempUnicode.initFromBuffer();
+    promptText = tempUnicode;
+    calculateScreenPosition(0, 0, pi.promptScreenColumns, promptChars,
+                            promptIndentation, promptExtraLines);
+  }
+
+  void updateSearchPrompt(void) {
+    const Utf32String* basePrompt =
+        (direction > 0) ? &forwardSearchBasePrompt : &reverseSearchBasePrompt;
+    size_t promptStartLength = basePrompt->length();
+    promptChars = static_cast<int>(promptStartLength + searchTextLen +
+                                   endSearchBasePrompt.length());
+    promptBytes = promptChars;
+    Utf32String tempUnicode(promptChars + 1);
+    memcpy(tempUnicode.get(), basePrompt->get(),
+           sizeof(char32_t) * promptStartLength);
+    memcpy(&tempUnicode[promptStartLength], searchText.get(),
+           sizeof(char32_t) * searchTextLen);
+    size_t endIndex = promptStartLength + searchTextLen;
+    memcpy(&tempUnicode[endIndex], endSearchBasePrompt.get(),
+           sizeof(char32_t) * (endSearchBasePrompt.length() + 1));
+    tempUnicode.initFromBuffer();
+    promptText = tempUnicode;
+  }
+
+  void updateSearchText(const char32_t* textPtr) {
+    Utf32String tempUnicode(textPtr);
+    searchTextLen = static_cast<int>(tempUnicode.chars());
+    searchText = tempUnicode;
+    updateSearchPrompt();
+  }
+};
+
+class KillRing {
+  static const int capacity = 10;
+  int size;
+  int index;
+  char indexToSlot[10];
+  vector<Utf32String> theRing;
+
+ public:
+  enum action { actionOther, actionKill, actionYank };
+  action lastAction;
+  size_t lastYankSize;
+
+  KillRing() : size(0), index(0), lastAction(actionOther) {
+    theRing.reserve(capacity);
+  }
+
+  void kill(const char32_t* text, int textLen, bool forward) {
+    if (textLen == 0) {
+      return;
+    }
+    Utf32String killedText(text, textLen);
+    if (lastAction == actionKill && size > 0) {
+      int slot = indexToSlot[0];
+      int currentLen = static_cast<int>(theRing[slot].length());
+      int resultLen = currentLen + textLen;
+      Utf32String temp(resultLen + 1);
+      if (forward) {
+        memcpy(temp.get(), theRing[slot].get(), currentLen * sizeof(char32_t));
+        memcpy(&temp[currentLen], killedText.get(), textLen * sizeof(char32_t));
+      } else {
+        memcpy(temp.get(), killedText.get(), textLen * sizeof(char32_t));
+        memcpy(&temp[textLen], theRing[slot].get(),
+               currentLen * sizeof(char32_t));
+      }
+      temp[resultLen] = 0;
+      temp.initFromBuffer();
+      theRing[slot] = temp;
+    } else {
+      if (size < capacity) {
+        if (size > 0) {
+          memmove(&indexToSlot[1], &indexToSlot[0], size);
+        }
+        indexToSlot[0] = size;
+        size++;
+        theRing.push_back(killedText);
+      } else {
+        int slot = indexToSlot[capacity - 1];
+        theRing[slot] = killedText;
+        memmove(&indexToSlot[1], &indexToSlot[0], capacity - 1);
+        indexToSlot[0] = slot;
+      }
+      index = 0;
+    }
+  }
+
+  Utf32String* yank() { return (size > 0) ? &theRing[indexToSlot[index]] : 0; }
+
+  Utf32String* yankPop() {
+    if (size == 0) {
+      return 0;
+    }
+    ++index;
+    if (index == size) {
+      index = 0;
+    }
+    return &theRing[indexToSlot[index]];
+  }
+};
+
+class InputBuffer {
+  char32_t* buf32;   // input buffer
+  char* charWidths;  // character widths from mk_wcwidth()
+  int buflen;        // buffer size in characters
+  int len;           // length of text in input buffer
+  int pos;           // character position in buffer ( 0 <= pos <= len )
+
+  void clearScreen(PromptBase& pi);
+  int incrementalHistorySearch(PromptBase& pi, int startChar);
+  int completeLine(PromptBase& pi);
+  void refreshLine(PromptBase& pi);
+
+ public:
+  InputBuffer(char32_t* buffer, char* widthArray, int bufferLen)
+      : buf32(buffer),
+        charWidths(widthArray),
+        buflen(bufferLen - 1),
+        len(0),
+        pos(0) {
+    buf32[0] = 0;
+  }
+  void preloadBuffer(const char* preloadText) {
+    size_t ucharCount = 0;
+    copyString8to32(buf32, buflen + 1, ucharCount, preloadText);
+    recomputeCharacterWidths(buf32, charWidths, static_cast<int>(ucharCount));
+    len = static_cast<int>(ucharCount);
+    pos = static_cast<int>(ucharCount);
+  }
+  int getInputLine(PromptBase& pi);
+  int length(void) const { return len; }
+};
+
+// Special codes for keyboard input:
+//
+// Between Windows and the various Linux "terminal" programs, there is some
+// pretty diverse behavior in the "scan codes" and escape sequences we are
+// presented with.  So ... we'll translate them all into our own pidgin
+// pseudocode, trying to stay out of the way of UTF-8 and international
+// characters.  Here's the general plan.
+//
+// "User input keystrokes" (key chords, whatever) will be encoded as a single
+// value.
+// The low 21 bits are reserved for Unicode characters.  Popular function-type
+// keys
+// get their own codes in the range 0x10200000 to (if needed) 0x1FE00000,
+// currently
+// just arrow keys, Home, End and Delete.  Keypresses with Ctrl get ORed with
+// 0x20000000, with Alt get ORed with 0x40000000.  So, Ctrl+Alt+Home is encoded
+// as 0x20000000 + 0x40000000 + 0x10A00000 == 0x70A00000.  To keep things
+// complicated,
+// the Alt key is equivalent to prefixing the keystroke with ESC, so ESC
+// followed by
+// D is treated the same as Alt + D ... we'll just use Emacs terminology and
+// call
+// this "Meta".  So, we will encode both ESC followed by D and Alt held down
+// while D
+// is pressed the same, as Meta-D, encoded as 0x40000064.
+//
+// Here are the definitions of our component constants:
+//
+// Maximum unsigned 32-bit value    = 0xFFFFFFFF;   // For reference, max 32-bit
+// value
+// Highest allocated Unicode char   = 0x001FFFFF;   // For reference, max
+// Unicode value
+static const int META = 0x40000000;  // Meta key combination
+static const int CTRL = 0x20000000;  // Ctrl key combination
+// static const int SPECIAL_KEY = 0x10000000;   // Common bit for all special
+// keys
+static const int UP_ARROW_KEY = 0x10200000;  // Special keys
+static const int DOWN_ARROW_KEY = 0x10400000;
+static const int RIGHT_ARROW_KEY = 0x10600000;
+static const int LEFT_ARROW_KEY = 0x10800000;
+static const int HOME_KEY = 0x10A00000;
+static const int END_KEY = 0x10C00000;
+static const int DELETE_KEY = 0x10E00000;
+static const int PAGE_UP_KEY = 0x11000000;
+static const int PAGE_DOWN_KEY = 0x11200000;
+
+static const char* unsupported_term[] = {"dumb", "cons25", "emacs", NULL};
+static linenoiseCompletionCallback* completionCallback = NULL;
+
+#ifdef _WIN32
+static HANDLE console_in, console_out;
+static DWORD oldMode;
+static WORD oldDisplayAttribute;
+#else
+static struct termios orig_termios; /* in order to restore at exit */
+#endif
+
+static KillRing killRing;
+
+static int rawmode = 0; /* for atexit() function to check if restore is needed*/
+static int atexit_registered = 0; /* register atexit just 1 time */
+static int historyMaxLen = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
+static int historyLen = 0;
+static int historyIndex = 0;
+static char8_t** history = NULL;
+
+// used to emulate Windows command prompt on down-arrow after a recall
+// we use -2 as our "not set" value because we add 1 to the previous index on
+// down-arrow,
+// and zero is a valid index (so -1 is a valid "previous index")
+static int historyPreviousIndex = -2;
+static bool historyRecallMostRecent = false;
+
+static void linenoiseAtExit(void);
+
+static bool isUnsupportedTerm(void) {
+  char* term = getenv("TERM");
+  if (term == NULL) return false;
+  for (int j = 0; unsupported_term[j]; ++j)
+    if (!strcasecmp(term, unsupported_term[j])) {
+      return true;
+    }
+  return false;
+}
+
+static void beep() {
+  fprintf(stderr, "\x7");  // ctrl-G == bell/beep
+  fflush(stderr);
+}
+
+void linenoiseHistoryFree(void) {
+  if (history) {
+    for (int j = 0; j < historyLen; ++j) free(history[j]);
+    historyLen = 0;
+    free(history);
+    history = 0;
+  }
+}
+
+static int enableRawMode(void) {
+#ifdef _WIN32
+  if (!console_in) {
+    console_in = GetStdHandle(STD_INPUT_HANDLE);
+    console_out = GetStdHandle(STD_OUTPUT_HANDLE);
+
+    GetConsoleMode(console_in, &oldMode);
+    SetConsoleMode(console_in, oldMode &
+                                   ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT |
+                                     ENABLE_PROCESSED_INPUT));
+  }
+  return 0;
+#else
+  struct termios raw;
+
+  if (!isatty(STDIN_FILENO)) goto fatal;
+  if (!atexit_registered) {
+    atexit(linenoiseAtExit);
+    atexit_registered = 1;
+  }
+  if (tcgetattr(0, &orig_termios) == -1) goto fatal;
+
+  raw = orig_termios; /* modify the original mode */
+  /* input modes: no break, no CR to NL, no parity check, no strip char,
+   * no start/stop output control. */
+  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
+  /* output modes - disable post processing */
+  // this is wrong, we don't want raw output, it turns newlines into straight
+  // linefeeds
+  // raw.c_oflag &= ~(OPOST);
+  /* control modes - set 8 bit chars */
+  raw.c_cflag |= (CS8);
+  /* local modes - echoing off, canonical off, no extended functions,
+   * no signal chars (^Z,^C) */
+  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
+  /* control chars - set return condition: min number of bytes and timer.
+   * We want read to return every single byte, without timeout. */
+  raw.c_cc[VMIN] = 1;
+  raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
+
+  /* put terminal in raw mode after flushing */
+  if (tcsetattr(0, TCSADRAIN, &raw) < 0) goto fatal;
+  rawmode = 1;
+  return 0;
+
+fatal:
+  errno = ENOTTY;
+  return -1;
+#endif
+}
+
+static void disableRawMode(void) {
+#ifdef _WIN32
+  SetConsoleMode(console_in, oldMode);
+  console_in = 0;
+  console_out = 0;
+#else
+  if (rawmode && tcsetattr(0, TCSADRAIN, &orig_termios) != -1) rawmode = 0;
+#endif
+}
+
+// At exit we'll try to fix the terminal to the initial conditions
+static void linenoiseAtExit(void) { disableRawMode(); }
+
+static int getScreenColumns(void) {
+  int cols;
+#ifdef _WIN32
+  CONSOLE_SCREEN_BUFFER_INFO inf;
+  GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &inf);
+  cols = inf.dwSize.X;
+#else
+  struct winsize ws;
+  cols = (ioctl(1, TIOCGWINSZ, &ws) == -1) ? 80 : ws.ws_col;
+#endif
+  // cols is 0 in certain circumstances like inside debugger, which creates
+  // further issues
+  return (cols > 0) ? cols : 80;
+}
+
+static int getScreenRows(void) {
+  int rows;
+#ifdef _WIN32
+  CONSOLE_SCREEN_BUFFER_INFO inf;
+  GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &inf);
+  rows = 1 + inf.srWindow.Bottom - inf.srWindow.Top;
+#else
+  struct winsize ws;
+  rows = (ioctl(1, TIOCGWINSZ, &ws) == -1) ? 24 : ws.ws_row;
+#endif
+  return (rows > 0) ? rows : 24;
+}
+
+static void setDisplayAttribute(bool enhancedDisplay, bool error) {
+#ifdef _WIN32
+  if (enhancedDisplay) {
+    CONSOLE_SCREEN_BUFFER_INFO inf;
+    GetConsoleScreenBufferInfo(console_out, &inf);
+    oldDisplayAttribute = inf.wAttributes;
+    BYTE oldLowByte = oldDisplayAttribute & 0xFF;
+    BYTE newLowByte;
+    switch (oldLowByte) {
+      case 0x07:
+        // newLowByte = FOREGROUND_BLUE | FOREGROUND_INTENSITY;  // too dim
+        // newLowByte = FOREGROUND_BLUE;                         // even dimmer
+        newLowByte = FOREGROUND_BLUE |
+                     FOREGROUND_GREEN;  // most similar to xterm appearance
+        break;
+      case 0x70:
+        newLowByte = BACKGROUND_BLUE | BACKGROUND_INTENSITY;
+        break;
+      default:
+        newLowByte = oldLowByte ^ 0xFF;  // default to inverse video
+        break;
+    }
+    inf.wAttributes = (inf.wAttributes & 0xFF00) | newLowByte;
+    SetConsoleTextAttribute(console_out, inf.wAttributes);
+  } else {
+    SetConsoleTextAttribute(console_out, oldDisplayAttribute);
+  }
+#else
+  if (enhancedDisplay) {
+    char const* p = (error ? "\x1b[1;31m" : "\x1b[1;34m");
+    if (write(1, p, 7) == -1)
+      return; /* bright blue (visible with both B&W bg) */
+  } else {
+    if (write(1, "\x1b[0m", 4) == -1) return; /* reset */
+  }
+#endif
+}
+
+/**
+ * Display the dynamic incremental search prompt and the current user input
+ * line.
+ * @param pi   PromptBase struct holding information about the prompt and our
+ * screen position
+ * @param buf32  input buffer to be displayed
+ * @param len  count of characters in the buffer
+ * @param pos  current cursor position within the buffer (0 <= pos <= len)
+ */
+static void dynamicRefresh(PromptBase& pi, char32_t* buf32, int len, int pos) {
+  // calculate the position of the end of the prompt
+  int xEndOfPrompt, yEndOfPrompt;
+  calculateScreenPosition(0, 0, pi.promptScreenColumns, pi.promptChars,
+                          xEndOfPrompt, yEndOfPrompt);
+  pi.promptIndentation = xEndOfPrompt;
+
+  // calculate the position of the end of the input line
+  int xEndOfInput, yEndOfInput;
+  calculateScreenPosition(xEndOfPrompt, yEndOfPrompt, pi.promptScreenColumns,
+                          calculateColumnPosition(buf32, len), xEndOfInput,
+                          yEndOfInput);
+
+  // calculate the desired position of the cursor
+  int xCursorPos, yCursorPos;
+  calculateScreenPosition(xEndOfPrompt, yEndOfPrompt, pi.promptScreenColumns,
+                          calculateColumnPosition(buf32, pos), xCursorPos,
+                          yCursorPos);
+
+#ifdef _WIN32
+  // position at the start of the prompt, clear to end of previous input
+  CONSOLE_SCREEN_BUFFER_INFO inf;
+  GetConsoleScreenBufferInfo(console_out, &inf);
+  inf.dwCursorPosition.X = 0;
+  inf.dwCursorPosition.Y -= pi.promptCursorRowOffset /*- pi.promptExtraLines*/;
+  SetConsoleCursorPosition(console_out, inf.dwCursorPosition);
+  DWORD count;
+  FillConsoleOutputCharacterA(console_out, ' ',
+                              pi.promptPreviousLen + pi.promptPreviousInputLen,
+                              inf.dwCursorPosition, &count);
+  pi.promptPreviousLen = pi.promptIndentation;
+  pi.promptPreviousInputLen = len;
+
+  // display the prompt
+  if (!pi.write()) return;
+
+  // display the input line
+  if (write32(1, buf32, len) == -1) return;
+
+  // position the cursor
+  GetConsoleScreenBufferInfo(console_out, &inf);
+  inf.dwCursorPosition.X = xCursorPos;  // 0-based on Win32
+  inf.dwCursorPosition.Y -= yEndOfInput - yCursorPos;
+  SetConsoleCursorPosition(console_out, inf.dwCursorPosition);
+#else  // _WIN32
+  char seq[64];
+  int cursorRowMovement = pi.promptCursorRowOffset - pi.promptExtraLines;
+  if (cursorRowMovement > 0) {  // move the cursor up as required
+    snprintf(seq, sizeof seq, "\x1b[%dA", cursorRowMovement);
+    if (write(1, seq, strlen(seq)) == -1) return;
+  }
+  // position at the start of the prompt, clear to end of screen
+  snprintf(seq, sizeof seq, "\x1b[1G\x1b[J");  // 1-based on VT100
+  if (write(1, seq, strlen(seq)) == -1) return;
+
+  // display the prompt
+  if (!pi.write()) return;
+
+  // display the input line
+  if (write32(1, buf32, len) == -1) return;
+
+  // we have to generate our own newline on line wrap
+  if (xEndOfInput == 0 && yEndOfInput > 0)
+    if (write(1, "\n", 1) == -1) return;
+
+  // position the cursor
+  cursorRowMovement = yEndOfInput - yCursorPos;
+  if (cursorRowMovement > 0) {  // move the cursor up as required
+    snprintf(seq, sizeof seq, "\x1b[%dA", cursorRowMovement);
+    if (write(1, seq, strlen(seq)) == -1) return;
+  }
+  // position the cursor within the line
+  snprintf(seq, sizeof seq, "\x1b[%dG", xCursorPos + 1);  // 1-based on VT100
+  if (write(1, seq, strlen(seq)) == -1) return;
+#endif
+
+  pi.promptCursorRowOffset =
+      pi.promptExtraLines + yCursorPos;  // remember row for next pass
+}
+
+/**
+ * Refresh the user's input line: the prompt is already onscreen and is not
+ * redrawn here
+ * @param pi   PromptBase struct holding information about the prompt and our
+ * screen position
+ */
+void InputBuffer::refreshLine(PromptBase& pi) {
+  // check for a matching brace/bracket/paren, remember its position if found
+  int highlight = -1;
+  bool indicateError = false;
+  if (pos < len) {
+    /* this scans for a brace matching buf32[pos] to highlight */
+    unsigned char part1, part2;
+    int scanDirection = 0;
+    if (strchr("}])", buf32[pos])) {
+      scanDirection = -1; /* backwards */
+      if (buf32[pos] == '}') {
+        part1 = '}'; part2 = '{';
+      } else if (buf32[pos] == ']') {
+        part1 = ']'; part2 = '[';
+      } else {
+        part1 = ')'; part2 = '(';
+      }
+    }
+    else if (strchr("{[(", buf32[pos])) {
+      scanDirection = 1; /* forwards */
+      if (buf32[pos] == '{') {
+        //part1 = '{'; part2 = '}';
+        part1 = '}'; part2 = '{';
+      } else if (buf32[pos] == '[') {
+        //part1 = '['; part2 = ']';
+        part1 = ']'; part2 = '[';
+      } else {
+        //part1 = '('; part2 = ')';
+        part1 = ')'; part2 = '(';
+      }
+    }
+
+    if (scanDirection) {
+      int unmatched = scanDirection;
+      int unmatchedOther = 0;
+      for (int i = pos + scanDirection; i >= 0 && i < len; i += scanDirection) {
+        /* TODO: the right thing when inside a string */
+        if (strchr("}])", buf32[i])) {
+          if (buf32[i] == part1) {
+            --unmatched;
+          } else {
+            --unmatchedOther;
+          }
+        } else if (strchr("{[(", buf32[i])) {
+          if (buf32[i] == part2) {
+            ++unmatched;
+          } else {
+            ++unmatchedOther;
+          }
+        }
+/*
+        if (strchr("}])", buf32[i]))
+          --unmatched;
+        else if (strchr("{[(", buf32[i]))
+          ++unmatched;
+*/
+        if (unmatched == 0) {
+          highlight = i;
+          indicateError = (unmatchedOther != 0);
+          break;
+        }
+      }
+    }
+  }
+
+  // calculate the position of the end of the input line
+  int xEndOfInput, yEndOfInput;
+  calculateScreenPosition(pi.promptIndentation, 0, pi.promptScreenColumns,
+                          calculateColumnPosition(buf32, len), xEndOfInput,
+                          yEndOfInput);
+
+  // calculate the desired position of the cursor
+  int xCursorPos, yCursorPos;
+  calculateScreenPosition(pi.promptIndentation, 0, pi.promptScreenColumns,
+                          calculateColumnPosition(buf32, pos), xCursorPos,
+                          yCursorPos);
+
+#ifdef _WIN32
+  // position at the end of the prompt, clear to end of previous input
+  CONSOLE_SCREEN_BUFFER_INFO inf;
+  GetConsoleScreenBufferInfo(console_out, &inf);
+  inf.dwCursorPosition.X = pi.promptIndentation;  // 0-based on Win32
+  inf.dwCursorPosition.Y -= pi.promptCursorRowOffset - pi.promptExtraLines;
+  SetConsoleCursorPosition(console_out, inf.dwCursorPosition);
+  DWORD count;
+  if (len < pi.promptPreviousInputLen)
+    FillConsoleOutputCharacterA(console_out, ' ', pi.promptPreviousInputLen,
+                                inf.dwCursorPosition, &count);
+  pi.promptPreviousInputLen = len;
+
+  // display the input line
+  if (highlight == -1) {
+    if (write32(1, buf32, len) == -1) return;
+  } else {
+    if (write32(1, buf32, highlight) == -1) return;
+    setDisplayAttribute(true, indicateError); /* bright blue (visible with both B&W bg) */
+    if (write32(1, &buf32[highlight], 1) == -1) return;
+    setDisplayAttribute(false, indicateError);
+    if (write32(1, buf32 + highlight + 1, len - highlight - 1) == -1) return;
+  }
+
+  // position the cursor
+  GetConsoleScreenBufferInfo(console_out, &inf);
+  inf.dwCursorPosition.X = xCursorPos;  // 0-based on Win32
+  inf.dwCursorPosition.Y -= yEndOfInput - yCursorPos;
+  SetConsoleCursorPosition(console_out, inf.dwCursorPosition);
+#else  // _WIN32
+  char seq[64];
+  int cursorRowMovement = pi.promptCursorRowOffset - pi.promptExtraLines;
+  if (cursorRowMovement > 0) {  // move the cursor up as required
+    snprintf(seq, sizeof seq, "\x1b[%dA", cursorRowMovement);
+    if (write(1, seq, strlen(seq)) == -1) return;
+  }
+  // position at the end of the prompt, clear to end of screen
+  snprintf(seq, sizeof seq, "\x1b[%dG\x1b[J",
+           pi.promptIndentation + 1);  // 1-based on VT100
+  if (write(1, seq, strlen(seq)) == -1) return;
+
+  if (highlight == -1) {  // write unhighlighted text
+    if (write32(1, buf32, len) == -1) return;
+  } else {  // highlight the matching brace/bracket/parenthesis
+    if (write32(1, buf32, highlight) == -1) return;
+    setDisplayAttribute(true, indicateError);
+    if (write32(1, &buf32[highlight], 1) == -1) return;
+    setDisplayAttribute(false, indicateError);
+    if (write32(1, buf32 + highlight + 1, len - highlight - 1) == -1) return;
+  }
+
+  // we have to generate our own newline on line wrap
+  if (xEndOfInput == 0 && yEndOfInput > 0)
+    if (write(1, "\n", 1) == -1) return;
+
+  // position the cursor
+  cursorRowMovement = yEndOfInput - yCursorPos;
+  if (cursorRowMovement > 0) {  // move the cursor up as required
+    snprintf(seq, sizeof seq, "\x1b[%dA", cursorRowMovement);
+    if (write(1, seq, strlen(seq)) == -1) return;
+  }
+  // position the cursor within the line
+  snprintf(seq, sizeof seq, "\x1b[%dG", xCursorPos + 1);  // 1-based on VT100
+  if (write(1, seq, strlen(seq)) == -1) return;
+#endif
+
+  pi.promptCursorRowOffset =
+      pi.promptExtraLines + yCursorPos;  // remember row for next pass
+}
+
+#ifndef _WIN32
+
+/**
+ * Read a UTF-8 sequence from the non-Windows keyboard and return the Unicode
+ * (char32_t) character it
+ * encodes
+ *
+ * @return  char32_t Unicode character
+ */
+static char32_t readUnicodeCharacter(void) {
+  static char8_t utf8String[5];
+  static size_t utf8Count = 0;
+  while (true) {
+    char8_t c;
+
+    /* Continue reading if interrupted by signal. */
+    ssize_t nread;
+    do {
+      nread = read(0, &c, 1);
+    } while ((nread == -1) && (errno == EINTR));
+
+    if (nread <= 0) return 0;
+    if (c <= 0x7F) {  // short circuit ASCII
+      utf8Count = 0;
+      return c;
+    } else if (utf8Count < sizeof(utf8String) - 1) {
+      utf8String[utf8Count++] = c;
+      utf8String[utf8Count] = 0;
+      char32_t unicodeChar[2];
+      size_t ucharCount;
+      ConversionResult res =
+          copyString8to32(unicodeChar, 2, ucharCount, utf8String);
+      if (res == conversionOK && ucharCount) {
+        utf8Count = 0;
+        return unicodeChar[0];
+      }
+    } else {
+      utf8Count =
+          0;  // this shouldn't happen: got four bytes but no UTF-8 character
+    }
+  }
+}
+
+namespace EscapeSequenceProcessing {  // move these out of global namespace
+
+// This chunk of code does parsing of the escape sequences sent by various Linux
+// terminals.
+//
+// It handles arrow keys, Home, End and Delete keys by interpreting the
+// sequences sent by
+// gnome terminal, xterm, rxvt, konsole, aterm and yakuake including the Alt and
+// Ctrl key
+// combinations that are understood by linenoise.
+//
+// The parsing uses tables, a bunch of intermediate dispatch routines and a
+// doDispatch
+// loop that reads the tables and sends control to "deeper" routines to continue
+// the
+// parsing.  The starting call to doDispatch( c, initialDispatch ) will
+// eventually return
+// either a character (with optional CTRL and META bits set), or -1 if parsing
+// fails, or
+// zero if an attempt to read from the keyboard fails.
+//
+// This is rather sloppy escape sequence processing, since we're not paying
+// attention to what the
+// actual TERM is set to and are processing all key sequences for all terminals,
+// but it works with
+// the most common keystrokes on the most common terminals.  It's intricate, but
+// the nested 'if'
+// statements required to do it directly would be worse.  This way has the
+// advantage of allowing
+// changes and extensions without having to touch a lot of code.
+
+// This is a typedef for the routine called by doDispatch().  It takes the
+// current character
+// as input, does any required processing including reading more characters and
+// calling other
+// dispatch routines, then eventually returns the final (possibly extended or
+// special) character.
+//
+typedef char32_t (*CharacterDispatchRoutine)(char32_t);
+
+// This structure is used by doDispatch() to hold a list of characters to test
+// for and
+// a list of routines to call if the character matches.  The dispatch routine
+// list is one
+// longer than the character list; the final entry is used if no character
+// matches.
+//
+struct CharacterDispatch {
+  unsigned int len;                    // length of the chars list
+  const char* chars;                   // chars to test
+  CharacterDispatchRoutine* dispatch;  // array of routines to call
+};
+
+// This dispatch routine is given a dispatch table and then farms work out to
+// routines
+// listed in the table based on the character it is called with.  The dispatch
+// routines can
+// read more input characters to decide what should eventually be returned.
+// Eventually,
+// a called routine returns either a character or -1 to indicate parsing
+// failure.
+//
+static char32_t doDispatch(char32_t c, CharacterDispatch& dispatchTable) {
+  for (unsigned int i = 0; i < dispatchTable.len; ++i) {
+    if (static_cast<unsigned char>(dispatchTable.chars[i]) == c) {
+      return dispatchTable.dispatch[i](c);
+    }
+  }
+  return dispatchTable.dispatch[dispatchTable.len](c);
+}
+
+static char32_t thisKeyMetaCtrl =
+    0;  // holds pre-set Meta and/or Ctrl modifiers
+
+// Final dispatch routines -- return something
+//
+static char32_t normalKeyRoutine(char32_t c) { return thisKeyMetaCtrl | c; }
+static char32_t upArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | UP_ARROW_KEY;
+}
+static char32_t downArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | DOWN_ARROW_KEY;
+}
+static char32_t rightArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | RIGHT_ARROW_KEY;
+}
+static char32_t leftArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | LEFT_ARROW_KEY;
+}
+static char32_t homeKeyRoutine(char32_t) { return thisKeyMetaCtrl | HOME_KEY; }
+static char32_t endKeyRoutine(char32_t) { return thisKeyMetaCtrl | END_KEY; }
+static char32_t pageUpKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | PAGE_UP_KEY;
+}
+static char32_t pageDownKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | PAGE_DOWN_KEY;
+}
+static char32_t deleteCharRoutine(char32_t) {
+  return thisKeyMetaCtrl | ctrlChar('H');
+}  // key labeled Backspace
+static char32_t deleteKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | DELETE_KEY;
+}  // key labeled Delete
+static char32_t ctrlUpArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | CTRL | UP_ARROW_KEY;
+}
+static char32_t ctrlDownArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | CTRL | DOWN_ARROW_KEY;
+}
+static char32_t ctrlRightArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | CTRL | RIGHT_ARROW_KEY;
+}
+static char32_t ctrlLeftArrowKeyRoutine(char32_t) {
+  return thisKeyMetaCtrl | CTRL | LEFT_ARROW_KEY;
+}
+static char32_t escFailureRoutine(char32_t) {
+  beep();
+  return -1;
+}
+
+// Handle ESC [ 1 ; 3 (or 5) <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracket1Semicolon3or5Routines[] = {
+    upArrowKeyRoutine, downArrowKeyRoutine, rightArrowKeyRoutine,
+    leftArrowKeyRoutine, escFailureRoutine};
+static CharacterDispatch escLeftBracket1Semicolon3or5Dispatch = {
+    4, "ABCD", escLeftBracket1Semicolon3or5Routines};
+
+// Handle ESC [ 1 ; <more stuff> escape sequences
+//
+static char32_t escLeftBracket1Semicolon3Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  thisKeyMetaCtrl |= META;
+  return doDispatch(c, escLeftBracket1Semicolon3or5Dispatch);
+}
+static char32_t escLeftBracket1Semicolon5Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  thisKeyMetaCtrl |= CTRL;
+  return doDispatch(c, escLeftBracket1Semicolon3or5Dispatch);
+}
+static CharacterDispatchRoutine escLeftBracket1SemicolonRoutines[] = {
+    escLeftBracket1Semicolon3Routine, escLeftBracket1Semicolon5Routine,
+    escFailureRoutine};
+static CharacterDispatch escLeftBracket1SemicolonDispatch = {
+    2, "35", escLeftBracket1SemicolonRoutines};
+
+// Handle ESC [ 1 <more stuff> escape sequences
+//
+static char32_t escLeftBracket1SemicolonRoutine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket1SemicolonDispatch);
+}
+static CharacterDispatchRoutine escLeftBracket1Routines[] = {
+    homeKeyRoutine, escLeftBracket1SemicolonRoutine, escFailureRoutine};
+static CharacterDispatch escLeftBracket1Dispatch = {2, "~;",
+                                                    escLeftBracket1Routines};
+
+// Handle ESC [ 3 <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracket3Routines[] = {deleteKeyRoutine,
+                                                             escFailureRoutine};
+static CharacterDispatch escLeftBracket3Dispatch = {1, "~",
+                                                    escLeftBracket3Routines};
+
+// Handle ESC [ 4 <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracket4Routines[] = {endKeyRoutine,
+                                                             escFailureRoutine};
+static CharacterDispatch escLeftBracket4Dispatch = {1, "~",
+                                                    escLeftBracket4Routines};
+
+// Handle ESC [ 5 <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracket5Routines[] = {pageUpKeyRoutine,
+                                                             escFailureRoutine};
+static CharacterDispatch escLeftBracket5Dispatch = {1, "~",
+                                                    escLeftBracket5Routines};
+
+// Handle ESC [ 6 <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracket6Routines[] = {pageDownKeyRoutine,
+                                                             escFailureRoutine};
+static CharacterDispatch escLeftBracket6Dispatch = {1, "~",
+                                                    escLeftBracket6Routines};
+
+// Handle ESC [ 7 <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracket7Routines[] = {homeKeyRoutine,
+                                                             escFailureRoutine};
+static CharacterDispatch escLeftBracket7Dispatch = {1, "~",
+                                                    escLeftBracket7Routines};
+
+// Handle ESC [ 8 <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracket8Routines[] = {endKeyRoutine,
+                                                             escFailureRoutine};
+static CharacterDispatch escLeftBracket8Dispatch = {1, "~",
+                                                    escLeftBracket8Routines};
+
+// Handle ESC [ <digit> escape sequences
+//
+static char32_t escLeftBracket0Routine(char32_t c) {
+  return escFailureRoutine(c);
+}
+static char32_t escLeftBracket1Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket1Dispatch);
+}
+static char32_t escLeftBracket2Routine(char32_t c) {
+  return escFailureRoutine(c);  // Insert key, unused
+}
+static char32_t escLeftBracket3Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket3Dispatch);
+}
+static char32_t escLeftBracket4Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket4Dispatch);
+}
+static char32_t escLeftBracket5Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket5Dispatch);
+}
+static char32_t escLeftBracket6Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket6Dispatch);
+}
+static char32_t escLeftBracket7Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket7Dispatch);
+}
+static char32_t escLeftBracket8Routine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracket8Dispatch);
+}
+static char32_t escLeftBracket9Routine(char32_t c) {
+  return escFailureRoutine(c);
+}
+
+// Handle ESC [ <more stuff> escape sequences
+//
+static CharacterDispatchRoutine escLeftBracketRoutines[] = {
+    upArrowKeyRoutine,      downArrowKeyRoutine,    rightArrowKeyRoutine,
+    leftArrowKeyRoutine,    homeKeyRoutine,         endKeyRoutine,
+    escLeftBracket0Routine, escLeftBracket1Routine, escLeftBracket2Routine,
+    escLeftBracket3Routine, escLeftBracket4Routine, escLeftBracket5Routine,
+    escLeftBracket6Routine, escLeftBracket7Routine, escLeftBracket8Routine,
+    escLeftBracket9Routine, escFailureRoutine};
+static CharacterDispatch escLeftBracketDispatch = {16, "ABCDHF0123456789",
+                                                   escLeftBracketRoutines};
+
+// Handle ESC O <char> escape sequences
+//
+static CharacterDispatchRoutine escORoutines[] = {
+    upArrowKeyRoutine,       downArrowKeyRoutine,     rightArrowKeyRoutine,
+    leftArrowKeyRoutine,     homeKeyRoutine,          endKeyRoutine,
+    ctrlUpArrowKeyRoutine,   ctrlDownArrowKeyRoutine, ctrlRightArrowKeyRoutine,
+    ctrlLeftArrowKeyRoutine, escFailureRoutine};
+static CharacterDispatch escODispatch = {10, "ABCDHFabcd", escORoutines};
+
+// Initial ESC dispatch -- could be a Meta prefix or the start of an escape
+// sequence
+//
+static char32_t escLeftBracketRoutine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escLeftBracketDispatch);
+}
+static char32_t escORoutine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escODispatch);
+}
+static char32_t setMetaRoutine(char32_t c);  // need forward reference
+static CharacterDispatchRoutine escRoutines[] = {escLeftBracketRoutine,
+                                                 escORoutine, setMetaRoutine};
+static CharacterDispatch escDispatch = {2, "[O", escRoutines};
+
+// Initial dispatch -- we are not in the middle of anything yet
+//
+static char32_t escRoutine(char32_t c) {
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+  return doDispatch(c, escDispatch);
+}
+static CharacterDispatchRoutine initialRoutines[] = {
+    escRoutine, deleteCharRoutine, normalKeyRoutine};
+static CharacterDispatch initialDispatch = {2, "\x1B\x7F", initialRoutines};
+
+// Special handling for the ESC key because it does double duty
+//
+static char32_t setMetaRoutine(char32_t c) {
+  thisKeyMetaCtrl = META;
+  if (c == 0x1B) {  // another ESC, stay in ESC processing mode
+    c = readUnicodeCharacter();
+    if (c == 0) return 0;
+    return doDispatch(c, escDispatch);
+  }
+  return doDispatch(c, initialDispatch);
+}
+
+}  // namespace EscapeSequenceProcessing // move these out of global namespace
+
+#endif  // #ifndef _WIN32
+
+// linenoiseReadChar -- read a keystroke or keychord from the keyboard, and
+// translate it
+// into an encoded "keystroke".  When convenient, extended keys are translated
+// into their
+// simpler Emacs keystrokes, so an unmodified "left arrow" becomes Ctrl-B.
+//
+// A return value of zero means "no input available", and a return value of -1
+// means "invalid key".
+//
+static char32_t linenoiseReadChar(void) {
+#ifdef _WIN32
+
+  INPUT_RECORD rec;
+  DWORD count;
+  int modifierKeys = 0;
+  bool escSeen = false;
+  while (true) {
+    ReadConsoleInputW(console_in, &rec, 1, &count);
+#if 0  // helper for debugging keystrokes, display info in the debug "Output"
+       // window in the debugger
+        {
+            if ( rec.EventType == KEY_EVENT ) {
+                //if ( rec.Event.KeyEvent.uChar.UnicodeChar ) {
+                    char buf[1024];
+                    sprintf(
+                            buf,
+                            "Unicode character 0x%04X, repeat count %d, virtual keycode 0x%04X, "
+                            "virtual scancode 0x%04X, key %s%s%s%s%s\n",
+                            rec.Event.KeyEvent.uChar.UnicodeChar,
+                            rec.Event.KeyEvent.wRepeatCount,
+                            rec.Event.KeyEvent.wVirtualKeyCode,
+                            rec.Event.KeyEvent.wVirtualScanCode,
+                            rec.Event.KeyEvent.bKeyDown ? "down" : "up",
+                                (rec.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED)  ?
+                                    " L-Ctrl" : "",
+                                (rec.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED) ?
+                                    " R-Ctrl" : "",
+                                (rec.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED)   ?
+                                    " L-Alt"  : "",
+                                (rec.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)  ?
+                                    " R-Alt"  : ""
+                           );
+                    OutputDebugStringA( buf );
+                //}
+            }
+        }
+#endif
+    if (rec.EventType != KEY_EVENT) {
+      continue;
+    }
+    // Windows provides for entry of characters that are not on your keyboard by
+    // sending the
+    // Unicode characters as a "key up" with virtual keycode 0x12 (VK_MENU ==
+    // Alt key) ...
+    // accept these characters, otherwise only process characters on "key down"
+    if (!rec.Event.KeyEvent.bKeyDown &&
+        rec.Event.KeyEvent.wVirtualKeyCode != VK_MENU) {
+      continue;
+    }
+    modifierKeys = 0;
+    // AltGr is encoded as ( LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED ), so don't
+    // treat this
+    // combination as either CTRL or META we just turn off those two bits, so it
+    // is still
+    // possible to combine CTRL and/or META with an AltGr key by using
+    // right-Ctrl and/or
+    // left-Alt
+    if ((rec.Event.KeyEvent.dwControlKeyState &
+         (LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED)) ==
+        (LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED)) {
+      rec.Event.KeyEvent.dwControlKeyState &=
+          ~(LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED);
+    }
+    if (rec.Event.KeyEvent.dwControlKeyState &
+        (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
+      modifierKeys |= CTRL;
+    }
+    if (rec.Event.KeyEvent.dwControlKeyState &
+        (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)) {
+      modifierKeys |= META;
+    }
+    if (escSeen) {
+      modifierKeys |= META;
+    }
+    if (rec.Event.KeyEvent.uChar.UnicodeChar == 0) {
+      switch (rec.Event.KeyEvent.wVirtualKeyCode) {
+        case VK_LEFT:
+          return modifierKeys | LEFT_ARROW_KEY;
+        case VK_RIGHT:
+          return modifierKeys | RIGHT_ARROW_KEY;
+        case VK_UP:
+          return modifierKeys | UP_ARROW_KEY;
+        case VK_DOWN:
+          return modifierKeys | DOWN_ARROW_KEY;
+        case VK_DELETE:
+          return modifierKeys | DELETE_KEY;
+        case VK_HOME:
+          return modifierKeys | HOME_KEY;
+        case VK_END:
+          return modifierKeys | END_KEY;
+        case VK_PRIOR:
+          return modifierKeys | PAGE_UP_KEY;
+        case VK_NEXT:
+          return modifierKeys | PAGE_DOWN_KEY;
+        default:
+          continue;  // in raw mode, ReadConsoleInput shows shift, ctrl ...
+      }              //  ... ignore them
+    } else if (rec.Event.KeyEvent.uChar.UnicodeChar ==
+               ctrlChar('[')) {  // ESC, set flag for later
+      escSeen = true;
+      continue;
+    } else {
+      // we got a real character, return it
+      return modifierKeys | rec.Event.KeyEvent.uChar.UnicodeChar;
+    }
+  }
+
+#else
+  char32_t c;
+  c = readUnicodeCharacter();
+  if (c == 0) return 0;
+
+// If _DEBUG_LINUX_KEYBOARD is set, then ctrl-^ puts us into a keyboard
+// debugging mode
+// where we print out decimal and decoded values for whatever the "terminal"
+// program
+// gives us on different keystrokes.  Hit ctrl-C to exit this mode.
+//
+#define _DEBUG_LINUX_KEYBOARD
+#if defined(_DEBUG_LINUX_KEYBOARD)
+  if (c == ctrlChar('^')) {  // ctrl-^, special debug mode, prints all keys hit,
+                             // ctrl-C to get out
+    printf(
+        "\nEntering keyboard debugging mode (on ctrl-^), press ctrl-C to exit "
+        "this mode\n");
+    while (true) {
+      unsigned char keys[10];
+      int ret = read(0, keys, 10);
+
+      if (ret <= 0) {
+        printf("\nret: %d\n", ret);
+      }
+      for (int i = 0; i < ret; ++i) {
+        char32_t key = static_cast<char32_t>(keys[i]);
+        char* friendlyTextPtr;
+        char friendlyTextBuf[10];
+        const char* prefixText = (key < 0x80) ? "" : "0x80+";
+        char32_t keyCopy = (key < 0x80) ? key : key - 0x80;
+        if (keyCopy >= '!' && keyCopy <= '~') {  // printable
+          friendlyTextBuf[0] = '\'';
+          friendlyTextBuf[1] = keyCopy;
+          friendlyTextBuf[2] = '\'';
+          friendlyTextBuf[3] = 0;
+          friendlyTextPtr = friendlyTextBuf;
+        } else if (keyCopy == ' ') {
+          friendlyTextPtr = const_cast<char*>("space");
+        } else if (keyCopy == 27) {
+          friendlyTextPtr = const_cast<char*>("ESC");
+        } else if (keyCopy == 0) {
+          friendlyTextPtr = const_cast<char*>("NUL");
+        } else if (keyCopy == 127) {
+          friendlyTextPtr = const_cast<char*>("DEL");
+        } else {
+          friendlyTextBuf[0] = '^';
+          friendlyTextBuf[1] = keyCopy + 0x40;
+          friendlyTextBuf[2] = 0;
+          friendlyTextPtr = friendlyTextBuf;
+        }
+        printf("%d x%02X (%s%s)  ", key, key, prefixText, friendlyTextPtr);
+      }
+      printf("\x1b[1G\n");  // go to first column of new line
+
+      // drop out of this loop on ctrl-C
+      if (keys[0] == ctrlChar('C')) {
+        printf("Leaving keyboard debugging mode (on ctrl-C)\n");
+        fflush(stdout);
+        return -2;
+      }
+    }
+  }
+#endif  // _DEBUG_LINUX_KEYBOARD
+
+  EscapeSequenceProcessing::thisKeyMetaCtrl =
+      0;  // no modifiers yet at initialDispatch
+  return EscapeSequenceProcessing::doDispatch(
+      c, EscapeSequenceProcessing::initialDispatch);
+#endif  // #_WIN32
+}
+
+/**
+ * Free memory used in a recent command completion session
+ *
+ * @param lc pointer to a linenoiseCompletions struct
+ */
+static void freeCompletions(linenoiseCompletions* lc) {
+  lc->completionStrings.clear();
+}
+
+/**
+ * convert {CTRL + 'A'}, {CTRL + 'a'} and {CTRL + ctrlChar( 'A' )} into
+ * ctrlChar( 'A' )
+ * leave META alone
+ *
+ * @param c character to clean up
+ * @return cleaned-up character
+ */
+static int cleanupCtrl(int c) {
+  if (c & CTRL) {
+    int d = c & 0x1FF;
+    if (d >= 'a' && d <= 'z') {
+      c = (c + ('a' - ctrlChar('A'))) & ~CTRL;
+    }
+    if (d >= 'A' && d <= 'Z') {
+      c = (c + ('A' - ctrlChar('A'))) & ~CTRL;
+    }
+    if (d >= ctrlChar('A') && d <= ctrlChar('Z')) {
+      c = c & ~CTRL;
+    }
+  }
+  return c;
+}
+
+// break characters that may precede items to be completed
+static const char breakChars[] = " =+-/\\*?\"'`&<>;|@{([])}";
+
+// maximum number of completions to display without asking
+static const size_t completionCountCutoff = 100;
+
+/**
+ * Handle command completion, using a completionCallback() routine to provide
+ * possible substitutions
+ * This routine handles the mechanics of updating the user's input buffer with
+ * possible replacement
+ * of text as the user selects a proposed completion string, or cancels the
+ * completion attempt.
+ * @param pi     PromptBase struct holding information about the prompt and our
+ * screen position
+ */
+int InputBuffer::completeLine(PromptBase& pi) {
+  linenoiseCompletions lc;
+  char32_t c = 0;
+
+  // completionCallback() expects a parsable entity, so find the previous break
+  // character and
+  // extract a copy to parse.  we also handle the case where tab is hit while
+  // not at end-of-line.
+  int startIndex = pos;
+  while (--startIndex >= 0) {
+    if (strchr(breakChars, buf32[startIndex])) {
+      break;
+    }
+  }
+  ++startIndex;
+  int itemLength = pos - startIndex;
+  Utf32String unicodeCopy(&buf32[startIndex], itemLength);
+  Utf8String parseItem(unicodeCopy);
+
+  // get a list of completions
+  completionCallback(parseItem.get(), &lc);
+
+  // if no completions, we are done
+  if (lc.completionStrings.size() == 0) {
+    beep();
+    freeCompletions(&lc);
+    return 0;
+  }
+
+  // at least one completion
+  int longestCommonPrefix = 0;
+  int displayLength = 0;
+  if (lc.completionStrings.size() == 1) {
+    longestCommonPrefix = static_cast<int>(lc.completionStrings[0].length());
+  } else {
+    bool keepGoing = true;
+    while (keepGoing) {
+      for (size_t j = 0; j < lc.completionStrings.size() - 1; ++j) {
+        char32_t c1 = lc.completionStrings[j][longestCommonPrefix];
+        char32_t c2 = lc.completionStrings[j + 1][longestCommonPrefix];
+        if ((0 == c1) || (0 == c2) || (c1 != c2)) {
+          keepGoing = false;
+          break;
+        }
+      }
+      if (keepGoing) {
+        ++longestCommonPrefix;
+      }
+    }
+  }
+  if (lc.completionStrings.size() != 1) {  // beep if ambiguous
+    beep();
+  }
+
+  // if we can extend the item, extend it and return to main loop
+  if (longestCommonPrefix > itemLength) {
+    displayLength = len + longestCommonPrefix - itemLength;
+    if (displayLength > buflen) {
+      longestCommonPrefix -= displayLength - buflen;  // don't overflow buffer
+      displayLength = buflen;                         // truncate the insertion
+      beep();                                         // and make a noise
+    }
+    Utf32String displayText(displayLength + 1);
+    memcpy(displayText.get(), buf32, sizeof(char32_t) * startIndex);
+    memcpy(&displayText[startIndex], &lc.completionStrings[0][0],
+           sizeof(char32_t) * longestCommonPrefix);
+    int tailIndex = startIndex + longestCommonPrefix;
+    memcpy(&displayText[tailIndex], &buf32[pos],
+           sizeof(char32_t) * (displayLength - tailIndex + 1));
+    copyString32(buf32, displayText.get(), displayLength);
+    pos = startIndex + longestCommonPrefix;
+    len = displayLength;
+    refreshLine(pi);
+    return 0;
+  }
+
+  // we can't complete any further, wait for second tab
+  do {
+    c = linenoiseReadChar();
+    c = cleanupCtrl(c);
+  } while (c == static_cast<char32_t>(-1));
+
+  // if any character other than tab, pass it to the main loop
+  if (c != ctrlChar('I')) {
+    freeCompletions(&lc);
+    return c;
+  }
+
+  // we got a second tab, maybe show list of possible completions
+  bool showCompletions = true;
+  bool onNewLine = false;
+  if (lc.completionStrings.size() > completionCountCutoff) {
+    int savePos =
+        pos;  // move cursor to EOL to avoid overwriting the command line
+    pos = len;
+    refreshLine(pi);
+    pos = savePos;
+    printf("\nDisplay all %u possibilities? (y or n)",
+           static_cast<unsigned int>(lc.completionStrings.size()));
+    fflush(stdout);
+    onNewLine = true;
+    while (c != 'y' && c != 'Y' && c != 'n' && c != 'N' && c != ctrlChar('C')) {
+      do {
+        c = linenoiseReadChar();
+        c = cleanupCtrl(c);
+      } while (c == static_cast<char32_t>(-1));
+    }
+    switch (c) {
+      case 'n':
+      case 'N':
+        showCompletions = false;
+        freeCompletions(&lc);
+        break;
+      case ctrlChar('C'):
+        showCompletions = false;
+        freeCompletions(&lc);
+        if (write(1, "^C", 2) == -1) return -1;  // Display the ^C we got
+        c = 0;
+        break;
+    }
+  }
+
+  // if showing the list, do it the way readline does it
+  bool stopList = false;
+  if (showCompletions) {
+    int longestCompletion = 0;
+    for (size_t j = 0; j < lc.completionStrings.size(); ++j) {
+      itemLength = static_cast<int>(lc.completionStrings[j].length());
+      if (itemLength > longestCompletion) {
+        longestCompletion = itemLength;
+      }
+    }
+    longestCompletion += 2;
+    int columnCount = pi.promptScreenColumns / longestCompletion;
+    if (columnCount < 1) {
+      columnCount = 1;
+    }
+    if (!onNewLine) {  // skip this if we showed "Display all %d possibilities?"
+      int savePos =
+          pos;  // move cursor to EOL to avoid overwriting the command line
+      pos = len;
+      refreshLine(pi);
+      pos = savePos;
+    }
+    size_t pauseRow = getScreenRows() - 1;
+    size_t rowCount =
+        (lc.completionStrings.size() + columnCount - 1) / columnCount;
+    for (size_t row = 0; row < rowCount; ++row) {
+      if (row == pauseRow) {
+        printf("\n--More--");
+        fflush(stdout);
+        c = 0;
+        bool doBeep = false;
+        while (c != ' ' && c != '\r' && c != '\n' && c != 'y' && c != 'Y' &&
+               c != 'n' && c != 'N' && c != 'q' && c != 'Q' &&
+               c != ctrlChar('C')) {
+          if (doBeep) {
+            beep();
+          }
+          doBeep = true;
+          do {
+            c = linenoiseReadChar();
+            c = cleanupCtrl(c);
+          } while (c == static_cast<char32_t>(-1));
+        }
+        switch (c) {
+          case ' ':
+          case 'y':
+          case 'Y':
+            printf("\r        \r");
+            pauseRow += getScreenRows() - 1;
+            break;
+          case '\r':
+          case '\n':
+            printf("\r        \r");
+            ++pauseRow;
+            break;
+          case 'n':
+          case 'N':
+          case 'q':
+          case 'Q':
+            printf("\r        \r");
+            stopList = true;
+            break;
+          case ctrlChar('C'):
+            if (write(1, "^C", 2) == -1) return -1;  // Display the ^C we got
+            stopList = true;
+            break;
+        }
+      } else {
+        printf("\n");
+      }
+      if (stopList) {
+        break;
+      }
+      for (int column = 0; column < columnCount; ++column) {
+        size_t index = (column * rowCount) + row;
+        if (index < lc.completionStrings.size()) {
+          itemLength = static_cast<int>(lc.completionStrings[index].length());
+          fflush(stdout);
+          if (write32(1, lc.completionStrings[index].get(), itemLength) == -1)
+            return -1;
+          if (((column + 1) * rowCount) + row < lc.completionStrings.size()) {
+            for (int k = itemLength; k < longestCompletion; ++k) {
+              printf(" ");
+            }
+          }
+        }
+      }
+    }
+    fflush(stdout);
+    freeCompletions(&lc);
+  }
+
+  // display the prompt on a new line, then redisplay the input buffer
+  if (!stopList || c == ctrlChar('C')) {
+    if (write(1, "\n", 1) == -1) return 0;
+  }
+  if (!pi.write()) return 0;
+#ifndef _WIN32
+  // we have to generate our own newline on line wrap on Linux
+  if (pi.promptIndentation == 0 && pi.promptExtraLines > 0)
+    if (write(1, "\n", 1) == -1) return 0;
+#endif
+  pi.promptCursorRowOffset = pi.promptExtraLines;
+  refreshLine(pi);
+  return 0;
+}
+
+/**
+ * Clear the screen ONLY (no redisplay of anything)
+ */
+void linenoiseClearScreen(void) {
+#ifdef _WIN32
+  COORD coord = {0, 0};
+  CONSOLE_SCREEN_BUFFER_INFO inf;
+  HANDLE screenHandle = GetStdHandle(STD_OUTPUT_HANDLE);
+  GetConsoleScreenBufferInfo(screenHandle, &inf);
+  SetConsoleCursorPosition(screenHandle, coord);
+  DWORD count;
+  FillConsoleOutputCharacterA(screenHandle, ' ', inf.dwSize.X * inf.dwSize.Y,
+                              coord, &count);
+#else
+  if (write(1, "\x1b[H\x1b[2J", 7) <= 0) return;
+#endif
+}
+
+void InputBuffer::clearScreen(PromptBase& pi) {
+  linenoiseClearScreen();
+  if (!pi.write()) return;
+#ifndef _WIN32
+  // we have to generate our own newline on line wrap on Linux
+  if (pi.promptIndentation == 0 && pi.promptExtraLines > 0)
+    if (write(1, "\n", 1) == -1) return;
+#endif
+  pi.promptCursorRowOffset = pi.promptExtraLines;
+  refreshLine(pi);
+}
+
+/**
+ * Incremental history search -- take over the prompt and keyboard as the user
+ * types a search
+ * string, deletes characters from it, changes direction, and either accepts the
+ * found line (for
+ * execution orediting) or cancels.
+ * @param pi        PromptBase struct holding information about the (old,
+ * static) prompt and our
+ *                  screen position
+ * @param startChar the character that began the search, used to set the initial
+ * direction
+ */
+int InputBuffer::incrementalHistorySearch(PromptBase& pi, int startChar) {
+  size_t bufferSize;
+  size_t ucharCount = 0;
+
+  // if not already recalling, add the current line to the history list so we
+  // don't have to
+  // special case it
+  if (historyIndex == historyLen - 1) {
+    free(history[historyLen - 1]);
+    bufferSize = sizeof(char32_t) * len + 1;
+    unique_ptr<char[]> tempBuffer(new char[bufferSize]);
+    copyString32to8(tempBuffer.get(), bufferSize, buf32);
+    history[historyLen - 1] = strdup8(tempBuffer.get());
+  }
+  int historyLineLength = len;
+  int historyLinePosition = pos;
+  char32_t emptyBuffer[1];
+  char emptyWidths[1];
+  InputBuffer empty(emptyBuffer, emptyWidths, 1);
+  empty.refreshLine(pi);  // erase the old input first
+  DynamicPrompt dp(pi, (startChar == ctrlChar('R')) ? -1 : 1);
+
+  dp.promptPreviousLen = pi.promptPreviousLen;
+  dp.promptPreviousInputLen = pi.promptPreviousInputLen;
+  dynamicRefresh(dp, buf32, historyLineLength,
+                 historyLinePosition);  // draw user's text with our prompt
+
+  // loop until we get an exit character
+  int c = 0;
+  bool keepLooping = true;
+  bool useSearchedLine = true;
+  bool searchAgain = false;
+  char32_t* activeHistoryLine = 0;
+  while (keepLooping) {
+    c = linenoiseReadChar();
+    c = cleanupCtrl(c);  // convert CTRL + <char> into normal ctrl
+
+    switch (c) {
+      // these characters keep the selected text but do not execute it
+      case ctrlChar('A'):  // ctrl-A, move cursor to start of line
+      case HOME_KEY:
+      case ctrlChar('B'):  // ctrl-B, move cursor left by one character
+      case LEFT_ARROW_KEY:
+      case META + 'b':  // meta-B, move cursor left by one word
+      case META + 'B':
+      case CTRL + LEFT_ARROW_KEY:
+      case META + LEFT_ARROW_KEY:  // Emacs allows Meta, bash & readline don't
+      case ctrlChar('D'):
+      case META + 'd':  // meta-D, kill word to right of cursor
+      case META + 'D':
+      case ctrlChar('E'):  // ctrl-E, move cursor to end of line
+      case END_KEY:
+      case ctrlChar('F'):  // ctrl-F, move cursor right by one character
+      case RIGHT_ARROW_KEY:
+      case META + 'f':  // meta-F, move cursor right by one word
+      case META + 'F':
+      case CTRL + RIGHT_ARROW_KEY:
+      case META + RIGHT_ARROW_KEY:  // Emacs allows Meta, bash & readline don't
+      case META + ctrlChar('H'):
+      case ctrlChar('J'):
+      case ctrlChar('K'):  // ctrl-K, kill from cursor to end of line
+      case ctrlChar('M'):
+      case ctrlChar('N'):  // ctrl-N, recall next line in history
+      case ctrlChar('P'):  // ctrl-P, recall previous line in history
+      case DOWN_ARROW_KEY:
+      case UP_ARROW_KEY:
+      case ctrlChar('T'):  // ctrl-T, transpose characters
+      case ctrlChar(
+          'U'):  // ctrl-U, kill all characters to the left of the cursor
+      case ctrlChar('W'):
+      case META + 'y':  // meta-Y, "yank-pop", rotate popped text
+      case META + 'Y':
+      case 127:
+      case DELETE_KEY:
+      case META + '<':  // start of history
+      case PAGE_UP_KEY:
+      case META + '>':  // end of history
+      case PAGE_DOWN_KEY:
+        keepLooping = false;
+        break;
+
+      // these characters revert the input line to its previous state
+      case ctrlChar('C'):  // ctrl-C, abort this line
+      case ctrlChar('G'):
+      case ctrlChar('L'):  // ctrl-L, clear screen and redisplay line
+        keepLooping = false;
+        useSearchedLine = false;
+        if (c != ctrlChar('L')) {
+          c = -1;  // ctrl-C and ctrl-G just abort the search and do nothing
+                   // else
+        }
+        break;
+
+      // these characters stay in search mode and update the display
+      case ctrlChar('S'):
+      case ctrlChar('R'):
+        if (dp.searchTextLen ==
+            0) {  // if no current search text, recall previous text
+          if (previousSearchText.length()) {
+            dp.updateSearchText(previousSearchText.get());
+          }
+        }
+        if ((dp.direction == 1 && c == ctrlChar('R')) ||
+            (dp.direction == -1 && c == ctrlChar('S'))) {
+          dp.direction = 0 - dp.direction;  // reverse direction
+          dp.updateSearchPrompt();          // change the prompt
+        } else {
+          searchAgain = true;  // same direction, search again
+        }
+        break;
+
+// job control is its own thing
+#ifndef _WIN32
+      case ctrlChar('Z'):  // ctrl-Z, job control
+        disableRawMode();  // Returning to Linux (whatever) shell, leave raw
+                           // mode
+        raise(SIGSTOP);    // Break out in mid-line
+        enableRawMode();   // Back from Linux shell, re-enter raw mode
+        {
+          bufferSize = historyLineLength + 1;
+          unique_ptr<char32_t[]> tempUnicode(new char32_t[bufferSize]);
+          copyString8to32(tempUnicode.get(), bufferSize, ucharCount,
+                          history[historyIndex]);
+          dynamicRefresh(dp, tempUnicode.get(), historyLineLength,
+                         historyLinePosition);
+        }
+        continue;
+        break;
+#endif
+
+      // these characters update the search string, and hence the selected input
+      // line
+      case ctrlChar('H'):  // backspace/ctrl-H, delete char to left of cursor
+        if (dp.searchTextLen > 0) {
+          unique_ptr<char32_t[]> tempUnicode(new char32_t[dp.searchTextLen]);
+          --dp.searchTextLen;
+          dp.searchText[dp.searchTextLen] = 0;
+          copyString32(tempUnicode.get(), dp.searchText.get(),
+                       dp.searchTextLen);
+          dp.updateSearchText(tempUnicode.get());
+        } else {
+          beep();
+        }
+        break;
+
+      case ctrlChar('Y'):  // ctrl-Y, yank killed text
+        break;
+
+      default:
+        if (!isControlChar(c) && c <= 0x0010FFFF) {  // not an action character
+          unique_ptr<char32_t[]> tempUnicode(
+              new char32_t[dp.searchTextLen + 2]);
+          copyString32(tempUnicode.get(), dp.searchText.get(),
+                       dp.searchTextLen);
+          tempUnicode[dp.searchTextLen] = c;
+          tempUnicode[dp.searchTextLen + 1] = 0;
+          dp.updateSearchText(tempUnicode.get());
+        } else {
+          beep();
+        }
+    }  // switch
+
+    // if we are staying in search mode, search now
+    if (keepLooping) {
+      bufferSize = historyLineLength + 1;
+      if (activeHistoryLine) {
+        delete[] activeHistoryLine;
+        activeHistoryLine = nullptr;
+      }
+      activeHistoryLine = new char32_t[bufferSize];
+      copyString8to32(activeHistoryLine, bufferSize, ucharCount,
+                      history[historyIndex]);
+      if (dp.searchTextLen > 0) {
+        bool found = false;
+        int historySearchIndex = historyIndex;
+        int lineLength = static_cast<int>(ucharCount);
+        int lineSearchPos = historyLinePosition;
+        if (searchAgain) {
+          lineSearchPos += dp.direction;
+        }
+        searchAgain = false;
+        while (true) {
+          while ((dp.direction > 0) ? (lineSearchPos < lineLength)
+                                    : (lineSearchPos >= 0)) {
+            if (strncmp32(dp.searchText.get(),
+                          &activeHistoryLine[lineSearchPos],
+                          dp.searchTextLen) == 0) {
+              found = true;
+              break;
+            }
+            lineSearchPos += dp.direction;
+          }
+          if (found) {
+            historyIndex = historySearchIndex;
+            historyLineLength = lineLength;
+            historyLinePosition = lineSearchPos;
+            break;
+          } else if ((dp.direction > 0) ? (historySearchIndex < historyLen - 1)
+                                        : (historySearchIndex > 0)) {
+            historySearchIndex += dp.direction;
+            bufferSize = strlen8(history[historySearchIndex]) + 1;
+            delete[] activeHistoryLine;
+            activeHistoryLine = nullptr;
+            activeHistoryLine = new char32_t[bufferSize];
+            copyString8to32(activeHistoryLine, bufferSize, ucharCount,
+                            history[historySearchIndex]);
+            lineLength = static_cast<int>(ucharCount);
+            lineSearchPos =
+                (dp.direction > 0) ? 0 : (lineLength - dp.searchTextLen);
+          } else {
+            beep();
+            break;
+          }
+        };  // while
+      }
+      if (activeHistoryLine) {
+        delete[] activeHistoryLine;
+        activeHistoryLine = nullptr;
+      }
+      bufferSize = historyLineLength + 1;
+      activeHistoryLine = new char32_t[bufferSize];
+      copyString8to32(activeHistoryLine, bufferSize, ucharCount,
+                      history[historyIndex]);
+      dynamicRefresh(dp, activeHistoryLine, historyLineLength,
+                     historyLinePosition);  // draw user's text with our prompt
+    }
+  }  // while
+
+  // leaving history search, restore previous prompt, maybe make searched line
+  // current
+  PromptBase pb;
+  pb.promptChars = pi.promptIndentation;
+  pb.promptBytes = pi.promptBytes;
+  Utf32String tempUnicode(pb.promptBytes + 1);
+
+  copyString32(tempUnicode.get(), &pi.promptText[pi.promptLastLinePosition],
+               pb.promptBytes - pi.promptLastLinePosition);
+  tempUnicode.initFromBuffer();
+  pb.promptText = tempUnicode;
+  pb.promptExtraLines = 0;
+  pb.promptIndentation = pi.promptIndentation;
+  pb.promptLastLinePosition = 0;
+  pb.promptPreviousInputLen = historyLineLength;
+  pb.promptCursorRowOffset = dp.promptCursorRowOffset;
+  pb.promptScreenColumns = pi.promptScreenColumns;
+  pb.promptPreviousLen = dp.promptChars;
+  if (useSearchedLine && activeHistoryLine) {
+    historyRecallMostRecent = true;
+    copyString32(buf32, activeHistoryLine, buflen + 1);
+    len = historyLineLength;
+    pos = historyLinePosition;
+  }
+  if (activeHistoryLine) {
+    delete[] activeHistoryLine;
+    activeHistoryLine = nullptr;
+  }
+  dynamicRefresh(pb, buf32, len,
+                 pos);  // redraw the original prompt with current input
+  pi.promptPreviousInputLen = len;
+  pi.promptCursorRowOffset = pi.promptExtraLines + pb.promptCursorRowOffset;
+  previousSearchText =
+      dp.searchText;  // save search text for possible reuse on ctrl-R ctrl-R
+  return c;           // pass a character or -1 back to main loop
+}
+
+static bool isCharacterAlphanumeric(char32_t testChar) {
+#ifdef _WIN32
+  return (iswalnum((wint_t)testChar) != 0 ? true : false);
+#else
+  return (iswalnum(testChar) != 0 ? true : false);
+#endif
+}
+
+#ifndef _WIN32
+static bool gotResize = false;
+#endif
+static int keyType = 0;
+
+int InputBuffer::getInputLine(PromptBase& pi) {
+  keyType = 0;
+
+  // The latest history entry is always our current buffer
+  if (len > 0) {
+    size_t bufferSize = sizeof(char32_t) * len + 1;
+    unique_ptr<char[]> tempBuffer(new char[bufferSize]);
+    copyString32to8(tempBuffer.get(), bufferSize, buf32);
+    linenoiseHistoryAdd(tempBuffer.get());
+  } else {
+    linenoiseHistoryAdd("");
+  }
+  historyIndex = historyLen - 1;
+  historyRecallMostRecent = false;
+
+  // display the prompt
+  if (!pi.write()) return -1;
+
+#ifndef _WIN32
+  // we have to generate our own newline on line wrap on Linux
+  if (pi.promptIndentation == 0 && pi.promptExtraLines > 0)
+    if (write(1, "\n", 1) == -1) return -1;
+#endif
+
+  // the cursor starts out at the end of the prompt
+  pi.promptCursorRowOffset = pi.promptExtraLines;
+
+  // kill and yank start in "other" mode
+  killRing.lastAction = KillRing::actionOther;
+
+  // when history search returns control to us, we execute its terminating
+  // keystroke
+  int terminatingKeystroke = -1;
+
+  // if there is already text in the buffer, display it first
+  if (len > 0) {
+    refreshLine(pi);
+  }
+
+  // loop collecting characters, respond to line editing characters
+  while (true) {
+    int c;
+    if (terminatingKeystroke == -1) {
+      c = linenoiseReadChar();  // get a new keystroke
+
+      keyType = 0; 
+      if (c != 0) {
+        // set flag that we got some input
+        if (c == ctrlChar('C')) {
+          keyType = 1;
+        } else if (c == ctrlChar('D')) {
+          keyType = 2;
+        }
+      }
+
+#ifndef _WIN32
+      if (c == 0 && gotResize) {
+        // caught a window resize event
+        // now redraw the prompt and line
+        gotResize = false;
+        pi.promptScreenColumns = getScreenColumns();
+        dynamicRefresh(pi, buf32, len,
+                       pos);  // redraw the original prompt with current input
+        continue;
+      }
+#endif
+    } else {
+      c = terminatingKeystroke;   // use the terminating keystroke from search
+      terminatingKeystroke = -1;  // clear it once we've used it
+    }
+
+    c = cleanupCtrl(c);  // convert CTRL + <char> into normal ctrl
+
+    if (c == 0) {
+      return len;
+    }
+
+    if (c == -1) {
+      refreshLine(pi);
+      continue;
+    }
+
+    if (c == -2) {
+      if (!pi.write()) return -1;
+      refreshLine(pi);
+      continue;
+    }
+
+    // ctrl-I/tab, command completion, needs to be before switch statement
+    if (c == ctrlChar('I') && completionCallback) {
+      if (pos == 0)  // SERVER-4967 -- in earlier versions, you could paste
+                     // previous output
+        continue;    //  back into the shell ... this output may have leading
+                     //  tabs.
+      // This hack (i.e. what the old code did) prevents command completion
+      //  on an empty line but lets users paste text with leading tabs.
+
+      killRing.lastAction = KillRing::actionOther;
+      historyRecallMostRecent = false;
+
+      // completeLine does the actual completion and replacement
+      c = completeLine(pi);
+
+      if (c < 0)  // return on error
+        return len;
+
+      if (c == 0)  // read next character when 0
+        continue;
+
+      // deliberate fall-through here, so we use the terminating character
+    }
+
+    switch (c) {
+      case ctrlChar('A'):  // ctrl-A, move cursor to start of line
+      case HOME_KEY:
+        killRing.lastAction = KillRing::actionOther;
+        pos = 0;
+        refreshLine(pi);
+        break;
+
+      case ctrlChar('B'):  // ctrl-B, move cursor left by one character
+      case LEFT_ARROW_KEY:
+        killRing.lastAction = KillRing::actionOther;
+        if (pos > 0) {
+          --pos;
+          refreshLine(pi);
+        }
+        break;
+
+      case META + 'b':  // meta-B, move cursor left by one word
+      case META + 'B':
+      case CTRL + LEFT_ARROW_KEY:
+      case META + LEFT_ARROW_KEY:  // Emacs allows Meta, bash & readline don't
+        killRing.lastAction = KillRing::actionOther;
+        if (pos > 0) {
+          while (pos > 0 && !isCharacterAlphanumeric(buf32[pos - 1])) {
+            --pos;
+          }
+          while (pos > 0 && isCharacterAlphanumeric(buf32[pos - 1])) {
+            --pos;
+          }
+          refreshLine(pi);
+        }
+        break;
+
+      case ctrlChar('C'):  // ctrl-C, abort this line
+        killRing.lastAction = KillRing::actionOther;
+        historyRecallMostRecent = false;
+        errno = EAGAIN;
+        --historyLen;
+        free(history[historyLen]);
+        // we need one last refresh with the cursor at the end of the line
+        // so we don't display the next prompt over the previous input line
+        pos = len;  // pass len as pos for EOL
+        refreshLine(pi);
+        if (write(1, "^C", 2) == -1) return -1;  // Display the ^C we got
+        return -1;
+
+      case META + 'c':  // meta-C, give word initial Cap
+      case META + 'C':
+        killRing.lastAction = KillRing::actionOther;
+        historyRecallMostRecent = false;
+        if (pos < len) {
+          while (pos < len && !isCharacterAlphanumeric(buf32[pos])) {
+            ++pos;
+          }
+          if (pos < len && isCharacterAlphanumeric(buf32[pos])) {
+            if (buf32[pos] >= 'a' && buf32[pos] <= 'z') {
+              buf32[pos] += 'A' - 'a';
+            }
+            ++pos;
+          }
+          while (pos < len && isCharacterAlphanumeric(buf32[pos])) {
+            if (buf32[pos] >= 'A' && buf32[pos] <= 'Z') {
+              buf32[pos] += 'a' - 'A';
+            }
+            ++pos;
+          }
+          refreshLine(pi);
+        }
+        break;
+
+      // ctrl-D, delete the character under the cursor
+      // on an empty line, exit the shell
+      case ctrlChar('D'):
+        killRing.lastAction = KillRing::actionOther;
+        if (len > 0 && pos < len) {
+          historyRecallMostRecent = false;
+          memmove(buf32 + pos, buf32 + pos + 1, sizeof(char32_t) * (len - pos));
+          --len;
+          refreshLine(pi);
+        } else if (len == 0) {
+          --historyLen;
+          free(history[historyLen]);
+          return -1;
+        }
+        break;
+
+      case META + 'd':  // meta-D, kill word to right of cursor
+      case META + 'D':
+        if (pos < len) {
+          historyRecallMostRecent = false;
+          int endingPos = pos;
+          while (endingPos < len &&
+                 !isCharacterAlphanumeric(buf32[endingPos])) {
+            ++endingPos;
+          }
+          while (endingPos < len && isCharacterAlphanumeric(buf32[endingPos])) {
+            ++endingPos;
+          }
+          killRing.kill(&buf32[pos], endingPos - pos, true);
+          memmove(buf32 + pos, buf32 + endingPos,
+                  sizeof(char32_t) * (len - endingPos + 1));
+          len -= endingPos - pos;
+          refreshLine(pi);
+        }
+        killRing.lastAction = KillRing::actionKill;
+        break;
+
+      case ctrlChar('E'):  // ctrl-E, move cursor to end of line
+      case END_KEY:
+        killRing.lastAction = KillRing::actionOther;
+        pos = len;
+        refreshLine(pi);
+        break;
+
+      case ctrlChar('F'):  // ctrl-F, move cursor right by one character
+      case RIGHT_ARROW_KEY:
+        killRing.lastAction = KillRing::actionOther;
+        if (pos < len) {
+          ++pos;
+          refreshLine(pi);
+        }
+        break;
+
+      case META + 'f':  // meta-F, move cursor right by one word
+      case META + 'F':
+      case CTRL + RIGHT_ARROW_KEY:
+      case META + RIGHT_ARROW_KEY:  // Emacs allows Meta, bash & readline don't
+        killRing.lastAction = KillRing::actionOther;
+        if (pos < len) {
+          while (pos < len && !isCharacterAlphanumeric(buf32[pos])) {
+            ++pos;
+          }
+          while (pos < len && isCharacterAlphanumeric(buf32[pos])) {
+            ++pos;
+          }
+          refreshLine(pi);
+        }
+        break;
+
+      case ctrlChar('H'):  // backspace/ctrl-H, delete char to left of cursor
+        killRing.lastAction = KillRing::actionOther;
+        if (pos > 0) {
+          historyRecallMostRecent = false;
+          memmove(buf32 + pos - 1, buf32 + pos,
+                  sizeof(char32_t) * (1 + len - pos));
+          --pos;
+          --len;
+          refreshLine(pi);
+        }
+        break;
+
+      // meta-Backspace, kill word to left of cursor
+      case META + ctrlChar('H'):
+        if (pos > 0) {
+          historyRecallMostRecent = false;
+          int startingPos = pos;
+          while (pos > 0 && !isCharacterAlphanumeric(buf32[pos - 1])) {
+            --pos;
+          }
+          while (pos > 0 && isCharacterAlphanumeric(buf32[pos - 1])) {
+            --pos;
+          }
+          killRing.kill(&buf32[pos], startingPos - pos, false);
+          memmove(buf32 + pos, buf32 + startingPos,
+                  sizeof(char32_t) * (len - startingPos + 1));
+          len -= startingPos - pos;
+          refreshLine(pi);
+        }
+        killRing.lastAction = KillRing::actionKill;
+        break;
+
+      case ctrlChar('J'):  // ctrl-J/linefeed/newline, accept line
+      case ctrlChar('M'):  // ctrl-M/return/enter
+        killRing.lastAction = KillRing::actionOther;
+        // we need one last refresh with the cursor at the end of the line
+        // so we don't display the next prompt over the previous input line
+        pos = len;  // pass len as pos for EOL
+        refreshLine(pi);
+        historyPreviousIndex = historyRecallMostRecent ? historyIndex : -2;
+        --historyLen;
+        free(history[historyLen]);
+        return len;
+
+      case ctrlChar('K'):  // ctrl-K, kill from cursor to end of line
+        killRing.kill(&buf32[pos], len - pos, true);
+        buf32[pos] = '\0';
+        len = pos;
+        refreshLine(pi);
+        killRing.lastAction = KillRing::actionKill;
+        historyRecallMostRecent = false;
+        break;
+
+      case ctrlChar('L'):  // ctrl-L, clear screen and redisplay line
+        clearScreen(pi);
+        break;
+
+      case META + 'l':  // meta-L, lowercase word
+      case META + 'L':
+        killRing.lastAction = KillRing::actionOther;
+        if (pos < len) {
+          historyRecallMostRecent = false;
+          while (pos < len && !isCharacterAlphanumeric(buf32[pos])) {
+            ++pos;
+          }
+          while (pos < len && isCharacterAlphanumeric(buf32[pos])) {
+            if (buf32[pos] >= 'A' && buf32[pos] <= 'Z') {
+              buf32[pos] += 'a' - 'A';
+            }
+            ++pos;
+          }
+          refreshLine(pi);
+        }
+        break;
+
+      case ctrlChar('N'):  // ctrl-N, recall next line in history
+      case ctrlChar('P'):  // ctrl-P, recall previous line in history
+      case DOWN_ARROW_KEY:
+      case UP_ARROW_KEY:
+        killRing.lastAction = KillRing::actionOther;
+        // if not already recalling, add the current line to the history list so
+        // we don't
+        // have to special case it
+        if (historyIndex == historyLen - 1) {
+          free(history[historyLen - 1]);
+          size_t tempBufferSize = sizeof(char32_t) * len + 1;
+          unique_ptr<char[]> tempBuffer(new char[tempBufferSize]);
+          copyString32to8(tempBuffer.get(), tempBufferSize, buf32);
+          history[historyLen - 1] = strdup8(tempBuffer.get());
+        }
+        if (historyLen > 1) {
+          if (c == UP_ARROW_KEY) {
+            c = ctrlChar('P');
+          }
+          if (historyPreviousIndex != -2 && c != ctrlChar('P')) {
+            historyIndex =
+                1 + historyPreviousIndex;  // emulate Windows down-arrow
+          } else {
+            historyIndex += (c == ctrlChar('P')) ? -1 : 1;
+          }
+          historyPreviousIndex = -2;
+          if (historyIndex < 0) {
+            historyIndex = 0;
+            break;
+          } else if (historyIndex >= historyLen) {
+            historyIndex = historyLen - 1;
+            break;
+          }
+          historyRecallMostRecent = true;
+          size_t ucharCount = 0;
+          copyString8to32(buf32, buflen, ucharCount, history[historyIndex]);
+          len = pos = static_cast<int>(ucharCount);
+          refreshLine(pi);
+        }
+        break;
+
+      case ctrlChar('R'):  // ctrl-R, reverse history search
+      case ctrlChar('S'):  // ctrl-S, forward history search
+        terminatingKeystroke = incrementalHistorySearch(pi, c);
+        break;
+
+      case ctrlChar('T'):  // ctrl-T, transpose characters
+        killRing.lastAction = KillRing::actionOther;
+        if (pos > 0 && len > 1) {
+          historyRecallMostRecent = false;
+          size_t leftCharPos = (pos == len) ? pos - 2 : pos - 1;
+          char32_t aux = buf32[leftCharPos];
+          buf32[leftCharPos] = buf32[leftCharPos + 1];
+          buf32[leftCharPos + 1] = aux;
+          if (pos != len) ++pos;
+          refreshLine(pi);
+        }
+        break;
+
+      case ctrlChar(
+          'U'):  // ctrl-U, kill all characters to the left of the cursor
+        if (pos > 0) {
+          historyRecallMostRecent = false;
+          killRing.kill(&buf32[0], pos, false);
+          len -= pos;
+          memmove(buf32, buf32 + pos, sizeof(char32_t) * (len + 1));
+          pos = 0;
+          refreshLine(pi);
+        }
+        killRing.lastAction = KillRing::actionKill;
+        break;
+
+      case META + 'u':  // meta-U, uppercase word
+      case META + 'U':
+        killRing.lastAction = KillRing::actionOther;
+        if (pos < len) {
+          historyRecallMostRecent = false;
+          while (pos < len && !isCharacterAlphanumeric(buf32[pos])) {
+            ++pos;
+          }
+          while (pos < len && isCharacterAlphanumeric(buf32[pos])) {
+            if (buf32[pos] >= 'a' && buf32[pos] <= 'z') {
+              buf32[pos] += 'A' - 'a';
+            }
+            ++pos;
+          }
+          refreshLine(pi);
+        }
+        break;
+
+      // ctrl-W, kill to whitespace (not word) to left of cursor
+      case ctrlChar('W'):
+        if (pos > 0) {
+          historyRecallMostRecent = false;
+          int startingPos = pos;
+          while (pos > 0 && buf32[pos - 1] == ' ') {
+            --pos;
+          }
+          while (pos > 0 && buf32[pos - 1] != ' ') {
+            --pos;
+          }
+          killRing.kill(&buf32[pos], startingPos - pos, false);
+          memmove(buf32 + pos, buf32 + startingPos,
+                  sizeof(char32_t) * (len - startingPos + 1));
+          len -= startingPos - pos;
+          refreshLine(pi);
+        }
+        killRing.lastAction = KillRing::actionKill;
+        break;
+
+      case ctrlChar('Y'):  // ctrl-Y, yank killed text
+        historyRecallMostRecent = false;
+        {
+          Utf32String* restoredText = killRing.yank();
+          if (restoredText) {
+            bool truncated = false;
+            size_t ucharCount = restoredText->length();
+            if (ucharCount > static_cast<size_t>(buflen - len)) {
+              ucharCount = buflen - len;
+              truncated = true;
+            }
+            memmove(buf32 + pos + ucharCount, buf32 + pos,
+                    sizeof(char32_t) * (len - pos + 1));
+            memmove(buf32 + pos, restoredText->get(),
+                    sizeof(char32_t) * ucharCount);
+            pos += static_cast<int>(ucharCount);
+            len += static_cast<int>(ucharCount);
+            refreshLine(pi);
+            killRing.lastAction = KillRing::actionYank;
+            killRing.lastYankSize = ucharCount;
+            if (truncated) {
+              beep();
+            }
+          } else {
+            beep();
+          }
+        }
+        break;
+
+      case META + 'y':  // meta-Y, "yank-pop", rotate popped text
+      case META + 'Y':
+        if (killRing.lastAction == KillRing::actionYank) {
+          historyRecallMostRecent = false;
+          Utf32String* restoredText = killRing.yankPop();
+          if (restoredText) {
+            bool truncated = false;
+            size_t ucharCount = restoredText->length();
+            if (ucharCount >
+                static_cast<size_t>(killRing.lastYankSize + buflen - len)) {
+              ucharCount = killRing.lastYankSize + buflen - len;
+              truncated = true;
+            }
+            if (ucharCount > killRing.lastYankSize) {
+              memmove(buf32 + pos + ucharCount - killRing.lastYankSize,
+                      buf32 + pos, sizeof(char32_t) * (len - pos + 1));
+              memmove(buf32 + pos - killRing.lastYankSize, restoredText->get(),
+                      sizeof(char32_t) * ucharCount);
+            } else {
+              memmove(buf32 + pos - killRing.lastYankSize, restoredText->get(),
+                      sizeof(char32_t) * ucharCount);
+              memmove(buf32 + pos + ucharCount - killRing.lastYankSize,
+                      buf32 + pos, sizeof(char32_t) * (len - pos + 1));
+            }
+            pos += static_cast<int>(ucharCount - killRing.lastYankSize);
+            len += static_cast<int>(ucharCount - killRing.lastYankSize);
+            killRing.lastYankSize = ucharCount;
+            refreshLine(pi);
+            if (truncated) {
+              beep();
+            }
+            break;
+          }
+        }
+        beep();
+        break;
+
+#ifndef _WIN32
+      case ctrlChar('Z'):  // ctrl-Z, job control
+        disableRawMode();  // Returning to Linux (whatever) shell, leave raw
+                           // mode
+        raise(SIGSTOP);    // Break out in mid-line
+        enableRawMode();   // Back from Linux shell, re-enter raw mode
+        if (!pi.write()) break;  // Redraw prompt
+        refreshLine(pi);         // Refresh the line
+        break;
+#endif
+
+      // DEL, delete the character under the cursor
+      case 127:
+      case DELETE_KEY:
+        killRing.lastAction = KillRing::actionOther;
+        if (len > 0 && pos < len) {
+          historyRecallMostRecent = false;
+          memmove(buf32 + pos, buf32 + pos + 1, sizeof(char32_t) * (len - pos));
+          --len;
+          refreshLine(pi);
+        }
+        break;
+
+      case META + '<':     // meta-<, beginning of history
+      case PAGE_UP_KEY:    // Page Up, beginning of history
+      case META + '>':     // meta->, end of history
+      case PAGE_DOWN_KEY:  // Page Down, end of history
+        killRing.lastAction = KillRing::actionOther;
+        // if not already recalling, add the current line to the history list so
+        // we don't
+        // have to special case it
+        if (historyIndex == historyLen - 1) {
+          free(history[historyLen - 1]);
+          size_t tempBufferSize = sizeof(char32_t) * len + 1;
+          unique_ptr<char[]> tempBuffer(new char[tempBufferSize]);
+          copyString32to8(tempBuffer.get(), tempBufferSize, buf32);
+          history[historyLen - 1] = strdup8(tempBuffer.get());
+        }
+        if (historyLen > 1) {
+          historyIndex =
+              (c == META + '<' || c == PAGE_UP_KEY) ? 0 : historyLen - 1;
+          historyPreviousIndex = -2;
+          historyRecallMostRecent = true;
+          size_t ucharCount = 0;
+          copyString8to32(buf32, buflen, ucharCount, history[historyIndex]);
+          len = pos = static_cast<int>(ucharCount);
+          refreshLine(pi);
+        }
+        break;
+
+      // not one of our special characters, maybe insert it in the buffer
+      default:
+        killRing.lastAction = KillRing::actionOther;
+        historyRecallMostRecent = false;
+        if (c & (META | CTRL)) {  // beep on unknown Ctrl and/or Meta keys
+          beep();
+          break;
+        }
+        if (len < buflen) {
+          if (isControlChar(c)) {  // don't insert control characters
+            beep();
+            break;
+          }
+          if (len == pos) {  // at end of buffer
+            buf32[pos] = c;
+            ++pos;
+            ++len;
+            buf32[len] = '\0';
+            int inputLen = calculateColumnPosition(buf32, len);
+            if (pi.promptIndentation + inputLen < pi.promptScreenColumns) {
+              if (inputLen > pi.promptPreviousInputLen)
+                pi.promptPreviousInputLen = inputLen;
+              /* Avoid a full update of the line in the
+               * trivial case. */
+              if (write32(1, reinterpret_cast<char32_t*>(&c), 1) == -1)
+                return -1;
+            } else {
+              refreshLine(pi);
+            }
+          } else {  // not at end of buffer, have to move characters to our
+                    // right
+            memmove(buf32 + pos + 1, buf32 + pos,
+                    sizeof(char32_t) * (len - pos));
+            buf32[pos] = c;
+            ++len;
+            ++pos;
+            buf32[len] = '\0';
+            refreshLine(pi);
+          }
+        } else {
+          beep();  // buffer is full, beep on new characters
+        }
+        break;
+    }
+  }
+  return len;
+}
+
+static string preloadedBufferContents;  // used with linenoisePreloadBuffer
+static string preloadErrorMessage;
+
+/**
+ * linenoisePreloadBuffer provides text to be inserted into the command buffer
+ *
+ * the provided text will be processed to be usable and will be used to preload
+ * the input buffer on the next call to linenoise()
+ *
+ * @param preloadText text to begin with on the next call to linenoise()
+ */
+void linenoisePreloadBuffer(const char* preloadText) {
+  if (!preloadText) {
+    return;
+  }
+  int bufferSize = static_cast<int>(strlen(preloadText) + 1);
+  unique_ptr<char[]> tempBuffer(new char[bufferSize]);
+  strncpy(&tempBuffer[0], preloadText, bufferSize);
+
+  // remove characters that won't display correctly
+  char* pIn = &tempBuffer[0];
+  char* pOut = pIn;
+  bool controlsStripped = false;
+  bool whitespaceSeen = false;
+  while (*pIn) {
+    unsigned char c =
+        *pIn++;       // we need unsigned so chars 0x80 and above are allowed
+    if ('\r' == c) {  // silently skip CR
+      continue;
+    }
+    if ('\n' == c || '\t' == c) {  // note newline or tab
+      whitespaceSeen = true;
+      continue;
+    }
+    if (isControlChar(
+            c)) {  // remove other control characters, flag for message
+      controlsStripped = true;
+      *pOut++ = ' ';
+      continue;
+    }
+    if (whitespaceSeen) {  // convert whitespace to a single space
+      *pOut++ = ' ';
+      whitespaceSeen = false;
+    }
+    *pOut++ = c;
+  }
+  *pOut = 0;
+  int processedLength = static_cast<int>(pOut - tempBuffer.get());
+  bool lineTruncated = false;
+  if (processedLength > (LINENOISE_MAX_LINE - 1)) {
+    lineTruncated = true;
+    tempBuffer[LINENOISE_MAX_LINE - 1] = 0;
+  }
+  preloadedBufferContents = tempBuffer.get();
+  if (controlsStripped) {
+    preloadErrorMessage +=
+        " [Edited line: control characters were converted to spaces]\n";
+  }
+  if (lineTruncated) {
+    preloadErrorMessage += " [Edited line: the line length was reduced from ";
+    char buf[128];
+    snprintf(buf, sizeof(buf), "%d to %d]\n", processedLength,
+             (LINENOISE_MAX_LINE - 1));
+    preloadErrorMessage += buf;
+  }
+}
+
+/**
+ * linenoise is a readline replacement.
+ *
+ * call it with a prompt to display and it will return a line of input from the
+ * user
+ *
+ * @param prompt text of prompt to display to the user
+ * @return       the returned string belongs to the caller on return and must be
+ * freed to prevent
+ *               memory leaks
+ */
+char* linenoise(const char* prompt) {
+#ifndef _WIN32
+  gotResize = false;
+#endif
+  if (isatty(STDIN_FILENO)) {  // input is from a terminal
+    char32_t buf32[LINENOISE_MAX_LINE];
+    char charWidths[LINENOISE_MAX_LINE];
+    if (!preloadErrorMessage.empty()) {
+      printf("%s", preloadErrorMessage.c_str());
+      fflush(stdout);
+      preloadErrorMessage.clear();
+    }
+    PromptInfo pi(prompt, getScreenColumns());
+    if (isUnsupportedTerm()) {
+      if (!pi.write()) return 0;
+      fflush(stdout);
+      if (preloadedBufferContents.empty()) {
+        unique_ptr<char[]> buf8(new char[LINENOISE_MAX_LINE]);
+        if (fgets(buf8.get(), LINENOISE_MAX_LINE, stdin) == NULL) {
+          return NULL;
+        }
+        size_t len = strlen(buf8.get());
+        while (len && (buf8[len - 1] == '\n' || buf8[len - 1] == '\r')) {
+          --len;
+          buf8[len] = '\0';
+        }
+        return strdup(buf8.get());  // caller must free buffer
+      } else {
+        char* buf8 = strdup(preloadedBufferContents.c_str());
+        preloadedBufferContents.clear();
+        return buf8;  // caller must free buffer
+      }
+    } else {
+      if (enableRawMode() == -1) {
+        return NULL;
+      }
+      InputBuffer ib(buf32, charWidths, LINENOISE_MAX_LINE);
+      if (!preloadedBufferContents.empty()) {
+        ib.preloadBuffer(preloadedBufferContents.c_str());
+        preloadedBufferContents.clear();
+      }
+      int count = ib.getInputLine(pi);
+      disableRawMode();
+      printf("\n");
+      if (count == -1) {
+        return NULL;
+      }
+      size_t bufferSize = sizeof(char32_t) * ib.length() + 1;
+      unique_ptr<char[]> buf8(new char[bufferSize]);
+      copyString32to8(buf8.get(), bufferSize, buf32);
+      return strdup(buf8.get());  // caller must free buffer
+    }
+  } else {  // input not from a terminal, we should work with piped input, i.e.
+            // redirected stdin
+    unique_ptr<char[]> buf8(new char[LINENOISE_MAX_LINE]);
+    if (fgets(buf8.get(), LINENOISE_MAX_LINE, stdin) == NULL) {
+      return NULL;
+    }
+
+    // if fgets() gave us the newline, remove it
+    int count = static_cast<int>(strlen(buf8.get()));
+    if (count > 0 && buf8[count - 1] == '\n') {
+      --count;
+      buf8[count] = '\0';
+    }
+    return strdup(buf8.get());  // caller must free buffer
+  }
+}
+
+/* Register a callback function to be called for tab-completion. */
+void linenoiseSetCompletionCallback(linenoiseCompletionCallback* fn) {
+  completionCallback = fn;
+}
+
+void linenoiseAddCompletion(linenoiseCompletions* lc, const char* str) {
+  lc->completionStrings.push_back(Utf32String(str));
+}
+
+int linenoiseHistoryAdd(const char* line) {
+  if (historyMaxLen == 0) {
+    return 0;
+  }
+  if (history == NULL) {
+    history =
+        reinterpret_cast<char8_t**>(malloc(sizeof(char8_t*) * historyMaxLen));
+    if (history == NULL) {
+      return 0;
+    }
+    memset(history, 0, (sizeof(char*) * historyMaxLen));
+  }
+  char8_t* linecopy = strdup8(line);
+  if (!linecopy) {
+    return 0;
+  }
+
+  // convert newlines in multi-line code to spaces before storing
+  char8_t* p = linecopy;
+  while (*p) {
+    if (*p == '\n') {
+      *p = ' ';
+    }
+    ++p;
+  }
+
+  // prevent duplicate history entries
+  if (historyLen > 0 && history[historyLen - 1] != nullptr &&
+      strcmp(reinterpret_cast<char const*>(history[historyLen - 1]),
+             reinterpret_cast<char const*>(linecopy)) == 0) {
+    free(linecopy);
+    return 0;
+  }
+
+  if (historyLen == historyMaxLen) {
+    free(history[0]);
+    memmove(history, history + 1, sizeof(char*) * (historyMaxLen - 1));
+    --historyLen;
+    if (--historyPreviousIndex < -1) {
+      historyPreviousIndex = -2;
+    }
+  }
+
+  history[historyLen] = linecopy;
+  ++historyLen;
+  return 1;
+}
+
+int linenoiseHistorySetMaxLen(int len) {
+  if (len < 1) {
+    return 0;
+  }
+  if (history) {
+    int tocopy = historyLen;
+    char8_t** newHistory =
+        reinterpret_cast<char8_t**>(malloc(sizeof(char8_t*) * len));
+    if (newHistory == NULL) {
+      return 0;
+    }
+    if (len < tocopy) {
+      tocopy = len;
+    }
+    memcpy(newHistory, history + historyMaxLen - tocopy,
+           sizeof(char8_t*) * tocopy);
+    free(history);
+    history = newHistory;
+  }
+  historyMaxLen = len;
+  if (historyLen > historyMaxLen) {
+    historyLen = historyMaxLen;
+  }
+  return 1;
+}
+
+/* Fetch a line of the history by (zero-based) index.  If the requested
+ * line does not exist, NULL is returned.  The return value is a heap-allocated
+ * copy of the line, and the caller is responsible for de-allocating it. */
+char* linenoiseHistoryLine(int index) {
+  if (index < 0 || index >= historyLen) return NULL;
+
+  return strdup(reinterpret_cast<char const*>(history[index]));
+}
+
+/* Save the history in the specified file. On success 0 is returned
+ * otherwise -1 is returned. */
+int linenoiseHistorySave(const char* filename) {
+#if _WIN32
+  FILE* fp = fopen(filename, "wt");
+#else
+  int fd = open(filename, O_CREAT | O_TRUNC | O_WRONLY, S_IRUSR | S_IWUSR);
+
+  if (fd < 0) {
+    return -1;
+  }
+
+  FILE* fp = fdopen(fd, "wt");
+#endif
+
+  if (fp == NULL) {
+    return -1;
+  }
+
+  for (int j = 0; j < historyLen; ++j) {
+    if (history[j][0] != '\0') {
+      fprintf(fp, "%s\n", history[j]);
+    }
+  }
+
+  fclose(fp);
+
+  return 0;
+}
+
+/* Load the history from the specified file. If the file does not exist
+ * zero is returned and no operation is performed.
+ *
+ * If the file exists and the operation succeeded 0 is returned, otherwise
+ * on error -1 is returned. */
+int linenoiseHistoryLoad(const char* filename) {
+  FILE* fp = fopen(filename, "rt");
+  if (fp == NULL) {
+    return -1;
+  }
+
+  char buf[LINENOISE_MAX_LINE];
+  while (fgets(buf, LINENOISE_MAX_LINE, fp) != NULL) {
+    char* p = strchr(buf, '\r');
+    if (!p) {
+      p = strchr(buf, '\n');
+    }
+    if (p) {
+      *p = '\0';
+    }
+    if (p != buf) {
+      linenoiseHistoryAdd(buf);
+    }
+  }
+  fclose(fp);
+  return 0;
+}
+
+/* Set if to use or not the multi line mode. */
+/* note that this is a stub only, as linenoise-ng always multi-line */
+void linenoiseSetMultiLine(int) {}
+
+/* This special mode is used by linenoise in order to print scan codes
+ * on screen for debugging / development purposes. It is implemented
+ * by the linenoise_example program using the --keycodes option. */
+void linenoisePrintKeyCodes(void) {
+  char quit[4];
+
+  printf(
+      "Linenoise key codes debugging mode.\n"
+      "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
+  if (enableRawMode() == -1) return;
+  memset(quit, ' ', 4);
+  while (1) {
+    char c;
+    int nread;
+
+#if _WIN32
+    nread = _read(STDIN_FILENO, &c, 1);
+#else
+    nread = read(STDIN_FILENO, &c, 1);
+#endif
+    if (nread <= 0) continue;
+    memmove(quit, quit + 1, sizeof(quit) - 1); /* shift string to left. */
+    quit[sizeof(quit) - 1] = c; /* Insert current char on the right. */
+    if (memcmp(quit, "quit", sizeof(quit)) == 0) break;
+
+    printf("'%c' %02x (%d) (type quit to exit)\n", isprint(c) ? c : '?', (int)c,
+           (int)c);
+    printf("\r"); /* Go left edge manually, we are in raw mode. */
+    fflush(stdout);
+  }
+  disableRawMode();
+}
+
+#ifndef _WIN32
+static void WindowSizeChanged(int) {
+  // do nothing here but setting this flag
+  gotResize = true;
+}
+#endif
+
+int linenoiseInstallWindowChangeHandler(void) {
+#ifndef _WIN32
+  struct sigaction sa;
+  sigemptyset(&sa.sa_mask);
+  sa.sa_flags = 0;
+  sa.sa_handler = &WindowSizeChanged;
+
+  if (sigaction(SIGWINCH, &sa, nullptr) == -1) {
+    return errno;
+  }
+#endif
+  return 0;
+}
+
+int linenoiseKeyType(void) {
+  return keyType;
+}
diff -Naur ./ThirdParty/linenoise/src/wcwidth.cpp ../omniscidb-master/ThirdParty/linenoise/src/wcwidth.cpp
--- ./ThirdParty/linenoise/src/wcwidth.cpp	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/src/wcwidth.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,315 @@
+/*
+ * This is an implementation of wcwidth() and wcswidth() (defined in
+ * IEEE Std 1002.1-2001) for Unicode.
+ *
+ * http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html
+ * http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
+ *
+ * In fixed-width output devices, Latin characters all occupy a single
+ * "cell" position of equal width, whereas ideographic CJK characters
+ * occupy two such cells. Interoperability between terminal-line
+ * applications and (teletype-style) character terminals using the
+ * UTF-8 encoding requires agreement on which character should advance
+ * the cursor by how many cell positions. No established formal
+ * standards exist at present on which Unicode character shall occupy
+ * how many cell positions on character terminals. These routines are
+ * a first attempt of defining such behavior based on simple rules
+ * applied to data provided by the Unicode Consortium.
+ *
+ * For some graphical characters, the Unicode standard explicitly
+ * defines a character-cell width via the definition of the East Asian
+ * FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.
+ * In all these cases, there is no ambiguity about which width a
+ * terminal shall use. For characters in the East Asian Ambiguous (A)
+ * class, the width choice depends purely on a preference of backward
+ * compatibility with either historic CJK or Western practice.
+ * Choosing single-width for these characters is easy to justify as
+ * the appropriate long-term solution, as the CJK practice of
+ * displaying these characters as double-width comes from historic
+ * implementation simplicity (8-bit encoded characters were displayed
+ * single-width and 16-bit ones double-width, even for Greek,
+ * Cyrillic, etc.) and not any typographic considerations.
+ *
+ * Much less clear is the choice of width for the Not East Asian
+ * (Neutral) class. Existing practice does not dictate a width for any
+ * of these characters. It would nevertheless make sense
+ * typographically to allocate two character cells to characters such
+ * as for instance EM SPACE or VOLUME INTEGRAL, which cannot be
+ * represented adequately with a single-width glyph. The following
+ * routines at present merely assign a single-cell width to all
+ * neutral characters, in the interest of simplicity. This is not
+ * entirely satisfactory and should be reconsidered before
+ * establishing a formal standard in this area. At the moment, the
+ * decision which Not East Asian (Neutral) characters should be
+ * represented by double-width glyphs cannot yet be answered by
+ * applying a simple rule from the Unicode database content. Setting
+ * up a proper standard for the behavior of UTF-8 character terminals
+ * will require a careful analysis not only of each Unicode character,
+ * but also of each presentation form, something the author of these
+ * routines has avoided to do so far.
+ *
+ * http://www.unicode.org/unicode/reports/tr11/
+ *
+ * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
+ *
+ * Permission to use, copy, modify, and distribute this software
+ * for any purpose and without fee is hereby granted. The author
+ * disclaims all warranties with regard to this software.
+ *
+ * Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
+ */
+
+#include <wchar.h>
+#include <string>
+#include <memory>
+
+namespace linenoise_ng {
+
+struct interval {
+  char32_t first;
+  char32_t last;
+};
+
+/* auxiliary function for binary search in interval table */
+static int bisearch(char32_t ucs, const struct interval *table, int max) {
+  int min = 0;
+  int mid;
+
+  if (ucs < table[0].first || ucs > table[max].last)
+    return 0;
+  while (max >= min) {
+    mid = (min + max) / 2;
+    if (ucs > table[mid].last)
+      min = mid + 1;
+    else if (ucs < table[mid].first)
+      max = mid - 1;
+    else
+      return 1;
+  }
+
+  return 0;
+}
+
+
+/* The following two functions define the column width of an ISO 10646
+ * character as follows:
+ *
+ *    - The null character (U+0000) has a column width of 0.
+ *
+ *    - Other C0/C1 control characters and DEL will lead to a return
+ *      value of -1.
+ *
+ *    - Non-spacing and enclosing combining characters (general
+ *      category code Mn or Me in the Unicode database) have a
+ *      column width of 0.
+ *
+ *    - SOFT HYPHEN (U+00AD) has a column width of 1.
+ *
+ *    - Other format characters (general category code Cf in the Unicode
+ *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
+ *
+ *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
+ *      have a column width of 0.
+ *
+ *    - Spacing characters in the East Asian Wide (W) or East Asian
+ *      Full-width (F) category as defined in Unicode Technical
+ *      Report #11 have a column width of 2.
+ *
+ *    - All remaining characters (including all printable
+ *      ISO 8859-1 and WGL4 characters, Unicode control characters,
+ *      etc.) have a column width of 1.
+ *
+ * This implementation assumes that wchar_t characters are encoded
+ * in ISO 10646.
+ */
+
+int mk_wcwidth(char32_t ucs)
+{
+  /* sorted list of non-overlapping intervals of non-spacing characters */
+  /* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
+  static const struct interval combining[] = {
+    { 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
+    { 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
+    { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
+    { 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
+    { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
+    { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
+    { 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
+    { 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
+    { 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
+    { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
+    { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
+    { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
+    { 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
+    { 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
+    { 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
+    { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
+    { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
+    { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
+    { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
+    { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
+    { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
+    { 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
+    { 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
+    { 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
+    { 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
+    { 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
+    { 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
+    { 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
+    { 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
+    { 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
+    { 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
+    { 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
+    { 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
+    { 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
+    { 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
+    { 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
+    { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
+    { 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
+    { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
+    { 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },
+    { 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
+    { 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },
+    { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB },
+    { 0x10A01, 0x10A03 }, { 0x10A05, 0x10A06 }, { 0x10A0C, 0x10A0F },
+    { 0x10A38, 0x10A3A }, { 0x10A3F, 0x10A3F }, { 0x1D167, 0x1D169 },
+    { 0x1D173, 0x1D182 }, { 0x1D185, 0x1D18B }, { 0x1D1AA, 0x1D1AD },
+    { 0x1D242, 0x1D244 }, { 0xE0001, 0xE0001 }, { 0xE0020, 0xE007F },
+    { 0xE0100, 0xE01EF }
+  };
+
+  /* test for 8-bit control characters */
+  if (ucs == 0)
+    return 0;
+  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
+    return -1;
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch(ucs, combining,
+               sizeof(combining) / sizeof(struct interval) - 1))
+    return 0;
+
+  /* if we arrive here, ucs is not a combining or C0/C1 control character */
+
+  return 1 + 
+    (ucs >= 0x1100 &&
+     (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */
+      ucs == 0x2329 || ucs == 0x232a ||
+      (ucs >= 0x2e80 && ucs <= 0xa4cf &&
+       ucs != 0x303f) ||                  /* CJK ... Yi */
+      (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
+      (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
+      (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */
+      (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
+      (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */
+      (ucs >= 0xffe0 && ucs <= 0xffe6) ||
+      (ucs >= 0x20000 && ucs <= 0x2fffd) ||
+      (ucs >= 0x30000 && ucs <= 0x3fffd)));
+}
+
+
+int mk_wcswidth(const char32_t* pwcs, size_t n)
+{
+  int w, width = 0;
+
+  for (;*pwcs && n-- > 0; pwcs++)
+    if ((w = mk_wcwidth(*pwcs)) < 0)
+      return -1;
+    else
+      width += w;
+
+  return width;
+}
+
+
+/*
+ * The following functions are the same as mk_wcwidth() and
+ * mk_wcswidth(), except that spacing characters in the East Asian
+ * Ambiguous (A) category as defined in Unicode Technical Report #11
+ * have a column width of 2. This variant might be useful for users of
+ * CJK legacy encodings who want to migrate to UCS without changing
+ * the traditional terminal character-width behaviour. It is not
+ * otherwise recommended for general use.
+ */
+int mk_wcwidth_cjk(wchar_t ucs)
+{
+  /* sorted list of non-overlapping intervals of East Asian Ambiguous
+   * characters, generated by "uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c" */
+  static const struct interval ambiguous[] = {
+    { 0x00A1, 0x00A1 }, { 0x00A4, 0x00A4 }, { 0x00A7, 0x00A8 },
+    { 0x00AA, 0x00AA }, { 0x00AE, 0x00AE }, { 0x00B0, 0x00B4 },
+    { 0x00B6, 0x00BA }, { 0x00BC, 0x00BF }, { 0x00C6, 0x00C6 },
+    { 0x00D0, 0x00D0 }, { 0x00D7, 0x00D8 }, { 0x00DE, 0x00E1 },
+    { 0x00E6, 0x00E6 }, { 0x00E8, 0x00EA }, { 0x00EC, 0x00ED },
+    { 0x00F0, 0x00F0 }, { 0x00F2, 0x00F3 }, { 0x00F7, 0x00FA },
+    { 0x00FC, 0x00FC }, { 0x00FE, 0x00FE }, { 0x0101, 0x0101 },
+    { 0x0111, 0x0111 }, { 0x0113, 0x0113 }, { 0x011B, 0x011B },
+    { 0x0126, 0x0127 }, { 0x012B, 0x012B }, { 0x0131, 0x0133 },
+    { 0x0138, 0x0138 }, { 0x013F, 0x0142 }, { 0x0144, 0x0144 },
+    { 0x0148, 0x014B }, { 0x014D, 0x014D }, { 0x0152, 0x0153 },
+    { 0x0166, 0x0167 }, { 0x016B, 0x016B }, { 0x01CE, 0x01CE },
+    { 0x01D0, 0x01D0 }, { 0x01D2, 0x01D2 }, { 0x01D4, 0x01D4 },
+    { 0x01D6, 0x01D6 }, { 0x01D8, 0x01D8 }, { 0x01DA, 0x01DA },
+    { 0x01DC, 0x01DC }, { 0x0251, 0x0251 }, { 0x0261, 0x0261 },
+    { 0x02C4, 0x02C4 }, { 0x02C7, 0x02C7 }, { 0x02C9, 0x02CB },
+    { 0x02CD, 0x02CD }, { 0x02D0, 0x02D0 }, { 0x02D8, 0x02DB },
+    { 0x02DD, 0x02DD }, { 0x02DF, 0x02DF }, { 0x0391, 0x03A1 },
+    { 0x03A3, 0x03A9 }, { 0x03B1, 0x03C1 }, { 0x03C3, 0x03C9 },
+    { 0x0401, 0x0401 }, { 0x0410, 0x044F }, { 0x0451, 0x0451 },
+    { 0x2010, 0x2010 }, { 0x2013, 0x2016 }, { 0x2018, 0x2019 },
+    { 0x201C, 0x201D }, { 0x2020, 0x2022 }, { 0x2024, 0x2027 },
+    { 0x2030, 0x2030 }, { 0x2032, 0x2033 }, { 0x2035, 0x2035 },
+    { 0x203B, 0x203B }, { 0x203E, 0x203E }, { 0x2074, 0x2074 },
+    { 0x207F, 0x207F }, { 0x2081, 0x2084 }, { 0x20AC, 0x20AC },
+    { 0x2103, 0x2103 }, { 0x2105, 0x2105 }, { 0x2109, 0x2109 },
+    { 0x2113, 0x2113 }, { 0x2116, 0x2116 }, { 0x2121, 0x2122 },
+    { 0x2126, 0x2126 }, { 0x212B, 0x212B }, { 0x2153, 0x2154 },
+    { 0x215B, 0x215E }, { 0x2160, 0x216B }, { 0x2170, 0x2179 },
+    { 0x2190, 0x2199 }, { 0x21B8, 0x21B9 }, { 0x21D2, 0x21D2 },
+    { 0x21D4, 0x21D4 }, { 0x21E7, 0x21E7 }, { 0x2200, 0x2200 },
+    { 0x2202, 0x2203 }, { 0x2207, 0x2208 }, { 0x220B, 0x220B },
+    { 0x220F, 0x220F }, { 0x2211, 0x2211 }, { 0x2215, 0x2215 },
+    { 0x221A, 0x221A }, { 0x221D, 0x2220 }, { 0x2223, 0x2223 },
+    { 0x2225, 0x2225 }, { 0x2227, 0x222C }, { 0x222E, 0x222E },
+    { 0x2234, 0x2237 }, { 0x223C, 0x223D }, { 0x2248, 0x2248 },
+    { 0x224C, 0x224C }, { 0x2252, 0x2252 }, { 0x2260, 0x2261 },
+    { 0x2264, 0x2267 }, { 0x226A, 0x226B }, { 0x226E, 0x226F },
+    { 0x2282, 0x2283 }, { 0x2286, 0x2287 }, { 0x2295, 0x2295 },
+    { 0x2299, 0x2299 }, { 0x22A5, 0x22A5 }, { 0x22BF, 0x22BF },
+    { 0x2312, 0x2312 }, { 0x2460, 0x24E9 }, { 0x24EB, 0x254B },
+    { 0x2550, 0x2573 }, { 0x2580, 0x258F }, { 0x2592, 0x2595 },
+    { 0x25A0, 0x25A1 }, { 0x25A3, 0x25A9 }, { 0x25B2, 0x25B3 },
+    { 0x25B6, 0x25B7 }, { 0x25BC, 0x25BD }, { 0x25C0, 0x25C1 },
+    { 0x25C6, 0x25C8 }, { 0x25CB, 0x25CB }, { 0x25CE, 0x25D1 },
+    { 0x25E2, 0x25E5 }, { 0x25EF, 0x25EF }, { 0x2605, 0x2606 },
+    { 0x2609, 0x2609 }, { 0x260E, 0x260F }, { 0x2614, 0x2615 },
+    { 0x261C, 0x261C }, { 0x261E, 0x261E }, { 0x2640, 0x2640 },
+    { 0x2642, 0x2642 }, { 0x2660, 0x2661 }, { 0x2663, 0x2665 },
+    { 0x2667, 0x266A }, { 0x266C, 0x266D }, { 0x266F, 0x266F },
+    { 0x273D, 0x273D }, { 0x2776, 0x277F }, { 0xE000, 0xF8FF },
+    { 0xFFFD, 0xFFFD }, { 0xF0000, 0xFFFFD }, { 0x100000, 0x10FFFD }
+  };
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch(ucs, ambiguous,
+               sizeof(ambiguous) / sizeof(struct interval) - 1))
+    return 2;
+
+  return mk_wcwidth(ucs);
+}
+
+
+int mk_wcswidth_cjk(const wchar_t *pwcs, size_t n)
+{
+  int w, width = 0;
+
+  for (;*pwcs && n-- > 0; pwcs++)
+    if ((w = mk_wcwidth_cjk(*pwcs)) < 0)
+      return -1;
+    else
+      width += w;
+
+  return width;
+}
+
+}
diff -Naur ./ThirdParty/linenoise/tst/example.c ../omniscidb-master/ThirdParty/linenoise/tst/example.c
--- ./ThirdParty/linenoise/tst/example.c	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/ThirdParty/linenoise/tst/example.c	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,68 @@
+#include "linenoise.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+static const char* examples[] = {
+  "db", "hello", "hallo", "hans", "hansekogge", "seamann", "quetzalcoatl", "quit", "power", NULL
+};
+
+void completionHook (char const* prefix, linenoiseCompletions* lc) {
+  size_t i;
+
+  for (i = 0;  examples[i] != NULL; ++i) {
+    if (strncmp(prefix, examples[i], strlen(prefix)) == 0) {
+      linenoiseAddCompletion(lc, examples[i]);
+    }
+  }
+}
+
+int main (int argc, char** argv) {
+  linenoiseInstallWindowChangeHandler();
+
+  while(argc > 1) {
+    argc--;
+    argv++;
+    if (!strcmp(*argv, "--keycodes")) {
+      linenoisePrintKeyCodes();
+      exit(0);
+    }
+  }
+
+  const char* file = "./history";
+
+  linenoiseHistoryLoad(file);
+  linenoiseSetCompletionCallback(completionHook);
+
+  printf("starting...\n");
+
+  char const* prompt = "\x1b[1;32mlinenoise\x1b[0m> ";
+
+  while (1) {
+    char* result = linenoise(prompt);
+
+    if (result == NULL) {
+      break;
+    } else if (!strncmp(result, "/history", 8)) {
+      /* Display the current history. */
+      for (int index = 0; ; ++index) {
+        char* hist = linenoiseHistoryLine(index);
+        if (hist == NULL) break;
+        printf("%4d: %s\n", index, hist);
+        free(hist);
+       }
+    }
+    if (*result == '\0') {
+      free(result);
+      break;
+    }
+
+    printf("thanks for the input.\n");
+    linenoiseHistoryAdd(result);
+    free(result);
+  }
+
+  linenoiseHistorySave(file);
+  linenoiseHistoryFree();
+}
diff -Naur ./ThriftHandler/CommandLineOptions.cpp ../omniscidb-master/ThriftHandler/CommandLineOptions.cpp
--- ./ThriftHandler/CommandLineOptions.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThriftHandler/CommandLineOptions.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -449,6 +449,11 @@
           ->default_value(allow_multifrag)
           ->implicit_value(true),
       "Enable execution over multiple fragments in a single round-trip to GPU.");
+  developer_desc.add_options()("enable-lazy-fetch",
+                               po::value<bool>(&g_enable_lazy_fetch)
+                                   ->default_value(g_enable_lazy_fetch)
+                                   ->implicit_value(true),
+                               "Enable lazy fetch columns in query results.");
   developer_desc.add_options()(
       "enable-shared-mem-group-by",
       po::value<bool>(&g_enable_smem_group_by)
@@ -780,28 +785,31 @@
     const auto lock_file = boost::filesystem::path(base_path) / "omnisci_server_pid.lck";
     auto pid = std::to_string(getpid());
 
-    int pid_fd = open(lock_file.c_str(), O_RDWR | O_CREAT, 0644);
+    int pid_fd = open(lock_file.string().c_str(), O_RDWR | O_CREAT, 0644);
     if (pid_fd == -1) {
-      auto err = std::string("Failed to open PID file ") + lock_file.c_str() + ". " +
-                 strerror(errno) + ".";
+      auto err = std::string("Failed to open PID file ") + lock_file.string().c_str() +
+                 ". " + strerror(errno) + ".";
       throw std::runtime_error(err);
     }
+// TODO: support lock on Windows
+#ifndef _WIN32
     if (lockf(pid_fd, F_TLOCK, 0) == -1) {
-      close(pid_fd);
+      ::close(pid_fd);
       auto err = std::string("Another OmniSci Server is using data directory ") +
                  base_path + ".";
       throw std::runtime_error(err);
     }
+#endif
     if (ftruncate(pid_fd, 0) == -1) {
-      close(pid_fd);
-      auto err = std::string("Failed to truncate PID file ") + lock_file.c_str() + ". " +
-                 strerror(errno) + ".";
+      ::close(pid_fd);
+      auto err = std::string("Failed to truncate PID file ") +
+                 lock_file.string().c_str() + ". " + strerror(errno) + ".";
       throw std::runtime_error(err);
     }
     if (write(pid_fd, pid.c_str(), pid.length()) == -1) {
-      close(pid_fd);
-      auto err = std::string("Failed to write PID file ") + lock_file.c_str() + ". " +
-                 strerror(errno) + ".";
+      ::close(pid_fd);
+      auto err = std::string("Failed to write PID file ") + lock_file.string().c_str() +
+                 ". " + strerror(errno) + ".";
       throw std::runtime_error(err);
     }
   }
diff -Naur ./ThriftHandler/CommandLineOptions.h ../omniscidb-master/ThriftHandler/CommandLineOptions.h
--- ./ThriftHandler/CommandLineOptions.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThriftHandler/CommandLineOptions.h	2021-04-21 00:02:57.000000000 +0300
@@ -178,6 +178,7 @@
 extern bool g_enable_smem_non_grouped_agg;
 extern bool g_enable_smem_grouped_non_count_agg;
 extern bool g_use_estimator_result_cache;
+extern bool g_enable_lazy_fetch;
 
 extern int64_t g_omni_kafka_seek;
 extern size_t g_leaf_count;
diff -Naur ./ThriftHandler/DBHandler.cpp ../omniscidb-master/ThriftHandler/DBHandler.cpp
--- ./ThriftHandler/DBHandler.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThriftHandler/DBHandler.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -41,7 +41,6 @@
 #include "Catalog/DdlCommandExecutor.h"
 #include "DataMgr/ForeignStorage/ArrowForeignStorage.h"
 #include "DataMgr/ForeignStorage/DummyForeignStorage.h"
-#include "DataMgr/ForeignStorage/ForeignStorageInterface.h"
 #include "DistributedHandler.h"
 #include "Fragmenter/InsertOrderFragmenter.h"
 #include "Geospatial/GDAL.h"
@@ -74,10 +73,7 @@
 
 #include <fcntl.h>
 #include <picosha2.h>
-#include <sys/time.h>
 #include <sys/types.h>
-#include <sys/wait.h>
-#include <unistd.h>
 #include <algorithm>
 #include <boost/algorithm/string.hpp>
 #include <boost/filesystem.hpp>
@@ -244,7 +240,8 @@
 #ifdef ENABLE_GEOS
                      const std::string& libgeos_so_filename,
 #endif
-                     const DiskCacheConfig& disk_cache_config)
+                     const DiskCacheConfig& disk_cache_config,
+                     const bool is_new_db)
     : leaf_aggregator_(db_leaves)
     , db_leaves_(db_leaves)
     , string_leaves_(string_leaves)
@@ -285,10 +282,10 @@
 
 {
   LOG(INFO) << "OmniSci Server " << MAPD_RELEASE;
-  initialize();
+  initialize(is_new_db);
 }
 
-void DBHandler::initialize() {
+void DBHandler::initialize(const bool is_new_db) {
   if (!initialized_) {
     initialized_ = true;
   } else {
@@ -312,9 +309,6 @@
 #endif
   }
 
-  // Register foreign storage interfaces here
-  registerArrowCsvForeignStorage();
-
   bool is_rendering_enabled = enable_rendering_;
   if (system_parameters_.num_gpus == 0) {
     is_rendering_enabled = false;
@@ -426,7 +420,7 @@
                                 data_mgr_,
                                 authMetadata_,
                                 calcite_,
-                                false,
+                                is_new_db,
                                 !db_leaves_.empty(),
                                 string_leaves_);
   } catch (const std::exception& e) {
@@ -1104,6 +1098,100 @@
   return datum;
 }
 
+void DBHandler::sql_execute_local(
+    TQueryResult& _return,
+    const QueryStateProxy& query_state_proxy,
+    const std::shared_ptr<Catalog_Namespace::SessionInfo> session_ptr,
+    const std::string& query_str,
+    const bool column_format,
+    const std::string& nonce,
+    const int32_t first_n,
+    const int32_t at_most_n,
+    const bool use_calcite) {
+  _return.total_time_ms = 0;
+  _return.nonce = nonce;
+  ParserWrapper pw{query_str};
+  switch (pw.getQueryType()) {
+    case ParserWrapper::QueryType::Read: {
+      _return.query_type = TQueryType::READ;
+      VLOG(1) << "query type: READ";
+      break;
+    }
+    case ParserWrapper::QueryType::Write: {
+      _return.query_type = TQueryType::WRITE;
+      VLOG(1) << "query type: WRITE";
+      break;
+    }
+    case ParserWrapper::QueryType::SchemaRead: {
+      _return.query_type = TQueryType::SCHEMA_READ;
+      VLOG(1) << "query type: SCHEMA READ";
+      break;
+    }
+    case ParserWrapper::QueryType::SchemaWrite: {
+      _return.query_type = TQueryType::SCHEMA_WRITE;
+      VLOG(1) << "query type: SCHEMA WRITE";
+      break;
+    }
+    default: {
+      _return.query_type = TQueryType::UNKNOWN;
+      LOG(WARNING) << "query type: UNKNOWN";
+      break;
+    }
+  }
+  ExecutionResult result;
+  _return.total_time_ms += measure<>::execution([&]() {
+    DBHandler::sql_execute_impl(result,
+                                query_state_proxy,
+                                column_format,
+                                session_ptr->get_executor_device_type(),
+                                first_n,
+                                at_most_n,
+                                use_calcite);
+    DBHandler::convertData(
+        _return, result, query_state_proxy, query_str, column_format, first_n, at_most_n);
+  });
+}
+
+void DBHandler::convertData(TQueryResult& _return,
+                            ExecutionResult& result,
+                            const QueryStateProxy& query_state_proxy,
+                            const std::string& query_str,
+                            const bool column_format,
+                            const int32_t first_n,
+                            const int32_t at_most_n) {
+  _return.execution_time_ms += result.getExecutionTime();
+  if (result.empty()) {
+    return;
+  }
+
+  switch (result.getResultType()) {
+    case ExecutionResult::QueryResult:
+      convertRows(_return,
+                  query_state_proxy,
+                  result.getTargetsMeta(),
+                  *result.getRows(),
+                  column_format,
+                  first_n,
+                  at_most_n);
+      break;
+    case ExecutionResult::SimpleResult:
+      convertResult(_return, *result.getRows(), true);
+      break;
+    case ExecutionResult::Explaination:
+      convertExplain(_return, *result.getRows(), true);
+      break;
+    case ExecutionResult::CalciteDdl:
+      convertRows(_return,
+                  query_state_proxy,
+                  result.getTargetsMeta(),
+                  *result.getRows(),
+                  column_format,
+                  -1,
+                  -1);
+      break;
+  }
+}
+
 void DBHandler::sql_execute(TQueryResult& _return,
                             const TSessionId& session,
                             const std::string& query_str,
@@ -1111,13 +1199,16 @@
                             const std::string& nonce,
                             const int32_t first_n,
                             const int32_t at_most_n) {
+  const std::string exec_ra_prefix = "execute relalg";
+  const bool use_calcite = !boost::starts_with(query_str, exec_ra_prefix);
+  auto actual_query =
+      use_calcite ? query_str : boost::trim_copy(query_str.substr(exec_ra_prefix.size()));
   auto session_ptr = get_session_ptr(session);
-  auto query_state = create_query_state(session_ptr, query_str);
+  auto query_state = create_query_state(session_ptr, actual_query);
   auto stdlog = STDLOG(session_ptr, query_state);
   stdlog.appendNameValuePairs("client", getConnectionInfo().toString());
   stdlog.appendNameValuePairs("nonce", nonce);
   auto timer = DEBUG_TIMER(__func__);
-
   try {
     ScopeGuard reset_was_geo_copy_from = [this, &session_ptr] {
       geo_copy_from_sessions.remove(session_ptr->get_session_id());
@@ -1144,45 +1235,17 @@
       });
       _return.nonce = nonce;
     } else {
-      _return.total_time_ms = measure<>::execution([&]() {
-        DBHandler::sql_execute_impl(_return,
-                                    query_state->createQueryStateProxy(),
-                                    column_format,
-                                    nonce,
-                                    session_ptr->get_executor_device_type(),
-                                    first_n,
-                                    at_most_n);
-      });
-    }
-
-    // if the SQL statement we just executed was a geo COPY FROM, the import
-    // parameters were captured, and this flag set, so we do the actual import here
-    if (auto geo_copy_from_state =
-            geo_copy_from_sessions(session_ptr->get_session_id())) {
-      // import_geo_table() calls create_table() which calls this function to
-      // do the work, so reset the flag now to avoid executing this part a
-      // second time at the end of that, which would fail as the table was
-      // already created! Also reset the flag with a ScopeGuard on exiting
-      // this function any other way, such as an exception from the code above!
-      geo_copy_from_sessions.remove(session_ptr->get_session_id());
-
-      // create table as replicated?
-      TCreateParams create_params;
-      if (geo_copy_from_state->geo_copy_from_partitions == "REPLICATED") {
-        create_params.is_replicated = true;
-      }
-
-      // now do (and time) the import
-      _return.total_time_ms = measure<>::execution([&]() {
-        import_geo_table(
-            session,
-            geo_copy_from_state->geo_copy_from_table,
-            geo_copy_from_state->geo_copy_from_file_name,
-            copyparams_to_thrift(geo_copy_from_state->geo_copy_from_copy_params),
-            TRowDescriptor(),
-            create_params);
-      });
+      sql_execute_local(_return,
+                        query_state->createQueryStateProxy(),
+                        session_ptr,
+                        actual_query,
+                        column_format,
+                        nonce,
+                        first_n,
+                        at_most_n,
+                        use_calcite);
     }
+    _return.total_time_ms += process_geo_copy_from(session);
     std::string debug_json = timer.stopAndGetJson();
     if (!debug_json.empty()) {
       _return.__set_debug(std::move(debug_json));
@@ -1208,6 +1271,96 @@
   }
 }
 
+void DBHandler::sql_execute(ExecutionResult& _return,
+                            const TSessionId& session,
+                            const std::string& query_str,
+                            const bool column_format,
+                            const int32_t first_n,
+                            const int32_t at_most_n) {
+  const std::string exec_ra_prefix = "execute relalg";
+  const bool use_calcite = !boost::starts_with(query_str, exec_ra_prefix);
+  auto actual_query =
+      use_calcite ? query_str : boost::trim_copy(query_str.substr(exec_ra_prefix.size()));
+
+  auto session_ptr = get_session_ptr(session);
+  auto query_state = create_query_state(session_ptr, actual_query);
+  auto stdlog = STDLOG(session_ptr, query_state);
+  auto timer = DEBUG_TIMER(__func__);
+
+  try {
+    ScopeGuard reset_was_geo_copy_from = [this, &session_ptr] {
+      geo_copy_from_sessions.remove(session_ptr->get_session_id());
+    };
+
+    if (first_n >= 0 && at_most_n >= 0) {
+      THROW_MAPD_EXCEPTION(
+          std::string("At most one of first_n and at_most_n can be set"));
+    }
+    auto total_time_ms = measure<>::execution([&]() {
+      DBHandler::sql_execute_impl(_return,
+                                  query_state->createQueryStateProxy(),
+                                  column_format,
+                                  session_ptr->get_executor_device_type(),
+                                  first_n,
+                                  at_most_n,
+                                  use_calcite);
+    });
+
+    _return.setExecutionTime(total_time_ms + process_geo_copy_from(session));
+
+    stdlog.appendNameValuePairs(
+        "execution_time_ms",
+        _return.getExecutionTime(),
+        "total_time_ms",  // BE-3420 - Redundant with duration field
+        stdlog.duration<std::chrono::milliseconds>());
+    VLOG(1) << "Table Schema Locks:\n" << lockmgr::TableSchemaLockMgr::instance();
+    VLOG(1) << "Table Data Locks:\n" << lockmgr::TableDataLockMgr::instance();
+  } catch (const std::exception& e) {
+    if (strstr(e.what(), "java.lang.NullPointerException")) {
+      THROW_MAPD_EXCEPTION(std::string("Exception: ") +
+                           "query failed from broken view or other schema related issue");
+    } else if (strstr(e.what(), "SQL Error: Encountered \";\"")) {
+      THROW_MAPD_EXCEPTION("multiple SQL statements not allowed");
+    } else if (strstr(e.what(), "SQL Error: Encountered \"<EOF>\" at line 0, column 0")) {
+      THROW_MAPD_EXCEPTION("empty SQL statment not allowed");
+    } else {
+      THROW_MAPD_EXCEPTION(std::string("Exception: ") + e.what());
+    }
+  }
+}
+
+int64_t DBHandler::process_geo_copy_from(const TSessionId& session_id) {
+  int64_t total_time_ms(0);
+  // if the SQL statement we just executed was a geo COPY FROM, the import
+  // parameters were captured, and this flag set, so we do the actual import here
+  if (auto geo_copy_from_state = geo_copy_from_sessions(session_id)) {
+    // import_geo_table() calls create_table() which calls this function to
+    // do the work, so reset the flag now to avoid executing this part a
+    // second time at the end of that, which would fail as the table was
+    // already created! Also reset the flag with a ScopeGuard on exiting
+    // this function any other way, such as an exception from the code above!
+    geo_copy_from_sessions.remove(session_id);
+
+    // create table as replicated?
+    TCreateParams create_params;
+    if (geo_copy_from_state->geo_copy_from_partitions == "REPLICATED") {
+      create_params.is_replicated = true;
+    }
+
+    // now do (and time) the import
+    total_time_ms = measure<>::execution([&]() {
+      import_geo_table(
+          session_id,
+          geo_copy_from_state->geo_copy_from_table,
+          geo_copy_from_state->geo_copy_from_file_name,
+          copyparams_to_thrift(geo_copy_from_state->geo_copy_from_copy_params),
+          TRowDescriptor(),
+          create_params);
+    });
+  }
+  return total_time_ms;
+}
+
 void DBHandler::sql_execute_df(TDataFrame& _return,
                                const TSessionId& session,
                                const std::string& query_str,
@@ -1571,7 +1724,8 @@
 
 TQueryResult DBHandler::validate_rel_alg(const std::string& query_ra,
                                          QueryStateProxy query_state_proxy) {
-  TQueryResult result;
+  TQueryResult _return;
+  ExecutionResult result;
   auto execute_rel_alg_task = std::make_shared<QueryDispatchQueue::Task>(
       [this, &result, &query_state_proxy, &query_ra](const size_t executor_index) {
         execute_rel_alg(result,
@@ -1590,7 +1744,8 @@
   dispatch_queue_->submit(execute_rel_alg_task, /*is_update_delete=*/false);
   auto result_future = execute_rel_alg_task->get_future();
   result_future.get();
-  return result;
+  DBHandler::convertData(_return, result, query_state_proxy, query_ra, true, -1, -1);
+  return _return;
 }
 
 void DBHandler::get_roles(std::vector<std::string>& roles, const TSessionId& session) {
@@ -2294,8 +2449,8 @@
             query_state_proxy, td->viewSQL, {}, with_table_locks, system_parameters_);
         const auto query_ra = parse_result.plan_result;
 
-        TQueryResult result;
-        execute_rel_alg(result,
+        ExecutionResult ex_result;
+        execute_rel_alg(ex_result,
                         query_state_proxy,
                         query_ra,
                         true,
@@ -2305,6 +2460,9 @@
                         /*just_validate=*/true,
                         /*find_push_down_candidates=*/false,
                         ExplainInfo::defaults());
+        TQueryResult result;
+        DBHandler::convertData(
+            result, ex_result, query_state_proxy, query_ra, true, -1, -1);
         num_cols = result.row_set.row_desc.size();
         for (const auto& col : result.row_set.row_desc) {
           if (col.is_physical) {
@@ -5173,7 +5331,7 @@
 }
 
 std::vector<PushedDownFilterInfo> DBHandler::execute_rel_alg(
-    TQueryResult& _return,
+    ExecutionResult& _return,
     QueryStateProxy query_state_proxy,
     const std::string& query_ra,
     const bool column_format,
@@ -5233,34 +5391,21 @@
                                   .empty(),
                          g_running_query_interrupt_freq,
                          g_pending_query_interrupt_freq};
-  ExecutionResult result{std::make_shared<ResultSet>(std::vector<TargetInfo>{},
-                                                     ExecutorDeviceType::CPU,
-                                                     QueryMemoryDescriptor(),
-                                                     nullptr,
-                                                     nullptr,
-                                                     0,
-                                                     0),
-                         {}};
-  _return.execution_time_ms += measure<>::execution([&]() {
-    result = ra_executor.executeRelAlgQuery(co, eo, explain_info.explain_plan, nullptr);
-  });
+  auto execution_time_ms = _return.getExecutionTime() + measure<>::execution([&]() {
+                             _return = ra_executor.executeRelAlgQuery(
+                                 co, eo, explain_info.explain_plan, nullptr);
+                           });
   // reduce execution time by the time spent during queue waiting
-  _return.execution_time_ms -= result.getRows()->getQueueTime();
+  _return.setExecutionTime(execution_time_ms -= _return.getRows()->getQueueTime());
   VLOG(1) << cat.getDataMgr().getSystemMemoryUsage();
-  const auto& filter_push_down_info = result.getPushedDownFilterInfo();
+  const auto& filter_push_down_info = _return.getPushedDownFilterInfo();
   if (!filter_push_down_info.empty()) {
     return filter_push_down_info;
   }
   if (explain_info.justExplain()) {
-    convert_explain(_return, *result.getRows(), column_format);
+    _return.setResultType(ExecutionResult::Explaination);
   } else if (!explain_info.justCalciteExplain()) {
-    convert_rows(_return,
-                 timer.createQueryStateProxy(),
-                 result.getTargetsMeta(),
-                 *result.getRows(),
-                 column_format,
-                 first_n,
-                 at_most_n);
+    _return.setResultType(ExecutionResult::QueryResult);
   }
   return {};
 }
@@ -5383,13 +5528,13 @@
   return names;
 }
 
-void DBHandler::convert_rows(TQueryResult& _return,
-                             QueryStateProxy query_state_proxy,
-                             const std::vector<TargetMetaInfo>& targets,
-                             const ResultSet& results,
-                             const bool column_format,
-                             const int32_t first_n,
-                             const int32_t at_most_n) const {
+void DBHandler::convertRows(TQueryResult& _return,
+                            QueryStateProxy query_state_proxy,
+                            const std::vector<TargetMetaInfo>& targets,
+                            const ResultSet& results,
+                            const bool column_format,
+                            const int32_t first_n,
+                            const int32_t at_most_n) {
   query_state::Timer timer = query_state_proxy.createTimer(__func__);
   _return.row_set.row_desc = ThriftSerializers::target_meta_infos_to_thrift(targets);
   int32_t fetched{0};
@@ -5454,10 +5599,10 @@
 }
 
 // create simple result set to return a single column result
-void DBHandler::create_simple_result(TQueryResult& _return,
-                                     const ResultSet& results,
-                                     const bool column_format,
-                                     const std::string label) const {
+void DBHandler::createSimpleResult(TQueryResult& _return,
+                                   const ResultSet& results,
+                                   const bool column_format,
+                                   const std::string label) {
   CHECK_EQ(size_t(1), results.rowCount());
   TColumnType proj_info;
   proj_info.col_name = label;
@@ -5491,16 +5636,16 @@
   }
 }
 
-void DBHandler::convert_explain(TQueryResult& _return,
-                                const ResultSet& results,
-                                const bool column_format) const {
-  create_simple_result(_return, results, column_format, "Explanation");
+void DBHandler::convertExplain(TQueryResult& _return,
+                               const ResultSet& results,
+                               const bool column_format) {
+  createSimpleResult(_return, results, column_format, "Explanation");
 }
 
-void DBHandler::convert_result(TQueryResult& _return,
-                               const ResultSet& results,
-                               const bool column_format) const {
-  create_simple_result(_return, results, column_format, "Result");
+void DBHandler::convertResult(TQueryResult& _return,
+                              const ResultSet& results,
+                              const bool column_format) {
+  createSimpleResult(_return, results, column_format, "Result");
 }
 
 // this all should be moved out of here to catalog
@@ -5541,24 +5686,20 @@
   }
 }
 
-void DBHandler::sql_execute_impl(TQueryResult& _return,
+void DBHandler::sql_execute_impl(ExecutionResult& _return,
                                  QueryStateProxy query_state_proxy,
                                  const bool column_format,
-                                 const std::string& nonce,
                                  const ExecutorDeviceType executor_device_type,
                                  const int32_t first_n,
-                                 const int32_t at_most_n) {
+                                 const int32_t at_most_n,
+                                 const bool use_calcite) {
   if (leaf_handler_) {
     leaf_handler_->flush_queue();
   }
-
-  _return.nonce = nonce;
-  _return.execution_time_ms = 0;
   auto const query_str = strip(query_state_proxy.getQueryState().getQueryStr());
   auto session_ptr = query_state_proxy.getQueryState().getConstSessionInfo();
   // Call to DistributedValidate() below may change cat.
   auto& cat = session_ptr->getCatalog();
-
   std::list<std::unique_ptr<Parser::Stmt>> parse_trees;
 
   mapd_unique_lock<mapd_shared_mutex> executeWriteLock;
@@ -5566,70 +5707,41 @@
 
   lockmgr::LockedTableDescriptors locks;
   ParserWrapper pw{query_str};
-  switch (pw.getQueryType()) {
-    case ParserWrapper::QueryType::Read: {
-      _return.query_type = TQueryType::READ;
-      VLOG(1) << "query type: READ";
-      break;
-    }
-    case ParserWrapper::QueryType::Write: {
-      _return.query_type = TQueryType::WRITE;
-      VLOG(1) << "query type: WRITE";
-      break;
-    }
-    case ParserWrapper::QueryType::SchemaRead: {
-      _return.query_type = TQueryType::SCHEMA_READ;
-      VLOG(1) << "query type: SCHEMA READ";
-      break;
-    }
-    case ParserWrapper::QueryType::SchemaWrite: {
-      _return.query_type = TQueryType::SCHEMA_WRITE;
-      VLOG(1) << "query type: SCHEMA WRITE";
-      break;
-    }
-    default: {
-      _return.query_type = TQueryType::UNKNOWN;
-      LOG(WARNING) << "query type: UNKNOWN";
-      break;
-    }
-  }
   if (pw.isCalcitePathPermissable(read_only_)) {
     // run DDL before the locks as DDL statements should handle their own locking
     if (pw.isCalciteDdl()) {
       std::string query_ra;
-      _return.execution_time_ms += measure<>::execution([&]() {
+      _return.addExecutionTime(measure<>::execution([&]() {
         TPlanResult result;
         std::tie(result, locks) =
             parse_to_ra(query_state_proxy, query_str, {}, false, system_parameters_);
         query_ra = result.plan_result;
-      });
-
+      }));
       executeDdl(_return, query_ra, session_ptr);
       return;
     }
-
     executeReadLock = mapd_shared_lock<mapd_shared_mutex>(
         *legacylockmgr::LockMgr<mapd_shared_mutex, bool>::getMutex(
             legacylockmgr::ExecutorOuterLock, true));
 
-    std::string query_ra;
-    _return.execution_time_ms += measure<>::execution([&]() {
-      TPlanResult result;
-      std::tie(result, locks) =
-          parse_to_ra(query_state_proxy, query_str, {}, true, system_parameters_);
-      query_ra = result.plan_result;
-    });
-
+    std::string query_ra = query_str;
+    if (use_calcite) {
+      _return.addExecutionTime(measure<>::execution([&]() {
+        TPlanResult result;
+        std::tie(result, locks) =
+            parse_to_ra(query_state_proxy, query_str, {}, true, system_parameters_);
+        query_ra = result.plan_result;
+      }));
+    }
     std::string query_ra_calcite_explain;
     if (pw.isCalciteExplain() && (!g_enable_filter_push_down || g_cluster)) {
       // return the ra as the result
-      convert_explain(_return, ResultSet(query_ra), true);
+      _return.updateResultSet(query_ra, ExecutionResult::Explaination);
       return;
     } else if (pw.isCalciteExplain()) {
       // removing the "explain calcite " from the beginning of the "query_str":
       std::string temp_query_str =
           query_str.substr(std::string("explain calcite ").length());
-
       CHECK(!locks.empty());
       query_ra_calcite_explain =
           parse_to_ra(query_state_proxy, temp_query_str, {}, false, system_parameters_)
@@ -5666,7 +5778,7 @@
           if (explain_info.justCalciteExplain() && filter_push_down_requests.empty()) {
             // we only reach here if filter push down was enabled, but no filter
             // push down candidate was found
-            convert_explain(_return, ResultSet(query_ra), true);
+            _return.updateResultSet(query_ra, ExecutionResult::Explaination);
           } else if (!filter_push_down_requests.empty()) {
             CHECK(!locks.empty());
             execute_rel_alg_with_filter_push_down(_return,
@@ -5689,7 +5801,7 @@
             query_ra =
                 parse_to_ra(query_state_proxy, query_str, {}, false, system_parameters_)
                     .first.plan_result;
-            convert_explain(_return, ResultSet(query_ra), true);
+            _return.updateResultSet(query_ra, ExecutionResult::Explaination);
           }
         });
     CHECK(dispatch_queue_);
@@ -5717,7 +5829,7 @@
           dynamic_cast<Parser::OptimizeTableStmt*>(parse_trees.front().get());
       CHECK(optimize_stmt);
 
-      _return.execution_time_ms += measure<>::execution([&]() {
+      _return.addExecutionTime(measure<>::execution([&]() {
         const auto td_with_lock =
             lockmgr::TableSchemaLockContainer<lockmgr::WriteLock>::acquireTableDescriptor(
                 cat, optimize_stmt->getTableName());
@@ -5739,8 +5851,7 @@
           optimizer.vacuumDeletedRows();
         }
         optimizer.recomputeMetadata();
-      });
-
+      }));
       return;
     }
     if (pw.is_validate) {
@@ -5760,7 +5871,7 @@
       std::string output{"Result for validate"};
       if (g_cluster) {
         if (leaf_aggregator_.leafCount()) {
-          _return.execution_time_ms += measure<>::execution([&]() {
+          _return.addExecutionTime(measure<>::execution([&]() {
             const system_validator::DistributedValidate validator(
                 validate_stmt->getType(),
                 validate_stmt->isRepairTypeRemove(),
@@ -5769,23 +5880,22 @@
                 *session_ptr,
                 *this);
             output = validator.validate(query_state_proxy);
-          });
+          }));
         } else {
           THROW_MAPD_EXCEPTION("Validate command should be executed on the aggregator.");
         }
       } else {
-        _return.execution_time_ms += measure<>::execution([&]() {
+        _return.addExecutionTime(measure<>::execution([&]() {
           const system_validator::SingleNodeValidator validator(validate_stmt->getType(),
                                                                 cat);
           output = validator.validate();
-        });
+        }));
       }
-      convert_result(_return, ResultSet(output), true);
+      _return.updateResultSet(output, ExecutionResult::SimpleResult);
       return;
     }
   }
   LOG(INFO) << "passing query to legacy processor";
-
   const auto result = apply_copy_to_shim(query_str);
   DBHandler::parser_with_error_handler(result, parse_trees);
   auto handle_ddl = [&query_state_proxy, &session_ptr, &_return, &locks, this](
@@ -5795,10 +5905,10 @@
     }
     const auto show_create_stmt = dynamic_cast<Parser::ShowCreateTableStmt*>(ddl);
     if (show_create_stmt) {
-      _return.execution_time_ms +=
-          measure<>::execution([&]() { ddl->execute(*session_ptr); });
+      _return.addExecutionTime(
+          measure<>::execution([&]() { ddl->execute(*session_ptr); }));
       const auto create_string = show_create_stmt->getCreateStmt();
-      convert_result(_return, ResultSet(create_string), true);
+      _return.updateResultSet(create_string, ExecutionResult::SimpleResult);
       return true;
     }
 
@@ -5809,16 +5919,17 @@
         throw std::runtime_error(
             "Cannot import on an individual leaf. Please import from the Aggregator.");
       } else if (leaf_aggregator_.leafCount() > 0) {
-        _return.execution_time_ms += measure<>::execution(
-            [&]() { execute_distributed_copy_statement(import_stmt, *session_ptr); });
+        _return.addExecutionTime(measure<>::execution(
+            [&]() { execute_distributed_copy_statement(import_stmt, *session_ptr); }));
       } else {
-        _return.execution_time_ms +=
-            measure<>::execution([&]() { ddl->execute(*session_ptr); });
+        _return.addExecutionTime(
+            measure<>::execution([&]() { ddl->execute(*session_ptr); }));
       }
 
       // Read response message
-      convert_result(_return, ResultSet(*import_stmt->return_message.get()), true);
-      _return.success = import_stmt->get_success();
+      _return.updateResultSet(*import_stmt->return_message.get(),
+                              ExecutionResult::SimpleResult,
+                              import_stmt->get_success());
 
       // get geo_copy_from info
       if (import_stmt->was_geo_copy_from()) {
@@ -5842,10 +5953,11 @@
       std::tie(result, locks) =
           parse_to_ra(query_state_proxy, query_string, {}, true, system_parameters_);
     }
-    _return.execution_time_ms += measure<>::execution([&]() {
+    _return.addExecutionTime(measure<>::execution([&]() {
       ddl->execute(*session_ptr);
       check_and_invalidate_sessions(ddl);
-    });
+    }));
+    _return.setResultType(ExecutionResult::CalciteDdl);
     return true;
   };
 
@@ -5864,18 +5976,17 @@
     if (!handle_ddl(ddl)) {
       auto stmtp = dynamic_cast<Parser::InsertValuesStmt*>(stmt.get());
       CHECK(stmtp);  // no other statements supported
-
       if (parse_trees.size() != 1) {
         throw std::runtime_error("Can only run one INSERT INTO query at a time.");
       }
-      _return.execution_time_ms +=
-          measure<>::execution([&]() { stmtp->execute(*session_ptr); });
+      _return.addExecutionTime(
+          measure<>::execution([&]() { stmtp->execute(*session_ptr); }));
     }
   }
 }
 
 void DBHandler::execute_rel_alg_with_filter_push_down(
-    TQueryResult& _return,
+    ExecutionResult& _return,
     QueryStateProxy query_state_proxy,
     std::string& query_ra,
     const bool column_format,
@@ -5895,18 +6006,18 @@
     filter_push_down_info.push_back(filter_push_down_info_for_request);
   }
   // deriving the new relational algebra plan with respect to the pushed down filters
-  _return.execution_time_ms += measure<>::execution([&]() {
+  _return.addExecutionTime(measure<>::execution([&]() {
     query_ra = parse_to_ra(query_state_proxy,
                            query_state_proxy.getQueryState().getQueryStr(),
                            filter_push_down_info,
                            false,
                            system_parameters_)
                    .first.plan_result;
-  });
+  }));
 
   if (just_calcite_explain) {
     // return the new ra as the result
-    convert_explain(_return, ResultSet(query_ra), true);
+    _return.updateResultSet(query_ra, ExecutionResult::Explaination);
     return;
   }
 
@@ -5946,7 +6057,7 @@
     const std::string& query_str,
     const std::vector<TFilterPushDownInfo>& filter_push_down_info,
     const bool acquire_locks,
-    const SystemParameters system_parameters,
+    const SystemParameters& system_parameters,
     bool check_privileges) {
   query_state::Timer timer = query_state_proxy.createTimer(__func__);
   ParserWrapper pw{query_str};
@@ -6540,12 +6651,12 @@
   ExtensionFunctionsWhitelist::addRTUdfs(whitelist);
 }
 
-void DBHandler::convert_result_set(ExecutionResult& result,
-                                   const Catalog_Namespace::SessionInfo& session_info,
-                                   const std::string& query_state_str,
-                                   TQueryResult& _return) {
+void DBHandler::convertResultSet(ExecutionResult& result,
+                                 const Catalog_Namespace::SessionInfo& session_info,
+                                 const std::string& query_state_str,
+                                 TQueryResult& _return) {
   // Stuff ResultSet into _return (which is a TQueryResult)
-  // calls convert_rows, but after some setup using session_info
+  // calls convertRows, but after some setup using session_info
 
   auto session_ptr = get_session_ptr(session_info.get_session_id());
   auto qs = create_query_state(session_ptr, query_state_str);
@@ -6555,13 +6666,13 @@
   //   assume that omnisci_server should only return column format
   int32_t nRows = result.getDataPtr()->rowCount();
 
-  convert_rows(_return,
-               qsp,
-               result.getTargetsMeta(),
-               *result.getDataPtr(),
-               /*column_format=*/true,
-               /*first_n=*/nRows,
-               /*at_most_n=*/nRows);
+  convertRows(_return,
+              qsp,
+              result.getTargetsMeta(),
+              *result.getDataPtr(),
+              /*column_format=*/true,
+              /*first_n=*/nRows,
+              /*at_most_n=*/nRows);
 }
 
 static std::unique_ptr<RexLiteral> genLiteralStr(std::string val) {
@@ -6785,7 +6896,33 @@
       // reduce execution time by the time spent during queue waiting
       _return.execution_time_ms -= result.getRows()->getQueueTime();
 
-      convert_result_set(result, *session_ptr, commandStr, _return);
+      convertResultSet(result, *session_ptr, commandStr, _return);
+    }
+  }
+}
+
+void DBHandler::executeDdl(
+    ExecutionResult& _return,
+    const std::string& query_ra,
+    std::shared_ptr<Catalog_Namespace::SessionInfo const> session_ptr) {
+  DdlCommandExecutor executor = DdlCommandExecutor(query_ra, session_ptr);
+  std::string commandStr = executor.commandStr();
+  if (executor.isKillQuery()) {
+    interruptQuery(*session_ptr, executor.getTargetQuerySessionToKill());
+  } else {
+    int64_t execution_time_ms;
+    if (executor.isShowQueries()) {
+      // getQueries still requires Thrift cannot be nested into DdlCommandExecutor
+      execution_time_ms =
+          measure<>::execution([&]() { _return = getQueries(session_ptr); });
+    } else if (executor.isShowUserSessions()) {
+      // getUserSessions still requires Thrift cannot be nested into DdlCommandExecutor
+      execution_time_ms =
+          measure<>::execution([&]() { _return = getUserSessions(session_ptr); });
+    } else {
+      execution_time_ms = measure<>::execution([&]() { _return = executor.execute(); });
     }
+    _return.setExecutionTime(execution_time_ms);
   }
+  _return.setResultType(ExecutionResult::CalciteDdl);
 }
diff -Naur ./ThriftHandler/DBHandler.h ../omniscidb-master/ThriftHandler/DBHandler.h
--- ./ThriftHandler/DBHandler.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThriftHandler/DBHandler.h	2021-04-21 00:02:57.000000000 +0300
@@ -185,11 +185,12 @@
 #ifdef ENABLE_GEOS
             const std::string& libgeos_so_filename,
 #endif
-            const DiskCacheConfig& disk_cache_config);
-  void initialize();
+            const DiskCacheConfig& disk_cache_config,
+            const bool is_new_db);
+  void initialize(const bool is_new_db);
   ~DBHandler() override;
 
-  static inline size_t max_bytes_for_thrift() { return 2 * 1000 * 1000 * 1000L; }
+  static inline size_t max_bytes_for_thrift() { return 2 * 1000 * 1000 * 1000LL; }
 
   // Important ****
   //         This block must be keep in sync with mapd.thrift and HAHandler.h
@@ -271,6 +272,13 @@
                         const std::vector<TTableEpochInfo>& table_epochs) override;
 
   void get_session_info(TSessionInfo& _return, const TSessionId& session) override;
+
+  void sql_execute(ExecutionResult& _return,
+                   const TSessionId& session,
+                   const std::string& query,
+                   const bool column_format,
+                   const int32_t first_n,
+                   const int32_t at_most_n);
   // query, render
   void sql_execute(TQueryResult& _return,
                    const TSessionId& session,
@@ -648,16 +656,37 @@
       const std::string& query_str,
       const std::vector<TFilterPushDownInfo>& filter_push_down_info,
       const bool acquire_locks,
-      const SystemParameters system_parameters,
+      const SystemParameters& system_parameters,
       bool check_privileges = true);
 
-  void sql_execute_impl(TQueryResult& _return,
+  void sql_execute_local(
+      TQueryResult& _return,
+      const QueryStateProxy& query_state_proxy,
+      const std::shared_ptr<Catalog_Namespace::SessionInfo> session_ptr,
+      const std::string& query_str,
+      const bool column_format,
+      const std::string& nonce,
+      const int32_t first_n,
+      const int32_t at_most_n,
+      const bool use_calcite);
+
+  int64_t process_geo_copy_from(const TSessionId& session_id);
+
+  static void convertData(TQueryResult& _return,
+                          ExecutionResult& result,
+                          const QueryStateProxy& query_state_proxy,
+                          const std::string& query_str,
+                          const bool column_format,
+                          const int32_t first_n,
+                          const int32_t at_most_n);
+
+  void sql_execute_impl(ExecutionResult& _return,
                         QueryStateProxy,
                         const bool column_format,
-                        const std::string& nonce,
                         const ExecutorDeviceType executor_device_type,
                         const int32_t first_n,
-                        const int32_t at_most_n);
+                        const int32_t at_most_n,
+                        const bool use_calcite);
 
   bool user_can_access_table(const Catalog_Namespace::SessionInfo&,
                              const TableDescriptor* td,
@@ -670,7 +699,7 @@
   TQueryResult validate_rel_alg(const std::string& query_ra, QueryStateProxy);
 
   std::vector<PushedDownFilterInfo> execute_rel_alg(
-      TQueryResult& _return,
+      ExecutionResult& _return,
       QueryStateProxy,
       const std::string& query_ra,
       const bool column_format,
@@ -683,7 +712,7 @@
       const std::optional<size_t> executor_index = std::nullopt) const;
 
   void execute_rel_alg_with_filter_push_down(
-      TQueryResult& _return,
+      ExecutionResult& _return,
       QueryStateProxy,
       std::string& query_ra,
       const bool column_format,
@@ -707,6 +736,10 @@
                   const std::string& query_ra,
                   std::shared_ptr<Catalog_Namespace::SessionInfo const> session_ptr);
 
+  void executeDdl(ExecutionResult& _return,
+                  const std::string& query_ra,
+                  std::shared_ptr<Catalog_Namespace::SessionInfo const> session_ptr);
+
   TColumnType populateThriftColumnType(const Catalog_Namespace::Catalog* cat,
                                        const ColumnDescriptor* cd);
   TRowDescriptor fixup_row_descriptor(const TRowDescriptor& row_desc,
@@ -729,32 +762,32 @@
                                 const std::string& name,
                                 const bool is_array);
 
-  void convert_explain(TQueryResult& _return,
-                       const ResultSet& results,
-                       const bool column_format) const;
-  void convert_result(TQueryResult& _return,
-                      const ResultSet& results,
-                      const bool column_format) const;
-
-  void convert_rows(TQueryResult& _return,
-                    QueryStateProxy query_state_proxy,
-                    const std::vector<TargetMetaInfo>& targets,
-                    const ResultSet& results,
-                    const bool column_format,
-                    const int32_t first_n,
-                    const int32_t at_most_n) const;
+  static void convertExplain(TQueryResult& _return,
+                             const ResultSet& results,
+                             const bool column_format);
+  static void convertResult(TQueryResult& _return,
+                            const ResultSet& results,
+                            const bool column_format);
 
-  // Use ExecutionResult to populate a TQueryResult
-  //    calls convert_rows, but after some setup using session_info
-  void convert_result_set(ExecutionResult& result,
-                          const Catalog_Namespace::SessionInfo& session_info,
-                          const std::string& query_state_str,
-                          TQueryResult& _return);
+  static void convertRows(TQueryResult& _return,
+                          QueryStateProxy query_state_proxy,
+                          const std::vector<TargetMetaInfo>& targets,
+                          const ResultSet& results,
+                          const bool column_format,
+                          const int32_t first_n,
+                          const int32_t at_most_n);
 
-  void create_simple_result(TQueryResult& _return,
-                            const ResultSet& results,
-                            const bool column_format,
-                            const std::string label) const;
+  // Use ExecutionResult to populate a TQueryResult
+  //    calls convertRows, but after some setup using session_info
+  void convertResultSet(ExecutionResult& result,
+                        const Catalog_Namespace::SessionInfo& session_info,
+                        const std::string& query_state_str,
+                        TQueryResult& _return);
+
+  static void createSimpleResult(TQueryResult& _return,
+                                 const ResultSet& results,
+                                 const bool column_format,
+                                 const std::string label);
 
   std::vector<TargetMetaInfo> getTargetMetaInfo(
       const std::vector<std::shared_ptr<Analyzer::TargetEntry>>& targets) const;
diff -Naur ./ThriftHandler/QueryState.h ../omniscidb-master/ThriftHandler/QueryState.h
--- ./ThriftHandler/QueryState.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/ThriftHandler/QueryState.h	2021-04-21 00:02:57.000000000 +0300
@@ -173,6 +173,7 @@
       : query_state_(query_state), parent_(parent) {}
   Timer createTimer(char const* event_name);
   QueryState& getQueryState() { return query_state_; }
+  const QueryState& getConstQueryState() const { return query_state_; }
 };
 
 // At this point it is not clear how long we want to keep completed queries.
diff -Naur ./Utils/CMakeLists.txt ../omniscidb-master/Utils/CMakeLists.txt
--- ./Utils/CMakeLists.txt	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Utils/CMakeLists.txt	2021-04-21 00:02:57.000000000 +0300
@@ -7,4 +7,4 @@
 )
 
 add_library(Utils ${utils_source_files})
-target_link_libraries(Utils ${Boost_LIBRARIES} Shared)
+target_link_libraries(Utils OSDependent ${Boost_LIBRARIES} Shared)
diff -Naur ./Utils/DdlUtils.cpp ../omniscidb-master/Utils/DdlUtils.cpp
--- ./Utils/DdlUtils.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Utils/DdlUtils.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -573,14 +573,19 @@
 
 void validate_expanded_file_path(const std::string& file_path,
                                  const std::vector<std::string>& whitelisted_root_paths) {
-  boost::filesystem::path canonical_file_path = boost::filesystem::canonical(file_path);
+  const auto& canonical_file_path = boost::filesystem::canonical(file_path);
   for (const auto& root_path : whitelisted_root_paths) {
     if (boost::istarts_with(canonical_file_path.string(), root_path)) {
       return;
     }
   }
+  if (canonical_file_path == boost::filesystem::absolute(file_path)) {
+    throw std::runtime_error{"File or directory path \"" + file_path +
+                             "\" is not whitelisted."};
+  }
   throw std::runtime_error{"File or directory path \"" + file_path +
-                           "\" is not whitelisted."};
+                           "\" (resolved to \"" + canonical_file_path.string() +
+                           "\") is not whitelisted."};
 }
 
 std::vector<std::string> get_expanded_file_paths(
@@ -630,8 +635,14 @@
       get_expanded_file_paths(file_path, data_transfer_type);
   for (const auto& path : expanded_file_paths) {
     if (FilePathBlacklist::isBlacklistedPath(path)) {
+      const auto& canonical_file_path = boost::filesystem::canonical(file_path);
+      if (canonical_file_path == boost::filesystem::absolute(file_path)) {
+        throw std::runtime_error{"Access to file or directory path \"" + file_path +
+                                 "\" is not allowed."};
+      }
       throw std::runtime_error{"Access to file or directory path \"" + file_path +
-                               "\" is not allowed."};
+                               "\" (resolved to \"" + canonical_file_path.string() +
+                               "\") is not allowed."};
     }
   }
   FilePathWhitelist::validateWhitelistedFilePath(expanded_file_paths, data_transfer_type);
diff -Naur ./Utils/Regexp.cpp ../omniscidb-master/Utils/Regexp.cpp
--- ./Utils/Regexp.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Utils/Regexp.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -38,11 +38,11 @@
  * @param escape_char the escape character.  '\\' is expected by default.
  * @return true if str matches pattern, false otherwise.
  */
-extern "C" DEVICE bool regexp_like(const char* str,
-                                   const int32_t str_len,
-                                   const char* pattern,
-                                   const int32_t pat_len,
-                                   const char escape_char) {
+extern "C" RUNTIME_EXPORT DEVICE bool regexp_like(const char* str,
+                                                  const int32_t str_len,
+                                                  const char* pattern,
+                                                  const int32_t pat_len,
+                                                  const char escape_char) {
 #ifndef __CUDACC__
   bool result;
   try {
@@ -59,12 +59,12 @@
 #endif
 }
 
-extern "C" DEVICE int8_t regexp_like_nullable(const char* str,
-                                              const int32_t str_len,
-                                              const char* pattern,
-                                              const int32_t pat_len,
-                                              const char escape_char,
-                                              const int8_t bool_null) {
+extern "C" RUNTIME_EXPORT DEVICE int8_t regexp_like_nullable(const char* str,
+                                                             const int32_t str_len,
+                                                             const char* pattern,
+                                                             const int32_t pat_len,
+                                                             const char escape_char,
+                                                             const int8_t bool_null) {
   if (!str || !pattern) {
     return bool_null;
   }
diff -Naur ./Utils/Regexp.h ../omniscidb-master/Utils/Regexp.h
--- ./Utils/Regexp.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Utils/Regexp.h	2021-04-21 00:02:57.000000000 +0300
@@ -39,10 +39,10 @@
  * @return true if str matches pattern, false otherwise.
  */
 
-extern "C" DEVICE bool regexp_like(const char* str,
-                                   int str_len,
-                                   const char* pattern,
-                                   int pat_len,
-                                   char escape_char);
+extern "C" RUNTIME_EXPORT DEVICE bool regexp_like(const char* str,
+                                                  int str_len,
+                                                  const char* pattern,
+                                                  int pat_len,
+                                                  char escape_char);
 
 #endif  // REGEX_H
diff -Naur ./Utils/StringLike.cpp ../omniscidb-master/Utils/StringLike.cpp
--- ./Utils/StringLike.cpp	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Utils/StringLike.cpp	2021-04-21 00:02:57.000000000 +0300
@@ -40,10 +40,10 @@
   return c;
 }
 
-extern "C" DEVICE bool string_like_simple(const char* str,
-                                          const int32_t str_len,
-                                          const char* pattern,
-                                          const int32_t pat_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_like_simple(const char* str,
+                                                         const int32_t str_len,
+                                                         const char* pattern,
+                                                         const int32_t pat_len) {
   int i, j;
   int search_len = str_len - pat_len + 1;
   for (i = 0; i < search_len; ++i) {
@@ -56,10 +56,10 @@
   return false;
 }
 
-extern "C" DEVICE bool string_ilike_simple(const char* str,
-                                           const int32_t str_len,
-                                           const char* pattern,
-                                           const int32_t pat_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_ilike_simple(const char* str,
+                                                          const int32_t str_len,
+                                                          const char* pattern,
+                                                          const int32_t pat_len) {
   int i, j;
   int search_len = str_len - pat_len + 1;
   for (i = 0; i < search_len; ++i) {
@@ -72,16 +72,16 @@
   return false;
 }
 
-#define STR_LIKE_SIMPLE_NULLABLE(base_func)                               \
-  extern "C" DEVICE int8_t base_func##_nullable(const char* lhs,          \
-                                                const int32_t lhs_len,    \
-                                                const char* rhs,          \
-                                                const int32_t rhs_len,    \
-                                                const int8_t bool_null) { \
-    if (!lhs || !rhs) {                                                   \
-      return bool_null;                                                   \
-    }                                                                     \
-    return base_func(lhs, lhs_len, rhs, rhs_len) ? 1 : 0;                 \
+#define STR_LIKE_SIMPLE_NULLABLE(base_func)                                              \
+  extern "C" RUNTIME_EXPORT DEVICE int8_t base_func##_nullable(const char* lhs,          \
+                                                               const int32_t lhs_len,    \
+                                                               const char* rhs,          \
+                                                               const int32_t rhs_len,    \
+                                                               const int8_t bool_null) { \
+    if (!lhs || !rhs) {                                                                  \
+      return bool_null;                                                                  \
+    }                                                                                    \
+    return base_func(lhs, lhs_len, rhs, rhs_len) ? 1 : 0;                                \
   }
 
 STR_LIKE_SIMPLE_NULLABLE(string_like_simple)
@@ -243,32 +243,32 @@
  * @return true if str matchs pattern, false otherwise.  error condition
  * not handled for now.
  */
-extern "C" DEVICE bool string_like(const char* str,
-                                   const int32_t str_len,
-                                   const char* pattern,
-                                   const int32_t pat_len,
-                                   const char escape_char) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_like(const char* str,
+                                                  const int32_t str_len,
+                                                  const char* pattern,
+                                                  const int32_t pat_len,
+                                                  const char escape_char) {
   // @TODO(wei/alex) add runtime error handling
   LikeStatus status =
       string_like_match(str, str_len, pattern, pat_len, escape_char, false);
   return status == kLIKE_TRUE;
 }
 
-extern "C" DEVICE bool string_ilike(const char* str,
-                                    const int32_t str_len,
-                                    const char* pattern,
-                                    const int32_t pat_len,
-                                    const char escape_char) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_ilike(const char* str,
+                                                   const int32_t str_len,
+                                                   const char* pattern,
+                                                   const int32_t pat_len,
+                                                   const char escape_char) {
   // @TODO(wei/alex) add runtime error handling
   LikeStatus status =
       string_like_match(str, str_len, pattern, pat_len, escape_char, true);
   return status == kLIKE_TRUE;
 }
 
-extern "C" DEVICE int32_t StringCompare(const char* s1,
-                                        const int32_t s1_len,
-                                        const char* s2,
-                                        const int32_t s2_len) {
+extern "C" RUNTIME_EXPORT DEVICE int32_t StringCompare(const char* s1,
+                                                       const int32_t s1_len,
+                                                       const char* s2,
+                                                       const int32_t s2_len) {
   const char* s1_ = s1;
   const char* s2_ = s2;
 
@@ -283,17 +283,17 @@
   return c1 - c2;
 }
 
-#define STR_LIKE_NULLABLE(base_func)                                      \
-  extern "C" DEVICE int8_t base_func##_nullable(const char* lhs,          \
-                                                const int32_t lhs_len,    \
-                                                const char* rhs,          \
-                                                const int32_t rhs_len,    \
-                                                const char escape_char,   \
-                                                const int8_t bool_null) { \
-    if (!lhs || !rhs) {                                                   \
-      return bool_null;                                                   \
-    }                                                                     \
-    return base_func(lhs, lhs_len, rhs, rhs_len, escape_char) ? 1 : 0;    \
+#define STR_LIKE_NULLABLE(base_func)                                                     \
+  extern "C" RUNTIME_EXPORT DEVICE int8_t base_func##_nullable(const char* lhs,          \
+                                                               const int32_t lhs_len,    \
+                                                               const char* rhs,          \
+                                                               const int32_t rhs_len,    \
+                                                               const char escape_char,   \
+                                                               const int8_t bool_null) { \
+    if (!lhs || !rhs) {                                                                  \
+      return bool_null;                                                                  \
+    }                                                                                    \
+    return base_func(lhs, lhs_len, rhs, rhs_len, escape_char) ? 1 : 0;                   \
   }
 
 STR_LIKE_NULLABLE(string_like)
@@ -301,58 +301,58 @@
 
 #undef STR_LIKE_NULLABLE
 
-extern "C" DEVICE bool string_lt(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_lt(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len) {
   return StringCompare(lhs, lhs_len, rhs, rhs_len) < 0;
 }
 
-extern "C" DEVICE bool string_le(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_le(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len) {
   return StringCompare(lhs, lhs_len, rhs, rhs_len) <= 0;
 }
 
-extern "C" DEVICE bool string_gt(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_gt(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len) {
   return StringCompare(lhs, lhs_len, rhs, rhs_len) > 0;
 }
 
-extern "C" DEVICE bool string_ge(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_ge(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len) {
   return StringCompare(lhs, lhs_len, rhs, rhs_len) >= 0;
 }
 
-extern "C" DEVICE bool string_eq(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_eq(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len) {
   return StringCompare(lhs, lhs_len, rhs, rhs_len) == 0;
 }
 
-extern "C" DEVICE bool string_ne(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len) {
+extern "C" RUNTIME_EXPORT DEVICE bool string_ne(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len) {
   return StringCompare(lhs, lhs_len, rhs, rhs_len) != 0;
 }
 
-#define STR_CMP_NULLABLE(base_func)                                       \
-  extern "C" DEVICE int8_t base_func##_nullable(const char* lhs,          \
-                                                const int32_t lhs_len,    \
-                                                const char* rhs,          \
-                                                const int32_t rhs_len,    \
-                                                const int8_t bool_null) { \
-    if (!lhs || !rhs) {                                                   \
-      return bool_null;                                                   \
-    }                                                                     \
-    return base_func(lhs, lhs_len, rhs, rhs_len) ? 1 : 0;                 \
+#define STR_CMP_NULLABLE(base_func)                                                      \
+  extern "C" RUNTIME_EXPORT DEVICE int8_t base_func##_nullable(const char* lhs,          \
+                                                               const int32_t lhs_len,    \
+                                                               const char* rhs,          \
+                                                               const int32_t rhs_len,    \
+                                                               const int8_t bool_null) { \
+    if (!lhs || !rhs) {                                                                  \
+      return bool_null;                                                                  \
+    }                                                                                    \
+    return base_func(lhs, lhs_len, rhs, rhs_len) ? 1 : 0;                                \
   }
 
 STR_CMP_NULLABLE(string_lt)
diff -Naur ./Utils/StringLike.h ../omniscidb-master/Utils/StringLike.h
--- ./Utils/StringLike.h	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/Utils/StringLike.h	2021-04-21 00:02:57.000000000 +0300
@@ -42,61 +42,61 @@
  * @return true if str matchs pattern, false otherwise.  error condition
  * not handled for now.
  */
-extern "C" DEVICE bool string_like(const char* str,
-                                   int str_len,
-                                   const char* pattern,
-                                   int pat_len,
-                                   char escape_char);
-
-extern "C" DEVICE bool string_ilike(const char* str,
-                                    int str_len,
-                                    const char* pattern,
-                                    int pat_len,
-                                    char escape_char);
-
-extern "C" DEVICE bool string_like_simple(const char* str,
-                                          const int32_t str_len,
-                                          const char* pattern,
-                                          const int32_t pat_len);
-
-extern "C" DEVICE bool string_ilike_simple(const char* str,
-                                           const int32_t str_len,
-                                           const char* pattern,
-                                           const int32_t pat_len);
-
-extern "C" DEVICE bool string_lt(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len);
-
-extern "C" DEVICE bool string_le(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len);
-
-extern "C" DEVICE bool string_eq(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len);
-
-extern "C" DEVICE bool string_ne(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len);
-
-extern "C" DEVICE bool string_ge(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len);
-
-extern "C" DEVICE bool string_gt(const char* lhs,
-                                 const int32_t lhs_len,
-                                 const char* rhs,
-                                 const int32_t rhs_len);
-
-extern "C" DEVICE int32_t StringCompare(const char* s1,
-                                        const int32_t s1_len,
-                                        const char* s2,
-                                        const int32_t s2_len);
+extern "C" RUNTIME_EXPORT DEVICE bool string_like(const char* str,
+                                                  int str_len,
+                                                  const char* pattern,
+                                                  int pat_len,
+                                                  char escape_char);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_ilike(const char* str,
+                                                   int str_len,
+                                                   const char* pattern,
+                                                   int pat_len,
+                                                   char escape_char);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_like_simple(const char* str,
+                                                         const int32_t str_len,
+                                                         const char* pattern,
+                                                         const int32_t pat_len);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_ilike_simple(const char* str,
+                                                          const int32_t str_len,
+                                                          const char* pattern,
+                                                          const int32_t pat_len);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_lt(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_le(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_eq(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_ne(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_ge(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len);
+
+extern "C" RUNTIME_EXPORT DEVICE bool string_gt(const char* lhs,
+                                                const int32_t lhs_len,
+                                                const char* rhs,
+                                                const int32_t rhs_len);
+
+extern "C" RUNTIME_EXPORT DEVICE int32_t StringCompare(const char* s1,
+                                                       const int32_t s1_len,
+                                                       const char* s2,
+                                                       const int32_t s2_len);
 
 #endif  // STRING_LIKE_H
diff -Naur ./cmake/Modules/FindMLPACK.cmake ../omniscidb-master/cmake/Modules/FindMLPACK.cmake
--- ./cmake/Modules/FindMLPACK.cmake	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/cmake/Modules/FindMLPACK.cmake	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,77 @@
+#.rst:
+# FindMLPACK
+# -------------
+#
+# Find MLPACK
+#
+# Find the MLPACK C++ library
+#
+# Using MLPACK::
+#
+#   find_package(MLPACK REQUIRED)
+#   include_directories(${MLPACK_INCLUDE_DIRS})
+#   add_executable(foo foo.cc)
+#   target_link_libraries(foo ${MLPACK_LIBRARIES})
+#
+# This module sets the following variables::
+#
+#   MLPACK_FOUND - set to true if the library is found
+#   MLPACK_INCLUDE_DIRS - list of required include directories
+#   MLPACK_LIBRARIES - list of libraries to be linked
+#   MLPACK_VERSION_MAJOR - major version number
+#   MLPACK_VERSION_MINOR - minor version number
+#   MLPACK_VERSION_PATCH - patch version number
+#   MLPACK_VERSION_STRING - version number as a string (ex: "1.0.4")
+
+if(MLPACK_USE_STATIC_LIBS)
+  set(_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
+  set(CMAKE_FIND_LIBRARY_SUFFIXES .lib .a ${CMAKE_FIND_LIBRARY_SUFFIXES})
+endif()
+
+# UNIX paths are standard, no need to specify them.
+find_library(MLPACK_LIBRARY
+  NAMES mlpack
+  HINTS
+  ENV LD_LIBRARY_PATH
+  ENV DYLD_LIBRARY_PATH
+  PATHS
+  /usr/lib
+  /usr/lib/x86_64-linux-gnu
+  /usr/local/lib
+  /usr/local/homebrew/lib
+  /opt/local/lib
+)
+
+get_filename_component(MLPACK_LIBRARY_DIR ${MLPACK_LIBRARY} DIRECTORY)
+
+find_path(MLPACK_INCLUDE_DIR
+  NAMES mlpack/core.hpp mlpack/prereqs.hpp
+  HINTS
+  ${MLPACK_LIBRARY_DIR}/../include
+  ${MLPACK_LIBRARY_DIR}/../../include
+  PATHS
+  /include
+  /usr/include
+  /usr/local/include
+  /usr/local/homebrew/include
+  /opt/local/include
+)
+
+if(MLPACK_USE_STATIC_LIBS)
+  set(CMAKE_FIND_LIBRARY_SUFFIXES ${_CMAKE_FIND_LIBRARY_SUFFIXES})
+endif()
+
+set(MLPACK_LIBRARIES ${MLPACK_LIBRARY})
+set(MLPACK_INCLUDE_DIRS ${MLPACK_INCLUDE_DIR})
+
+include(FindPackageHandleStandardArgs)
+
+find_package_handle_standard_args(MLPACK
+	REQUIRED_VARS MLPACK_LIBRARY MLPACK_INCLUDE_DIR
+)
+
+# Hide internal variables
+mark_as_advanced(
+  MLPACK_INCLUDE_DIR
+  MLPACK_LIBRARY
+)
\ No newline at end of file
diff -Naur ./common.thrift ../omniscidb-master/common.thrift
--- ./common.thrift	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/common.thrift	2021-04-21 00:02:57.000000000 +0300
@@ -41,13 +41,13 @@
 }
 
 struct TTypeInfo {
-  1: TDatumType type,
-  4: TEncodingType encoding,
-  2: bool nullable,
-  3: bool is_array,
-  5: i32 precision,
-  6: i32 scale,
-  7: i32 comp_param,
-  8: optional i32 size=-1
+  1: TDatumType type;
+  4: TEncodingType encoding;
+  2: bool nullable;
+  3: bool is_array;
+  5: i32 precision;
+  6: i32 scale;
+  7: i32 comp_param;
+  8: optional i32 size=-1;
 }
 
diff -Naur ./docs/source/flow/data.rst ../omniscidb-master/docs/source/flow/data.rst
--- ./docs/source/flow/data.rst	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/docs/source/flow/data.rst	2021-04-21 00:02:57.000000000 +0300
@@ -4,14 +4,14 @@
 Data Flow
 ==================================
 
-A SQL query is essentially a series of transformations on some input data. While the input to the query engine is a SQL query, the query engine (and more so, the ``Exectutor``) can be thought of a black box which builds a transformation, loads data, applies the transformation, and returns the result. In the following section, we provide a summary of how data flows through the system, from physical storage on disk through the memory hierarchy to the output.
+A SQL query is essentially a series of transformations on some input data. While the input to the query engine is a SQL query, the query engine (and more so, the ``Executor``) can be thought of a black box which builds a transformation, loads data, applies the transformation, and returns the result. In the following section, we provide a summary of how data flows through the system, from physical storage on disk through the memory hierarchy to the output.
 
 Input Data
 ==========
 
 All requests for input data start from the ``Executor``. The executor loads chunks required for a query to device memory by making a call into the standalone ``ColumnFetcher`` class. The ``ColumnFetcher`` makes calls directly into the buffer manager hierarchy and storage layer to ensure requested chunks are available in the appropriate memory level for the device. 
 
-The following schematic illustrates the proess for requesting inputs for a query step, from storage through to the execution device (in this example, a GPU). 
+The following schematic illustrates the process for requesting inputs for a query step, from storage through to the execution device (in this example, a GPU). 
 
 .. uml::
     :align: center
diff -Naur ./java/calcite/src/main/java/com/mapd/calcite/parser/MapDParser.java ../omniscidb-master/java/calcite/src/main/java/com/mapd/calcite/parser/MapDParser.java
--- ./java/calcite/src/main/java/com/mapd/calcite/parser/MapDParser.java	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/java/calcite/src/main/java/com/mapd/calcite/parser/MapDParser.java	2021-04-21 00:02:57.000000000 +0300
@@ -18,6 +18,7 @@
 import static org.apache.calcite.sql.parser.SqlParserPos.ZERO;
 
 import com.google.common.collect.ImmutableList;
+import com.mapd.calcite.parser.MapDParserOptions.FilterPushDownInfo;
 import com.mapd.common.SockTransportProperties;
 import com.mapd.parser.extension.ddl.ExtendedSqlParser;
 import com.mapd.parser.extension.ddl.JsonSerializableDdl;
@@ -380,10 +381,13 @@
     return new Pair<String, SqlIdentifierCapturer>(res, capture);
   }
 
-  public String optimizeRAQuery(String query) throws IOException {
+  public String optimizeRAQuery(String query, final MapDParserOptions parserOptions)
+          throws IOException {
     MapDSchema schema =
             new MapDSchema(dataDir, this, mapdPort, mapdUser, sock_transport_properties);
     MapDPlanner planner = getPlanner(true, true);
+
+    planner.setFilterPushDownInfo(parserOptions.getFilterPushDownInfo());
     RelRoot optRel = planner.optimizeRaQuery(query, schema);
     optRel = replaceIsTrue(planner.getTypeFactory(), optRel);
     return MapDSerializer.toString(optRel.project());
diff -Naur ./java/calcite/src/main/java/com/mapd/calcite/parser/MapDSqlOperatorTable.java ../omniscidb-master/java/calcite/src/main/java/com/mapd/calcite/parser/MapDSqlOperatorTable.java
--- ./java/calcite/src/main/java/com/mapd/calcite/parser/MapDSqlOperatorTable.java	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/java/calcite/src/main/java/com/mapd/calcite/parser/MapDSqlOperatorTable.java	2021-04-21 00:02:57.000000000 +0300
@@ -1698,7 +1698,7 @@
     public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
       assert opBinding.getOperandCount() == 0;
       final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();
-      return typeFactory.createSqlType(SqlTypeName.INTEGER);
+      return typeFactory.createSqlType(SqlTypeName.BIGINT);
     }
   }
 
diff -Naur ./java/calcite/src/main/java/com/mapd/parser/hint/OmniSciHintStrategyTable.java ../omniscidb-master/java/calcite/src/main/java/com/mapd/parser/hint/OmniSciHintStrategyTable.java
--- ./java/calcite/src/main/java/com/mapd/parser/hint/OmniSciHintStrategyTable.java	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/java/calcite/src/main/java/com/mapd/parser/hint/OmniSciHintStrategyTable.java	2021-04-21 00:02:57.000000000 +0300
@@ -15,6 +15,8 @@
             .hintStrategy("overlaps_bucket_threshold", HintPredicates.SET_VAR)
             .hintStrategy("overlaps_max_size", HintPredicates.SET_VAR)
             .hintStrategy("overlaps_allow_gpu_build", HintPredicates.SET_VAR)
+            .hintStrategy("overlaps_no_cache", HintPredicates.SET_VAR)
+            .hintStrategy("overlaps_keys_per_bin", HintPredicates.SET_VAR)
             .build();
   }
 }
diff -Naur ./java/calcite/src/main/java/com/mapd/parser/server/CalciteServerHandler.java ../omniscidb-master/java/calcite/src/main/java/com/mapd/parser/server/CalciteServerHandler.java
--- ./java/calcite/src/main/java/com/mapd/parser/server/CalciteServerHandler.java	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/java/calcite/src/main/java/com/mapd/parser/server/CalciteServerHandler.java	2021-04-21 00:02:57.000000000 +0300
@@ -182,17 +182,19 @@
     TAccessedQueryObjects primaryAccessedObjects = new TAccessedQueryObjects();
     TAccessedQueryObjects resolvedAccessedObjects = new TAccessedQueryObjects();
     try {
+      final List<MapDParserOptions.FilterPushDownInfo> filterPushDownInfo =
+              new ArrayList<>();
+      for (final TFilterPushDownInfo req : thriftFilterPushDownInfo) {
+        filterPushDownInfo.add(new MapDParserOptions.FilterPushDownInfo(
+                req.input_prev, req.input_start, req.input_next));
+      }
+      MapDParserOptions parserOptions = new MapDParserOptions(
+              filterPushDownInfo, legacySyntax, isExplain, isViewOptimize);
+
       if (!isRAQuery) {
-        final List<MapDParserOptions.FilterPushDownInfo> filterPushDownInfo =
-                new ArrayList<>();
-        for (final TFilterPushDownInfo req : thriftFilterPushDownInfo) {
-          filterPushDownInfo.add(new MapDParserOptions.FilterPushDownInfo(
-                  req.input_prev, req.input_start, req.input_next));
-        }
         Pair<String, SqlIdentifierCapturer> res;
         SqlNode node;
-        MapDParserOptions parserOptions = new MapDParserOptions(
-                filterPushDownInfo, legacySyntax, isExplain, isViewOptimize);
+
         res = parser.process(queryText, parserOptions);
         jsonResult = res.left;
         capturer = res.right;
@@ -210,8 +212,9 @@
         resolvedAccessedObjects.tables_inserted_into = new ArrayList<>(capturer.inserts);
         resolvedAccessedObjects.tables_updated_in = new ArrayList<>(capturer.updates);
         resolvedAccessedObjects.tables_deleted_from = new ArrayList<>(capturer.deletes);
+
       } else {
-        jsonResult = parser.optimizeRAQuery(queryText);
+        jsonResult = parser.optimizeRAQuery(queryText, parserOptions);
       }
     } catch (SqlParseException ex) {
       String msg = "SQL Error: " + ex.getMessage();
diff -Naur ./java/calcite/src/main/java/org/apache/calcite/prepare/MapDPlanner.java ../omniscidb-master/java/calcite/src/main/java/org/apache/calcite/prepare/MapDPlanner.java
--- ./java/calcite/src/main/java/org/apache/calcite/prepare/MapDPlanner.java	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/java/calcite/src/main/java/org/apache/calcite/prepare/MapDPlanner.java	2021-04-21 00:02:57.000000000 +0300
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.prepare;
 
+import com.google.common.collect.ImmutableSet;
 import com.mapd.calcite.parser.MapDParserOptions;
 import com.mapd.calcite.parser.MapDSchema;
 import com.mapd.calcite.parser.ProjectProjectRemoveRule;
@@ -28,6 +29,7 @@
 import org.apache.calcite.plan.Context;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelOptCostImpl;
+import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.hep.HepPlanner;
 import org.apache.calcite.plan.hep.HepProgram;
 import org.apache.calcite.plan.hep.HepProgramBuilder;
@@ -36,6 +38,7 @@
 import org.apache.calcite.rel.RelRoot;
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.rel.externalize.MapDRelJsonReader;
+import org.apache.calcite.rel.metadata.DefaultRelMetadataProvider;
 import org.apache.calcite.rel.rules.CoreRules;
 import org.apache.calcite.rel.rules.DynamicFilterJoinRule;
 import org.apache.calcite.rel.rules.FilterJoinRule;
@@ -64,10 +67,9 @@
 import java.util.Properties;
 
 /**
- * Customised version of the PlannerImpl for MapD.
- * Used to be a copy of PlannerImpl,
- * refactored now to use inheritance to minimize maintenance efforts.
- * Implementation of {@link org.apache.calcite.tools.Planner}.
+ * Customised version of the PlannerImpl for MapD. Used to be a copy of
+ * PlannerImpl, refactored now to use inheritance to minimize maintenance
+ * efforts. Implementation of {@link org.apache.calcite.tools.Planner}.
  */
 public class MapDPlanner extends PlannerImpl {
   FrameworkConfig config;
@@ -229,6 +231,16 @@
     return root.withRel(rootRelNode);
   }
 
+  private RelRoot applyOptimizationsRules(RelRoot root, ImmutableSet<RelOptRule> rules) {
+    HepProgramBuilder programBuilder = new HepProgramBuilder();
+    for (RelOptRule rule : rules) {
+      programBuilder.addRuleInstance(rule);
+    }
+    HepPlanner hepPlanner = MapDPlanner.getHepPlanner(programBuilder.build(), false);
+    hepPlanner.setRoot(root.rel);
+    return root.withRel(hepPlanner.findBestExp());
+  }
+
   public RelRoot optimizeRaQuery(String query, MapDSchema schema) throws IOException {
     ready();
     RexBuilder builder = new RexBuilder(getTypeFactory());
@@ -237,22 +249,23 @@
     MapDRelJsonReader reader = new MapDRelJsonReader(cluster, catalogReader, schema);
 
     RelRoot relR = RelRoot.of(reader.read(query), SqlKind.SELECT);
-    applyQueryOptimizationRules(relR);
-    applyFilterPushdown(relR);
 
-    HepProgramBuilder hepBuilder = new HepProgramBuilder();
-    hepBuilder.addRuleInstance(CoreRules.JOIN_PROJECT_BOTH_TRANSPOSE_INCLUDE_OUTER);
-    hepBuilder.addRuleInstance(CoreRules.FILTER_MERGE);
-    hepBuilder.addRuleInstance(CoreRules.FILTER_PROJECT_TRANSPOSE);
-    hepBuilder.addRuleInstance(CoreRules.PROJECT_MERGE);
-    hepBuilder.addRuleInstance(ProjectProjectRemoveRule.INSTANCE);
-
-    HepPlanner hepPlanner = new HepPlanner(hepBuilder.build());
-    final RelNode root = relR.project();
-    hepPlanner.setRoot(root);
-    final RelNode newRel = hepPlanner.findBestExp();
+    if (restriction != null) {
+      relR = applyInjectFilterRule(relR, restriction);
+    }
 
-    return RelRoot.of(newRel, relR.kind);
+    relR = applyQueryOptimizationRules(relR);
+    relR = applyFilterPushdown(relR);
+    relR = applyOptimizationsRules(relR,
+            ImmutableSet.of(CoreRules.JOIN_PROJECT_BOTH_TRANSPOSE_INCLUDE_OUTER,
+                    CoreRules.FILTER_REDUCE_EXPRESSIONS,
+                    ProjectProjectRemoveRule.INSTANCE,
+                    CoreRules.PROJECT_FILTER_TRANSPOSE));
+    relR = applyOptimizationsRules(relR, ImmutableSet.of(CoreRules.PROJECT_MERGE));
+    relR = applyOptimizationsRules(relR,
+            ImmutableSet.of(
+                    CoreRules.FILTER_PROJECT_TRANSPOSE, CoreRules.PROJECT_REMOVE));
+    return RelRoot.of(relR.project(), relR.kind);
   }
 
   public void setFilterPushDownInfo(
diff -Naur ./java/thrift/calciteserver.thrift ../omniscidb-master/java/thrift/calciteserver.thrift
--- ./java/thrift/calciteserver.thrift	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/java/thrift/calciteserver.thrift	2021-04-21 00:02:57.000000000 +0300
@@ -4,8 +4,8 @@
 include "QueryEngine/extension_functions.thrift"
 
 exception InvalidParseRequest {
-  1: i32 whatUp,
-  2: string whyUp
+  1: i32 whatUp;
+  2: string whyUp;
 }
 
 struct TAccessedQueryObjects {
@@ -16,8 +16,8 @@
 }
 
 struct TPlanResult {
-  1: string plan_result
-  2: i64 execution_time_ms
+  1: string plan_result;
+  2: i64 execution_time_ms;
      // these are the primary objects accessed in this query without resolving views
   3: TAccessedQueryObjects primary_accessed_objects;
      // these are the accessed objects during this query after resolving all views 
@@ -25,29 +25,29 @@
 }
 
 struct TFilterPushDownInfo {
-  1: i32 input_prev
-  2: i32 input_start
-  3: i32 input_next
+  1: i32 input_prev;
+  2: i32 input_start;
+  3: i32 input_next;
 }
 
 struct TRestriction {
-  1: string column
-  2: list<string> values
+  1: string column;
+  2: list<string> values;
 }
 
 service CalciteServer {
 
-   void ping(),
-   void shutdown(),
-   TPlanResult process(1:string user 2:string passwd 3:string catalog 4:string sql_text
-                       5:list<TFilterPushDownInfo> filterPushDownInfo 6:bool legacySyntax
-                       7:bool isexplain 8:bool isViewOptimize 9:TRestriction restriction)
-                      throws (1:InvalidParseRequest parseErr),
+   void ping()
+   void shutdown()
+   TPlanResult process(1:string user, 2:string passwd, 3:string catalog, 4:string sql_text
+                       5:list<TFilterPushDownInfo> filterPushDownInfo, 6:bool legacySyntax
+                       7:bool isexplain, 8:bool isViewOptimize, 9:TRestriction restriction)
+                      throws (1:InvalidParseRequest parseErr)
    string getExtensionFunctionWhitelist()
    string getUserDefinedFunctionWhitelist()
    string getRuntimeExtensionFunctionWhitelist()
    void setRuntimeExtensionFunctions(1: list<extension_functions.TUserDefinedFunction> udfs, 2: list<extension_functions.TUserDefinedTableFunction> udtfs, 3:bool isruntime)
-   void updateMetadata(1: string catalog, 2:string table),
+   void updateMetadata(1: string catalog, 2:string table)
    list<completion_hints.TCompletionHint> getCompletionHints(1:string user, 2:string passwd, 3:string catalog,
     4:list<string> visible_tables, 5:string sql, 6:i32 cursor)
 
diff -Naur ./omnisci.thrift ../omniscidb-master/omnisci.thrift
--- ./omnisci.thrift	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/omnisci.thrift	2021-04-21 00:02:57.000000000 +0300
@@ -45,50 +45,50 @@
 }
 
 /* union */ struct TDatumVal {
-  1: i64 int_val,
-  2: double real_val,
-  3: string str_val,
-  4: list<TDatum> arr_val
+  1: i64 int_val;
+  2: double real_val;
+  3: string str_val;
+  4: list<TDatum> arr_val;
 }
 
 struct TDatum {
-  1: TDatumVal val,
-  2: bool is_null
+  1: TDatumVal val;
+  2: bool is_null;
 }
 
 struct TStringValue {
-  1: string str_val
-  2: bool is_null
+  1: string str_val;
+  2: bool is_null;
 }
 
 struct TColumnType {
-  1: string col_name,
-  2: common.TTypeInfo col_type,
-  3: bool is_reserved_keyword,
-  4: string src_name,
-  5: bool is_system,
-  6: bool is_physical,
-  7: i64 col_id
+  1: string col_name;
+  2: common.TTypeInfo col_type;
+  3: bool is_reserved_keyword;
+  4: string src_name;
+  5: bool is_system;
+  6: bool is_physical;
+  7: i64 col_id;
 }
 
 struct TRow {
-  1: list<TDatum> cols
+  1: list<TDatum> cols;
 }
 
 /* union */ struct TColumnData {
-  1: list<i64> int_col,
-  2: list<double> real_col,
-  3: list<string> str_col,
-  4: list<TColumn> arr_col
+  1: list<i64> int_col;
+  2: list<double> real_col;
+  3: list<string> str_col;
+  4: list<TColumn> arr_col;
 }
 
 struct TColumn {
-  1: TColumnData data,
-  2: list<bool> nulls
+  1: TColumnData data;
+  2: list<bool> nulls;
 }
 
 struct TStringRow {
-  1: list<TStringValue> cols
+  1: list<TStringValue> cols;
 }
 
 typedef list<TColumnType> TRowDescriptor
@@ -98,8 +98,8 @@
 typedef i64 TSubqueryId
 
 struct TKrb5Session {
-  1: TSessionId sessionId
-  2: TKrb5Token krbToken
+  1: TSessionId sessionId;
+  2: TKrb5Token krbToken;
 }
 
 enum TMergeType {
@@ -108,19 +108,19 @@
 }
 
 struct TStepResult {
-  1: serialized_result_set.TSerializedRows serialized_rows
-  2: bool execution_finished
-  3: TMergeType merge_type
-  4: bool sharded
-  5: TRowDescriptor row_desc
-  6: i32 node_id
+  1: serialized_result_set.TSerializedRows serialized_rows;
+  2: bool execution_finished;
+  3: TMergeType merge_type;
+  4: bool sharded;
+  5: TRowDescriptor row_desc;
+  6: i32 node_id;
 }
 
 struct TRowSet {
-  1: TRowDescriptor row_desc
-  2: list<TRow> rows
-  3: list<TColumn> columns
-  4: bool is_columnar
+  1: TRowDescriptor row_desc;
+  2: list<TRow> rows;
+  3: list<TColumn> columns;
+  4: bool is_columnar;
 }
 
 enum TQueryType {
@@ -137,183 +137,183 @@
 }
 
 struct TQueryResult {
-  1: TRowSet row_set
-  2: i64 execution_time_ms
-  3: i64 total_time_ms
-  4: string nonce
-  5: string debug
-  6: bool success=true
-  7: TQueryType query_type=TQueryType.UNKNOWN
+  1: TRowSet row_set;
+  2: i64 execution_time_ms;
+  3: i64 total_time_ms;
+  4: string nonce;
+  5: string debug;
+  6: bool success=true;
+  7: TQueryType query_type=TQueryType.UNKNOWN;
 }
 
 struct TDataFrame {
-  1: binary sm_handle
-  2: i64 sm_size
-  3: binary df_handle
-  4: i64 df_size
-  5: i64 execution_time_ms
-  6: i64 arrow_conversion_time_ms
-  7: binary df_buffer
+  1: binary sm_handle;
+  2: i64 sm_size;
+  3: binary df_handle;
+  4: i64 df_size;
+  5: i64 execution_time_ms;
+  6: i64 arrow_conversion_time_ms;
+  7: binary df_buffer;
 }
 
 struct TDBInfo {
-  1: string db_name
-  2: string db_owner
+  1: string db_name;
+  2: string db_owner;
 }
 
 exception TOmniSciException {
-  1: string error_msg
+  1: string error_msg;
 }
 
 struct TCopyParams {
-  1: string delimiter
-  2: string null_str
-  3: TImportHeaderRow has_header=TImportHeaderRow.AUTODETECT
-  4: bool quoted
-  5: string quote
-  6: string escape
-  7: string line_delim
-  8: string array_delim
-  9: string array_begin
-  10: string array_end
-  11: i32 threads
-  12: TFileType file_type=TFileType.DELIMITED
-  13: string s3_access_key
-  14: string s3_secret_key
-  15: string s3_region
-  16: common.TEncodingType geo_coords_encoding=TEncodingType.GEOINT
-  17: i32 geo_coords_comp_param=32
-  18: common.TDatumType geo_coords_type=TDatumType.GEOMETRY
-  19: i32 geo_coords_srid=4326
-  20: bool sanitize_column_names=true
-  21: string geo_layer_name
-  22: string s3_endpoint
-  23: bool geo_assign_render_groups=true
-  24: bool geo_explode_collections=false
-  25: i32 source_srid=0
+  1: string delimiter;
+  2: string null_str;
+  3: TImportHeaderRow has_header=TImportHeaderRow.AUTODETECT;
+  4: bool quoted;
+  5: string quote;
+  6: string escape;
+  7: string line_delim;
+  8: string array_delim;
+  9: string array_begin;
+  10: string array_end;
+  11: i32 threads;
+  12: TFileType file_type=TFileType.DELIMITED;
+  13: string s3_access_key;
+  14: string s3_secret_key;
+  15: string s3_region;
+  16: common.TEncodingType geo_coords_encoding=TEncodingType.GEOINT;
+  17: i32 geo_coords_comp_param=32;
+  18: common.TDatumType geo_coords_type=TDatumType.GEOMETRY;
+  19: i32 geo_coords_srid=4326;
+  20: bool sanitize_column_names=true;
+  21: string geo_layer_name;
+  22: string s3_endpoint;
+  23: bool geo_assign_render_groups=true;
+  24: bool geo_explode_collections=false;
+  25: i32 source_srid=0;
 }
 
 struct TCreateParams {
-  1: bool is_replicated
+  1: bool is_replicated;
 }
 
 struct TDetectResult {
-  1: TRowSet row_set
-  2: TCopyParams copy_params
+  1: TRowSet row_set;
+  2: TCopyParams copy_params;
 }
 
 struct TImportStatus {
-  1: i64 elapsed
-  2: i64 rows_completed
-  3: i64 rows_estimated
-  4: i64 rows_rejected
+  1: i64 elapsed;
+  2: i64 rows_completed;
+  3: i64 rows_estimated;
+  4: i64 rows_rejected;
 }
 
 struct TFrontendView {
-  1: string view_name
-  2: string view_state
-  3: string image_hash
-  4: string update_time
-  5: string view_metadata
+  1: string view_name;
+  2: string view_state;
+  3: string image_hash;
+  4: string update_time;
+  5: string view_metadata;
 }
 
 struct TServerStatus {
-  1: bool read_only
-  2: string version
-  3: bool rendering_enabled
-  4: i64 start_time
-  5: string edition
-  6: string host_name
-  7: bool poly_rendering_enabled
-  8: TRole role
+  1: bool read_only;
+  2: string version;
+  3: bool rendering_enabled;
+  4: i64 start_time;
+  5: string edition;
+  6: string host_name;
+  7: bool poly_rendering_enabled;
+  8: TRole role;
 }
 
 struct TPixel {
-  1: i64 x
-  2: i64 y
+  1: i64 x;
+  2: i64 y;
 }
 
 struct TPixelTableRowResult {
-  1: TPixel pixel
-  2: string vega_table_name
-  3: list<i64> table_id
-  4: list<i64> row_id
-  5: TRowSet row_set
-  6: string nonce
+  1: TPixel pixel;
+  2: string vega_table_name;
+  3: list<i64> table_id;
+  4: list<i64> row_id;
+  5: TRowSet row_set;
+  6: string nonce;
 }
 
 struct TRenderResult {
-  1: binary image
-  2: string nonce
-  3: i64 execution_time_ms
-  4: i64 render_time_ms
-  5: i64 total_time_ms
-  6: string vega_metadata
+  1: binary image;
+  2: string nonce;
+  3: i64 execution_time_ms;
+  4: i64 render_time_ms;
+  5: i64 total_time_ms;
+  6: string vega_metadata;
 }
 
 struct TGpuSpecification {
-  1: i32 num_sm
-  2: i64 clock_frequency_kHz
-  3: i64 memory
-  4: i16 compute_capability_major
-  5: i16 compute_capability_minor
+  1: i32 num_sm;
+  2: i64 clock_frequency_kHz;
+  3: i64 memory;
+  4: i16 compute_capability_major;
+  5: i16 compute_capability_minor;
 }
 
 struct THardwareInfo {
-  1: i16 num_gpu_hw
-  2: i16 num_cpu_hw
-  3: i16 num_gpu_allocated
-  4: i16 start_gpu
-  5: string host_name
-  6: list<TGpuSpecification> gpu_info
+  1: i16 num_gpu_hw;
+  2: i16 num_cpu_hw;
+  3: i16 num_gpu_allocated;
+  4: i16 start_gpu;
+  5: string host_name;
+  6: list<TGpuSpecification> gpu_info;
 }
 
 struct TClusterHardwareInfo {
-  1: list<THardwareInfo> hardware_info
+  1: list<THardwareInfo> hardware_info;
 }
 
 struct TMemoryData {
-  1: i64 slab
-  2: i32 start_page
-  3: i64 num_pages
-  4: i32 touch
-  5: list<i64> chunk_key
-  6: i32 buffer_epoch
-  7: bool is_free
+  1: i64 slab;
+  2: i32 start_page;
+  3: i64 num_pages;
+  4: i32 touch;
+  5: list<i64> chunk_key;
+  6: i32 buffer_epoch;
+  7: bool is_free;
 }
 
 struct TNodeMemoryInfo {
-  1: string host_name
-  2: i64 page_size
-  3: i64 max_num_pages
-  4: i64 num_pages_allocated
-  5: bool is_allocation_capped
-  6: list<TMemoryData> node_memory_data
+  1: string host_name;
+  2: i64 page_size;
+  3: i64 max_num_pages;
+  4: i64 num_pages_allocated;
+  5: bool is_allocation_capped;
+  6: list<TMemoryData> node_memory_data;
 }
 
 struct TTableMeta {
-  1: string table_name
-  2: i64 num_cols
-  4: bool is_view
-  5: bool is_replicated
-  6: i64 shard_count
-  7: i64 max_rows
-  8: i64 table_id
-  9: i64 max_table_id
-  10: list<common.TTypeInfo> col_types
-  11: list<string> col_names
+  1: string table_name;
+  2: i64 num_cols;
+  4: bool is_view;
+  5: bool is_replicated;
+  6: i64 shard_count;
+  7: i64 max_rows;
+  8: i64 table_id;
+  9: i64 max_table_id;
+  10: list<common.TTypeInfo> col_types;
+  11: list<string> col_names;
 }
 
 struct TTableDetails {
-  1: TRowDescriptor row_desc
-  2: i64 fragment_size
-  3: i64 page_size
-  4: i64 max_rows
-  5: string view_sql
-  6: i64 shard_count
-  7: string key_metainfo
-  8: bool is_temporary
-  9: TPartitionDetail partition_detail
+  1: TRowDescriptor row_desc;
+  2: i64 fragment_size;
+  3: i64 page_size;
+  4: i64 max_rows;
+  5: string view_sql;
+  6: i64 shard_count;
+  7: string key_metainfo;
+  8: bool is_temporary;
+  9: TPartitionDetail partition_detail;
 }
 
 enum TExpressionRangeType {
@@ -324,100 +324,100 @@
 }
 
 struct TColumnRange {
-  1: TExpressionRangeType type
-  2: i32 col_id
-  3: i32 table_id
-  4: bool has_nulls
-  5: i64 int_min
-  6: i64 int_max
-  7: i64 bucket
-  8: double fp_min
-  9: double fp_max
+  1: TExpressionRangeType type;
+  2: i32 col_id;
+  3: i32 table_id;
+  4: bool has_nulls;
+  5: i64 int_min;
+  6: i64 int_max;
+  7: i64 bucket;
+  8: double fp_min;
+  9: double fp_max;
 }
 
 struct TDictionaryGeneration {
-  1: i32 dict_id
-  2: i64 entry_count
+  1: i32 dict_id;
+  2: i64 entry_count;
 }
 
 struct TTableGeneration {
-  1: i32 table_id
-  2: i64 tuple_count
-  3: i64 start_rowid
+  1: i32 table_id;
+  2: i64 tuple_count;
+  3: i64 start_rowid;
 }
 
 struct TPendingQuery {
-  1: TQueryId id
-  2: list<TColumnRange> column_ranges
-  3: list<TDictionaryGeneration> dictionary_generations
-  4: list<TTableGeneration> table_generations
-  5: TSessionId parent_session_id
+  1: TQueryId id;
+  2: list<TColumnRange> column_ranges;
+  3: list<TDictionaryGeneration> dictionary_generations;
+  4: list<TTableGeneration> table_generations;
+  5: TSessionId parent_session_id;
 }
 
 struct TVarLen {
-  1: binary payload
-  2: bool is_null
+  1: binary payload;
+  2: bool is_null;
 }
 
 union TDataBlockPtr {
-  1: binary fixed_len_data
-  2: list<TVarLen> var_len_data
+  1: binary fixed_len_data;
+  2: list<TVarLen> var_len_data;
 }
 
 struct TInsertData {
-  1: i32 db_id
-  2: i32 table_id
-  3: list<i32> column_ids
-  4: list<TDataBlockPtr> data
-  5: i64 num_rows
-  6: list<bool> is_default
+  1: i32 db_id;
+  2: i32 table_id;
+  3: list<i32> column_ids;
+  4: list<TDataBlockPtr> data;
+  5: i64 num_rows;
+  6: list<bool> is_default;
 }
 
 struct TPendingRenderQuery {
-  1: TQueryId id
+  1: TQueryId id;
 }
 
 struct TRenderParseResult {
-  1: TMergeType merge_type
-  2: i32 node_id
-  3: i64 execution_time_ms
-  4: i64 render_time_ms
-  5: i64 total_time_ms
+  1: TMergeType merge_type;
+  2: i32 node_id;
+  3: i64 execution_time_ms;
+  4: i64 render_time_ms;
+  5: i64 total_time_ms;
 }
 
 struct TRawRenderPassDataResult {
-  1: i32 num_pixel_channels
-  2: i32 num_pixel_samples
-  3: binary pixels
-  4: binary row_ids_A
-  5: binary row_ids_B
-  6: binary table_ids
-  7: binary accum_data
-  8: i32 accum_depth
+  1: i32 num_pixel_channels;
+  2: i32 num_pixel_samples;
+  3: binary pixels;
+  4: binary row_ids_A;
+  5: binary row_ids_B;
+  6: binary table_ids;
+  7: binary accum_data;
+  8: i32 accum_depth;
 }
 
 typedef map<i32, TRawRenderPassDataResult> TRenderPassMap
 
 struct TRawPixelData {
-  1: i32 width
-  2: i32 height
-  3: TRenderPassMap render_pass_map
+  1: i32 width;
+  2: i32 height;
+  3: TRenderPassMap render_pass_map;
 }
 
 struct TRenderDatum {
-  1: common.TDatumType type
-  2: i32 cnt
-  3: binary value
+  1: common.TDatumType type;
+  2: i32 cnt;
+  3: binary value;
 }
 
 typedef map<string, map<string, map<string, map<string, list<TRenderDatum>>>>> TRenderAggDataMap
 
 struct TRenderStepResult {
-  1: TRenderAggDataMap merge_data
-  2: TRawPixelData raw_pixel_data
-  3: i64 execution_time_ms
-  4: i64 render_time_ms
-  5: i64 total_time_ms
+  1: TRenderAggDataMap merge_data;
+  2: TRawPixelData raw_pixel_data;
+  3: i64 execution_time_ms;
+  4: i64 render_time_ms;
+  5: i64 total_time_ms;
 }
 struct TDatabasePermissions {
   1: bool create_;
@@ -461,28 +461,28 @@
 }
 
 union TDBObjectPermissions {
-  1: TDatabasePermissions database_permissions_
-  2: TTablePermissions table_permissions_
-  3: TDashboardPermissions dashboard_permissions_
-  4: TViewPermissions view_permissions_
-  5: TServerPermissions server_permissions_
+  1: TDatabasePermissions database_permissions_;
+  2: TTablePermissions table_permissions_;
+  3: TDashboardPermissions dashboard_permissions_;
+  4: TViewPermissions view_permissions_;
+  5: TServerPermissions server_permissions_;
 }
 
 enum TDBObjectType {
   AbstractDBObjectType = 0,
   DatabaseDBObjectType,
   TableDBObjectType,
-  DashboardDBObjectType
+  DashboardDBObjectType,
   ViewDBObjectType,
   ServerDBObjectType
 }
 
 struct TDBObject {
-  1: string objectName
-  2: TDBObjectType objectType
-  3: list<bool> privs
-  4: string grantee
-  5: TDBObjectType privilegeObjectType
+  1: string objectName;
+  2: TDBObjectType objectType;
+  3: list<bool> privs;
+  4: string grantee;
+  5: TDBObjectType privilegeObjectType;
 }
 
 struct TDashboardGrantees {
@@ -492,19 +492,19 @@
 }
 
 struct TDashboard {
-  1: string dashboard_name
-  2: string dashboard_state
-  3: string image_hash
-  4: string update_time
-  5: string dashboard_metadata
-  6: i32 dashboard_id
-  7: string dashboard_owner
-  8: bool is_dash_shared
-  9: TDashboardPermissions dashboard_permissions
+  1: string dashboard_name;
+  2: string dashboard_state;
+  3: string image_hash;
+  4: string update_time;
+  5: string dashboard_metadata;
+  6: i32 dashboard_id;
+  7: string dashboard_owner;
+  8: bool is_dash_shared;
+  9: TDashboardPermissions dashboard_permissions;
 }
 
 struct TLicenseInfo {
-  1: list<string> claims
+  1: list<string> claims;
 }
 
 struct TSessionInfo {
@@ -552,21 +552,21 @@
   void clear_gpu_memory(1: TSessionId session) throws (1: TOmniSciException e)
   void set_cur_session(1: TSessionId parent_session, 2: TSessionId leaf_session, 3: string start_time_str, 4: string label) throws (1: TOmniSciException e)
   void invalidate_cur_session(1: TSessionId parent_session, 2: TSessionId leaf_session, 3: string start_time_str, 4: string label) throws (1: TOmniSciException e)
-  void set_table_epoch (1: TSessionId session 2: i32 db_id 3: i32 table_id 4: i32 new_epoch) throws (1: TOmniSciException e)
-  void set_table_epoch_by_name (1: TSessionId session 2: string table_name 3: i32 new_epoch) throws (1: TOmniSciException e)
-  i32 get_table_epoch (1: TSessionId session 2: i32 db_id 3: i32 table_id);
-  i32 get_table_epoch_by_name (1: TSessionId session 2: string table_name);
-  list<TTableEpochInfo> get_table_epochs(1: TSessionId session 2: i32 db_id 3: i32 table_id);
-  void set_table_epochs(1: TSessionId session 2: i32 db_id 3: list<TTableEpochInfo> table_epochs);
+  void set_table_epoch (1: TSessionId session, 2: i32 db_id, 3: i32 table_id, 4: i32 new_epoch) throws (1: TOmniSciException e)
+  void set_table_epoch_by_name (1: TSessionId session, 2: string table_name, 3: i32 new_epoch) throws (1: TOmniSciException e)
+  i32 get_table_epoch (1: TSessionId session, 2: i32 db_id, 3: i32 table_id)
+  i32 get_table_epoch_by_name (1: TSessionId session, 2: string table_name)
+  list<TTableEpochInfo> get_table_epochs(1: TSessionId session, 2: i32 db_id, 3: i32 table_id)
+  void set_table_epochs(1: TSessionId session, 2: i32 db_id, 3: list<TTableEpochInfo> table_epochs)
   TSessionInfo get_session_info(1: TSessionId session) throws (1: TOmniSciException e)
   # query, render
-  TQueryResult sql_execute(1: TSessionId session, 2: string query 3: bool column_format, 4: string nonce, 5: i32 first_n = -1, 6: i32 at_most_n = -1) throws (1: TOmniSciException e)
-  TDataFrame sql_execute_df(1: TSessionId session, 2: string query 3: common.TDeviceType device_type 4: i32 device_id = 0 5: i32 first_n = -1 6: TArrowTransport transport_method) throws (1: TOmniSciException e)
-  TDataFrame sql_execute_gdf(1: TSessionId session, 2: string query 3: i32 device_id = 0, 4: i32 first_n = -1) throws (1: TOmniSciException e)
+  TQueryResult sql_execute(1: TSessionId session, 2: string query, 3: bool column_format, 4: string nonce, 5: i32 first_n = -1, 6: i32 at_most_n = -1) throws (1: TOmniSciException e)
+  TDataFrame sql_execute_df(1: TSessionId session, 2: string query, 3: common.TDeviceType device_type, 4: i32 device_id = 0, 5: i32 first_n = -1, 6: TArrowTransport transport_method) throws (1: TOmniSciException e)
+  TDataFrame sql_execute_gdf(1: TSessionId session, 2: string query, 3: i32 device_id = 0, 4: i32 first_n = -1) throws (1: TOmniSciException e)
   void deallocate_df(1: TSessionId session, 2: TDataFrame df, 3: common.TDeviceType device_type, 4: i32 device_id = 0) throws (1: TOmniSciException e)
   void interrupt(1: TSessionId query_session, 2: TSessionId interrupt_session) throws (1: TOmniSciException e)
   TRowDescriptor sql_validate(1: TSessionId session, 2: string query) throws (1: TOmniSciException e)
-  list<completion_hints.TCompletionHint> get_completion_hints(1: TSessionId session, 2:string sql, 3:i32 cursor) throws (1: TOmniSciException e)
+  list<completion_hints.TCompletionHint> get_completion_hints(1: TSessionId session, 2: string sql, 3: i32 cursor) throws (1: TOmniSciException e)
   void set_execution_mode(1: TSessionId session, 2: TExecuteMode mode) throws (1: TOmniSciException e)
   TRenderResult render_vega(1: TSessionId session, 2: i64 widget_id, 3: string vega_json, 4: i32 compression_level, 5: string nonce) throws (1: TOmniSciException e)
   TPixelTableRowResult get_result_row_for_pixel(1: TSessionId session, 2: i64 widget_id, 3: TPixel pixel, 4: map<string, list<string>> table_col_names, 5: bool column_format, 6: i32 pixelRadius, 7: string nonce) throws (1: TOmniSciException e)
@@ -611,11 +611,11 @@
   void checkpoint(1: TSessionId session, 2: i32 table_id) throws (1: TOmniSciException e)
   # object privileges
   list<string> get_roles(1: TSessionId session) throws (1: TOmniSciException e)
-  list<TDBObject> get_db_objects_for_grantee(1: TSessionId session 2: string roleName) throws (1: TOmniSciException e)
-  list<TDBObject> get_db_object_privs(1: TSessionId session 2: string objectName 3: TDBObjectType type) throws (1: TOmniSciException e)
-  list<string> get_all_roles_for_user(1: TSessionId session 2: string userName) throws (1: TOmniSciException e)
-  bool has_role(1: TSessionId session 2: string granteeName 3: string roleName) throws (1: TOmniSciException e)
-  bool has_object_privilege(1: TSessionId session 2: string granteeName 3: string ObjectName 4: TDBObjectType objectType 5: TDBObjectPermissions permissions) throws (1: TOmniSciException e)
+  list<TDBObject> get_db_objects_for_grantee(1: TSessionId session, 2: string roleName) throws (1: TOmniSciException e)
+  list<TDBObject> get_db_object_privs(1: TSessionId session, 2: string objectName, 3: TDBObjectType type) throws (1: TOmniSciException e)
+  list<string> get_all_roles_for_user(1: TSessionId session, 2: string userName) throws (1: TOmniSciException e)
+  bool has_role(1: TSessionId session, 2: string granteeName, 3: string roleName) throws (1: TOmniSciException e)
+  bool has_object_privilege(1: TSessionId session, 2: string granteeName, 3: string ObjectName, 4: TDBObjectType objectType, 5: TDBObjectPermissions permissions) throws (1: TOmniSciException e)
   # licensing
   TLicenseInfo set_license_key(1: TSessionId session, 2: string key, 3: string nonce = "") throws (1: TOmniSciException e)
   TLicenseInfo get_license_claims(1: TSessionId session, 2: string nonce = "") throws (1: TOmniSciException e)
diff -Naur ./scripts/arch/arrow/PKGBUILD ../omniscidb-master/scripts/arch/arrow/PKGBUILD
--- ./scripts/arch/arrow/PKGBUILD	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/scripts/arch/arrow/PKGBUILD	2021-04-21 00:02:57.000000000 +0300
@@ -7,7 +7,7 @@
 arch=('x86_64')
 url="https://arrow.apache.org"
 license=('Apache')
-depends=('boost-libs' 'double-conversion' 'c-ares-cmake' 'gflags' 'google-glog' 'libutf8proc' 'lz4' 'protobuf' 'rapidjson' 'thrift' 'uriparser' 'zstd')
+depends=('boost-libs' 'double-conversion' 'c-ares' 'gflags' 'google-glog' 'libutf8proc' 'lz4' 'protobuf' 'rapidjson' 'thrift' 'uriparser' 'zstd')
 checkdepends=('git')
 optdepends=()
 provides=('parquet-cpp')
diff -Naur ./scripts/conda/build-install-all.sh ../omniscidb-master/scripts/conda/build-install-all.sh
--- ./scripts/conda/build-install-all.sh	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/build-install-all.sh	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+set -ex
+[ -z "$PREFIX" ] && export PREFIX=${CONDA_PREFIX:-/usr/local}
+this_dir=$(dirname "${BASH_SOURCE[0]}")
+
+bash $this_dir/build.sh
+bash $this_dir/install-omniscidb-common.sh
+cmake --install build --component "exe" --prefix $PREFIX
+cmake --install build --component "DBE" --prefix $PREFIX
+bash $this_dir/install-omniscidbe4py.sh
diff -Naur ./scripts/conda/build.sh ../omniscidb-master/scripts/conda/build.sh
--- ./scripts/conda/build.sh	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/build.sh	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,101 @@
+#!/usr/bin/env bash
+
+set -ex
+
+# Free some disk space, see also
+# https://github.com/conda-forge/omniscidb-feedstock/issues/5
+df -h
+
+export EXTRA_CMAKE_OPTIONS=""
+
+# Make sure -fPIC is not in CXXFLAGS (that some conda packages may
+# add), otherwise omniscidb server will crash when executing generated
+# machine code:
+export CXXFLAGS="`echo $CXXFLAGS | sed 's/-fPIC//'`"
+
+# Fixes https://github.com/Quansight/pearu-sandbox/issues/7
+#       https://github.com/omnisci/omniscidb/issues/374
+export CXXFLAGS="$CXXFLAGS -Dsecure_getenv=getenv"
+
+# Fixes `error: expected ')' before 'PRIxPTR'`
+export CXXFLAGS="$CXXFLAGS -D__STDC_FORMAT_MACROS"
+
+# Remove --as-needed to resolve undefined reference to `__vdso_clock_gettime@GLIBC_PRIVATE'
+export LDFLAGS="`echo $LDFLAGS | sed 's/-Wl,--as-needed//'`"
+
+export EXTRA_CMAKE_OPTIONS="$EXTRA_CMAKE_OPTIONS -DCMAKE_C_COMPILER=${CC} -DCMAKE_CXX_COMPILER=${CXX}"
+
+# Run tests labels:
+#   0 - disable building and running sanity tests
+#   1 - build and run the sanity tests
+#   2 - detect if sanity tests can be run, then set 1, otherwise set 0
+#
+# Ideally, this should 2, but to save disk space, running sanity tests
+# will be disabled:
+export RUN_TESTS=${RUN_TESTS:-0}
+
+export INSTALL_BASE=. # was opt/omnisci-cpu
+
+if [[ "$RUN_TESTS" == "0" ]]
+then
+   export EXTRA_CMAKE_OPTIONS="$EXTRA_CMAKE_OPTIONS -DENABLE_TESTS=off"
+else
+   export RUN_TESTS=1
+   export EXTRA_CMAKE_OPTIONS="$EXTRA_CMAKE_OPTIONS -DENABLE_TESTS=on"
+fi
+
+if [[ "$CMAKE_BUILD_TYPE" ]]
+then
+    export BUILD_TYPE="$CMAKE_BUILD_TYPE"
+else
+    export BUILD_TYPE="release"
+fi
+
+export EXTRA_CMAKE_OPTIONS="$EXTRA_CMAKE_OPTIONS -DBoost_NO_BOOST_CMAKE=on"
+
+this_dir=$(dirname "${BASH_SOURCE[0]}")
+RECIPE_DIR=${RECIPE_DIR:-${this_dir}}
+
+# Omnisci UDF support uses CLangTool for parsing Load-time UDF C++
+# code to AST. If the C++ code uses C++ std headers, we need to
+# specify the locations of include directories:
+. ${RECIPE_DIR}/get_cxx_include_path.sh
+export CPLUS_INCLUDE_PATH=$(get_cxx_include_path)
+
+# generate ~/.m2/settings.xml if proxy are set and there are no settings
+[ -f ~/.m2/settings.xml -o -z "$http_proxy" ] || python ${RECIPE_DIR}/make-m2-proxy.py
+
+mkdir -p build
+cd build
+
+cmake -Wno-dev \
+    -DCMAKE_PREFIX_PATH=$PREFIX \
+    -DCMAKE_INSTALL_PREFIX=$PREFIX/$INSTALL_BASE \
+    -DCMAKE_BUILD_TYPE=$BUILD_TYPE \
+    -DMAPD_DOCS_DOWNLOAD=off \
+    -DENABLE_AWS_S3=off \
+    -DENABLE_FOLLY=off \
+    -DENABLE_JAVA_REMOTE_DEBUG=off \
+    -DENABLE_PROFILER=off \
+    -DPREFER_STATIC_LIBS=off \
+    -DENABLE_CUDA=off \
+    -DENABLE_DBE=ON \
+    -DENABLE_FSI=ON \
+    -DENABLE_ITT=OFF \
+    -DENABLE_JIT_DEBUG=OFF \
+    -DENABLE_INTEL_JIT_LISTENER=OFF \
+    $EXTRA_CMAKE_OPTIONS \
+    ..
+
+make -j ${CPU_COUNT:-`nproc`} || make -j ${CPU_COUNT:-`nproc`} || make
+
+
+if [[ "$RUN_TESTS" == "2" ]]
+then
+    mkdir tmp
+    $PREFIX/bin/initdb tmp
+    make sanity_tests
+    rm -rf tmp
+else
+    echo "Skipping sanity tests"
+fi
diff -Naur ./scripts/conda/conda_build_config.yaml ../omniscidb-master/scripts/conda/conda_build_config.yaml
--- ./scripts/conda/conda_build_config.yaml	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/conda_build_config.yaml	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,14 @@
+c_compiler: gcc
+cxx_compiler: gxx
+ignore_build_only_deps:
+- numpy
+- python
+numpy: '1.18'
+tbb: '2021.1.1'
+python:
+- 3.7
+#- 3.8
+boost_cpp: '1.72'
+pin_run_as_build:
+  boost-cpp:
+    max_pin: x.x.x
diff -Naur ./scripts/conda/get_cxx_include_path.sh ../omniscidb-master/scripts/conda/get_cxx_include_path.sh
--- ./scripts/conda/get_cxx_include_path.sh	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/get_cxx_include_path.sh	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,34 @@
+#
+# Usage:
+#
+#   source this file and call ${get_cxx_include_path} to get a full
+#   include path of ${CXX}
+#
+# Author: Pearu Peterson
+# Created: November 2019
+#
+function get_cxx_include_path() {
+    local cplus_include_path=""
+    local start_include_search=false
+    local sep=""
+    (${CXX} -E -x c++ - -v < /dev/null) 2>&1 |
+        while read -r LINE
+        do
+            case "$LINE" in
+                '#include <...> search starts here:' | '#include "..." search starts here:')
+                    start_include_search=true
+                    ;;
+                'End of search list.')
+                    echo "$cplus_include_path"
+                    break
+                    ;;
+                *)
+                    if [ "$start_include_search" = "true" ];
+                    then
+                        cplus_include_path="$cplus_include_path${sep}$(readlink -f ${LINE})"
+                        sep=":"
+                    fi
+                    ;;
+            esac
+        done
+}
diff -Naur ./scripts/conda/install-omniscidb-common.sh ../omniscidb-master/scripts/conda/install-omniscidb-common.sh
--- ./scripts/conda/install-omniscidb-common.sh	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/install-omniscidb-common.sh	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+set -xe
+[ -z "$PREFIX" ] && export PREFIX=${CONDA_PREFIX:-/usr/local}
+cmake --install build --component "include" --prefix $PREFIX/include/omnisci
+cmake --install build --component "doc" --prefix $PREFIX/share/doc/omnisci
+cmake --install build --component "data" --prefix $PREFIX/opt/omnisci
+cmake --install build --component "thrift" --prefix $PREFIX/opt/omnisci
+cmake --install build --component "QE" --prefix $PREFIX
+cmake --install build --component "jar" --prefix $PREFIX
+cmake --install build --component "Unspecified" --prefix $PREFIX/opt/omnisci
diff -Naur ./scripts/conda/install-omniscidb-cpu.sh ../omniscidb-master/scripts/conda/install-omniscidb-cpu.sh
--- ./scripts/conda/install-omniscidb-cpu.sh	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/install-omniscidb-cpu.sh	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,39 @@
+#!/usr/bin/env bash
+set -xe
+#INSTALL_BASE=opt/omnisci/cpu
+INSTALL_BASE=.
+
+cmake --install build --component "exe" --prefix ${PREFIX:-/usr/local}/$INSTALL_BASE
+# copy initdb to omnisci_initdb to avoid conflict with psql initdb
+mv $PREFIX/$INSTALL_BASE/bin/initdb $PREFIX/$INSTALL_BASE/bin/omnisci_initdb
+exit 0
+
+mkdir -p "${PREFIX}/etc/conda/activate.d"
+cat > "${PREFIX}/etc/conda/activate.d/${PKG_NAME}_activate.sh" <<EOF
+#!/bin/bash
+# Avoid cuda and cpu variants of omniscidb in the same environment.
+if [[ ! -z "\${PATH_CONDA_OMNISCIDB_BACKUP+x}" ]]
+then
+  echo "Unset PATH_CONDA_OMNISCIDB_BACKUP(=\${PATH_CONDA_OMNISCIDB_BACKUP}) when activating ${PKG_NAME} from \${CONDA_PREFIX}/${INSTALL_BASE}"
+  export PATH="\${PATH_CONDA_OMNISCIDB_BACKUP}"
+  unset PATH_CONDA_OMNISCIDB_BACKUP
+fi
+# Backup environment variables (only if the variables are set)
+if [[ ! -z "\${PATH+x}" ]]
+then
+  export PATH_CONDA_OMNISCIDB_BACKUP="\${PATH:-}"
+fi
+export PATH="\${PATH}:\${CONDA_PREFIX}/${INSTALL_BASE}/bin"
+EOF
+
+
+mkdir -p "${PREFIX}/etc/conda/deactivate.d"
+cat > "${PREFIX}/etc/conda/deactivate.d/${PKG_NAME}_deactivate.sh" <<EOF
+#!/bin/bash
+# Restore environment variables (if there is anything to restore)
+if [[ ! -z "\${PATH_CONDA_OMNISCIDB_BACKUP+x}" ]]
+then
+  export PATH="\${PATH_CONDA_OMNISCIDB_BACKUP}"
+  unset PATH_CONDA_OMNISCIDB_BACKUP
+fi
+EOF
diff -Naur ./scripts/conda/install-omniscidbe.sh ../omniscidb-master/scripts/conda/install-omniscidbe.sh
--- ./scripts/conda/install-omniscidbe.sh	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/install-omniscidbe.sh	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,3 @@
+#!/usr/bin/env bash
+set -xe
+cmake --install build --component "DBE" --prefix ${PREFIX:-/usr/local}
diff -Naur ./scripts/conda/install-omniscidbe4py.sh ../omniscidb-master/scripts/conda/install-omniscidbe4py.sh
--- ./scripts/conda/install-omniscidbe4py.sh	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/install-omniscidbe4py.sh	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,4 @@
+#!/usr/bin/env bash
+set -xe
+cd build/Embedded
+${PYTHON:-python} setup.py build_ext -g -f install
diff -Naur ./scripts/conda/make-m2-proxy.py ../omniscidb-master/scripts/conda/make-m2-proxy.py
--- ./scripts/conda/make-m2-proxy.py	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/make-m2-proxy.py	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,89 @@
+#!/usr/bin/env python
+
+'''
+Generate ~/.m2/settings.xml specifying proxies
+if such environment variables are set.
+'''
+
+import os
+import sys
+import re
+import errno
+
+def simple_xml(name, sections):
+    ''' very simple xml generator for one-level depth items '''
+    result = ['<%s>' % name]
+    for sec_name, sec_value in sections:
+        result.append('  <{0}>{1}</{0}>'.format(sec_name, sec_value))
+    result.append('</%s>' % name)
+    return '\n'.join('    ' + line for line in result)
+
+_made_ids = set()
+
+def gen_proxy(var_name):
+    value = os.environ.get(var_name, '')
+    if not value:
+        return None
+    try:
+        parsed = re.search(r'''((?P<protocol>[^:]+)://)?    # protocol followed by ://, optional
+            ((?P<username>[^:]+)(:(?P<password>[^@]+))?@)?  # user:password part, optional
+            (?P<host>[^@]+?)                                # hostname, which is basically everything but other known parts
+            (:(?P<port>\d+))?                               # port, optional
+            $''', value, re.VERBOSE).groupdict()
+    except AttributeError:
+        sys.stderr.write('WARNING: unexpected format, could not parse $%s=%s\n' % (var_name, value))
+        return None
+
+    if not parsed['host']:
+        return None
+    id_name = var_name.lower()
+    if id_name in _made_ids:
+        num = 0
+        while ('%s.%s' % (id_name, num)) in _made_ids:
+            num +=1
+        id_name = '%s.%s' % (id_name, num)
+    _made_ids.add(id_name)
+    sections = [('id', id_name), ('active', 'true')]
+    for param_name in ('protocol', 'host', 'port', 'username', 'password'):
+        if parsed[param_name]:
+            sections.append((param_name, parsed[param_name]))
+    return simple_xml('proxy', sections)
+
+def make_settings(*var_names):
+    sections = []
+    for name in var_names:
+        value = gen_proxy(name)
+        if value:
+            sections.append(value)
+    if not sections:
+        return None
+    template = '''<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
+                      https://maven.apache.org/xsd/settings-1.0.0.xsd">
+  <proxies>
+%s
+  </proxies>
+</settings>'''
+    return template % '\n'.join(sections)
+
+def main():
+    settings = make_settings('http_proxy', 'HTTP_PROXY', 'https_proxy', 'HTTPS_PROXY')
+    target = os.path.expanduser('~/.m2/settings.xml')
+    if not settings:
+        try:
+            os.remove(target)
+        except OSError as ex:
+            if ex.errno != errno.ENOENT:
+                raise
+        return
+    try:
+        os.makedirs(os.path.dirname(target))
+    except OSError as ex:
+        if ex.errno != errno.EEXIST:
+            raise
+    with open(target, 'w') as out:
+        out.write(settings)
+
+if __name__ == '__main__':
+    main()
diff -Naur ./scripts/conda/meta.yaml ../omniscidb-master/scripts/conda/meta.yaml
--- ./scripts/conda/meta.yaml	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/conda/meta.yaml	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,252 @@
+{% set version = GIT_DESCRIBE_TAG %}
+{% set number = GIT_DESCRIBE_NUMBER|int %}
+{% set build_ext = "cpu" %}
+{% set build_string = "{}_{}_{}".format(PKG_HASH, GIT_DESCRIBE_HASH, number) %}
+
+package:
+  name: omniscidb
+  version: {{ version }}
+
+source:
+  path: ../..
+
+build:
+  number: {{ number }}
+  string: h{{ build_string }}
+  script_env:
+    - http_proxy
+    - https_proxy
+
+requirements:
+  build:
+    - {{ compiler('cxx') }}
+    - clangdev <11
+    - clangxx <11
+    - cmake >=3.16
+    - llvmdev <11
+    - make
+    - maven
+    # new tbb needs glibc >= 2.14
+    - sysroot_linux-64 >=2.14 # [linux]
+  host:
+    - numpy
+    - cython
+    - arrow-cpp =2.0
+    - bisonpp
+    - blosc
+    - boost-cpp {{ boost_cpp }}
+    - clangdev <11
+    - double-conversion
+    - flex
+    - gflags
+    - glog
+    - llvmdev <11
+    - llvm <11
+    - libarchive
+    - libgdal
+    - libkml
+    - libpng
+    # for some reason, librdkafka 1.4+ triggers dependency conflicts
+    - librdkafka <1.4
+    - ncurses
+    - openldap
+    - openssl
+    - snappy
+    - thrift-cpp
+    - tbb-devel {{ tbb }}
+  # no need in run: section when using multiple outputs
+
+outputs:
+  - name: omniscidb-common
+    script: install-omniscidb-common.sh
+    requirements:
+      build:
+        - cmake >=3.16  # there is no building, just copying
+      run:             # common part of run requirements for other packages
+        - boost-cpp {{ boost_cpp }}
+        - bzip2
+        - blosc
+        # omnscidb Load-time UDF support calls clang++
+        - gxx_{{ target_platform }} 8.*
+        - double-conversion
+        - libgdal
+        - libkml
+        - libpng
+        - libarchive
+        - libclang-cpp <11
+        - ncurses
+        - openjdk 8.*
+        - xz
+        - zlib
+        - arrow-cpp =2.0
+        - tbb {{ tbb }}
+        - llvm <11
+
+    about:
+      home: https://www.omnisci.com/
+      license: Apache-2.0
+      license_family: APACHE
+      license_file: LICENSE.md
+      summary: 'Common parts for the OmniSci database'
+      doc_url: https://www.omnisci.com/docs/latest/
+      dev_url: https://github.com/omnisci/omniscidb
+      description: |
+        <strong>LEGAL NOTICE: Use of this software package is subject to the
+        software license agreement (as set forth above, in the license section of
+        the installed Conda package and/or the README file) and all notices,
+        disclaimers or license terms for third party or open source software
+        included in or with the software.</strong>
+        <br/><br/>
+        EULA: <a href="https://github.com/omnisci/omniscidb/blob/master/LICENSE.md" target="_blank">Apache-2.0</a>
+        <br/><br/>
+
+  - name: omniscidb-cpu
+    script: install-omniscidb-cpu.sh
+    requirements:
+      build:
+        - cmake >=3.16  # there is no building, just copying
+      run:
+        - boost-cpp {{ boost_cpp }}
+        - bzip2
+        - blosc
+        # omnscidb Load-time UDF support calls clang++
+        - gxx_{{ target_platform }}
+        - double-conversion
+        - libgdal
+        - libkml
+        - libpng
+        - libarchive
+        - ncurses
+        - openjdk 8.*
+        - xz
+        - zlib
+        - arrow-cpp =2.0
+        - tbb {{ tbb }}
+        - {{ pin_subpackage('omniscidb-common', exact=True) }}
+      run_constrained:
+        - arrow-cpp-proc * {{ build_ext }}
+    test:
+      commands:
+        - omnisql -v
+        - which omnisci_initdb
+        - which omnisci_server
+    about:
+      home: https://www.omnisci.com/
+      license: Apache-2.0
+      license_family: APACHE
+      license_file: LICENSE.md
+      summary: 'The OmniSci database server for CPU'
+      doc_url: https://www.omnisci.com/docs/latest/
+      dev_url: https://github.com/omnisci/omniscidb
+      description: |
+        <strong>LEGAL NOTICE: Use of this software package is subject to the
+        software license agreement (as set forth above, in the license section of
+        the installed Conda package and/or the README file) and all notices,
+        disclaimers or license terms for third party or open source software
+        included in or with the software.</strong>
+        <br/><br/>
+        EULA: <a href="https://github.com/omnisci/omniscidb/blob/master/LICENSE.md" target="_blank">Apache-2.0</a>
+        <br/><br/>
+
+  - name: omniscidbe
+    script: install-omniscidbe.sh
+    requirements:
+      build:
+        - cmake >=3.16
+      run:
+        - {{ pin_subpackage('omniscidb-common', exact=True) }}
+    about:
+      home: https://www.omnisci.com/
+      license: Apache-2.0
+      license_family: APACHE
+      license_file: LICENSE.md
+      summary: 'The OmniSci database as a library'
+      doc_url: https://www.omnisci.com/docs/latest/
+      dev_url: https://github.com/omnisci/omniscidb
+      description: |
+        <strong>LEGAL NOTICE: Use of this software package is subject to the
+        software license agreement (as set forth above, in the license section of
+        the installed Conda package and/or the README file) and all notices,
+        disclaimers or license terms for third party or open source software
+        included in or with the software.</strong>
+        <br/><br/>
+        EULA: <a href="https://github.com/omnisci/omniscidb/blob/master/LICENSE.md" target="_blank">Apache-2.0</a>
+        <br/><br/>
+
+
+  - name: omniscidbe4py
+    script: install-omniscidbe4py.sh
+    build:
+      string: py{{ py }}h{{ build_string }}
+    requirements:
+      build:
+        - {{ compiler('cxx') }}   # this section really builds
+        - clangdev <11
+        - clangxx <11
+        - cmake >=3.16
+        - llvmdev <11
+        - make
+        - maven
+        # new tbb needs glibc >= 2.14
+        - sysroot_linux-64 >=2.14 # [linux]
+      host:
+        - arrow-cpp =2.0
+        - bisonpp
+        - blosc
+        - boost-cpp {{ boost_cpp }}
+        - clangdev <11
+        - double-conversion
+        - flex
+        - gflags
+        - glog
+        - llvmdev <11
+        - llvm <11
+        - libarchive
+        - libgdal
+        - libkml
+        - libpng
+        # for some reason, librdkafka 1.4+ triggers dependency conflicts
+        - librdkafka <1.4
+        - ncurses
+        - openldap
+        - openssl
+        - snappy
+        - thrift-cpp
+        - tbb-devel {{ tbb }}
+        - python
+        - cython
+        - numpy
+        - pyarrow =2.0
+        - {{ pin_subpackage('omniscidbe', exact=True) }}
+      run:
+        - python
+        - pyarrow =2.0
+        - tbb4py {{ tbb }}
+        - {{ pin_subpackage('omniscidbe', exact=True) }}
+        - {{ pin_subpackage('omniscidb-common', exact=True) }}
+    test:
+      imports:
+        - dbe
+    about:
+      home: https://www.omnisci.com/
+      license: Apache-2.0
+      license_family: APACHE
+      license_file: LICENSE.md
+      summary: 'The OmniSci database library for Python'
+      doc_url: https://www.omnisci.com/docs/latest/
+      dev_url: https://github.com/omnisci/omniscidb
+      description: |
+        <strong>LEGAL NOTICE: Use of this software package is subject to the
+        software license agreement (as set forth above, in the license section of
+        the installed Conda package and/or the README file) and all notices,
+        disclaimers or license terms for third party or open source software
+        included in or with the software.</strong>
+        <br/><br/>
+        EULA: <a href="https://github.com/omnisci/omniscidb/blob/master/LICENSE.md" target="_blank">Apache-2.0</a>
+        <br/><br/>
+
+extra:
+  recipe-maintainers:
+    - xmnlab
+    - pearu
+    - andrewseidl
diff -Naur ./scripts/mapd-deps-arch.sh ../omniscidb-master/scripts/mapd-deps-arch.sh
--- ./scripts/mapd-deps-arch.sh	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/scripts/mapd-deps-arch.sh	2021-04-21 00:02:57.000000000 +0300
@@ -14,7 +14,7 @@
     aws-sdk-cpp \
     blosc \
     boost \
-    c-ares-cmake \
+    c-ares \
     clang \
     cmake \
     cuda \
diff -Naur ./scripts/mapd-deps-centos.sh ../omniscidb-master/scripts/mapd-deps-centos.sh
--- ./scripts/mapd-deps-centos.sh	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/scripts/mapd-deps-centos.sh	2021-04-21 00:02:57.000000000 +0300
@@ -246,6 +246,9 @@
 
 install_snappy
 
+VERS=3.52.14
+CFLAGS="-fPIC" CXXFLAGS="-fPIC" download_make_install https://github.com/openlink/iODBC/releases/download/v${VERS}/libiodbc-${VERS}.tar.gz
+
 # c-blosc
 VERS=1.14.4
 download https://github.com/Blosc/c-blosc/archive/v$VERS.tar.gz
diff -Naur ./scripts/mapd-deps-conda-dev-env.yml ../omniscidb-master/scripts/mapd-deps-conda-dev-env.yml
--- ./scripts/mapd-deps-conda-dev-env.yml	1970-01-01 03:00:00.000000000 +0300
+++ ../omniscidb-master/scripts/mapd-deps-conda-dev-env.yml	2021-04-21 00:02:57.000000000 +0300
@@ -0,0 +1,60 @@
+#  To create environment, execute:
+#     conda env create -f scripts/mapd-deps-conda-dev-env.yml
+#
+#  To activate:
+#     conda activate omnisci-dev
+#
+#  To build OmnisciDB for development:
+#     scripts/conda/build-install-all.sh
+
+#  TODO: autogenerate this file from conda/meta.yaml requirements
+name: omnisci-dev
+channels:
+  - local
+  - defaults
+  - conda-forge
+
+dependencies:
+  - gxx_linux-64   9.*
+  - gcc_linux-64   9.*
+  - ccache
+  - libgdal    >=2.3
+  - sysroot_linux-64 >=2.14
+  - arrow-cpp  2.0
+  - pyarrow    2.0
+  - pandas     1.1.5
+  - thrift-cpp  0.13.*
+  - thrift      0.13.*
+  - llvmdev     9.*
+  - librdkafka <1.4
+  - openjdk     8.*
+  - cmake       3.16
+  - libpng
+  - tbb-devel
+  - cython
+  - make
+  - go
+  - maven
+  - boost-cpp
+  - clangdev
+  - llvm
+  - double-conversion
+  - snappy
+  - gflags
+  - glog
+  - libarchive
+  - libkml
+  - libiconv
+  - blosc
+  - ncurses
+  - flex
+  - bisonpp
+  - openssl
+  - xz
+  - bzip2
+  - zlib
+  - ittapi
+  - pytest
+  # when cuda is enabled, install also
+  - nvcc_linux-64
+  #- arrow-cpp=0.16=*cuda
diff -Naur ./scripts/mapd-deps-osx.sh ../omniscidb-master/scripts/mapd-deps-osx.sh
--- ./scripts/mapd-deps-osx.sh	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/scripts/mapd-deps-osx.sh	2021-04-21 00:02:57.000000000 +0300
@@ -27,6 +27,7 @@
 brew install double-conversion
 brew install llvm
 brew install libuv
+brew install libiodbc
 
 function build_pin_dep {
   brew unpin $1 || true
diff -Naur ./scripts/mapd-deps-ubuntu.sh ../omniscidb-master/scripts/mapd-deps-ubuntu.sh
--- ./scripts/mapd-deps-ubuntu.sh	2021-04-22 18:00:37.000000000 +0300
+++ ../omniscidb-master/scripts/mapd-deps-ubuntu.sh	2021-04-21 00:02:57.000000000 +0300
@@ -144,6 +144,9 @@
 make install
 popd
 
+VERS=3.52.14
+CFLAGS="-fPIC" CXXFLAGS="-fPIC" download_make_install https://github.com/openlink/iODBC/releases/download/v${VERS}/libiodbc-${VERS}.tar.gz
+
 #c-blosc
 VERS=1.14.4
 wget --continue https://github.com/Blosc/c-blosc/archive/v$VERS.tar.gz
